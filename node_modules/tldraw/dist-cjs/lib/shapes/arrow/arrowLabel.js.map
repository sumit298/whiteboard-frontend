{
  "version": 3,
  "sources": ["../../../../src/lib/shapes/arrow/arrowLabel.ts"],
  "sourcesContent": ["import {\n\tArc2d,\n\tBox,\n\tCircle2d,\n\tEdge2d,\n\tEditor,\n\tGeometry2d,\n\tGroup2d,\n\tPolygon2d,\n\tPolyline2d,\n\tTLArrowShape,\n\tVec,\n\tVecLike,\n\tclamp,\n\tcreateComputedCache,\n\texhaustiveSwitchError,\n} from '@tldraw/editor'\nimport {\n\tARROW_LABEL_FONT_SIZES,\n\tARROW_LABEL_PADDING,\n\tFONT_FAMILIES,\n\tLABEL_TO_ARROW_PADDING,\n\tSTROKE_SIZES,\n\tTEXT_PROPS,\n} from '../shared/default-shape-constants'\nimport { TLArrowInfo } from './arrow-types'\nimport { getArrowInfo } from './shared'\n\nexport const arrowBodyGeometryCache = createComputedCache(\n\t'arrow body geometry',\n\t(editor: Editor, shape: TLArrowShape) => {\n\t\tconst info = getArrowInfo(editor, shape)!\n\t\tswitch (info.type) {\n\t\t\tcase 'straight':\n\t\t\t\treturn new Edge2d({\n\t\t\t\t\tstart: Vec.From(info.start.point),\n\t\t\t\t\tend: Vec.From(info.end.point),\n\t\t\t\t})\n\t\t\tcase 'arc':\n\t\t\t\treturn new Arc2d({\n\t\t\t\t\tcenter: Vec.Cast(info.handleArc.center),\n\t\t\t\t\tstart: Vec.Cast(info.start.point),\n\t\t\t\t\tend: Vec.Cast(info.end.point),\n\t\t\t\t\tsweepFlag: info.bodyArc.sweepFlag,\n\t\t\t\t\tlargeArcFlag: info.bodyArc.largeArcFlag,\n\t\t\t\t})\n\t\t\tcase 'elbow':\n\t\t\t\treturn new Polyline2d({ points: info.route.points })\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(info, 'type')\n\t\t}\n\t}\n)\n\nconst labelSizeCache = createComputedCache(\n\t'arrow label size',\n\t(editor: Editor, shape: TLArrowShape) => {\n\t\teditor.fonts.trackFontsForShape(shape)\n\t\tlet width = 0\n\t\tlet height = 0\n\n\t\tconst bodyGeom = arrowBodyGeometryCache.get(editor, shape.id)!\n\t\t// We use 'i' as a default label to measure against as a minimum width.\n\t\tconst text = shape.props.text || 'i'\n\n\t\tconst bodyBounds = bodyGeom.bounds\n\n\t\tconst fontSize = getArrowLabelFontSize(shape)\n\n\t\t// First we measure the text with no constraints\n\t\tconst { w, h } = editor.textMeasure.measureText(text, {\n\t\t\t...TEXT_PROPS,\n\t\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\t\tfontSize,\n\t\t\tmaxWidth: null,\n\t\t})\n\n\t\twidth = w\n\t\theight = h\n\n\t\tlet shouldSquish = false\n\n\t\t// If the text is wider than the body, we need to squish it\n\t\tconst info = getArrowInfo(editor, shape)!\n\t\tconst labelToArrowPadding = getLabelToArrowPadding(shape)\n\t\tconst margin =\n\t\t\tinfo.type === 'elbow'\n\t\t\t\t? Math.max(info.elbow.A.arrowheadOffset + labelToArrowPadding, 32) +\n\t\t\t\t\tMath.max(info.elbow.B.arrowheadOffset + labelToArrowPadding, 32)\n\t\t\t\t: 64\n\n\t\tif (bodyBounds.width > bodyBounds.height) {\n\t\t\twidth = Math.max(Math.min(w, margin), Math.min(bodyBounds.width - margin, w))\n\t\t\tshouldSquish = true\n\t\t} else if (width > 16 * fontSize) {\n\t\t\twidth = 16 * fontSize\n\t\t\tshouldSquish = true\n\t\t}\n\n\t\tif (shouldSquish) {\n\t\t\tconst { w: squishedWidth, h: squishedHeight } = editor.textMeasure.measureText(text, {\n\t\t\t\t...TEXT_PROPS,\n\t\t\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\t\t\tfontSize,\n\t\t\t\tmaxWidth: width,\n\t\t\t})\n\n\t\t\twidth = squishedWidth\n\t\t\theight = squishedHeight\n\t\t}\n\n\t\treturn new Vec(width, height).addScalar(ARROW_LABEL_PADDING * 2 * shape.props.scale)\n\t},\n\t{ areRecordsEqual: (a, b) => a.props === b.props }\n)\n\nfunction getArrowLabelSize(editor: Editor, shape: TLArrowShape) {\n\treturn labelSizeCache.get(editor, shape.id) ?? new Vec(0, 0)\n}\n\nfunction getLabelToArrowPadding(shape: TLArrowShape) {\n\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\tconst labelToArrowPadding =\n\t\t(LABEL_TO_ARROW_PADDING +\n\t\t\t(strokeWidth - STROKE_SIZES.s) * 2 +\n\t\t\t(strokeWidth === STROKE_SIZES.xl ? 20 : 0)) *\n\t\tshape.props.scale\n\n\treturn labelToArrowPadding\n}\n\n/**\n * Return the range of possible label positions for an arrow. The full possible range is 0 to 1, but\n * as the label itself takes up space the usable range is smaller.\n */\nfunction getArrowLabelRange(editor: Editor, shape: TLArrowShape, info: TLArrowInfo) {\n\tconst bodyGeom = arrowBodyGeometryCache.get(editor, shape.id)!\n\tconst dbgPoints: VecLike[] = []\n\tconst dbg: Geometry2d[] = [new Group2d({ children: [bodyGeom], debugColor: 'lime' })]\n\n\tconst labelSize = getArrowLabelSize(editor, shape)\n\tconst labelToArrowPadding = getLabelToArrowPadding(shape)\n\tconst paddingRelative = labelToArrowPadding / bodyGeom.length\n\n\t// we can calculate the range by sticking the center of the label at the very start/end of the\n\t// arrow, and seeing where the label intersects with the arrow. Then, if we move the label's\n\t// center to that point, that'll be the start/end of the range.\n\n\tlet startBox, endBox\n\tif (info.type === 'elbow') {\n\t\t// for elbow arrows, because they have multiple segments but are always axis-aligned, we can use\n\t\t// an expanded box. This helps keep the box from partially covering the first segment when it's\n\t\t// very small.\n\t\tdbgPoints.push(info.start.point, info.end.point)\n\t\tstartBox = Box.FromCenter(info.start.point, labelSize).expandBy(labelToArrowPadding)\n\t\tendBox = Box.FromCenter(info.end.point, labelSize).expandBy(labelToArrowPadding)\n\t} else {\n\t\t// for other arrows, we move along the arrow by the padding amount to find the start/end points\n\t\tconst startPoint = bodyGeom.interpolateAlongEdge(paddingRelative)\n\t\tconst endPoint = bodyGeom.interpolateAlongEdge(1 - paddingRelative)\n\t\tdbgPoints.push(startPoint, endPoint)\n\t\tstartBox = Box.FromCenter(startPoint, labelSize)\n\t\tendBox = Box.FromCenter(endPoint, labelSize)\n\t}\n\tconst startIntersections = bodyGeom.intersectPolygon(startBox.corners)\n\tconst endIntersections = bodyGeom.intersectPolygon(endBox.corners)\n\n\tconst startConstrained = furthest(info.start.point, startIntersections)\n\tconst endConstrained = furthest(info.end.point, endIntersections)\n\n\tlet startRelative = startConstrained ? bodyGeom.uninterpolateAlongEdge(startConstrained) : 0.5\n\tlet endRelative = endConstrained ? bodyGeom.uninterpolateAlongEdge(endConstrained) : 0.5\n\n\tif (startRelative > endRelative) {\n\t\tstartRelative = 0.5\n\t\tendRelative = 0.5\n\t}\n\n\tfor (const pt of [...startIntersections, ...endIntersections, ...dbgPoints]) {\n\t\tdbg.push(\n\t\t\tnew Circle2d({\n\t\t\t\tx: pt.x - 3,\n\t\t\t\ty: pt.y - 3,\n\t\t\t\tradius: 3,\n\t\t\t\tisFilled: false,\n\t\t\t\tdebugColor: 'magenta',\n\t\t\t\tignore: true,\n\t\t\t})\n\t\t)\n\t}\n\tdbg.push(\n\t\tnew Polygon2d({\n\t\t\tpoints: startBox.corners,\n\t\t\tdebugColor: 'lime',\n\t\t\tisFilled: false,\n\t\t\tignore: true,\n\t\t}),\n\t\tnew Polygon2d({\n\t\t\tpoints: endBox.corners,\n\t\t\tdebugColor: 'lime',\n\t\t\tisFilled: false,\n\t\t\tignore: true,\n\t\t})\n\t)\n\n\treturn { start: startRelative, end: endRelative, dbg }\n}\n\ninterface ArrowheadInfo {\n\thasStartBinding: boolean\n\thasEndBinding: boolean\n\thasStartArrowhead: boolean\n\thasEndArrowhead: boolean\n}\nexport function getArrowLabelPosition(editor: Editor, shape: TLArrowShape) {\n\tconst debugGeom: Geometry2d[] = []\n\tconst info = getArrowInfo(editor, shape)!\n\n\tconst arrowheadInfo: ArrowheadInfo = {\n\t\thasStartBinding: !!info.bindings.start,\n\t\thasEndBinding: !!info.bindings.end,\n\t\thasStartArrowhead: info.start.arrowhead !== 'none',\n\t\thasEndArrowhead: info.end.arrowhead !== 'none',\n\t}\n\n\tconst range = getArrowLabelRange(editor, shape, info)\n\tif (range.dbg) debugGeom.push(...range.dbg)\n\n\tconst clampedPosition = getClampedPosition(shape, range, arrowheadInfo)\n\tconst bodyGeom = arrowBodyGeometryCache.get(editor, shape.id)!\n\tconst labelCenter = bodyGeom.interpolateAlongEdge(clampedPosition)\n\tconst labelSize = getArrowLabelSize(editor, shape)\n\n\treturn { box: Box.FromCenter(labelCenter, labelSize), debugGeom }\n}\n\nfunction getClampedPosition(\n\tshape: TLArrowShape,\n\trange: { start: number; end: number },\n\tarrowheadInfo: ArrowheadInfo\n) {\n\tconst { hasEndArrowhead, hasEndBinding, hasStartBinding, hasStartArrowhead } = arrowheadInfo\n\tconst clampedPosition = clamp(\n\t\tshape.props.labelPosition,\n\t\thasStartArrowhead || hasStartBinding ? range.start : 0,\n\t\thasEndArrowhead || hasEndBinding ? range.end : 1\n\t)\n\n\treturn clampedPosition\n}\n\nfunction furthest(from: VecLike, candidates: VecLike[]): VecLike | null {\n\tlet furthest: VecLike | null = null\n\tlet furthestDist = -Infinity\n\n\tfor (const candidate of candidates) {\n\t\tconst dist = Vec.Dist2(from, candidate)\n\t\tif (dist > furthestDist) {\n\t\t\tfurthest = candidate\n\t\t\tfurthestDist = dist\n\t\t}\n\t}\n\n\treturn furthest\n}\n\nexport function getArrowLabelFontSize(shape: TLArrowShape) {\n\treturn ARROW_LABEL_FONT_SIZES[shape.props.size] * shape.props.scale\n}\n\nexport function getArrowLabelDefaultPosition(editor: Editor, shape: TLArrowShape) {\n\tconst info = getArrowInfo(editor, shape)!\n\tswitch (info.type) {\n\t\tcase 'straight':\n\t\tcase 'arc':\n\t\t\treturn 0.5\n\t\tcase 'elbow': {\n\t\t\tconst midpointHandle = info.route.midpointHandle\n\t\t\tconst bodyGeom = arrowBodyGeometryCache.get(editor, shape.id)\n\t\t\tif (midpointHandle && bodyGeom) {\n\t\t\t\treturn bodyGeom.uninterpolateAlongEdge(midpointHandle.point)\n\t\t\t}\n\t\t\treturn 0.5\n\t\t}\n\t\tdefault:\n\t\t\texhaustiveSwitchError(info, 'type')\n\t}\n}\n"],
  "mappings": "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",
  "names": ["furthest"]
}
