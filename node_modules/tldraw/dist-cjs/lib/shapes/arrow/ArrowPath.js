"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ArrowPath_exports = {};
__export(ArrowPath_exports, {
  getArrowBodyPath: () => getArrowBodyPath,
  getArrowHandlePath: () => getArrowHandlePath
});
module.exports = __toCommonJS(ArrowPath_exports);
var import_editor = require("@tldraw/editor");
var import_PathBuilder = require("../shared/PathBuilder");
var import_getElbowArrowInfo = require("./elbow/getElbowArrowInfo");
function getArrowBodyPath(shape, info, opts) {
  switch (info.type) {
    case "straight":
      return new import_PathBuilder.PathBuilder().moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 }).lineTo(info.end.point.x, info.end.point.y, { offset: 0, roundness: 0 }).toSvg(opts);
    case "arc":
      return new import_PathBuilder.PathBuilder().moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 }).arcTo(
        info.bodyArc.radius,
        !!info.bodyArc.largeArcFlag,
        !!info.bodyArc.sweepFlag,
        info.end.point.x,
        info.end.point.y,
        { offset: 0, roundness: 0 }
      ).toSvg(opts);
    case "elbow": {
      const path = new import_PathBuilder.PathBuilder();
      path.moveTo(info.start.point.x, info.start.point.y, {
        offset: 0
      });
      for (let i = 1; i < info.route.points.length; i++) {
        const point = info.route.points[i];
        if (info.route.skipPointsWhenDrawing.has(point)) {
          continue;
        }
        path.lineTo(point.x, point.y, {
          offset: i === info.route.points.length - 1 ? 0 : void 0
        });
      }
      return path.toSvg(opts);
    }
    default:
      (0, import_editor.exhaustiveSwitchError)(info, "type");
  }
}
function getArrowHandlePath(info, opts) {
  switch (info.type) {
    case "straight":
      return new import_PathBuilder.PathBuilder().moveTo(info.start.handle.x, info.start.handle.y).lineTo(info.end.handle.x, info.end.handle.y).toSvg(opts);
    case "arc":
      return new import_PathBuilder.PathBuilder().moveTo(info.start.handle.x, info.start.handle.y).arcTo(
        info.handleArc.radius,
        !!info.handleArc.largeArcFlag,
        !!info.handleArc.sweepFlag,
        info.end.handle.x,
        info.end.handle.y
      ).toSvg(opts);
    case "elbow": {
      const handleRoute = (0, import_getElbowArrowInfo.getRouteHandlePath)(info.elbow, info.route);
      return import_PathBuilder.PathBuilder.throughPoints(handleRoute.points).toSvg(opts);
    }
    default:
      (0, import_editor.exhaustiveSwitchError)(info, "type");
  }
}
//# sourceMappingURL=ArrowPath.js.map
