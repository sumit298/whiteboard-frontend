{
  "version": 3,
  "sources": ["../../../../../src/lib/shapes/arrow/elbow/elbowArrowSnapLines.tsx"],
  "sourcesContent": ["import {\n\tcomputed,\n\tComputed,\n\tEditor,\n\tTLArrowShape,\n\tTLShapeId,\n\tVec,\n\tVecLike,\n\tWeakCache,\n} from '@tldraw/editor'\nimport { getArrowBindings } from '../shared'\n\n/**\n * A snap line for an elbow arrow segment.\n *\n * This should already belong to ElbowArrowSnapLines establishing an angle of the line.\n */\ninterface ElbowArrowSnapLine {\n\t/** The id of the shape that the snap line starts from. */\n\tstartBoundShapeId: TLShapeId | undefined\n\t/** The id of the shape that the snap line ends at. */\n\tendBoundShapeId: TLShapeId | undefined\n\t/** The perpendicular distance from the snap line to the origin. */\n\tperpDistance: number\n}\n\n/**\n * A map from an angle (0-\u03C0) to a set of snap lines. Snap lines are stored in page space. They're\n * modelled as an angle (the angle of the line itself) and a perpendicular signed distance from the\n * page origin. Each line is effectively infinite in length, but modelling them in this way makes it\n * pretty efficient for us to query for relevant snap lines.\n */\ntype ElbowArrowSnapLines = Map<number, Set<ElbowArrowSnapLine>>\n\nconst snapLinesStore = new WeakCache<Editor, Computed<ElbowArrowSnapLines>>()\n\nexport function getElbowArrowSnapLines(editor: Editor) {\n\treturn snapLinesStore\n\t\t.get(editor, (editor) => {\n\t\t\tconst currentSelectedArrowShape = computed('current selected arrow shape', () => {\n\t\t\t\tconst shape = editor.getOnlySelectedShape()\n\t\t\t\tif (!shape || !editor.isShapeOfType<TLArrowShape>(shape, 'arrow')) return null\n\t\t\t\treturn shape.id\n\t\t\t})\n\n\t\t\tconst unselectedArrowShapeIds = editor.store.query.ids('shape', () => {\n\t\t\t\tconst activeArrowShapeId = currentSelectedArrowShape.get()\n\t\t\t\tif (!activeArrowShapeId) return { type: { eq: 'arrow' } }\n\t\t\t\treturn {\n\t\t\t\t\ttype: { eq: 'arrow' },\n\t\t\t\t\tid: { neq: activeArrowShapeId },\n\t\t\t\t}\n\t\t\t})\n\n\t\t\treturn computed('elbow arrow snap lines', () => {\n\t\t\t\t// the result is a map from angle (0-\u03C0), to a set of single-axis co-ordinates. For\n\t\t\t\t// example, if a line from (0, 1) to (1, 1) is found (ie a horizontal line at y-coord 1),\n\t\t\t\t// we'll add an entry to the map with the key 0 (horizontal), and the set containing 1.\n\t\t\t\tconst result = new Map<number, Set<ElbowArrowSnapLine>>()\n\n\t\t\t\tconst currentPageShapeIds = editor.getCurrentPageShapeIds()\n\t\t\t\tconst viewportBounds = editor.getViewportPageBounds()\n\n\t\t\t\tfor (const id of unselectedArrowShapeIds.get()) {\n\t\t\t\t\tif (!currentPageShapeIds.has(id)) continue\n\n\t\t\t\t\tconst shape = editor.getShape<TLArrowShape>(id)\n\t\t\t\t\tif (shape?.type !== 'arrow') continue\n\n\t\t\t\t\tconst shapeBounds = editor.getShapePageBounds(id)\n\t\t\t\t\tif (!shapeBounds || !viewportBounds.includes(shapeBounds)) continue\n\n\t\t\t\t\tconst bindings = getArrowBindings(editor, shape)\n\n\t\t\t\t\tconst geometry = editor.getShapePageGeometry(id)\n\t\t\t\t\tconst vertices = geometry.getVertices({ includeInternal: false, includeLabels: false })\n\n\t\t\t\t\tfor (let i = 1; i < vertices.length; i++) {\n\t\t\t\t\t\tconst prev = vertices[i - 1]\n\t\t\t\t\t\tconst curr = vertices[i]\n\n\t\t\t\t\t\tlet angle = Vec.Angle(prev, curr)\n\n\t\t\t\t\t\t// we don't care if the angle is going \"up\" or \"down\" - so we only care\n\t\t\t\t\t\t// about the 0-\u03C0 range\n\t\t\t\t\t\tif (angle < 0) angle += Math.PI\n\n\t\t\t\t\t\tlet set = result.get(angle)\n\t\t\t\t\t\tif (!set) {\n\t\t\t\t\t\t\tset = new Set()\n\t\t\t\t\t\t\tresult.set(angle, set)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst perpDistance = perpDistanceToLineAngle(prev, angle)\n\n\t\t\t\t\t\tset.add({\n\t\t\t\t\t\t\tperpDistance,\n\t\t\t\t\t\t\tstartBoundShapeId: bindings.start?.toId,\n\t\t\t\t\t\t\tendBoundShapeId: bindings.end?.toId,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result\n\t\t\t})\n\t\t})\n\t\t.get()\n}\n\n/**\n * Return the signed distance from the origin to a point on a line of angle `lineAngle` that passes\n * through the point `pointOnLine`.\n */\nexport function perpDistanceToLineAngle(pointOnLine: VecLike, lineAngle: number): number {\n\t// The perpendicular unit vector to the line direction\n\tconst perpDir = Vec.FromAngle(lineAngle).per()\n\t// Project the point onto the perpendicular vector\n\treturn Vec.Dpr(pointOnLine, perpDir)\n}\n\n/**\n * Return the signed distance from the origin to the line segment defined by `A` and `B`.\n */\nexport function perpDistanceToLine(A: VecLike, B: VecLike): number {\n\treturn perpDistanceToLineAngle(A, Vec.Angle(A, B))\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBASO;AACP,oBAAiC;AAwBjC,MAAM,iBAAiB,IAAI,wBAAiD;AAErE,SAAS,uBAAuB,QAAgB;AACtD,SAAO,eACL,IAAI,QAAQ,CAACA,YAAW;AACxB,UAAM,gCAA4B,wBAAS,gCAAgC,MAAM;AAChF,YAAM,QAAQA,QAAO,qBAAqB;AAC1C,UAAI,CAAC,SAAS,CAACA,QAAO,cAA4B,OAAO,OAAO,EAAG,QAAO;AAC1E,aAAO,MAAM;AAAA,IACd,CAAC;AAED,UAAM,0BAA0BA,QAAO,MAAM,MAAM,IAAI,SAAS,MAAM;AACrE,YAAM,qBAAqB,0BAA0B,IAAI;AACzD,UAAI,CAAC,mBAAoB,QAAO,EAAE,MAAM,EAAE,IAAI,QAAQ,EAAE;AACxD,aAAO;AAAA,QACN,MAAM,EAAE,IAAI,QAAQ;AAAA,QACpB,IAAI,EAAE,KAAK,mBAAmB;AAAA,MAC/B;AAAA,IACD,CAAC;AAED,eAAO,wBAAS,0BAA0B,MAAM;AAI/C,YAAM,SAAS,oBAAI,IAAqC;AAExD,YAAM,sBAAsBA,QAAO,uBAAuB;AAC1D,YAAM,iBAAiBA,QAAO,sBAAsB;AAEpD,iBAAW,MAAM,wBAAwB,IAAI,GAAG;AAC/C,YAAI,CAAC,oBAAoB,IAAI,EAAE,EAAG;AAElC,cAAM,QAAQA,QAAO,SAAuB,EAAE;AAC9C,YAAI,OAAO,SAAS,QAAS;AAE7B,cAAM,cAAcA,QAAO,mBAAmB,EAAE;AAChD,YAAI,CAAC,eAAe,CAAC,eAAe,SAAS,WAAW,EAAG;AAE3D,cAAM,eAAW,gCAAiBA,SAAQ,KAAK;AAE/C,cAAM,WAAWA,QAAO,qBAAqB,EAAE;AAC/C,cAAM,WAAW,SAAS,YAAY,EAAE,iBAAiB,OAAO,eAAe,MAAM,CAAC;AAEtF,iBAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACzC,gBAAM,OAAO,SAAS,IAAI,CAAC;AAC3B,gBAAM,OAAO,SAAS,CAAC;AAEvB,cAAI,QAAQ,kBAAI,MAAM,MAAM,IAAI;AAIhC,cAAI,QAAQ,EAAG,UAAS,KAAK;AAE7B,cAAI,MAAM,OAAO,IAAI,KAAK;AAC1B,cAAI,CAAC,KAAK;AACT,kBAAM,oBAAI,IAAI;AACd,mBAAO,IAAI,OAAO,GAAG;AAAA,UACtB;AAEA,gBAAM,eAAe,wBAAwB,MAAM,KAAK;AAExD,cAAI,IAAI;AAAA,YACP;AAAA,YACA,mBAAmB,SAAS,OAAO;AAAA,YACnC,iBAAiB,SAAS,KAAK;AAAA,UAChC,CAAC;AAAA,QACF;AAAA,MACD;AAEA,aAAO;AAAA,IACR,CAAC;AAAA,EACF,CAAC,EACA,IAAI;AACP;AAMO,SAAS,wBAAwB,aAAsB,WAA2B;AAExF,QAAM,UAAU,kBAAI,UAAU,SAAS,EAAE,IAAI;AAE7C,SAAO,kBAAI,IAAI,aAAa,OAAO;AACpC;AAKO,SAAS,mBAAmB,GAAY,GAAoB;AAClE,SAAO,wBAAwB,GAAG,kBAAI,MAAM,GAAG,CAAC,CAAC;AAClD;",
  "names": ["editor"]
}
