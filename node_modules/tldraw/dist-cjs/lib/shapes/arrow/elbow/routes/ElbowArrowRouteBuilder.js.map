{
  "version": 3,
  "sources": ["../../../../../../src/lib/shapes/arrow/elbow/routes/ElbowArrowRouteBuilder.ts"],
  "sourcesContent": ["import { assert, Vec, VecLike } from '@tldraw/editor'\nimport { ElbowArrowMidpointHandle, ElbowArrowRoute } from '../definitions'\nimport { ElbowArrowWorkingInfo } from './ElbowArrowWorkingInfo'\n\nconst MIN_DISTANCE = 0.01\n\nexport class ElbowArrowRouteBuilder {\n\tpoints: Vec[] = []\n\n\tconstructor(\n\t\tprivate readonly info: ElbowArrowWorkingInfo,\n\t\tpublic readonly name: string\n\t) {}\n\n\tadd(x: number, y: number): this {\n\t\tthis.points.push(this.info.vec(x, y))\n\n\t\treturn this\n\t}\n\n\tprivate _midpointHandle: ElbowArrowMidpointHandle | null = null\n\tmidpointHandle(axis: 'x' | 'y'): this {\n\t\tassert(this._midpointHandle === null, 'midX/midY called multiple times')\n\n\t\tconst point = Vec.Lrp(\n\t\t\tthis.points[this.points.length - 2],\n\t\t\tthis.points[this.points.length - 1],\n\t\t\t0.5\n\t\t)\n\n\t\tthis._midpointHandle = {\n\t\t\taxis: this.info.transform.transpose ? (axis === 'x' ? 'y' : 'x') : axis,\n\t\t\tpoint,\n\t\t\tsegmentStart: this.points[this.points.length - 2].clone(),\n\t\t\tsegmentEnd: this.points[this.points.length - 1].clone(),\n\t\t}\n\n\t\treturn this\n\t}\n\n\tbuild(): ElbowArrowRoute {\n\t\tconst finalPoints = []\n\t\tfor (let i = 0; i < this.points.length; i++) {\n\t\t\tconst p0 = this.points[i]\n\t\t\tconst p1 = finalPoints[finalPoints.length - 1]\n\t\t\tconst p2 = finalPoints[finalPoints.length - 2]\n\n\t\t\tif (!p1 || !p2) {\n\t\t\t\tfinalPoints.push(p0)\n\t\t\t} else {\n\t\t\t\tconst d1x = Math.abs(p0.x - p1.x)\n\t\t\t\tconst d1y = Math.abs(p0.y - p1.y)\n\t\t\t\tconst d2x = Math.abs(p0.x - p2.x)\n\t\t\t\tconst d2y = Math.abs(p0.y - p2.y)\n\n\t\t\t\tif (d1x < MIN_DISTANCE && d1y < MIN_DISTANCE) {\n\t\t\t\t\t// this point is basically in the same place as the last one, so ignore it\n\t\t\t\t} else if (d1x < MIN_DISTANCE && d2x < MIN_DISTANCE) {\n\t\t\t\t\t// this coord is extending the same vertical line as the last two, so update the\n\t\t\t\t\t// last point to this one.\n\t\t\t\t\tp1.y = p0.y\n\t\t\t\t} else if (d1y < MIN_DISTANCE && d2y < MIN_DISTANCE) {\n\t\t\t\t\t// this coord is extending the same horizontal line as the last two, so update the\n\t\t\t\t\t// last point to this one.\n\t\t\t\t\tp1.x = p0.x\n\t\t\t\t} else {\n\t\t\t\t\t// this coord is changing direction, so add it to the points\n\t\t\t\t\tfinalPoints.push(p0)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tpoints: finalPoints,\n\t\t\tdistance: measureRouteManhattanDistance(finalPoints),\n\t\t\taEdgePicking: 'manual',\n\t\t\tbEdgePicking: 'manual',\n\t\t\tskipPointsWhenDrawing: new Set(),\n\t\t\tmidpointHandle: this._midpointHandle,\n\t\t}\n\t}\n}\n\nfunction measureRouteManhattanDistance(path: VecLike[]): number {\n\tlet distance = 0\n\tfor (let i = 0; i < path.length - 1; i++) {\n\t\tconst start = path[i]\n\t\tconst end = path[i + 1]\n\t\tdistance += Math.abs(end.x - start.x) + Math.abs(end.y - start.y)\n\t}\n\treturn distance\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAqC;AAIrC,MAAM,eAAe;AAEd,MAAM,uBAAuB;AAAA,EAGnC,YACkB,MACD,MACf;AAFgB;AACD;AAAA,EACd;AAAA,EALH,SAAgB,CAAC;AAAA,EAOjB,IAAI,GAAW,GAAiB;AAC/B,SAAK,OAAO,KAAK,KAAK,KAAK,IAAI,GAAG,CAAC,CAAC;AAEpC,WAAO;AAAA,EACR;AAAA,EAEQ,kBAAmD;AAAA,EAC3D,eAAe,MAAuB;AACrC,8BAAO,KAAK,oBAAoB,MAAM,iCAAiC;AAEvE,UAAM,QAAQ,kBAAI;AAAA,MACjB,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAAA,MAClC,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAAA,MAClC;AAAA,IACD;AAEA,SAAK,kBAAkB;AAAA,MACtB,MAAM,KAAK,KAAK,UAAU,YAAa,SAAS,MAAM,MAAM,MAAO;AAAA,MACnE;AAAA,MACA,cAAc,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,EAAE,MAAM;AAAA,MACxD,YAAY,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,EAAE,MAAM;AAAA,IACvD;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,QAAyB;AACxB,UAAM,cAAc,CAAC;AACrB,aAAS,IAAI,GAAG,IAAI,KAAK,OAAO,QAAQ,KAAK;AAC5C,YAAM,KAAK,KAAK,OAAO,CAAC;AACxB,YAAM,KAAK,YAAY,YAAY,SAAS,CAAC;AAC7C,YAAM,KAAK,YAAY,YAAY,SAAS,CAAC;AAE7C,UAAI,CAAC,MAAM,CAAC,IAAI;AACf,oBAAY,KAAK,EAAE;AAAA,MACpB,OAAO;AACN,cAAM,MAAM,KAAK,IAAI,GAAG,IAAI,GAAG,CAAC;AAChC,cAAM,MAAM,KAAK,IAAI,GAAG,IAAI,GAAG,CAAC;AAChC,cAAM,MAAM,KAAK,IAAI,GAAG,IAAI,GAAG,CAAC;AAChC,cAAM,MAAM,KAAK,IAAI,GAAG,IAAI,GAAG,CAAC;AAEhC,YAAI,MAAM,gBAAgB,MAAM,cAAc;AAAA,QAE9C,WAAW,MAAM,gBAAgB,MAAM,cAAc;AAGpD,aAAG,IAAI,GAAG;AAAA,QACX,WAAW,MAAM,gBAAgB,MAAM,cAAc;AAGpD,aAAG,IAAI,GAAG;AAAA,QACX,OAAO;AAEN,sBAAY,KAAK,EAAE;AAAA,QACpB;AAAA,MACD;AAAA,IACD;AAEA,WAAO;AAAA,MACN,MAAM,KAAK;AAAA,MACX,QAAQ;AAAA,MACR,UAAU,8BAA8B,WAAW;AAAA,MACnD,cAAc;AAAA,MACd,cAAc;AAAA,MACd,uBAAuB,oBAAI,IAAI;AAAA,MAC/B,gBAAgB,KAAK;AAAA,IACtB;AAAA,EACD;AACD;AAEA,SAAS,8BAA8B,MAAyB;AAC/D,MAAI,WAAW;AACf,WAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AACzC,UAAM,QAAQ,KAAK,CAAC;AACpB,UAAM,MAAM,KAAK,IAAI,CAAC;AACtB,gBAAY,KAAK,IAAI,IAAI,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,IAAI,IAAI,MAAM,CAAC;AAAA,EACjE;AACA,SAAO;AACR;",
  "names": []
}
