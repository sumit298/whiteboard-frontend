{
  "version": 3,
  "sources": ["../../../../../src/lib/shapes/arrow/elbow/getElbowArrowInfo.tsx"],
  "sourcesContent": ["import {\n\tapproximately,\n\tassert,\n\tBox,\n\tEditor,\n\texhaustiveSwitchError,\n\tGeometry2dFilters,\n\tlerp,\n\tMat,\n\tTLArrowBinding,\n\tTLArrowBindingProps,\n\tTLArrowShape,\n\tTLShapeId,\n\tVec,\n\tVecLike,\n\tVecModel,\n} from '@tldraw/editor'\nimport { ArrowShapeUtil } from '../ArrowShapeUtil'\nimport { BOUND_ARROW_OFFSET, STROKE_SIZES, TLArrowBindings } from '../shared'\nimport {\n\tElbowArrowAxes,\n\tElbowArrowBox,\n\tElbowArrowBoxEdges,\n\tElbowArrowEdge,\n\tElbowArrowInfo,\n\tElbowArrowInfoWithoutRoute,\n\tElbowArrowOptions,\n\tElbowArrowRoute,\n\tElbowArrowSide,\n\tElbowArrowSideWithAxis,\n\tElbowArrowTargetBox,\n\tElbowArrowTerminal,\n} from './definitions'\nimport { createRange, expandRange, isWithinRange, rangeSize, subtractRange } from './range'\nimport { ElbowArrowWorkingInfo } from './routes/ElbowArrowWorkingInfo'\nimport {\n\trouteArrowWithAutoEdgePicking,\n\trouteArrowWithManualEdgePicking,\n\trouteArrowWithPartialEdgePicking,\n} from './routes/routeArrowWithAutoEdgePicking'\n\nexport function getElbowArrowInfo(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\tbindings: TLArrowBindings\n): ElbowArrowInfo {\n\tconst shapeOptions = editor.getShapeUtil<ArrowShapeUtil>(arrow.type).options\n\tconst options: ElbowArrowOptions = {\n\t\telbowMidpoint: arrow.props.elbowMidPoint,\n\t\texpandElbowLegLength: shapeOptions.expandElbowLegLength[arrow.props.size] * arrow.props.scale,\n\t\tminElbowLegLength: shapeOptions.minElbowLegLength[arrow.props.size] * arrow.props.scale,\n\t}\n\n\t// Before we can do anything else, we need to find the start and end terminals of the arrow.\n\t// These contain the binding info, geometry, bounds, etc.\n\tlet startTerminal = getElbowArrowTerminalInfo(editor, arrow, bindings.start, arrow.props.start)\n\tlet endTerminal = getElbowArrowTerminalInfo(editor, arrow, bindings.end, arrow.props.end)\n\t// unclosed paths are weird - we handle them outside of the initial terminal info.\n\tstartTerminal = adjustTerminalForUnclosedPathIfNeeded(startTerminal, endTerminal, options)\n\tendTerminal = adjustTerminalForUnclosedPathIfNeeded(endTerminal, startTerminal, options)\n\n\t// Ther terminal might include a \"side\" if the user has explicitly indicated what side the arrow\n\t// should come from. There are two terminals, and two cases for each terminal (explicit side or\n\t// not), for a total for 4 cases to handle. In order to keep things a bit simpler though, we\n\t// only handle 3 cases: if start no side and end has a side, we flip them around. From here on\n\t// out, we use A and B to refer to the terminals as they may be swapped.\n\tconst swapOrder = !!(!startTerminal.side && endTerminal.side)\n\n\tlet { aTerminal, bTerminal } = swapOrder\n\t\t? { aTerminal: endTerminal, bTerminal: startTerminal }\n\t\t: { aTerminal: startTerminal, bTerminal: endTerminal }\n\n\t// We model each edge that an arrow might enter/exit from separately. If an edge is blocked,\n\t// `getUsableEdge` might return null.\n\tlet edgesA = {\n\t\ttop: getUsableEdge(aTerminal, bTerminal, 'top', options),\n\t\tright: getUsableEdge(aTerminal, bTerminal, 'right', options),\n\t\tbottom: getUsableEdge(aTerminal, bTerminal, 'bottom', options),\n\t\tleft: getUsableEdge(aTerminal, bTerminal, 'left', options),\n\t}\n\n\tlet edgesB = {\n\t\ttop: getUsableEdge(bTerminal, aTerminal, 'top', options),\n\t\tright: getUsableEdge(bTerminal, aTerminal, 'right', options),\n\t\tbottom: getUsableEdge(bTerminal, aTerminal, 'bottom', options),\n\t\tleft: getUsableEdge(bTerminal, aTerminal, 'left', options),\n\t}\n\n\t// We we don't have a usable edge because it's blocked, we can convert some of the terminals to\n\t// points. Point terminals have less strict edge routing rules, but don't look as good\n\t// generally. For example, the arrow might go through the shape instead of around.\n\tconst aIsUsable = hasUsableEdge(edgesA, aTerminal.side)\n\tconst bIsUsable = hasUsableEdge(edgesB, bTerminal.side)\n\tlet needsNewEdges = false\n\tif (!aIsUsable || !bIsUsable) {\n\t\tneedsNewEdges = true\n\t\tif (!aIsUsable) {\n\t\t\tbTerminal = convertTerminalToPoint(bTerminal)\n\t\t}\n\n\t\tif (!bIsUsable) {\n\t\t\taTerminal = convertTerminalToPoint(aTerminal)\n\t\t}\n\n\t\tif (bTerminal.bounds.containsPoint(aTerminal.target, options.expandElbowLegLength)) {\n\t\t\tbTerminal = convertTerminalToPoint(bTerminal)\n\t\t}\n\n\t\tif (aTerminal.bounds.containsPoint(bTerminal.target, options.expandElbowLegLength)) {\n\t\t\taTerminal = convertTerminalToPoint(aTerminal)\n\t\t}\n\t}\n\n\tif (needsNewEdges) {\n\t\tedgesA = {\n\t\t\ttop: getUsableEdge(aTerminal, bTerminal, 'top', options),\n\t\t\tright: getUsableEdge(aTerminal, bTerminal, 'right', options),\n\t\t\tbottom: getUsableEdge(aTerminal, bTerminal, 'bottom', options),\n\t\t\tleft: getUsableEdge(aTerminal, bTerminal, 'left', options),\n\t\t}\n\n\t\tedgesB = {\n\t\t\ttop: getUsableEdge(bTerminal, aTerminal, 'top', options),\n\t\t\tright: getUsableEdge(bTerminal, aTerminal, 'right', options),\n\t\t\tbottom: getUsableEdge(bTerminal, aTerminal, 'bottom', options),\n\t\t\tleft: getUsableEdge(bTerminal, aTerminal, 'left', options),\n\t\t}\n\t}\n\n\t// We expand the bounds of the terminals so we can route arrows around them without the arrows\n\t// being too close to the shapes.\n\tconst expandedA = aTerminal.isPoint\n\t\t? aTerminal.bounds\n\t\t: aTerminal.bounds.clone().expandBy(options.expandElbowLegLength)\n\tconst expandedB = bTerminal.isPoint\n\t\t? bTerminal.bounds\n\t\t: bTerminal.bounds.clone().expandBy(options.expandElbowLegLength)\n\n\tconst common: ElbowArrowBox = {\n\t\toriginal: Box.Common([aTerminal.bounds, bTerminal.bounds]),\n\t\texpanded: Box.Common([expandedA, expandedB]),\n\t}\n\n\t// Calculate the gaps between the two terminals. If gap is positive, B is to the right of A. If\n\t// it's negative, the opposite is true. If it's 0, there's no gap between the shapes in that\n\t// dimension.\n\tlet gapX = bTerminal.bounds.minX - aTerminal.bounds.maxX\n\tif (gapX < 0) {\n\t\tgapX = aTerminal.bounds.minX - bTerminal.bounds.maxX\n\t\tif (gapX < 0) {\n\t\t\tgapX = 0\n\t\t}\n\t\tgapX = -gapX\n\t}\n\tlet gapY = bTerminal.bounds.minY - aTerminal.bounds.maxY\n\tif (gapY < 0) {\n\t\tgapY = aTerminal.bounds.minY - bTerminal.bounds.maxY\n\t\tif (gapY < 0) {\n\t\t\tgapY = 0\n\t\t}\n\t\tgapY = -gapY\n\t}\n\n\t// The midpoint of the gap is a useful point to route arrows through, but the user can also drag\n\t// it to choose a new midpoint. First, we calculate some constraints we'll need to keep in mind\n\t// when figuring out the midpoint...\n\tconst aMinLength = aTerminal.minEndSegmentLength * 3\n\tconst bMinLength = bTerminal.minEndSegmentLength * 3\n\tconst minLegDistanceNeeded =\n\t\t(aTerminal.isPoint ? aMinLength : options.minElbowLegLength) +\n\t\t(bTerminal.isPoint ? bMinLength : options.minElbowLegLength)\n\n\t// ...then, the possible range of the midpoint. This is also used when dragging the midpoint.\n\tlet mxRange: null | { a: number; b: number } = null\n\tif (gapX > minLegDistanceNeeded) {\n\t\tmxRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.maxX + aMinLength : expandedA.maxX,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.minX - bMinLength : expandedB.minX,\n\t\t}\n\t} else if (gapX < -minLegDistanceNeeded) {\n\t\tmxRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.minX - aMinLength : expandedA.minX,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.maxX + bMinLength : expandedB.maxX,\n\t\t}\n\t}\n\n\tlet myRange: null | { a: number; b: number } = null\n\tif (gapY > minLegDistanceNeeded) {\n\t\tmyRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.maxY + aMinLength : expandedA.maxY,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.minY - bMinLength : expandedB.minY,\n\t\t}\n\t} else if (gapY < -minLegDistanceNeeded) {\n\t\tmyRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.minY - aMinLength : expandedA.minY,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.maxY + bMinLength : expandedB.maxY,\n\t\t}\n\t}\n\n\t// and finally we take the range and the midpoint prop and calculate the actual position of the\n\t// midpoint. Note that the midpoint and midpoint range can be null if the gap is too small for a\n\t// midpoint line.\n\tconst midpoint = swapOrder ? 1 - options.elbowMidpoint : options.elbowMidpoint\n\tconst mx = mxRange ? lerp(mxRange.a, mxRange.b, midpoint) : null\n\tconst my = myRange ? lerp(myRange.a, myRange.b, midpoint) : null\n\n\t// The info without route is given to the route-finding functions to route between the two\n\t// terminals.\n\tconst info: ElbowArrowInfoWithoutRoute = {\n\t\toptions,\n\t\tswapOrder,\n\t\tA: {\n\t\t\tisPoint: aTerminal.isPoint,\n\t\t\ttarget: aTerminal.target,\n\t\t\tisExact: aTerminal.isExact,\n\t\t\tarrowheadOffset: aTerminal.arrowheadOffset,\n\t\t\tminEndSegmentLength: aTerminal.minEndSegmentLength,\n\t\t\toriginal: aTerminal.bounds,\n\t\t\texpanded: expandedA,\n\t\t\tedges: edgesA,\n\t\t\tgeometry: aTerminal.geometry,\n\t\t},\n\t\tB: {\n\t\t\tisPoint: bTerminal.isPoint,\n\t\t\ttarget: bTerminal.target,\n\t\t\tisExact: bTerminal.isExact,\n\t\t\tarrowheadOffset: bTerminal.arrowheadOffset,\n\t\t\tminEndSegmentLength: bTerminal.minEndSegmentLength,\n\t\t\toriginal: bTerminal.bounds,\n\t\t\texpanded: expandedB,\n\t\t\tedges: edgesB,\n\t\t\tgeometry: bTerminal.geometry,\n\t\t},\n\t\tcommon,\n\t\tgapX,\n\t\tgapY,\n\t\tmidX: mx,\n\t\tmidY: my,\n\t}\n\n\t// We wrap the info in a working info object that lets us mutate and reset it as needed.\n\tconst workingInfo = new ElbowArrowWorkingInfo(info)\n\n\t// Figure out the final sides to use for each terminal.\n\tconst aSide = getSideToUse(aTerminal, bTerminal, info.A.edges)\n\tconst bSide = getSideToUse(bTerminal, aTerminal, info.B.edges)\n\n\t// try to find a route with the specification we have:\n\tlet route\n\tif (aSide && bSide) {\n\t\troute = routeArrowWithManualEdgePicking(workingInfo, aSide, bSide)\n\t} else if (aSide && !bSide) {\n\t\troute = routeArrowWithPartialEdgePicking(workingInfo, aSide)\n\t}\n\tif (!route) {\n\t\troute = routeArrowWithAutoEdgePicking(workingInfo, aSide || bSide ? 'fallback' : 'auto')\n\t}\n\n\tif (route) {\n\t\t// If we found a route, we need to fix it up. The route will only go to the bounding box of\n\t\t// the shape, so we need to cast the final segments into the actual geometry of the shape.\n\t\tcastPathSegmentIntoGeometry('first', info.A, info.B, route)\n\t\tcastPathSegmentIntoGeometry('last', info.B, info.A, route)\n\t\t// If we have tiny L-shaped arrows, the arrowheads look super janky. We fix those up by just\n\t\t// drawing a straight line instead.\n\t\tfixTinyEndNubs(route, aTerminal, bTerminal)\n\n\t\t// If we swapped the order way back of the start of things, we need to reverse the route so\n\t\t// it flows start -> end instead of A -> B.\n\t\tif (swapOrder) route.points.reverse()\n\t}\n\n\treturn {\n\t\t...info,\n\t\troute,\n\t\tmidXRange: mxRange\n\t\t\t? swapOrder\n\t\t\t\t? { lo: mxRange.b, hi: mxRange.a }\n\t\t\t\t: { lo: mxRange.a, hi: mxRange.b }\n\t\t\t: null,\n\t\tmidYRange: myRange\n\t\t\t? swapOrder\n\t\t\t\t? { lo: myRange.b, hi: myRange.a }\n\t\t\t\t: { lo: myRange.a, hi: myRange.b }\n\t\t\t: null,\n\t}\n}\n\n/**\n * Take the route from `getElbowArrowInfo` (which represents the visible body of the arrow) and\n * convert it into a path we can use to show that paths to the handles, which may extend further\n * into the target shape geometries.\n * @returns\n */\nexport function getRouteHandlePath(info: ElbowArrowInfo, route: ElbowArrowRoute): ElbowArrowRoute {\n\tconst startTarget = info.swapOrder ? info.B.target : info.A.target\n\tconst endTarget = info.swapOrder ? info.A.target : info.B.target\n\n\tconst firstSegmentLength = Vec.ManhattanDist(route.points[0], route.points[1])\n\tconst lastSegmentLength = Vec.ManhattanDist(\n\t\troute.points[route.points.length - 2],\n\t\troute.points[route.points.length - 1]\n\t)\n\n\tconst newFirstSegmentLength = Vec.ManhattanDist(startTarget, route.points[1])\n\tconst newLastSegmentLength = Vec.ManhattanDist(route.points[route.points.length - 2], endTarget)\n\n\tconst firstSegmentLengthChange = firstSegmentLength - newFirstSegmentLength\n\tconst lastSegmentLengthChange = lastSegmentLength - newLastSegmentLength\n\n\tconst newPoints = [startTarget, ...route.points, endTarget]\n\n\treturn {\n\t\tname: route.name,\n\t\tdistance: route.distance + firstSegmentLengthChange + lastSegmentLengthChange,\n\t\tpoints: newPoints.filter((p) => !route.skipPointsWhenDrawing.has(p)),\n\t\taEdgePicking: route.aEdgePicking,\n\t\tbEdgePicking: route.bEdgePicking,\n\t\tskipPointsWhenDrawing: route.skipPointsWhenDrawing,\n\t\tmidpointHandle: route.midpointHandle,\n\t}\n}\n\n/**\n * Take a normalizes anchor and return the side we think it's closest to.\n */\nexport function getEdgeFromNormalizedAnchor(normalizedAnchor: VecLike) {\n\tif (approximately(normalizedAnchor.x, 0.5) && approximately(normalizedAnchor.y, 0.5)) {\n\t\treturn null\n\t}\n\n\tif (\n\t\tMath.abs(normalizedAnchor.x - 0.5) >\n\t\t// slightly bias towards x arrows to prevent flickering when the anchor is right on the line\n\t\t// between the two directions\n\t\tMath.abs(normalizedAnchor.y - 0.5) - 0.0001\n\t) {\n\t\treturn normalizedAnchor.x < 0.5 ? 'left' : 'right'\n\t}\n\n\treturn normalizedAnchor.y < 0.5 ? 'top' : 'bottom'\n}\n\nfunction getElbowArrowTerminalInfo(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\tbinding: TLArrowBinding | undefined,\n\tpoint: VecModel\n): ElbowArrowTerminal {\n\tconst arrowStrokeSize = (STROKE_SIZES[arrow.props.size] * arrow.props.scale) / 2\n\tconst minEndSegmentLength = arrowStrokeSize * arrow.props.scale * 3\n\n\tif (binding) {\n\t\tconst target = editor.getShape(binding.toId)\n\t\tconst geometry = getBindingGeometryInArrowSpace(editor, arrow, binding.toId, binding.props)\n\t\tif (geometry && target) {\n\t\t\tlet arrowheadOffset = 0\n\t\t\tconst arrowheadProp = binding.props.terminal === 'start' ? 'arrowheadStart' : 'arrowheadEnd'\n\t\t\tif (arrow.props[arrowheadProp] !== 'none') {\n\t\t\t\tconst targetScale = 'scale' in target.props ? target.props.scale : 1\n\t\t\t\tconst targetStrokeSize =\n\t\t\t\t\t'size' in target.props ? ((STROKE_SIZES[target.props.size] ?? 0) * targetScale) / 2 : 0\n\n\t\t\t\tarrowheadOffset =\n\t\t\t\t\tarrowStrokeSize + targetStrokeSize + BOUND_ARROW_OFFSET * arrow.props.scale\n\t\t\t}\n\n\t\t\tlet side: ElbowArrowSideWithAxis | null = null\n\t\t\tconst targetPoint = geometry.target\n\t\t\tif (binding.props.isPrecise) {\n\t\t\t\tside = getEdgeFromNormalizedAnchor(\n\t\t\t\t\tVec.RotWith(\n\t\t\t\t\t\tbinding.props.normalizedAnchor,\n\t\t\t\t\t\t{ x: 0.5, y: 0.5 },\n\t\t\t\t\t\tgeometry.shapeToArrowTransform.rotation()\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttargetShapeId: binding.toId,\n\t\t\t\tisPoint: false,\n\t\t\t\tisExact: binding.props.isExact,\n\t\t\t\tbounds: geometry.bounds,\n\t\t\t\tgeometry: geometry.geometry,\n\t\t\t\ttarget: targetPoint,\n\t\t\t\tarrowheadOffset,\n\t\t\t\tminEndSegmentLength,\n\t\t\t\tside,\n\t\t\t\tsnap: binding.props.snap,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\ttargetShapeId: null,\n\t\tbounds: Box.FromCenter(point, { x: 0, y: 0 }),\n\t\tgeometry: null,\n\t\tisExact: false,\n\t\tisPoint: true,\n\t\ttarget: Vec.From(point),\n\t\tarrowheadOffset: 0,\n\t\tminEndSegmentLength,\n\t\tside: null,\n\t\tsnap: 'none',\n\t}\n}\n\nfunction getBindingGeometryInArrowSpace(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\ttargetId: TLShapeId,\n\tbindingProps: TLArrowBindingProps\n) {\n\tconst hasArrowhead =\n\t\tbindingProps.terminal === 'start'\n\t\t\t? arrow.props.arrowheadStart !== 'none'\n\t\t\t: arrow.props.arrowheadEnd !== 'none'\n\n\tconst targetGeometryInTargetSpace = editor.getShapeGeometry(\n\t\ttargetId,\n\t\thasArrowhead ? undefined : { context: '@tldraw/arrow-without-arrowhead' }\n\t)\n\n\tif (!targetGeometryInTargetSpace) {\n\t\treturn null\n\t}\n\n\tconst arrowTransform = editor.getShapePageTransform(arrow.id)\n\tconst shapeTransform = editor.getShapePageTransform(targetId)\n\tconst shapeToArrowTransform = arrowTransform.clone().invert().multiply(shapeTransform)\n\n\tconst targetGeometryInArrowSpace = targetGeometryInTargetSpace.transform(shapeToArrowTransform)\n\n\tconst center = { x: 0.5, y: 0.5 }\n\tconst normalizedAnchor = bindingProps.isPrecise ? bindingProps.normalizedAnchor : center\n\n\tconst targetInShapeSpace = {\n\t\tx: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minX,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxX,\n\t\t\tnormalizedAnchor.x\n\t\t),\n\t\ty: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minY,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxY,\n\t\t\tnormalizedAnchor.y\n\t\t),\n\t}\n\tconst centerInShapeSpace = {\n\t\tx: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minX,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxX,\n\t\t\tcenter.x\n\t\t),\n\t\ty: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minY,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxY,\n\t\t\tcenter.y\n\t\t),\n\t}\n\n\tconst targetInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, targetInShapeSpace)\n\tconst centerInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, centerInShapeSpace)\n\n\treturn {\n\t\tbounds: targetGeometryInArrowSpace.bounds,\n\t\tgeometry: targetGeometryInArrowSpace,\n\t\ttarget: targetInArrowSpace,\n\t\tcenter: centerInArrowSpace,\n\t\tshapeToArrowTransform,\n\t}\n}\n\nconst sideProps = {\n\ttop: {\n\t\texpand: -1,\n\t\tmain: 'minY',\n\t\topposite: 'maxY',\n\t\tcrossMid: 'midX',\n\t\tcrossMin: 'minX',\n\t\tcrossMax: 'maxX',\n\t\tbRangeExpand: 'max',\n\t\tcrossAxis: 'x',\n\t},\n\tbottom: {\n\t\texpand: 1,\n\t\tmain: 'maxY',\n\t\topposite: 'minY',\n\t\tcrossMid: 'midX',\n\t\tcrossMin: 'minX',\n\t\tcrossMax: 'maxX',\n\t\tbRangeExpand: 'min',\n\t\tcrossAxis: 'x',\n\t},\n\tleft: {\n\t\texpand: -1,\n\t\tmain: 'minX',\n\t\topposite: 'maxX',\n\t\tcrossMid: 'midY',\n\t\tcrossMin: 'minY',\n\t\tcrossMax: 'maxY',\n\t\tbRangeExpand: 'max',\n\t\tcrossAxis: 'y',\n\t},\n\tright: {\n\t\texpand: 1,\n\t\tmain: 'maxX',\n\t\topposite: 'minX',\n\t\tcrossMid: 'midY',\n\t\tcrossMin: 'minY',\n\t\tcrossMax: 'maxY',\n\t\tbRangeExpand: 'min',\n\t\tcrossAxis: 'y',\n\t},\n} as const\n\nexport function getUsableEdge(\n\ta: ElbowArrowTerminal,\n\tb: ElbowArrowTerminal,\n\tside: 'top' | 'right' | 'bottom' | 'left',\n\toptions: ElbowArrowOptions\n): ElbowArrowEdge | null {\n\tconst props = sideProps[side]\n\n\t// if a shape is bound to itself, by default we'd end up routing the arrow _within_ the shape -\n\t// as if it were a point-to-point arrow. if one of the bindings is specifically to the edge\n\t// though, we route it externally instead.\n\tconst isSelfBoundAndShouldRouteExternal =\n\t\ta.targetShapeId === b.targetShapeId &&\n\t\ta.targetShapeId !== null &&\n\t\t(a.snap === 'edge' || a.snap === 'edge-point') &&\n\t\t(b.snap === 'edge' || b.snap === 'edge-point')\n\n\tconst aValue = a.bounds[props.main]\n\tconst aExpanded = a.isPoint ? null : aValue + props.expand * options.expandElbowLegLength\n\n\tconst originalACrossRange = createRange(a.bounds[props.crossMin], a.bounds[props.crossMax])\n\tlet aCrossRange = originalACrossRange\n\n\t// this edge is too small to be useful:\n\tif (!aCrossRange) {\n\t\treturn null\n\t}\n\n\tassert(originalACrossRange)\n\tconst bRange = createRange(b.bounds[props.main], b.bounds[props.opposite])\n\tif (!b.isPoint) {\n\t\tbRange[props.bRangeExpand] -= options.minElbowLegLength * 2 * props.expand\n\t}\n\n\tconst bCrossRange = expandRange(\n\t\tcreateRange(b.bounds[props.crossMin], b.bounds[props.crossMax]),\n\t\toptions.expandElbowLegLength\n\t)\n\tassert(bRange && bCrossRange)\n\n\tlet isPartial = false\n\tif (\n\t\tisWithinRange(aValue, bRange) &&\n\t\t!a.isPoint &&\n\t\t!b.isPoint &&\n\t\t!isSelfBoundAndShouldRouteExternal\n\t) {\n\t\tconst subtracted = subtractRange(aCrossRange, bCrossRange)\n\t\tswitch (subtracted.length) {\n\t\t\tcase 0:\n\t\t\t\treturn null\n\t\t\tcase 1:\n\t\t\t\tisPartial = subtracted[0] !== aCrossRange\n\t\t\t\taCrossRange = subtracted[0]\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\tisPartial = true\n\t\t\t\taCrossRange =\n\t\t\t\t\trangeSize(subtracted[0]) > rangeSize(subtracted[1]) ? subtracted[0] : subtracted[1]\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(subtracted)\n\t\t}\n\t}\n\n\tif (!isWithinRange(a.target[props.crossAxis], aCrossRange)) {\n\t\treturn null\n\t}\n\tconst crossTarget = a.target[props.crossAxis]\n\n\treturn {\n\t\tvalue: aValue,\n\t\texpanded: aExpanded,\n\t\tcross: aCrossRange,\n\t\tcrossTarget,\n\t\tisPartial,\n\t}\n}\n\nfunction hasUsableEdge(edges: ElbowArrowBoxEdges, side: ElbowArrowSideWithAxis | null) {\n\tif (side === null) {\n\t\treturn !!(edges.bottom || edges.left || edges.right || edges.top)\n\t}\n\n\tif (side === 'x') {\n\t\treturn !!edges.left || !!edges.right\n\t}\n\n\tif (side === 'y') {\n\t\treturn !!edges.top || !!edges.bottom\n\t}\n\n\treturn !!edges[side]\n}\n\nfunction getSideToUse(\n\tbinding: ElbowArrowTerminal,\n\tother: ElbowArrowTerminal,\n\tedges: ElbowArrowBoxEdges | null\n): ElbowArrowSide | null {\n\tswitch (binding.side) {\n\t\tcase null:\n\t\t\treturn null\n\t\tcase 'x':\n\t\t\tif (binding.bounds.center.x > other.bounds.center.x && edges?.left) {\n\t\t\t\treturn 'left'\n\t\t\t} else if (edges?.right) {\n\t\t\t\treturn 'right'\n\t\t\t}\n\t\t\treturn null\n\t\tcase 'y':\n\t\t\tif (binding.bounds.center.y > other.bounds.center.y && edges?.top) {\n\t\t\t\treturn 'top'\n\t\t\t} else if (edges?.bottom) {\n\t\t\t\treturn 'bottom'\n\t\t\t}\n\t\t\treturn null\n\t\tdefault:\n\t\t\treturn binding.side\n\t}\n}\n\nfunction convertTerminalToPoint(terminal: ElbowArrowTerminal): ElbowArrowTerminal {\n\tif (terminal.isPoint) return terminal\n\n\tlet side: ElbowArrowSideWithAxis | null = null\n\tlet arrowheadOffset = 0\n\tif (terminal.snap === 'edge' || terminal.snap === 'edge-point') {\n\t\tarrowheadOffset = terminal.arrowheadOffset\n\t\tif (terminal.side === 'x' || terminal.side === 'left' || terminal.side === 'right') {\n\t\t\tside = 'x'\n\t\t}\n\t\tif (terminal.side === 'y' || terminal.side === 'top' || terminal.side === 'bottom') {\n\t\t\tside = 'y'\n\t\t}\n\t}\n\n\treturn {\n\t\ttargetShapeId: terminal.targetShapeId,\n\t\tside,\n\t\tbounds: new Box(terminal.target.x, terminal.target.y, 0, 0),\n\t\tgeometry: terminal.geometry,\n\t\ttarget: terminal.target,\n\t\tarrowheadOffset,\n\t\tminEndSegmentLength: terminal.minEndSegmentLength,\n\t\tisExact: terminal.isExact,\n\t\tisPoint: true,\n\t\tsnap: terminal.snap,\n\t}\n}\n\n/**\n * Make sure the first path segments goes fully into the target, and doesn't just point to its\n * bounding box. This modifies the route in-place.\n */\nfunction castPathSegmentIntoGeometry(\n\tsegment: 'first' | 'last',\n\ttarget: ElbowArrowTargetBox,\n\tother: ElbowArrowTargetBox,\n\troute: ElbowArrowRoute\n) {\n\tif (!target.geometry) return\n\n\tconst point1 = segment === 'first' ? route.points[0] : route.points[route.points.length - 1]\n\tconst point2 = segment === 'first' ? route.points[1] : route.points[route.points.length - 2]\n\n\tconst pointToFindClosestIntersectionTo = target.geometry.isClosed ? point2 : target.target\n\n\tconst initialDistance = Vec.ManhattanDist(point1, pointToFindClosestIntersectionTo)\n\n\tlet nearestIntersectionToPoint2: VecLike | null = null\n\tlet nearestDistanceToPoint2 = Infinity\n\n\tif (target.isExact) {\n\t\tnearestIntersectionToPoint2 = target.target\n\t} else if (target.geometry) {\n\t\tconst intersections = target.geometry.intersectLineSegment(point2, target.target, {\n\t\t\tincludeLabels: false,\n\t\t\tincludeInternal: false,\n\t\t})\n\t\tif (\n\t\t\ttarget.geometry.hitTestPoint(\n\t\t\t\ttarget.target,\n\t\t\t\tMath.max(1, target.arrowheadOffset),\n\t\t\t\ttrue,\n\t\t\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t\t\t)\n\t\t) {\n\t\t\tintersections.push(target.target)\n\t\t}\n\t\tfor (const intersection of intersections) {\n\t\t\tconst point2Distance = Vec.ManhattanDist(pointToFindClosestIntersectionTo, intersection)\n\t\t\tif (point2Distance < nearestDistanceToPoint2) {\n\t\t\t\tnearestDistanceToPoint2 = point2Distance\n\t\t\t\tnearestIntersectionToPoint2 = intersection\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nearestIntersectionToPoint2) {\n\t\tlet offset = target.arrowheadOffset\n\n\t\tconst currentFinalSegmentLength = Vec.ManhattanDist(point2, nearestIntersectionToPoint2)\n\t\tconst minLength = target.arrowheadOffset * 2\n\t\tif (currentFinalSegmentLength < minLength) {\n\t\t\tconst targetLength = minLength - target.arrowheadOffset\n\t\t\toffset = currentFinalSegmentLength - targetLength\n\t\t}\n\t\tif (offset < target.minEndSegmentLength) {\n\t\t\tif (target.geometry.bounds.containsPoint(other.target)) {\n\t\t\t\toffset = Math.max(0, offset)\n\t\t\t} else {\n\t\t\t\toffset = -target.arrowheadOffset\n\t\t\t}\n\t\t}\n\n\t\tlet nudgedPoint = nearestIntersectionToPoint2\n\t\tlet shouldAddExtraPointForNudge = false\n\t\tif (!target.isExact && offset !== 0) {\n\t\t\tconst nudged = Vec.Nudge(nearestIntersectionToPoint2, point2, offset)\n\t\t\tnudgedPoint = nudged\n\t\t\tif (\n\t\t\t\toffset < 0 &&\n\t\t\t\t!target.geometry.hitTestPoint(nudged, 0, true, Geometry2dFilters.EXCLUDE_NON_STANDARD)\n\t\t\t) {\n\t\t\t\t// point has been nudged _out_ of the shape so lets not actually apply the nudge\n\t\t\t\tnudgedPoint = nearestIntersectionToPoint2\n\t\t\t} else {\n\t\t\t\tif (offset < 0) {\n\t\t\t\t\tshouldAddExtraPointForNudge = true\n\t\t\t\t}\n\t\t\t\tnudgedPoint = nudged\n\t\t\t}\n\t\t}\n\n\t\tconst newDistance = Vec.ManhattanDist(point2, nudgedPoint)\n\t\troute.distance += newDistance - initialDistance\n\t\tpoint1.x = nudgedPoint.x\n\t\tpoint1.y = nudgedPoint.y\n\n\t\tif (shouldAddExtraPointForNudge) {\n\t\t\tconst midPoint = Vec.Lrp(point2, point1, 0.5)\n\t\t\troute.skipPointsWhenDrawing.add(midPoint)\n\t\t\troute.points.splice(segment === 'first' ? 1 : route.points.length - 1, 0, midPoint)\n\t\t}\n\t}\n}\n\nfunction fixTinyEndNubs(\n\troute: ElbowArrowRoute,\n\taTerminal: ElbowArrowTerminal,\n\tbTerminal: ElbowArrowTerminal\n) {\n\tif (!route) return\n\n\tif (route.points.length >= 3) {\n\t\tconst a = route.points[0]\n\t\tconst b = route.points[1]\n\t\tconst firstSegmentLength = Vec.ManhattanDist(a, b)\n\t\tif (firstSegmentLength < aTerminal.minEndSegmentLength) {\n\t\t\troute.points.splice(1, 1)\n\t\t\tif (route.points.length >= 3) {\n\t\t\t\tconst matchAxis = approximately(a.x, b.x) ? 'y' : 'x'\n\t\t\t\troute.points[1][matchAxis] = a[matchAxis]\n\t\t\t}\n\t\t}\n\t}\n\n\tif (route.points.length >= 3) {\n\t\tconst a = route.points[route.points.length - 1]\n\t\tconst b = route.points[route.points.length - 2]\n\t\tconst lastSegmentLength = Vec.ManhattanDist(a, b)\n\t\tif (lastSegmentLength < bTerminal.minEndSegmentLength) {\n\t\t\troute.points.splice(route.points.length - 2, 1)\n\t\t\tif (route.points.length >= 3) {\n\t\t\t\tconst matchAxis = approximately(a.x, b.x) ? 'y' : 'x'\n\t\t\t\troute.points[route.points.length - 2][matchAxis] = a[matchAxis]\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction adjustTerminalForUnclosedPathIfNeeded(\n\tterminal: ElbowArrowTerminal,\n\totherTerminal: ElbowArrowTerminal,\n\toptions: ElbowArrowOptions\n): ElbowArrowTerminal {\n\tif (!terminal.geometry || terminal.geometry.isClosed) return terminal\n\tconst normalizedPointAlongPath = terminal.geometry.uninterpolateAlongEdge(\n\t\tterminal.target,\n\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t)\n\n\tconst prev = terminal.geometry.interpolateAlongEdge(\n\t\tnormalizedPointAlongPath - 0.01 / terminal.geometry.length\n\t)\n\tconst next = terminal.geometry.interpolateAlongEdge(\n\t\tnormalizedPointAlongPath + 0.01 / terminal.geometry.length\n\t)\n\n\tconst normal = next.sub(prev).per().uni()\n\tconst axis = Math.abs(normal.x) > Math.abs(normal.y) ? ElbowArrowAxes.x : ElbowArrowAxes.y\n\n\tif (terminal.geometry.bounds.containsPoint(otherTerminal.target, options.expandElbowLegLength)) {\n\t\tterminal.side = axis.self\n\t\treturn convertTerminalToPoint(terminal)\n\t}\n\n\tconst min = axis.v(\n\t\tterminal.target[axis.self] - terminal.bounds[axis.size] * 2,\n\t\tterminal.target[axis.cross]\n\t)\n\tconst max = axis.v(\n\t\tterminal.target[axis.self] + terminal.bounds[axis.size] * 2,\n\t\tterminal.target[axis.cross]\n\t)\n\n\tlet furthestIntersectionTowardsMin: VecLike | null = null\n\tlet furthestIntersectionTowardsMinDistance = 0\n\tlet furthestIntersectionTowardsMax: VecLike | null = null\n\tlet furthestIntersectionTowardsMaxDistance = 0\n\tlet side: ElbowArrowSideWithAxis = axis.self\n\n\tfor (const intersection of terminal.geometry.intersectLineSegment(\n\t\tmin,\n\t\tmax,\n\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t)) {\n\t\tif (Math.abs(intersection[axis.self] - terminal.target[axis.self]) < 1) {\n\t\t\tcontinue\n\t\t}\n\t\tif (intersection[axis.self] < terminal.target[axis.self]) {\n\t\t\tif (\n\t\t\t\tVec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMinDistance\n\t\t\t) {\n\t\t\t\tfurthestIntersectionTowardsMinDistance = Vec.ManhattanDist(intersection, terminal.target)\n\t\t\t\tfurthestIntersectionTowardsMin = intersection\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tVec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMaxDistance\n\t\t\t) {\n\t\t\t\tfurthestIntersectionTowardsMaxDistance = Vec.ManhattanDist(intersection, terminal.target)\n\t\t\t\tfurthestIntersectionTowardsMax = intersection\n\t\t\t}\n\t\t}\n\t}\n\n\tif (furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {\n\t\tif (furthestIntersectionTowardsMinDistance > furthestIntersectionTowardsMaxDistance) {\n\t\t\tside = axis.hiEdge\n\t\t} else {\n\t\t\tside = axis.loEdge\n\t\t}\n\t} else if (furthestIntersectionTowardsMin && !furthestIntersectionTowardsMax) {\n\t\tside = axis.hiEdge\n\t} else if (!furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {\n\t\tside = axis.loEdge\n\t}\n\n\tterminal.side = side\n\treturn terminal\n}\n"],
  "mappings": "AAAA;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAKA;AAAA,OAGM;AAEP,SAAS,oBAAoB,oBAAqC;AAClE;AAAA,EACC;AAAA,OAYM;AACP,SAAS,aAAa,aAAa,eAAe,WAAW,qBAAqB;AAClF,SAAS,6BAA6B;AACtC;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,OACM;AAEA,SAAS,kBACf,QACA,OACA,UACiB;AACjB,QAAM,eAAe,OAAO,aAA6B,MAAM,IAAI,EAAE;AACrE,QAAM,UAA6B;AAAA,IAClC,eAAe,MAAM,MAAM;AAAA,IAC3B,sBAAsB,aAAa,qBAAqB,MAAM,MAAM,IAAI,IAAI,MAAM,MAAM;AAAA,IACxF,mBAAmB,aAAa,kBAAkB,MAAM,MAAM,IAAI,IAAI,MAAM,MAAM;AAAA,EACnF;AAIA,MAAI,gBAAgB,0BAA0B,QAAQ,OAAO,SAAS,OAAO,MAAM,MAAM,KAAK;AAC9F,MAAI,cAAc,0BAA0B,QAAQ,OAAO,SAAS,KAAK,MAAM,MAAM,GAAG;AAExF,kBAAgB,sCAAsC,eAAe,aAAa,OAAO;AACzF,gBAAc,sCAAsC,aAAa,eAAe,OAAO;AAOvF,QAAM,YAAY,CAAC,EAAE,CAAC,cAAc,QAAQ,YAAY;AAExD,MAAI,EAAE,WAAW,UAAU,IAAI,YAC5B,EAAE,WAAW,aAAa,WAAW,cAAc,IACnD,EAAE,WAAW,eAAe,WAAW,YAAY;AAItD,MAAI,SAAS;AAAA,IACZ,KAAK,cAAc,WAAW,WAAW,OAAO,OAAO;AAAA,IACvD,OAAO,cAAc,WAAW,WAAW,SAAS,OAAO;AAAA,IAC3D,QAAQ,cAAc,WAAW,WAAW,UAAU,OAAO;AAAA,IAC7D,MAAM,cAAc,WAAW,WAAW,QAAQ,OAAO;AAAA,EAC1D;AAEA,MAAI,SAAS;AAAA,IACZ,KAAK,cAAc,WAAW,WAAW,OAAO,OAAO;AAAA,IACvD,OAAO,cAAc,WAAW,WAAW,SAAS,OAAO;AAAA,IAC3D,QAAQ,cAAc,WAAW,WAAW,UAAU,OAAO;AAAA,IAC7D,MAAM,cAAc,WAAW,WAAW,QAAQ,OAAO;AAAA,EAC1D;AAKA,QAAM,YAAY,cAAc,QAAQ,UAAU,IAAI;AACtD,QAAM,YAAY,cAAc,QAAQ,UAAU,IAAI;AACtD,MAAI,gBAAgB;AACpB,MAAI,CAAC,aAAa,CAAC,WAAW;AAC7B,oBAAgB;AAChB,QAAI,CAAC,WAAW;AACf,kBAAY,uBAAuB,SAAS;AAAA,IAC7C;AAEA,QAAI,CAAC,WAAW;AACf,kBAAY,uBAAuB,SAAS;AAAA,IAC7C;AAEA,QAAI,UAAU,OAAO,cAAc,UAAU,QAAQ,QAAQ,oBAAoB,GAAG;AACnF,kBAAY,uBAAuB,SAAS;AAAA,IAC7C;AAEA,QAAI,UAAU,OAAO,cAAc,UAAU,QAAQ,QAAQ,oBAAoB,GAAG;AACnF,kBAAY,uBAAuB,SAAS;AAAA,IAC7C;AAAA,EACD;AAEA,MAAI,eAAe;AAClB,aAAS;AAAA,MACR,KAAK,cAAc,WAAW,WAAW,OAAO,OAAO;AAAA,MACvD,OAAO,cAAc,WAAW,WAAW,SAAS,OAAO;AAAA,MAC3D,QAAQ,cAAc,WAAW,WAAW,UAAU,OAAO;AAAA,MAC7D,MAAM,cAAc,WAAW,WAAW,QAAQ,OAAO;AAAA,IAC1D;AAEA,aAAS;AAAA,MACR,KAAK,cAAc,WAAW,WAAW,OAAO,OAAO;AAAA,MACvD,OAAO,cAAc,WAAW,WAAW,SAAS,OAAO;AAAA,MAC3D,QAAQ,cAAc,WAAW,WAAW,UAAU,OAAO;AAAA,MAC7D,MAAM,cAAc,WAAW,WAAW,QAAQ,OAAO;AAAA,IAC1D;AAAA,EACD;AAIA,QAAM,YAAY,UAAU,UACzB,UAAU,SACV,UAAU,OAAO,MAAM,EAAE,SAAS,QAAQ,oBAAoB;AACjE,QAAM,YAAY,UAAU,UACzB,UAAU,SACV,UAAU,OAAO,MAAM,EAAE,SAAS,QAAQ,oBAAoB;AAEjE,QAAM,SAAwB;AAAA,IAC7B,UAAU,IAAI,OAAO,CAAC,UAAU,QAAQ,UAAU,MAAM,CAAC;AAAA,IACzD,UAAU,IAAI,OAAO,CAAC,WAAW,SAAS,CAAC;AAAA,EAC5C;AAKA,MAAI,OAAO,UAAU,OAAO,OAAO,UAAU,OAAO;AACpD,MAAI,OAAO,GAAG;AACb,WAAO,UAAU,OAAO,OAAO,UAAU,OAAO;AAChD,QAAI,OAAO,GAAG;AACb,aAAO;AAAA,IACR;AACA,WAAO,CAAC;AAAA,EACT;AACA,MAAI,OAAO,UAAU,OAAO,OAAO,UAAU,OAAO;AACpD,MAAI,OAAO,GAAG;AACb,WAAO,UAAU,OAAO,OAAO,UAAU,OAAO;AAChD,QAAI,OAAO,GAAG;AACb,aAAO;AAAA,IACR;AACA,WAAO,CAAC;AAAA,EACT;AAKA,QAAM,aAAa,UAAU,sBAAsB;AACnD,QAAM,aAAa,UAAU,sBAAsB;AACnD,QAAM,wBACJ,UAAU,UAAU,aAAa,QAAQ,sBACzC,UAAU,UAAU,aAAa,QAAQ;AAG3C,MAAI,UAA2C;AAC/C,MAAI,OAAO,sBAAsB;AAChC,cAAU;AAAA,MACT,GAAG,UAAU,UAAU,UAAU,OAAO,OAAO,aAAa,UAAU;AAAA,MACtE,GAAG,UAAU,UAAU,UAAU,OAAO,OAAO,aAAa,UAAU;AAAA,IACvE;AAAA,EACD,WAAW,OAAO,CAAC,sBAAsB;AACxC,cAAU;AAAA,MACT,GAAG,UAAU,UAAU,UAAU,OAAO,OAAO,aAAa,UAAU;AAAA,MACtE,GAAG,UAAU,UAAU,UAAU,OAAO,OAAO,aAAa,UAAU;AAAA,IACvE;AAAA,EACD;AAEA,MAAI,UAA2C;AAC/C,MAAI,OAAO,sBAAsB;AAChC,cAAU;AAAA,MACT,GAAG,UAAU,UAAU,UAAU,OAAO,OAAO,aAAa,UAAU;AAAA,MACtE,GAAG,UAAU,UAAU,UAAU,OAAO,OAAO,aAAa,UAAU;AAAA,IACvE;AAAA,EACD,WAAW,OAAO,CAAC,sBAAsB;AACxC,cAAU;AAAA,MACT,GAAG,UAAU,UAAU,UAAU,OAAO,OAAO,aAAa,UAAU;AAAA,MACtE,GAAG,UAAU,UAAU,UAAU,OAAO,OAAO,aAAa,UAAU;AAAA,IACvE;AAAA,EACD;AAKA,QAAM,WAAW,YAAY,IAAI,QAAQ,gBAAgB,QAAQ;AACjE,QAAM,KAAK,UAAU,KAAK,QAAQ,GAAG,QAAQ,GAAG,QAAQ,IAAI;AAC5D,QAAM,KAAK,UAAU,KAAK,QAAQ,GAAG,QAAQ,GAAG,QAAQ,IAAI;AAI5D,QAAM,OAAmC;AAAA,IACxC;AAAA,IACA;AAAA,IACA,GAAG;AAAA,MACF,SAAS,UAAU;AAAA,MACnB,QAAQ,UAAU;AAAA,MAClB,SAAS,UAAU;AAAA,MACnB,iBAAiB,UAAU;AAAA,MAC3B,qBAAqB,UAAU;AAAA,MAC/B,UAAU,UAAU;AAAA,MACpB,UAAU;AAAA,MACV,OAAO;AAAA,MACP,UAAU,UAAU;AAAA,IACrB;AAAA,IACA,GAAG;AAAA,MACF,SAAS,UAAU;AAAA,MACnB,QAAQ,UAAU;AAAA,MAClB,SAAS,UAAU;AAAA,MACnB,iBAAiB,UAAU;AAAA,MAC3B,qBAAqB,UAAU;AAAA,MAC/B,UAAU,UAAU;AAAA,MACpB,UAAU;AAAA,MACV,OAAO;AAAA,MACP,UAAU,UAAU;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM;AAAA,IACN,MAAM;AAAA,EACP;AAGA,QAAM,cAAc,IAAI,sBAAsB,IAAI;AAGlD,QAAM,QAAQ,aAAa,WAAW,WAAW,KAAK,EAAE,KAAK;AAC7D,QAAM,QAAQ,aAAa,WAAW,WAAW,KAAK,EAAE,KAAK;AAG7D,MAAI;AACJ,MAAI,SAAS,OAAO;AACnB,YAAQ,gCAAgC,aAAa,OAAO,KAAK;AAAA,EAClE,WAAW,SAAS,CAAC,OAAO;AAC3B,YAAQ,iCAAiC,aAAa,KAAK;AAAA,EAC5D;AACA,MAAI,CAAC,OAAO;AACX,YAAQ,8BAA8B,aAAa,SAAS,QAAQ,aAAa,MAAM;AAAA,EACxF;AAEA,MAAI,OAAO;AAGV,gCAA4B,SAAS,KAAK,GAAG,KAAK,GAAG,KAAK;AAC1D,gCAA4B,QAAQ,KAAK,GAAG,KAAK,GAAG,KAAK;AAGzD,mBAAe,OAAO,WAAW,SAAS;AAI1C,QAAI,UAAW,OAAM,OAAO,QAAQ;AAAA,EACrC;AAEA,SAAO;AAAA,IACN,GAAG;AAAA,IACH;AAAA,IACA,WAAW,UACR,YACC,EAAE,IAAI,QAAQ,GAAG,IAAI,QAAQ,EAAE,IAC/B,EAAE,IAAI,QAAQ,GAAG,IAAI,QAAQ,EAAE,IAChC;AAAA,IACH,WAAW,UACR,YACC,EAAE,IAAI,QAAQ,GAAG,IAAI,QAAQ,EAAE,IAC/B,EAAE,IAAI,QAAQ,GAAG,IAAI,QAAQ,EAAE,IAChC;AAAA,EACJ;AACD;AAQO,SAAS,mBAAmB,MAAsB,OAAyC;AACjG,QAAM,cAAc,KAAK,YAAY,KAAK,EAAE,SAAS,KAAK,EAAE;AAC5D,QAAM,YAAY,KAAK,YAAY,KAAK,EAAE,SAAS,KAAK,EAAE;AAE1D,QAAM,qBAAqB,IAAI,cAAc,MAAM,OAAO,CAAC,GAAG,MAAM,OAAO,CAAC,CAAC;AAC7E,QAAM,oBAAoB,IAAI;AAAA,IAC7B,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC;AAAA,IACpC,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC;AAAA,EACrC;AAEA,QAAM,wBAAwB,IAAI,cAAc,aAAa,MAAM,OAAO,CAAC,CAAC;AAC5E,QAAM,uBAAuB,IAAI,cAAc,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,GAAG,SAAS;AAE/F,QAAM,2BAA2B,qBAAqB;AACtD,QAAM,0BAA0B,oBAAoB;AAEpD,QAAM,YAAY,CAAC,aAAa,GAAG,MAAM,QAAQ,SAAS;AAE1D,SAAO;AAAA,IACN,MAAM,MAAM;AAAA,IACZ,UAAU,MAAM,WAAW,2BAA2B;AAAA,IACtD,QAAQ,UAAU,OAAO,CAAC,MAAM,CAAC,MAAM,sBAAsB,IAAI,CAAC,CAAC;AAAA,IACnE,cAAc,MAAM;AAAA,IACpB,cAAc,MAAM;AAAA,IACpB,uBAAuB,MAAM;AAAA,IAC7B,gBAAgB,MAAM;AAAA,EACvB;AACD;AAKO,SAAS,4BAA4B,kBAA2B;AACtE,MAAI,cAAc,iBAAiB,GAAG,GAAG,KAAK,cAAc,iBAAiB,GAAG,GAAG,GAAG;AACrF,WAAO;AAAA,EACR;AAEA,MACC,KAAK,IAAI,iBAAiB,IAAI,GAAG;AAAA;AAAA,EAGjC,KAAK,IAAI,iBAAiB,IAAI,GAAG,IAAI,MACpC;AACD,WAAO,iBAAiB,IAAI,MAAM,SAAS;AAAA,EAC5C;AAEA,SAAO,iBAAiB,IAAI,MAAM,QAAQ;AAC3C;AAEA,SAAS,0BACR,QACA,OACA,SACA,OACqB;AACrB,QAAM,kBAAmB,aAAa,MAAM,MAAM,IAAI,IAAI,MAAM,MAAM,QAAS;AAC/E,QAAM,sBAAsB,kBAAkB,MAAM,MAAM,QAAQ;AAElE,MAAI,SAAS;AACZ,UAAM,SAAS,OAAO,SAAS,QAAQ,IAAI;AAC3C,UAAM,WAAW,+BAA+B,QAAQ,OAAO,QAAQ,MAAM,QAAQ,KAAK;AAC1F,QAAI,YAAY,QAAQ;AACvB,UAAI,kBAAkB;AACtB,YAAM,gBAAgB,QAAQ,MAAM,aAAa,UAAU,mBAAmB;AAC9E,UAAI,MAAM,MAAM,aAAa,MAAM,QAAQ;AAC1C,cAAM,cAAc,WAAW,OAAO,QAAQ,OAAO,MAAM,QAAQ;AACnE,cAAM,mBACL,UAAU,OAAO,SAAU,aAAa,OAAO,MAAM,IAAI,KAAK,KAAK,cAAe,IAAI;AAEvF,0BACC,kBAAkB,mBAAmB,qBAAqB,MAAM,MAAM;AAAA,MACxE;AAEA,UAAI,OAAsC;AAC1C,YAAM,cAAc,SAAS;AAC7B,UAAI,QAAQ,MAAM,WAAW;AAC5B,eAAO;AAAA,UACN,IAAI;AAAA,YACH,QAAQ,MAAM;AAAA,YACd,EAAE,GAAG,KAAK,GAAG,IAAI;AAAA,YACjB,SAAS,sBAAsB,SAAS;AAAA,UACzC;AAAA,QACD;AAAA,MACD;AAEA,aAAO;AAAA,QACN,eAAe,QAAQ;AAAA,QACvB,SAAS;AAAA,QACT,SAAS,QAAQ,MAAM;AAAA,QACvB,QAAQ,SAAS;AAAA,QACjB,UAAU,SAAS;AAAA,QACnB,QAAQ;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM,QAAQ,MAAM;AAAA,MACrB;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AAAA,IACN,eAAe;AAAA,IACf,QAAQ,IAAI,WAAW,OAAO,EAAE,GAAG,GAAG,GAAG,EAAE,CAAC;AAAA,IAC5C,UAAU;AAAA,IACV,SAAS;AAAA,IACT,SAAS;AAAA,IACT,QAAQ,IAAI,KAAK,KAAK;AAAA,IACtB,iBAAiB;AAAA,IACjB;AAAA,IACA,MAAM;AAAA,IACN,MAAM;AAAA,EACP;AACD;AAEA,SAAS,+BACR,QACA,OACA,UACA,cACC;AACD,QAAM,eACL,aAAa,aAAa,UACvB,MAAM,MAAM,mBAAmB,SAC/B,MAAM,MAAM,iBAAiB;AAEjC,QAAM,8BAA8B,OAAO;AAAA,IAC1C;AAAA,IACA,eAAe,SAAY,EAAE,SAAS,kCAAkC;AAAA,EACzE;AAEA,MAAI,CAAC,6BAA6B;AACjC,WAAO;AAAA,EACR;AAEA,QAAM,iBAAiB,OAAO,sBAAsB,MAAM,EAAE;AAC5D,QAAM,iBAAiB,OAAO,sBAAsB,QAAQ;AAC5D,QAAM,wBAAwB,eAAe,MAAM,EAAE,OAAO,EAAE,SAAS,cAAc;AAErF,QAAM,6BAA6B,4BAA4B,UAAU,qBAAqB;AAE9F,QAAM,SAAS,EAAE,GAAG,KAAK,GAAG,IAAI;AAChC,QAAM,mBAAmB,aAAa,YAAY,aAAa,mBAAmB;AAElF,QAAM,qBAAqB;AAAA,IAC1B,GAAG;AAAA,MACF,4BAA4B,OAAO;AAAA,MACnC,4BAA4B,OAAO;AAAA,MACnC,iBAAiB;AAAA,IAClB;AAAA,IACA,GAAG;AAAA,MACF,4BAA4B,OAAO;AAAA,MACnC,4BAA4B,OAAO;AAAA,MACnC,iBAAiB;AAAA,IAClB;AAAA,EACD;AACA,QAAM,qBAAqB;AAAA,IAC1B,GAAG;AAAA,MACF,4BAA4B,OAAO;AAAA,MACnC,4BAA4B,OAAO;AAAA,MACnC,OAAO;AAAA,IACR;AAAA,IACA,GAAG;AAAA,MACF,4BAA4B,OAAO;AAAA,MACnC,4BAA4B,OAAO;AAAA,MACnC,OAAO;AAAA,IACR;AAAA,EACD;AAEA,QAAM,qBAAqB,IAAI,aAAa,uBAAuB,kBAAkB;AACrF,QAAM,qBAAqB,IAAI,aAAa,uBAAuB,kBAAkB;AAErF,SAAO;AAAA,IACN,QAAQ,2BAA2B;AAAA,IACnC,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR;AAAA,EACD;AACD;AAEA,MAAM,YAAY;AAAA,EACjB,KAAK;AAAA,IACJ,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,cAAc;AAAA,IACd,WAAW;AAAA,EACZ;AAAA,EACA,QAAQ;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,cAAc;AAAA,IACd,WAAW;AAAA,EACZ;AAAA,EACA,MAAM;AAAA,IACL,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,cAAc;AAAA,IACd,WAAW;AAAA,EACZ;AAAA,EACA,OAAO;AAAA,IACN,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,cAAc;AAAA,IACd,WAAW;AAAA,EACZ;AACD;AAEO,SAAS,cACf,GACA,GACA,MACA,SACwB;AACxB,QAAM,QAAQ,UAAU,IAAI;AAK5B,QAAM,oCACL,EAAE,kBAAkB,EAAE,iBACtB,EAAE,kBAAkB,SACnB,EAAE,SAAS,UAAU,EAAE,SAAS,kBAChC,EAAE,SAAS,UAAU,EAAE,SAAS;AAElC,QAAM,SAAS,EAAE,OAAO,MAAM,IAAI;AAClC,QAAM,YAAY,EAAE,UAAU,OAAO,SAAS,MAAM,SAAS,QAAQ;AAErE,QAAM,sBAAsB,YAAY,EAAE,OAAO,MAAM,QAAQ,GAAG,EAAE,OAAO,MAAM,QAAQ,CAAC;AAC1F,MAAI,cAAc;AAGlB,MAAI,CAAC,aAAa;AACjB,WAAO;AAAA,EACR;AAEA,SAAO,mBAAmB;AAC1B,QAAM,SAAS,YAAY,EAAE,OAAO,MAAM,IAAI,GAAG,EAAE,OAAO,MAAM,QAAQ,CAAC;AACzE,MAAI,CAAC,EAAE,SAAS;AACf,WAAO,MAAM,YAAY,KAAK,QAAQ,oBAAoB,IAAI,MAAM;AAAA,EACrE;AAEA,QAAM,cAAc;AAAA,IACnB,YAAY,EAAE,OAAO,MAAM,QAAQ,GAAG,EAAE,OAAO,MAAM,QAAQ,CAAC;AAAA,IAC9D,QAAQ;AAAA,EACT;AACA,SAAO,UAAU,WAAW;AAE5B,MAAI,YAAY;AAChB,MACC,cAAc,QAAQ,MAAM,KAC5B,CAAC,EAAE,WACH,CAAC,EAAE,WACH,CAAC,mCACA;AACD,UAAM,aAAa,cAAc,aAAa,WAAW;AACzD,YAAQ,WAAW,QAAQ;AAAA,MAC1B,KAAK;AACJ,eAAO;AAAA,MACR,KAAK;AACJ,oBAAY,WAAW,CAAC,MAAM;AAC9B,sBAAc,WAAW,CAAC;AAC1B;AAAA,MACD,KAAK;AACJ,oBAAY;AACZ,sBACC,UAAU,WAAW,CAAC,CAAC,IAAI,UAAU,WAAW,CAAC,CAAC,IAAI,WAAW,CAAC,IAAI,WAAW,CAAC;AACnF;AAAA,MACD;AACC,8BAAsB,UAAU;AAAA,IAClC;AAAA,EACD;AAEA,MAAI,CAAC,cAAc,EAAE,OAAO,MAAM,SAAS,GAAG,WAAW,GAAG;AAC3D,WAAO;AAAA,EACR;AACA,QAAM,cAAc,EAAE,OAAO,MAAM,SAAS;AAE5C,SAAO;AAAA,IACN,OAAO;AAAA,IACP,UAAU;AAAA,IACV,OAAO;AAAA,IACP;AAAA,IACA;AAAA,EACD;AACD;AAEA,SAAS,cAAc,OAA2B,MAAqC;AACtF,MAAI,SAAS,MAAM;AAClB,WAAO,CAAC,EAAE,MAAM,UAAU,MAAM,QAAQ,MAAM,SAAS,MAAM;AAAA,EAC9D;AAEA,MAAI,SAAS,KAAK;AACjB,WAAO,CAAC,CAAC,MAAM,QAAQ,CAAC,CAAC,MAAM;AAAA,EAChC;AAEA,MAAI,SAAS,KAAK;AACjB,WAAO,CAAC,CAAC,MAAM,OAAO,CAAC,CAAC,MAAM;AAAA,EAC/B;AAEA,SAAO,CAAC,CAAC,MAAM,IAAI;AACpB;AAEA,SAAS,aACR,SACA,OACA,OACwB;AACxB,UAAQ,QAAQ,MAAM;AAAA,IACrB,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AACJ,UAAI,QAAQ,OAAO,OAAO,IAAI,MAAM,OAAO,OAAO,KAAK,OAAO,MAAM;AACnE,eAAO;AAAA,MACR,WAAW,OAAO,OAAO;AACxB,eAAO;AAAA,MACR;AACA,aAAO;AAAA,IACR,KAAK;AACJ,UAAI,QAAQ,OAAO,OAAO,IAAI,MAAM,OAAO,OAAO,KAAK,OAAO,KAAK;AAClE,eAAO;AAAA,MACR,WAAW,OAAO,QAAQ;AACzB,eAAO;AAAA,MACR;AACA,aAAO;AAAA,IACR;AACC,aAAO,QAAQ;AAAA,EACjB;AACD;AAEA,SAAS,uBAAuB,UAAkD;AACjF,MAAI,SAAS,QAAS,QAAO;AAE7B,MAAI,OAAsC;AAC1C,MAAI,kBAAkB;AACtB,MAAI,SAAS,SAAS,UAAU,SAAS,SAAS,cAAc;AAC/D,sBAAkB,SAAS;AAC3B,QAAI,SAAS,SAAS,OAAO,SAAS,SAAS,UAAU,SAAS,SAAS,SAAS;AACnF,aAAO;AAAA,IACR;AACA,QAAI,SAAS,SAAS,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS,UAAU;AACnF,aAAO;AAAA,IACR;AAAA,EACD;AAEA,SAAO;AAAA,IACN,eAAe,SAAS;AAAA,IACxB;AAAA,IACA,QAAQ,IAAI,IAAI,SAAS,OAAO,GAAG,SAAS,OAAO,GAAG,GAAG,CAAC;AAAA,IAC1D,UAAU,SAAS;AAAA,IACnB,QAAQ,SAAS;AAAA,IACjB;AAAA,IACA,qBAAqB,SAAS;AAAA,IAC9B,SAAS,SAAS;AAAA,IAClB,SAAS;AAAA,IACT,MAAM,SAAS;AAAA,EAChB;AACD;AAMA,SAAS,4BACR,SACA,QACA,OACA,OACC;AACD,MAAI,CAAC,OAAO,SAAU;AAEtB,QAAM,SAAS,YAAY,UAAU,MAAM,OAAO,CAAC,IAAI,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC;AAC3F,QAAM,SAAS,YAAY,UAAU,MAAM,OAAO,CAAC,IAAI,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC;AAE3F,QAAM,mCAAmC,OAAO,SAAS,WAAW,SAAS,OAAO;AAEpF,QAAM,kBAAkB,IAAI,cAAc,QAAQ,gCAAgC;AAElF,MAAI,8BAA8C;AAClD,MAAI,0BAA0B;AAE9B,MAAI,OAAO,SAAS;AACnB,kCAA8B,OAAO;AAAA,EACtC,WAAW,OAAO,UAAU;AAC3B,UAAM,gBAAgB,OAAO,SAAS,qBAAqB,QAAQ,OAAO,QAAQ;AAAA,MACjF,eAAe;AAAA,MACf,iBAAiB;AAAA,IAClB,CAAC;AACD,QACC,OAAO,SAAS;AAAA,MACf,OAAO;AAAA,MACP,KAAK,IAAI,GAAG,OAAO,eAAe;AAAA,MAClC;AAAA,MACA,kBAAkB;AAAA,IACnB,GACC;AACD,oBAAc,KAAK,OAAO,MAAM;AAAA,IACjC;AACA,eAAW,gBAAgB,eAAe;AACzC,YAAM,iBAAiB,IAAI,cAAc,kCAAkC,YAAY;AACvF,UAAI,iBAAiB,yBAAyB;AAC7C,kCAA0B;AAC1B,sCAA8B;AAAA,MAC/B;AAAA,IACD;AAAA,EACD;AAEA,MAAI,6BAA6B;AAChC,QAAI,SAAS,OAAO;AAEpB,UAAM,4BAA4B,IAAI,cAAc,QAAQ,2BAA2B;AACvF,UAAM,YAAY,OAAO,kBAAkB;AAC3C,QAAI,4BAA4B,WAAW;AAC1C,YAAM,eAAe,YAAY,OAAO;AACxC,eAAS,4BAA4B;AAAA,IACtC;AACA,QAAI,SAAS,OAAO,qBAAqB;AACxC,UAAI,OAAO,SAAS,OAAO,cAAc,MAAM,MAAM,GAAG;AACvD,iBAAS,KAAK,IAAI,GAAG,MAAM;AAAA,MAC5B,OAAO;AACN,iBAAS,CAAC,OAAO;AAAA,MAClB;AAAA,IACD;AAEA,QAAI,cAAc;AAClB,QAAI,8BAA8B;AAClC,QAAI,CAAC,OAAO,WAAW,WAAW,GAAG;AACpC,YAAM,SAAS,IAAI,MAAM,6BAA6B,QAAQ,MAAM;AACpE,oBAAc;AACd,UACC,SAAS,KACT,CAAC,OAAO,SAAS,aAAa,QAAQ,GAAG,MAAM,kBAAkB,oBAAoB,GACpF;AAED,sBAAc;AAAA,MACf,OAAO;AACN,YAAI,SAAS,GAAG;AACf,wCAA8B;AAAA,QAC/B;AACA,sBAAc;AAAA,MACf;AAAA,IACD;AAEA,UAAM,cAAc,IAAI,cAAc,QAAQ,WAAW;AACzD,UAAM,YAAY,cAAc;AAChC,WAAO,IAAI,YAAY;AACvB,WAAO,IAAI,YAAY;AAEvB,QAAI,6BAA6B;AAChC,YAAM,WAAW,IAAI,IAAI,QAAQ,QAAQ,GAAG;AAC5C,YAAM,sBAAsB,IAAI,QAAQ;AACxC,YAAM,OAAO,OAAO,YAAY,UAAU,IAAI,MAAM,OAAO,SAAS,GAAG,GAAG,QAAQ;AAAA,IACnF;AAAA,EACD;AACD;AAEA,SAAS,eACR,OACA,WACA,WACC;AACD,MAAI,CAAC,MAAO;AAEZ,MAAI,MAAM,OAAO,UAAU,GAAG;AAC7B,UAAM,IAAI,MAAM,OAAO,CAAC;AACxB,UAAM,IAAI,MAAM,OAAO,CAAC;AACxB,UAAM,qBAAqB,IAAI,cAAc,GAAG,CAAC;AACjD,QAAI,qBAAqB,UAAU,qBAAqB;AACvD,YAAM,OAAO,OAAO,GAAG,CAAC;AACxB,UAAI,MAAM,OAAO,UAAU,GAAG;AAC7B,cAAM,YAAY,cAAc,EAAE,GAAG,EAAE,CAAC,IAAI,MAAM;AAClD,cAAM,OAAO,CAAC,EAAE,SAAS,IAAI,EAAE,SAAS;AAAA,MACzC;AAAA,IACD;AAAA,EACD;AAEA,MAAI,MAAM,OAAO,UAAU,GAAG;AAC7B,UAAM,IAAI,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC;AAC9C,UAAM,IAAI,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC;AAC9C,UAAM,oBAAoB,IAAI,cAAc,GAAG,CAAC;AAChD,QAAI,oBAAoB,UAAU,qBAAqB;AACtD,YAAM,OAAO,OAAO,MAAM,OAAO,SAAS,GAAG,CAAC;AAC9C,UAAI,MAAM,OAAO,UAAU,GAAG;AAC7B,cAAM,YAAY,cAAc,EAAE,GAAG,EAAE,CAAC,IAAI,MAAM;AAClD,cAAM,OAAO,MAAM,OAAO,SAAS,CAAC,EAAE,SAAS,IAAI,EAAE,SAAS;AAAA,MAC/D;AAAA,IACD;AAAA,EACD;AACD;AAEA,SAAS,sCACR,UACA,eACA,SACqB;AACrB,MAAI,CAAC,SAAS,YAAY,SAAS,SAAS,SAAU,QAAO;AAC7D,QAAM,2BAA2B,SAAS,SAAS;AAAA,IAClD,SAAS;AAAA,IACT,kBAAkB;AAAA,EACnB;AAEA,QAAM,OAAO,SAAS,SAAS;AAAA,IAC9B,2BAA2B,OAAO,SAAS,SAAS;AAAA,EACrD;AACA,QAAM,OAAO,SAAS,SAAS;AAAA,IAC9B,2BAA2B,OAAO,SAAS,SAAS;AAAA,EACrD;AAEA,QAAM,SAAS,KAAK,IAAI,IAAI,EAAE,IAAI,EAAE,IAAI;AACxC,QAAM,OAAO,KAAK,IAAI,OAAO,CAAC,IAAI,KAAK,IAAI,OAAO,CAAC,IAAI,eAAe,IAAI,eAAe;AAEzF,MAAI,SAAS,SAAS,OAAO,cAAc,cAAc,QAAQ,QAAQ,oBAAoB,GAAG;AAC/F,aAAS,OAAO,KAAK;AACrB,WAAO,uBAAuB,QAAQ;AAAA,EACvC;AAEA,QAAM,MAAM,KAAK;AAAA,IAChB,SAAS,OAAO,KAAK,IAAI,IAAI,SAAS,OAAO,KAAK,IAAI,IAAI;AAAA,IAC1D,SAAS,OAAO,KAAK,KAAK;AAAA,EAC3B;AACA,QAAM,MAAM,KAAK;AAAA,IAChB,SAAS,OAAO,KAAK,IAAI,IAAI,SAAS,OAAO,KAAK,IAAI,IAAI;AAAA,IAC1D,SAAS,OAAO,KAAK,KAAK;AAAA,EAC3B;AAEA,MAAI,iCAAiD;AACrD,MAAI,yCAAyC;AAC7C,MAAI,iCAAiD;AACrD,MAAI,yCAAyC;AAC7C,MAAI,OAA+B,KAAK;AAExC,aAAW,gBAAgB,SAAS,SAAS;AAAA,IAC5C;AAAA,IACA;AAAA,IACA,kBAAkB;AAAA,EACnB,GAAG;AACF,QAAI,KAAK,IAAI,aAAa,KAAK,IAAI,IAAI,SAAS,OAAO,KAAK,IAAI,CAAC,IAAI,GAAG;AACvE;AAAA,IACD;AACA,QAAI,aAAa,KAAK,IAAI,IAAI,SAAS,OAAO,KAAK,IAAI,GAAG;AACzD,UACC,IAAI,cAAc,cAAc,SAAS,MAAM,IAAI,wCAClD;AACD,iDAAyC,IAAI,cAAc,cAAc,SAAS,MAAM;AACxF,yCAAiC;AAAA,MAClC;AAAA,IACD,OAAO;AACN,UACC,IAAI,cAAc,cAAc,SAAS,MAAM,IAAI,wCAClD;AACD,iDAAyC,IAAI,cAAc,cAAc,SAAS,MAAM;AACxF,yCAAiC;AAAA,MAClC;AAAA,IACD;AAAA,EACD;AAEA,MAAI,kCAAkC,gCAAgC;AACrE,QAAI,yCAAyC,wCAAwC;AACpF,aAAO,KAAK;AAAA,IACb,OAAO;AACN,aAAO,KAAK;AAAA,IACb;AAAA,EACD,WAAW,kCAAkC,CAAC,gCAAgC;AAC7E,WAAO,KAAK;AAAA,EACb,WAAW,CAAC,kCAAkC,gCAAgC;AAC7E,WAAO,KAAK;AAAA,EACb;AAEA,WAAS,OAAO;AAChB,SAAO;AACR;",
  "names": []
}
