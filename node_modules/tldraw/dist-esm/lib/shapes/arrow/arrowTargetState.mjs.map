{
  "version": 3,
  "sources": ["../../../../src/lib/shapes/arrow/arrowTargetState.ts"],
  "sourcesContent": ["import {\n\tArrowShapeKindStyle,\n\tatom,\n\tAtom,\n\tBox,\n\tclamp,\n\tEditor,\n\tElbowArrowSnap,\n\tGeometry2dFilters,\n\tinvLerp,\n\tmapObjectMapValues,\n\tobjectMapEntries,\n\tobjectMapKeys,\n\tTLArrowBinding,\n\tTLArrowShape,\n\tTLArrowShapeKind,\n\tTLShape,\n\tVec,\n\tVecLike,\n\tWeakCache,\n} from '@tldraw/editor'\nimport { ArrowShapeUtil } from './ArrowShapeUtil'\nimport {\n\tElbowArrowAxes,\n\tElbowArrowSide,\n\tElbowArrowSideAxes,\n\tElbowArrowSideDeltas,\n} from './elbow/definitions'\n\nexport interface UpdateArrowTargetStateOpts {\n\teditor: Editor\n\tpointInPageSpace: VecLike\n\tarrow: TLArrowShape | undefined\n\tisPrecise: boolean\n\tisExact: boolean\n\tcurrentBinding: TLArrowBinding | undefined\n\t/** The binding from the opposite end of the arrow, if one exists. */\n\toppositeBinding: TLArrowBinding | undefined\n}\n\nexport interface ArrowTargetState {\n\ttarget: TLShape\n\tarrowKind: TLArrowShapeKind\n\n\thandlesInPageSpace: {\n\t\ttop: { point: VecLike; isEnabled: boolean }\n\t\tbottom: { point: VecLike; isEnabled: boolean }\n\t\tleft: { point: VecLike; isEnabled: boolean }\n\t\tright: { point: VecLike; isEnabled: boolean }\n\t}\n\n\tisExact: boolean\n\tisPrecise: boolean\n\n\tcenterInPageSpace: VecLike\n\tanchorInPageSpace: VecLike\n\tsnap: ElbowArrowSnap\n\tnormalizedAnchor: VecLike\n}\n\nconst arrowTargetStore = new WeakCache<Editor, Atom<ArrowTargetState | null>>()\n\nfunction getArrowTargetAtom(editor: Editor) {\n\treturn arrowTargetStore.get(editor, () => atom('arrowTarget', null))\n}\n\nexport function getArrowTargetState(editor: Editor) {\n\treturn getArrowTargetAtom(editor).get()\n}\n\nexport function clearArrowTargetState(editor: Editor) {\n\tgetArrowTargetAtom(editor).set(null)\n}\n\nexport function updateArrowTargetState({\n\teditor,\n\tpointInPageSpace,\n\tarrow,\n\tisPrecise,\n\tisExact,\n\tcurrentBinding,\n\toppositeBinding,\n}: UpdateArrowTargetStateOpts): ArrowTargetState | null {\n\t// no target picking when ctrl is held:\n\tif (editor.inputs.ctrlKey) {\n\t\tgetArrowTargetAtom(editor).set(null)\n\t\treturn null\n\t}\n\n\tconst util = editor.getShapeUtil<ArrowShapeUtil>('arrow')\n\tconst arrowKind = arrow ? arrow.props.kind : editor.getStyleForNextShape(ArrowShapeKindStyle)\n\n\tconst target = editor.getShapeAtPoint(pointInPageSpace, {\n\t\thitInside: true,\n\t\thitFrameInside: true,\n\t\tmargin: arrowKind === 'elbow' ? 8 : 0,\n\t\tfilter: (targetShape) => {\n\t\t\treturn (\n\t\t\t\t!targetShape.isLocked &&\n\t\t\t\teditor.canBindShapes({\n\t\t\t\t\tfromShape: arrow ?? targetFilterFallback,\n\t\t\t\t\ttoShape: targetShape,\n\t\t\t\t\tbinding: 'arrow',\n\t\t\t\t})\n\t\t\t)\n\t\t},\n\t})\n\n\tif (!target) {\n\t\tgetArrowTargetAtom(editor).set(null)\n\t\treturn null\n\t}\n\n\tconst targetGeometryInTargetSpace = editor.getShapeGeometry(target)\n\tconst targetBoundsInTargetSpace = Box.ZeroFix(targetGeometryInTargetSpace.bounds)\n\tconst targetCenterInTargetSpace = targetGeometryInTargetSpace.center\n\tconst targetTransform = editor.getShapePageTransform(target)\n\tconst pointInTargetSpace = editor.getPointInShapeSpace(target, pointInPageSpace)\n\n\tconst castDistance = Math.max(\n\t\ttargetGeometryInTargetSpace.bounds.width,\n\t\ttargetGeometryInTargetSpace.bounds.height\n\t)\n\n\tconst handlesInPageSpace = mapObjectMapValues(ElbowArrowSideDeltas, (side, delta) => {\n\t\tconst axis = ElbowArrowAxes[ElbowArrowSideAxes[side]]\n\n\t\tconst farPoint = Vec.Mul(delta, castDistance).add(targetCenterInTargetSpace)\n\n\t\tlet isEnabled = false\n\t\tlet handlePointInTargetSpace: VecLike = axis.v(\n\t\t\ttargetBoundsInTargetSpace[side],\n\t\t\ttargetBoundsInTargetSpace[axis.crossMid]\n\t\t)\n\t\tlet furthestDistance = 0\n\n\t\tconst intersections = targetGeometryInTargetSpace.intersectLineSegment(\n\t\t\ttargetCenterInTargetSpace,\n\t\t\tfarPoint,\n\t\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t\t)\n\t\tfor (const intersection of intersections) {\n\t\t\tconst distance = Vec.Dist2(intersection, targetCenterInTargetSpace)\n\t\t\tif (distance > furthestDistance) {\n\t\t\t\tfurthestDistance = distance\n\t\t\t\thandlePointInTargetSpace = intersection\n\t\t\t\tisEnabled = targetGeometryInTargetSpace.isClosed\n\t\t\t}\n\t\t}\n\n\t\tconst handlePointInPageSpace = targetTransform.applyToPoint(handlePointInTargetSpace)\n\n\t\treturn { point: handlePointInPageSpace, isEnabled, far: targetTransform.applyToPoint(farPoint) }\n\t})\n\n\tconst zoomLevel = editor.getZoomLevel()\n\tconst minDistScaled = util.options.minElbowHandleDistance / zoomLevel\n\n\tconst targetCenterInPageSpace = targetTransform.applyToPoint(targetCenterInTargetSpace)\n\tfor (const side of objectMapKeys(handlesInPageSpace)) {\n\t\tconst handle = handlesInPageSpace[side]\n\t\tif (Vec.DistMin(handle.point, targetCenterInPageSpace, minDistScaled)) {\n\t\t\thandle.isEnabled = false\n\t\t}\n\t}\n\n\tlet precise = isPrecise || isExact\n\n\tif (!precise) {\n\t\t// If we're switching to a new bound shape, then precise only if moving slowly\n\t\tif (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {\n\t\t\tprecise = editor.inputs.pointerVelocity.len() < 0.5\n\t\t}\n\t}\n\n\tif (!isPrecise) {\n\t\tif (!targetGeometryInTargetSpace.isClosed) {\n\t\t\tprecise = true\n\t\t}\n\n\t\t// Double check that we're not going to be doing an imprecise snap on\n\t\t// the same shape twice, as this would result in a zero length line\n\t\tif (oppositeBinding && target.id === oppositeBinding.toId && oppositeBinding.props.isPrecise) {\n\t\t\tprecise = true\n\t\t}\n\t}\n\n\tconst shouldSnapCenter = !isExact && precise && targetGeometryInTargetSpace.isClosed\n\tconst shouldSnapEdges =\n\t\t!isExact && ((precise && arrowKind === 'elbow') || !targetGeometryInTargetSpace.isClosed)\n\tconst shouldSnapEdgePoints =\n\t\t!isExact && precise && arrowKind === 'elbow' && targetGeometryInTargetSpace.isClosed\n\tconst shouldSnapNone = precise && (targetGeometryInTargetSpace.isClosed || isExact)\n\tconst shouldSnapCenterAxis =\n\t\t!isExact && precise && arrowKind === 'elbow' && targetGeometryInTargetSpace.isClosed\n\n\t// we run through all the snapping options from least to most specific:\n\tlet snap: ElbowArrowSnap = 'none'\n\tlet anchorInPageSpace: VecLike = pointInPageSpace\n\n\tif (!shouldSnapNone) {\n\t\tsnap = 'center'\n\t\tanchorInPageSpace = targetCenterInPageSpace\n\t}\n\n\tif (shouldSnapEdges) {\n\t\tconst snapDistance = shouldSnapNone\n\t\t\t? calculateSnapDistance(\n\t\t\t\t\teditor,\n\t\t\t\t\ttargetBoundsInTargetSpace,\n\t\t\t\t\tutil.options.elbowArrowEdgeSnapDistance\n\t\t\t\t)\n\t\t\t: Infinity\n\n\t\tconst nearestPointOnEdgeInTargetSpace = targetGeometryInTargetSpace.nearestPoint(\n\t\t\tpointInTargetSpace,\n\t\t\t{\n\t\t\t\tincludeLabels: false,\n\t\t\t\tincludeInternal: false,\n\t\t\t}\n\t\t)\n\n\t\tconst nearestPointOnEdgeInPageSpace = targetTransform.applyToPoint(\n\t\t\tnearestPointOnEdgeInTargetSpace\n\t\t)\n\n\t\tconst distance = Vec.Dist(nearestPointOnEdgeInPageSpace, pointInPageSpace)\n\n\t\tif (distance < snapDistance) {\n\t\t\tsnap = 'edge'\n\t\t\tanchorInPageSpace = nearestPointOnEdgeInPageSpace\n\t\t}\n\t}\n\n\tif (shouldSnapCenterAxis) {\n\t\tconst snapDistance = calculateSnapDistance(\n\t\t\teditor,\n\t\t\ttargetBoundsInTargetSpace,\n\t\t\tutil.options.elbowArrowAxisSnapDistance\n\t\t)\n\n\t\tconst distanceFromXAxis = Vec.DistanceToLineSegment(\n\t\t\thandlesInPageSpace.left.far,\n\t\t\thandlesInPageSpace.right.far,\n\t\t\tpointInPageSpace\n\t\t)\n\t\tconst distanceFromYAxis = Vec.DistanceToLineSegment(\n\t\t\thandlesInPageSpace.top.far,\n\t\t\thandlesInPageSpace.bottom.far,\n\t\t\tpointInPageSpace\n\t\t)\n\n\t\tconst snapAxis =\n\t\t\tdistanceFromXAxis < distanceFromYAxis && distanceFromXAxis < snapDistance\n\t\t\t\t? 'x'\n\t\t\t\t: distanceFromYAxis < snapDistance\n\t\t\t\t\t? 'y'\n\t\t\t\t\t: null\n\n\t\tif (snapAxis) {\n\t\t\tconst axis = ElbowArrowAxes[snapAxis]\n\n\t\t\tconst loDist2 = Vec.Dist2(handlesInPageSpace[axis.loEdge].far, pointInPageSpace)\n\t\t\tconst hiDist2 = Vec.Dist2(handlesInPageSpace[axis.hiEdge].far, pointInPageSpace)\n\n\t\t\tconst side = loDist2 < hiDist2 ? axis.loEdge : axis.hiEdge\n\n\t\t\tif (handlesInPageSpace[side].isEnabled) {\n\t\t\t\tsnap = 'edge-point'\n\t\t\t\tanchorInPageSpace = handlesInPageSpace[side].point\n\t\t\t}\n\t\t}\n\t}\n\n\tif (shouldSnapEdgePoints) {\n\t\tconst snapDistance = calculateSnapDistance(\n\t\t\teditor,\n\t\t\ttargetBoundsInTargetSpace,\n\t\t\tutil.options.elbowArrowPointSnapDistance\n\t\t)\n\n\t\tlet closestSide: ElbowArrowSide | null = null\n\t\tlet closestDistance = Infinity\n\n\t\tfor (const [side, handle] of objectMapEntries(handlesInPageSpace)) {\n\t\t\tif (!handle.isEnabled) continue\n\t\t\tconst distance = Vec.Dist(handle.point, pointInPageSpace)\n\t\t\tif (distance < snapDistance && distance < closestDistance) {\n\t\t\t\tclosestDistance = distance\n\t\t\t\tclosestSide = side\n\t\t\t}\n\t\t}\n\n\t\tif (closestSide) {\n\t\t\tsnap = 'edge-point'\n\t\t\tanchorInPageSpace = handlesInPageSpace[closestSide].point\n\t\t}\n\t}\n\n\tif (shouldSnapCenter) {\n\t\tconst snapDistance = calculateSnapDistance(\n\t\t\teditor,\n\t\t\ttargetBoundsInTargetSpace,\n\t\t\tarrowKind === 'elbow'\n\t\t\t\t? util.options.elbowArrowCenterSnapDistance\n\t\t\t\t: util.options.arcArrowCenterSnapDistance\n\t\t)\n\n\t\tif (Vec.Dist(pointInTargetSpace, targetBoundsInTargetSpace.center) < snapDistance) {\n\t\t\tsnap = 'center'\n\t\t\tanchorInPageSpace = targetCenterInPageSpace\n\t\t}\n\t}\n\n\tconst snapPointInTargetSpace = editor.getPointInShapeSpace(target, anchorInPageSpace)\n\n\tconst normalizedAnchor = {\n\t\tx: invLerp(\n\t\t\ttargetBoundsInTargetSpace.minX,\n\t\t\ttargetBoundsInTargetSpace.maxX,\n\t\t\tsnapPointInTargetSpace.x\n\t\t),\n\t\ty: invLerp(\n\t\t\ttargetBoundsInTargetSpace.minY,\n\t\t\ttargetBoundsInTargetSpace.maxY,\n\t\t\tsnapPointInTargetSpace.y\n\t\t),\n\t}\n\n\tconst result: ArrowTargetState = {\n\t\ttarget,\n\t\tarrowKind,\n\t\thandlesInPageSpace,\n\t\tcenterInPageSpace: targetCenterInPageSpace,\n\t\tanchorInPageSpace,\n\t\tisExact,\n\t\tisPrecise: precise,\n\t\tsnap,\n\t\tnormalizedAnchor,\n\t}\n\n\tgetArrowTargetAtom(editor).set(result)\n\n\treturn result\n}\n\nconst targetFilterFallback = { type: 'arrow' }\n\n/**\n * Funky math but we want the snap distance to be 4 at the minimum and either 16 or 15% of the\n * smaller dimension of the target shape, whichever is smaller\n */\nfunction calculateSnapDistance(\n\teditor: Editor,\n\ttargetBoundsInTargetSpace: Box,\n\tidealSnapDistance: number\n) {\n\treturn (\n\t\tclamp(\n\t\t\tMath.min(targetBoundsInTargetSpace.width, targetBoundsInTargetSpace.height) * 0.15,\n\t\t\t4,\n\t\t\tidealSnapDistance\n\t\t) / editor.getZoomLevel()\n\t)\n}\n"],
  "mappings": "AAAA;AAAA,EACC;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAKA;AAAA,EAEA;AAAA,OACM;AAEP;AAAA,EACC;AAAA,EAEA;AAAA,EACA;AAAA,OACM;AAiCP,MAAM,mBAAmB,IAAI,UAAiD;AAE9E,SAAS,mBAAmB,QAAgB;AAC3C,SAAO,iBAAiB,IAAI,QAAQ,MAAM,KAAK,eAAe,IAAI,CAAC;AACpE;AAEO,SAAS,oBAAoB,QAAgB;AACnD,SAAO,mBAAmB,MAAM,EAAE,IAAI;AACvC;AAEO,SAAS,sBAAsB,QAAgB;AACrD,qBAAmB,MAAM,EAAE,IAAI,IAAI;AACpC;AAEO,SAAS,uBAAuB;AAAA,EACtC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD,GAAwD;AAEvD,MAAI,OAAO,OAAO,SAAS;AAC1B,uBAAmB,MAAM,EAAE,IAAI,IAAI;AACnC,WAAO;AAAA,EACR;AAEA,QAAM,OAAO,OAAO,aAA6B,OAAO;AACxD,QAAM,YAAY,QAAQ,MAAM,MAAM,OAAO,OAAO,qBAAqB,mBAAmB;AAE5F,QAAM,SAAS,OAAO,gBAAgB,kBAAkB;AAAA,IACvD,WAAW;AAAA,IACX,gBAAgB;AAAA,IAChB,QAAQ,cAAc,UAAU,IAAI;AAAA,IACpC,QAAQ,CAAC,gBAAgB;AACxB,aACC,CAAC,YAAY,YACb,OAAO,cAAc;AAAA,QACpB,WAAW,SAAS;AAAA,QACpB,SAAS;AAAA,QACT,SAAS;AAAA,MACV,CAAC;AAAA,IAEH;AAAA,EACD,CAAC;AAED,MAAI,CAAC,QAAQ;AACZ,uBAAmB,MAAM,EAAE,IAAI,IAAI;AACnC,WAAO;AAAA,EACR;AAEA,QAAM,8BAA8B,OAAO,iBAAiB,MAAM;AAClE,QAAM,4BAA4B,IAAI,QAAQ,4BAA4B,MAAM;AAChF,QAAM,4BAA4B,4BAA4B;AAC9D,QAAM,kBAAkB,OAAO,sBAAsB,MAAM;AAC3D,QAAM,qBAAqB,OAAO,qBAAqB,QAAQ,gBAAgB;AAE/E,QAAM,eAAe,KAAK;AAAA,IACzB,4BAA4B,OAAO;AAAA,IACnC,4BAA4B,OAAO;AAAA,EACpC;AAEA,QAAM,qBAAqB,mBAAmB,sBAAsB,CAAC,MAAM,UAAU;AACpF,UAAM,OAAO,eAAe,mBAAmB,IAAI,CAAC;AAEpD,UAAM,WAAW,IAAI,IAAI,OAAO,YAAY,EAAE,IAAI,yBAAyB;AAE3E,QAAI,YAAY;AAChB,QAAI,2BAAoC,KAAK;AAAA,MAC5C,0BAA0B,IAAI;AAAA,MAC9B,0BAA0B,KAAK,QAAQ;AAAA,IACxC;AACA,QAAI,mBAAmB;AAEvB,UAAM,gBAAgB,4BAA4B;AAAA,MACjD;AAAA,MACA;AAAA,MACA,kBAAkB;AAAA,IACnB;AACA,eAAW,gBAAgB,eAAe;AACzC,YAAM,WAAW,IAAI,MAAM,cAAc,yBAAyB;AAClE,UAAI,WAAW,kBAAkB;AAChC,2BAAmB;AACnB,mCAA2B;AAC3B,oBAAY,4BAA4B;AAAA,MACzC;AAAA,IACD;AAEA,UAAM,yBAAyB,gBAAgB,aAAa,wBAAwB;AAEpF,WAAO,EAAE,OAAO,wBAAwB,WAAW,KAAK,gBAAgB,aAAa,QAAQ,EAAE;AAAA,EAChG,CAAC;AAED,QAAM,YAAY,OAAO,aAAa;AACtC,QAAM,gBAAgB,KAAK,QAAQ,yBAAyB;AAE5D,QAAM,0BAA0B,gBAAgB,aAAa,yBAAyB;AACtF,aAAW,QAAQ,cAAc,kBAAkB,GAAG;AACrD,UAAM,SAAS,mBAAmB,IAAI;AACtC,QAAI,IAAI,QAAQ,OAAO,OAAO,yBAAyB,aAAa,GAAG;AACtE,aAAO,YAAY;AAAA,IACpB;AAAA,EACD;AAEA,MAAI,UAAU,aAAa;AAE3B,MAAI,CAAC,SAAS;AAEb,QAAI,CAAC,kBAAmB,kBAAkB,OAAO,OAAO,eAAe,MAAO;AAC7E,gBAAU,OAAO,OAAO,gBAAgB,IAAI,IAAI;AAAA,IACjD;AAAA,EACD;AAEA,MAAI,CAAC,WAAW;AACf,QAAI,CAAC,4BAA4B,UAAU;AAC1C,gBAAU;AAAA,IACX;AAIA,QAAI,mBAAmB,OAAO,OAAO,gBAAgB,QAAQ,gBAAgB,MAAM,WAAW;AAC7F,gBAAU;AAAA,IACX;AAAA,EACD;AAEA,QAAM,mBAAmB,CAAC,WAAW,WAAW,4BAA4B;AAC5E,QAAM,kBACL,CAAC,YAAa,WAAW,cAAc,WAAY,CAAC,4BAA4B;AACjF,QAAM,uBACL,CAAC,WAAW,WAAW,cAAc,WAAW,4BAA4B;AAC7E,QAAM,iBAAiB,YAAY,4BAA4B,YAAY;AAC3E,QAAM,uBACL,CAAC,WAAW,WAAW,cAAc,WAAW,4BAA4B;AAG7E,MAAI,OAAuB;AAC3B,MAAI,oBAA6B;AAEjC,MAAI,CAAC,gBAAgB;AACpB,WAAO;AACP,wBAAoB;AAAA,EACrB;AAEA,MAAI,iBAAiB;AACpB,UAAM,eAAe,iBAClB;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK,QAAQ;AAAA,IACd,IACC;AAEH,UAAM,kCAAkC,4BAA4B;AAAA,MACnE;AAAA,MACA;AAAA,QACC,eAAe;AAAA,QACf,iBAAiB;AAAA,MAClB;AAAA,IACD;AAEA,UAAM,gCAAgC,gBAAgB;AAAA,MACrD;AAAA,IACD;AAEA,UAAM,WAAW,IAAI,KAAK,+BAA+B,gBAAgB;AAEzE,QAAI,WAAW,cAAc;AAC5B,aAAO;AACP,0BAAoB;AAAA,IACrB;AAAA,EACD;AAEA,MAAI,sBAAsB;AACzB,UAAM,eAAe;AAAA,MACpB;AAAA,MACA;AAAA,MACA,KAAK,QAAQ;AAAA,IACd;AAEA,UAAM,oBAAoB,IAAI;AAAA,MAC7B,mBAAmB,KAAK;AAAA,MACxB,mBAAmB,MAAM;AAAA,MACzB;AAAA,IACD;AACA,UAAM,oBAAoB,IAAI;AAAA,MAC7B,mBAAmB,IAAI;AAAA,MACvB,mBAAmB,OAAO;AAAA,MAC1B;AAAA,IACD;AAEA,UAAM,WACL,oBAAoB,qBAAqB,oBAAoB,eAC1D,MACA,oBAAoB,eACnB,MACA;AAEL,QAAI,UAAU;AACb,YAAM,OAAO,eAAe,QAAQ;AAEpC,YAAM,UAAU,IAAI,MAAM,mBAAmB,KAAK,MAAM,EAAE,KAAK,gBAAgB;AAC/E,YAAM,UAAU,IAAI,MAAM,mBAAmB,KAAK,MAAM,EAAE,KAAK,gBAAgB;AAE/E,YAAM,OAAO,UAAU,UAAU,KAAK,SAAS,KAAK;AAEpD,UAAI,mBAAmB,IAAI,EAAE,WAAW;AACvC,eAAO;AACP,4BAAoB,mBAAmB,IAAI,EAAE;AAAA,MAC9C;AAAA,IACD;AAAA,EACD;AAEA,MAAI,sBAAsB;AACzB,UAAM,eAAe;AAAA,MACpB;AAAA,MACA;AAAA,MACA,KAAK,QAAQ;AAAA,IACd;AAEA,QAAI,cAAqC;AACzC,QAAI,kBAAkB;AAEtB,eAAW,CAAC,MAAM,MAAM,KAAK,iBAAiB,kBAAkB,GAAG;AAClE,UAAI,CAAC,OAAO,UAAW;AACvB,YAAM,WAAW,IAAI,KAAK,OAAO,OAAO,gBAAgB;AACxD,UAAI,WAAW,gBAAgB,WAAW,iBAAiB;AAC1D,0BAAkB;AAClB,sBAAc;AAAA,MACf;AAAA,IACD;AAEA,QAAI,aAAa;AAChB,aAAO;AACP,0BAAoB,mBAAmB,WAAW,EAAE;AAAA,IACrD;AAAA,EACD;AAEA,MAAI,kBAAkB;AACrB,UAAM,eAAe;AAAA,MACpB;AAAA,MACA;AAAA,MACA,cAAc,UACX,KAAK,QAAQ,+BACb,KAAK,QAAQ;AAAA,IACjB;AAEA,QAAI,IAAI,KAAK,oBAAoB,0BAA0B,MAAM,IAAI,cAAc;AAClF,aAAO;AACP,0BAAoB;AAAA,IACrB;AAAA,EACD;AAEA,QAAM,yBAAyB,OAAO,qBAAqB,QAAQ,iBAAiB;AAEpF,QAAM,mBAAmB;AAAA,IACxB,GAAG;AAAA,MACF,0BAA0B;AAAA,MAC1B,0BAA0B;AAAA,MAC1B,uBAAuB;AAAA,IACxB;AAAA,IACA,GAAG;AAAA,MACF,0BAA0B;AAAA,MAC1B,0BAA0B;AAAA,MAC1B,uBAAuB;AAAA,IACxB;AAAA,EACD;AAEA,QAAM,SAA2B;AAAA,IAChC;AAAA,IACA;AAAA,IACA;AAAA,IACA,mBAAmB;AAAA,IACnB;AAAA,IACA;AAAA,IACA,WAAW;AAAA,IACX;AAAA,IACA;AAAA,EACD;AAEA,qBAAmB,MAAM,EAAE,IAAI,MAAM;AAErC,SAAO;AACR;AAEA,MAAM,uBAAuB,EAAE,MAAM,QAAQ;AAM7C,SAAS,sBACR,QACA,2BACA,mBACC;AACD,SACC;AAAA,IACC,KAAK,IAAI,0BAA0B,OAAO,0BAA0B,MAAM,IAAI;AAAA,IAC9E;AAAA,IACA;AAAA,EACD,IAAI,OAAO,aAAa;AAE1B;",
  "names": []
}
