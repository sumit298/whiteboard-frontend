import {
  AssetRecordType,
  DocumentRecordType,
  InstancePresenceRecordType,
  MediaHelpers,
  MigrationFailureReason,
  PageRecordType,
  Result,
  TAB_ID,
  TLDOCUMENT_ID,
  assert,
  assertExists,
  atom,
  clamp,
  computed,
  createTLSchema,
  createTLStore,
  defaultBindingUtils,
  defaultShapeUtils,
  defaultUserPreferences,
  exhaustiveSwitchError,
  fpsThrottle,
  getDefaultUserPresence,
  getHashForString,
  getOwnProperty,
  getUserPreferences,
  hasOwnProperty,
  isNativeStructuredClone,
  isSignal,
  objectMapEntries,
  objectMapKeys,
  objectMapValues,
  react,
  registerTldrawLibraryVersion,
  require_lodash,
  reverseRecordsDiff,
  squashRecordDiffs,
  structuredClone,
  transact,
  transaction,
  uniqueId,
  useAtom,
  useReactiveEvent,
  useRefState,
  useShallowObjectIdentity,
  useTLSchemaFromUtils,
  useValue,
  warnOnce
} from "./chunk-BBAGFWLJ.js";
import "./chunk-PYALTNEL.js";
import "./chunk-272GJBO6.js";
import "./chunk-36ZHPXHK.js";
import "./chunk-5EGB6KUH.js";
import {
  require_react
} from "./chunk-EFGKP4NK.js";
import {
  __publicField,
  __toESM
} from "./chunk-NNPG3NYD.js";

// node_modules/@tldraw/sync-core/dist-esm/lib/chunk.mjs
var MAX_CLIENT_SENT_MESSAGE_SIZE_BYTES = 1024 * 1024;
var MAX_BYTES_PER_CHAR = 4;
var MAX_SAFE_MESSAGE_SIZE = MAX_CLIENT_SENT_MESSAGE_SIZE_BYTES / MAX_BYTES_PER_CHAR;
function chunk(msg, maxSafeMessageSize = MAX_SAFE_MESSAGE_SIZE) {
  if (msg.length < maxSafeMessageSize) {
    return [msg];
  } else {
    const chunks = [];
    let chunkNumber = 0;
    let offset = msg.length;
    while (offset > 0) {
      const prefix = `${chunkNumber}_`;
      const chunkSize = Math.max(Math.min(maxSafeMessageSize - prefix.length, offset), 1);
      chunks.unshift(prefix + msg.slice(offset - chunkSize, offset));
      offset -= chunkSize;
      chunkNumber++;
    }
    return chunks;
  }
}
var chunkRe = /^(\d+)_(.*)$/;
var JsonChunkAssembler = class {
  constructor() {
    __publicField(this, "state", "idle");
  }
  handleMessage(msg) {
    if (msg.startsWith("{")) {
      const error = this.state === "idle" ? void 0 : new Error("Unexpected non-chunk message");
      this.state = "idle";
      return error ? { error } : { data: JSON.parse(msg), stringified: msg };
    } else {
      const match = chunkRe.exec(msg);
      if (!match) {
        this.state = "idle";
        return { error: new Error("Invalid chunk: " + JSON.stringify(msg.slice(0, 20) + "...")) };
      }
      const numChunksRemaining = Number(match[1]);
      const data = match[2];
      if (this.state === "idle") {
        this.state = {
          chunksReceived: [data],
          totalChunks: numChunksRemaining + 1
        };
      } else {
        this.state.chunksReceived.push(data);
        if (numChunksRemaining !== this.state.totalChunks - this.state.chunksReceived.length) {
          this.state = "idle";
          return { error: new Error(`Chunks received in wrong order`) };
        }
      }
      if (this.state.chunksReceived.length === this.state.totalChunks) {
        try {
          const stringified = this.state.chunksReceived.join("");
          const data2 = JSON.parse(stringified);
          return { data: data2, stringified };
        } catch (e) {
          return { error: e };
        } finally {
          this.state = "idle";
        }
      }
      return null;
    }
  }
};

// node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncClient.mjs
var import_lodash2 = __toESM(require_lodash(), 1);

// node_modules/@tldraw/sync-core/dist-esm/lib/diff.mjs
var import_lodash = __toESM(require_lodash(), 1);
var RecordOpType = {
  Put: "put",
  Patch: "patch",
  Remove: "remove"
};
function getNetworkDiff(diff) {
  let res = null;
  for (const [k, v] of objectMapEntries(diff.added)) {
    if (!res)
      res = {};
    res[k] = [RecordOpType.Put, v];
  }
  for (const [from, to] of objectMapValues(diff.updated)) {
    const diff2 = diffRecord(from, to);
    if (diff2) {
      if (!res)
        res = {};
      res[to.id] = [RecordOpType.Patch, diff2];
    }
  }
  for (const removed of Object.keys(diff.removed)) {
    if (!res)
      res = {};
    res[removed] = [RecordOpType.Remove];
  }
  return res;
}
var ValueOpType = {
  Put: "put",
  Delete: "delete",
  Append: "append",
  Patch: "patch"
};
function diffRecord(prev, next) {
  return diffObject(prev, next, /* @__PURE__ */ new Set(["props"]));
}
function diffObject(prev, next, nestedKeys) {
  if (prev === next) {
    return null;
  }
  let result = null;
  for (const key of Object.keys(prev)) {
    if (!(key in next)) {
      if (!result)
        result = {};
      result[key] = [ValueOpType.Delete];
      continue;
    }
    const prevVal = prev[key];
    const nextVal = next[key];
    if (!(0, import_lodash.default)(prevVal, nextVal)) {
      if ((nestedKeys == null ? void 0 : nestedKeys.has(key)) && prevVal && nextVal) {
        const diff = diffObject(prevVal, nextVal);
        if (diff) {
          if (!result)
            result = {};
          result[key] = [ValueOpType.Patch, diff];
        }
      } else if (Array.isArray(nextVal) && Array.isArray(prevVal)) {
        const op = diffArray(prevVal, nextVal);
        if (op) {
          if (!result)
            result = {};
          result[key] = op;
        }
      } else {
        if (!result)
          result = {};
        result[key] = [ValueOpType.Put, nextVal];
      }
    }
  }
  for (const key of Object.keys(next)) {
    if (!(key in prev)) {
      if (!result)
        result = {};
      result[key] = [ValueOpType.Put, next[key]];
    }
  }
  return result;
}
function diffValue(valueA, valueB) {
  if (Object.is(valueA, valueB))
    return null;
  if (Array.isArray(valueA) && Array.isArray(valueB)) {
    return diffArray(valueA, valueB);
  } else if (!valueA || !valueB || typeof valueA !== "object" || typeof valueB !== "object") {
    return (0, import_lodash.default)(valueA, valueB) ? null : [ValueOpType.Put, valueB];
  } else {
    const diff = diffObject(valueA, valueB);
    return diff ? [ValueOpType.Patch, diff] : null;
  }
}
function diffArray(prevArray, nextArray) {
  if (Object.is(prevArray, nextArray))
    return null;
  if (prevArray.length === nextArray.length) {
    const maxPatchIndexes = Math.max(prevArray.length / 5, 1);
    const toPatchIndexes = [];
    for (let i = 0; i < prevArray.length; i++) {
      if (!(0, import_lodash.default)(prevArray[i], nextArray[i])) {
        toPatchIndexes.push(i);
        if (toPatchIndexes.length > maxPatchIndexes) {
          return [ValueOpType.Put, nextArray];
        }
      }
    }
    if (toPatchIndexes.length === 0) {
      return null;
    }
    const diff = {};
    for (const i of toPatchIndexes) {
      const prevItem = prevArray[i];
      const nextItem = nextArray[i];
      if (!prevItem || !nextItem) {
        diff[i] = [ValueOpType.Put, nextItem];
      } else if (typeof prevItem === "object" && typeof nextItem === "object") {
        const op = diffValue(prevItem, nextItem);
        if (op) {
          diff[i] = op;
        }
      } else {
        diff[i] = [ValueOpType.Put, nextItem];
      }
    }
    return [ValueOpType.Patch, diff];
  }
  for (let i = 0; i < prevArray.length; i++) {
    if (!(0, import_lodash.default)(prevArray[i], nextArray[i])) {
      return [ValueOpType.Put, nextArray];
    }
  }
  return [ValueOpType.Append, nextArray.slice(prevArray.length), prevArray.length];
}
function applyObjectDiff(object, objectDiff) {
  if (!object || typeof object !== "object")
    return object;
  const isArray = Array.isArray(object);
  let newObject = void 0;
  const set = (k, v) => {
    if (!newObject) {
      if (isArray) {
        newObject = [...object];
      } else {
        newObject = { ...object };
      }
    }
    if (isArray) {
      newObject[Number(k)] = v;
    } else {
      newObject[k] = v;
    }
  };
  for (const [key, op] of Object.entries(objectDiff)) {
    switch (op[0]) {
      case ValueOpType.Put: {
        const value = op[1];
        if (!(0, import_lodash.default)(object[key], value)) {
          set(key, value);
        }
        break;
      }
      case ValueOpType.Append: {
        const values = op[1];
        const offset = op[2];
        const arr = object[key];
        if (Array.isArray(arr) && arr.length === offset) {
          set(key, [...arr, ...values]);
        }
        break;
      }
      case ValueOpType.Patch: {
        if (object[key] && typeof object[key] === "object") {
          const diff = op[1];
          const patched = applyObjectDiff(object[key], diff);
          if (patched !== object[key]) {
            set(key, patched);
          }
        }
        break;
      }
      case ValueOpType.Delete: {
        if (key in object) {
          if (!newObject) {
            if (isArray) {
              console.error("Can't delete array item yet (this should never happen)");
              newObject = [...object];
            } else {
              newObject = { ...object };
            }
          }
          delete newObject[key];
        }
      }
    }
  }
  return newObject ?? object;
}

// node_modules/@tldraw/sync-core/dist-esm/lib/interval.mjs
function interval(cb, timeout) {
  const i = setInterval(cb, timeout);
  return () => clearInterval(i);
}

// node_modules/@tldraw/sync-core/dist-esm/lib/protocol.mjs
var TLSYNC_PROTOCOL_VERSION = 7;
function getTlsyncProtocolVersion() {
  return TLSYNC_PROTOCOL_VERSION;
}
var TLIncompatibilityReason = {
  ClientTooOld: "clientTooOld",
  ServerTooOld: "serverTooOld",
  InvalidRecord: "invalidRecord",
  InvalidOperation: "invalidOperation"
};

// node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncClient.mjs
var TLSyncErrorCloseEventCode = 4099;
var TLSyncErrorCloseEventReason = {
  NOT_FOUND: "NOT_FOUND",
  FORBIDDEN: "FORBIDDEN",
  NOT_AUTHENTICATED: "NOT_AUTHENTICATED",
  UNKNOWN_ERROR: "UNKNOWN_ERROR",
  CLIENT_TOO_OLD: "CLIENT_TOO_OLD",
  SERVER_TOO_OLD: "SERVER_TOO_OLD",
  INVALID_RECORD: "INVALID_RECORD",
  RATE_LIMITED: "RATE_LIMITED",
  ROOM_FULL: "ROOM_FULL"
};
var PING_INTERVAL = 5e3;
var MAX_TIME_TO_WAIT_FOR_SERVER_INTERACTION_BEFORE_RESETTING_CONNECTION = PING_INTERVAL * 2;
var TLSyncClient = class {
  constructor(config) {
    /** The last clock time from the most recent server update */
    __publicField(this, "lastServerClock", 0);
    __publicField(this, "lastServerInteractionTimestamp", Date.now());
    /** The queue of in-flight push requests that have not yet been acknowledged by the server */
    __publicField(this, "pendingPushRequests", []);
    /**
     * The diff of 'unconfirmed', 'optimistic' changes that have been made locally by the user if we
     * take this diff, reverse it, and apply that to the store, our store will match exactly the most
     * recent state of the server that we know about
     */
    __publicField(this, "speculativeChanges", {
      added: {},
      updated: {},
      removed: {}
    });
    __publicField(this, "disposables", []);
    __publicField(this, "store");
    __publicField(this, "socket");
    __publicField(this, "presenceState");
    // isOnline is true when we have an open socket connection and we have
    // established a connection with the server room (i.e. we have received a 'connect' message)
    __publicField(this, "isConnectedToRoom", false);
    /**
     * The client clock is essentially a counter for push requests Each time a push request is created
     * the clock is incremented. This clock is sent with the push request to the server, and the
     * server returns it with the response so that we can match up the response with the request.
     *
     * The clock may also be used at one point in the future to allow the client to re-send push
     * requests idempotently (i.e. the server will keep track of each client's clock and not execute
     * requests it has already handled), but at the time of writing this is neither needed nor
     * implemented.
     */
    __publicField(this, "clientClock", 0);
    /**
     * Called immediately after a connect acceptance has been received and processed Use this to make
     * any changes to the store that are required to keep it operational
     */
    __publicField(this, "onAfterConnect");
    __publicField(this, "isDebugging", false);
    __publicField(this, "presenceType");
    __publicField(this, "didCancel");
    __publicField(this, "latestConnectRequestId", null);
    __publicField(this, "incomingDiffBuffer", []);
    __publicField(this, "lastPushedPresenceState", null);
    /** Send any unsent push requests to the server */
    __publicField(this, "flushPendingPushRequests", fpsThrottle(() => {
      this.debug("flushing pending push requests", {
        isConnectedToRoom: this.isConnectedToRoom,
        pendingPushRequests: this.pendingPushRequests
      });
      if (!this.isConnectedToRoom || this.store.isPossiblyCorrupted()) {
        return;
      }
      for (const pendingPushRequest of this.pendingPushRequests) {
        if (!pendingPushRequest.sent) {
          if (this.socket.connectionStatus !== "online") {
            return;
          }
          this.socket.sendMessage(pendingPushRequest.request);
          pendingPushRequest.sent = true;
        }
      }
    }));
    // eslint-disable-next-line local/prefer-class-methods
    __publicField(this, "rebase", () => {
      var _a;
      this.store._flushHistory();
      if (this.incomingDiffBuffer.length === 0)
        return;
      const diffs = this.incomingDiffBuffer;
      this.incomingDiffBuffer = [];
      try {
        this.store.mergeRemoteChanges(() => {
          this.store.applyDiff(reverseRecordsDiff(this.speculativeChanges), { runCallbacks: false });
          for (const diff of diffs) {
            if (diff.type === "patch") {
              this.applyNetworkDiff(diff.diff, true);
              continue;
            }
            if (this.pendingPushRequests.length === 0) {
              throw new Error("Received push_result but there are no pending push requests");
            }
            if (this.pendingPushRequests[0].request.clientClock !== diff.clientClock) {
              throw new Error(
                "Received push_result for a push request that is not at the front of the queue"
              );
            }
            if (diff.action === "discard") {
              this.pendingPushRequests.shift();
            } else if (diff.action === "commit") {
              const { request } = this.pendingPushRequests.shift();
              if ("diff" in request && request.diff) {
                this.applyNetworkDiff(request.diff, true);
              }
            } else {
              this.applyNetworkDiff(diff.action.rebaseWithDiff, true);
              this.pendingPushRequests.shift();
            }
          }
          try {
            this.speculativeChanges = this.store.extractingChanges(() => {
              for (const { request } of this.pendingPushRequests) {
                if (!("diff" in request) || !request.diff)
                  continue;
                this.applyNetworkDiff(request.diff, true);
              }
            });
          } catch (e) {
            console.error(e);
            this.speculativeChanges = { added: {}, updated: {}, removed: {} };
            this.resetConnection();
          }
        });
        this.lastServerClock = ((_a = diffs.at(-1)) == null ? void 0 : _a.serverClock) ?? this.lastServerClock;
      } catch (e) {
        console.error(e);
        this.store.ensureStoreIsUsable();
        this.resetConnection();
      }
    });
    __publicField(this, "scheduleRebase", fpsThrottle(this.rebase));
    this.didCancel = config.didCancel;
    this.presenceType = config.store.scopedTypes.presence.values().next().value ?? null;
    if (typeof window !== "undefined") {
      ;
      window.tlsync = this;
    }
    this.store = config.store;
    this.socket = config.socket;
    this.onAfterConnect = config.onAfterConnect;
    let didLoad = false;
    this.presenceState = config.presence;
    this.disposables.push(
      // when local 'user' changes are made, send them to the server
      // or stash them locally in offline mode
      this.store.listen(
        ({ changes }) => {
          var _a;
          if ((_a = this.didCancel) == null ? void 0 : _a.call(this))
            return this.close();
          this.debug("received store changes", { changes });
          this.push(changes);
        },
        { source: "user", scope: "document" }
      ),
      // when the server sends us events, handle them
      this.socket.onReceiveMessage((msg) => {
        var _a;
        if ((_a = this.didCancel) == null ? void 0 : _a.call(this))
          return this.close();
        this.debug("received message from server", msg);
        this.handleServerEvent(msg);
        if (!didLoad) {
          didLoad = true;
          config.onLoad(this);
        }
      }),
      // handle switching between online and offline
      this.socket.onStatusChange((ev) => {
        var _a;
        if ((_a = this.didCancel) == null ? void 0 : _a.call(this))
          return this.close();
        this.debug("socket status changed", ev.status);
        if (ev.status === "online") {
          this.sendConnectMessage();
        } else {
          this.resetConnection();
          if (ev.status === "error") {
            didLoad = true;
            config.onSyncError(ev.reason);
            this.close();
          }
        }
      }),
      // Send a ping every PING_INTERVAL ms while online
      interval(() => {
        var _a;
        if ((_a = this.didCancel) == null ? void 0 : _a.call(this))
          return this.close();
        this.debug("ping loop", { isConnectedToRoom: this.isConnectedToRoom });
        if (!this.isConnectedToRoom)
          return;
        try {
          this.socket.sendMessage({ type: "ping" });
        } catch (error) {
          console.warn("ping failed, resetting", error);
          this.resetConnection();
        }
      }, PING_INTERVAL),
      // Check the server connection health, reset the connection if needed
      interval(() => {
        var _a;
        if ((_a = this.didCancel) == null ? void 0 : _a.call(this))
          return this.close();
        this.debug("health check loop", { isConnectedToRoom: this.isConnectedToRoom });
        if (!this.isConnectedToRoom)
          return;
        const timeSinceLastServerInteraction = Date.now() - this.lastServerInteractionTimestamp;
        if (timeSinceLastServerInteraction < MAX_TIME_TO_WAIT_FOR_SERVER_INTERACTION_BEFORE_RESETTING_CONNECTION) {
          this.debug("health check passed", { timeSinceLastServerInteraction });
          return;
        }
        console.warn(`Haven't heard from the server in a while, resetting connection...`);
        this.resetConnection();
      }, PING_INTERVAL * 2)
    );
    if (this.presenceState) {
      this.disposables.push(
        react("pushPresence", () => {
          var _a;
          if ((_a = this.didCancel) == null ? void 0 : _a.call(this))
            return this.close();
          this.pushPresence(this.presenceState.get());
        })
      );
    }
    if (this.socket.connectionStatus === "online") {
      this.sendConnectMessage();
    }
  }
  debug(...args) {
    if (this.isDebugging) {
      console.debug(...args);
    }
  }
  /**
   * This is the first message that is sent over a newly established socket connection. And we need
   * to wait for the response before this client can be used.
   */
  sendConnectMessage() {
    if (this.isConnectedToRoom) {
      console.error("sendConnectMessage called while already connected");
      return;
    }
    this.debug("sending connect message");
    this.latestConnectRequestId = uniqueId();
    this.socket.sendMessage({
      type: "connect",
      connectRequestId: this.latestConnectRequestId,
      schema: this.store.schema.serialize(),
      protocolVersion: getTlsyncProtocolVersion(),
      lastServerClock: this.lastServerClock
    });
  }
  /** Switch to offline mode */
  resetConnection(hard = false) {
    this.debug("resetting connection");
    if (hard) {
      this.lastServerClock = 0;
    }
    this.store.mergeRemoteChanges(() => {
      this.store.remove(Object.keys(this.store.serialize("presence")));
    });
    this.lastPushedPresenceState = null;
    this.isConnectedToRoom = false;
    this.pendingPushRequests = [];
    this.incomingDiffBuffer = [];
    if (this.socket.connectionStatus === "online") {
      this.socket.restart();
    }
  }
  /**
   * Invoked when the socket connection comes online, either for the first time or as the result of
   * a reconnect. The goal is to rebase on the server's state and fire off a new push request for
   * any local changes that were made while offline.
   */
  didReconnect(event) {
    this.debug("did reconnect", event);
    if (event.connectRequestId !== this.latestConnectRequestId) {
      return;
    }
    this.latestConnectRequestId = null;
    if (this.isConnectedToRoom) {
      console.error("didReconnect called while already connected");
      this.resetConnection(true);
      return;
    }
    if (this.pendingPushRequests.length > 0) {
      console.error("pendingPushRequests should already be empty when we reconnect");
      this.resetConnection(true);
      return;
    }
    transact(() => {
      var _a;
      const stashedChanges = this.speculativeChanges;
      this.speculativeChanges = { added: {}, updated: {}, removed: {} };
      this.store.mergeRemoteChanges(() => {
        const wipeDiff = {};
        const wipeAll = event.hydrationType === "wipe_all";
        if (!wipeAll) {
          this.store.applyDiff(reverseRecordsDiff(stashedChanges), { runCallbacks: false });
        }
        for (const [id, record] of objectMapEntries(this.store.serialize("all"))) {
          if (wipeAll && this.store.scopedTypes.document.has(record.typeName) || record.typeName === this.presenceType) {
            wipeDiff[id] = [RecordOpType.Remove];
          }
        }
        this.applyNetworkDiff({ ...wipeDiff, ...event.diff }, true);
        this.isConnectedToRoom = true;
        const speculativeChanges = this.store.filterChangesByScope(
          this.store.extractingChanges(() => {
            this.store.applyDiff(stashedChanges);
          }),
          "document"
        );
        if (speculativeChanges)
          this.push(speculativeChanges);
      });
      (_a = this.onAfterConnect) == null ? void 0 : _a.call(this, this, { isReadonly: event.isReadonly });
    });
    this.lastServerClock = event.serverClock;
  }
  /** Handle events received from the server */
  handleServerEvent(event) {
    this.debug("received server event", event);
    this.lastServerInteractionTimestamp = Date.now();
    switch (event.type) {
      case "connect":
        this.didReconnect(event);
        break;
      case "patch":
      case "push_result":
        if (!this.isConnectedToRoom)
          break;
        this.incomingDiffBuffer.push(event);
        this.scheduleRebase();
        break;
      case "data":
        if (!this.isConnectedToRoom)
          break;
        this.incomingDiffBuffer.push(...event.data);
        this.scheduleRebase();
        break;
      case "incompatibility_error":
        console.error("incompatibility error is legacy and should no longer be sent by the server");
        break;
      case "pong":
        break;
      default:
        exhaustiveSwitchError(event);
    }
  }
  close() {
    var _a, _b, _c, _d;
    this.debug("closing");
    this.disposables.forEach((dispose) => dispose());
    (_b = (_a = this.flushPendingPushRequests).cancel) == null ? void 0 : _b.call(_a);
    (_d = (_c = this.scheduleRebase).cancel) == null ? void 0 : _d.call(_c);
  }
  pushPresence(nextPresence) {
    this.store._flushHistory();
    if (!this.isConnectedToRoom) {
      return;
    }
    let presence = void 0;
    if (!this.lastPushedPresenceState && nextPresence) {
      presence = [RecordOpType.Put, nextPresence];
    } else if (this.lastPushedPresenceState && nextPresence) {
      const diff = diffRecord(this.lastPushedPresenceState, nextPresence);
      if (diff) {
        presence = [RecordOpType.Patch, diff];
      }
    }
    if (!presence)
      return;
    this.lastPushedPresenceState = nextPresence;
    const lastPush = this.pendingPushRequests.at(-1);
    if (lastPush && !lastPush.sent && !lastPush.request.presence) {
      lastPush.request.presence = presence;
      return;
    }
    const req = {
      type: "push",
      clientClock: this.clientClock++,
      presence
    };
    if (req) {
      this.pendingPushRequests.push({ request: req, sent: false });
      this.flushPendingPushRequests();
    }
  }
  /** Push a change to the server, or stash it locally if we're offline */
  push(change) {
    this.debug("push", change);
    const diff = getNetworkDiff(change);
    if (!diff)
      return;
    this.speculativeChanges = squashRecordDiffs([this.speculativeChanges, change]);
    if (!this.isConnectedToRoom) {
      return;
    }
    const pushRequest = {
      type: "push",
      diff,
      clientClock: this.clientClock++
    };
    this.pendingPushRequests.push({ request: pushRequest, sent: false });
    this.flushPendingPushRequests();
  }
  /**
   * Applies a 'network' diff to the store this does value-based equality checking so that if the
   * data is the same (as opposed to merely identical with ===), then no change is made and no
   * changes will be propagated back to store listeners
   */
  applyNetworkDiff(diff, runCallbacks) {
    this.debug("applyNetworkDiff", diff);
    const changes = { added: {}, updated: {}, removed: {} };
    let hasChanges = false;
    for (const [id, op] of objectMapEntries(diff)) {
      if (op[0] === RecordOpType.Put) {
        const existing = this.store.get(id);
        if (existing && !(0, import_lodash2.default)(existing, op[1])) {
          hasChanges = true;
          changes.updated[id] = [existing, op[1]];
        } else {
          hasChanges = true;
          changes.added[id] = op[1];
        }
      } else if (op[0] === RecordOpType.Patch) {
        const record = this.store.get(id);
        if (!record) {
          continue;
        }
        const patched = applyObjectDiff(record, op[1]);
        hasChanges = true;
        changes.updated[id] = [record, patched];
      } else if (op[0] === RecordOpType.Remove) {
        if (this.store.has(id)) {
          hasChanges = true;
          changes.removed[id] = this.store.get(id);
        }
      }
    }
    if (hasChanges) {
      this.store.applyDiff(changes, { runCallbacks });
    }
  }
};

// node_modules/@tldraw/sync-core/dist-esm/lib/ClientWebSocketAdapter.mjs
function listenTo(target, event, handler) {
  target.addEventListener(event, handler);
  return () => {
    target.removeEventListener(event, handler);
  };
}
function debug(...args) {
  if (typeof window !== "undefined" && window.__tldraw_socket_debug) {
    const now = /* @__PURE__ */ new Date();
    console.log(
      `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}.${now.getMilliseconds()}`,
      ...args
      //, new Error().stack
    );
  }
}
var ClientWebSocketAdapter = class {
  constructor(getUri) {
    __publicField(this, "_ws", null);
    __publicField(this, "isDisposed", false);
    /** @internal */
    __publicField(this, "_reconnectManager");
    // TLPersistentClientSocket stuff
    __publicField(this, "_connectionStatus", atom(
      "websocket connection status",
      "initial"
    ));
    __publicField(this, "messageListeners", /* @__PURE__ */ new Set());
    __publicField(this, "statusListeners", /* @__PURE__ */ new Set());
    this._reconnectManager = new ReconnectManager(this, getUri);
  }
  // TODO: .close should be a project-wide interface with a common contract (.close()d thing
  //       can only be garbage collected, and can't be used anymore)
  close() {
    var _a;
    this.isDisposed = true;
    this._reconnectManager.close();
    (_a = this._ws) == null ? void 0 : _a.close();
  }
  _handleConnect() {
    debug("handleConnect");
    this._connectionStatus.set("online");
    this.statusListeners.forEach((cb) => cb({ status: "online" }));
    this._reconnectManager.connected();
  }
  _handleDisconnect(reason, closeCode, didOpen, closeReason) {
    closeReason = closeReason || TLSyncErrorCloseEventReason.UNKNOWN_ERROR;
    debug("handleDisconnect", {
      currentStatus: this.connectionStatus,
      closeCode,
      reason
    });
    let newStatus;
    switch (reason) {
      case "closed":
        if (closeCode === TLSyncErrorCloseEventCode) {
          newStatus = "error";
        } else {
          newStatus = "offline";
        }
        break;
      case "manual":
        newStatus = "offline";
        break;
    }
    if (closeCode === 1006 && !didOpen) {
      warnOnce(
        "Could not open WebSocket connection. This might be because you're trying to load a URL that doesn't support websockets. Check the URL you're trying to connect to."
      );
    }
    if (
      // it the status changed
      this.connectionStatus !== newStatus && // ignore errors if we're already in the offline state
      !(newStatus === "error" && this.connectionStatus === "offline")
    ) {
      this._connectionStatus.set(newStatus);
      this.statusListeners.forEach(
        (cb) => cb(newStatus === "error" ? { status: "error", reason: closeReason } : { status: newStatus })
      );
    }
    this._reconnectManager.disconnected();
  }
  _setNewSocket(ws) {
    var _a;
    assert(!this.isDisposed, "Tried to set a new websocket on a disposed socket");
    assert(
      this._ws === null || this._ws.readyState === WebSocket.CLOSED || this._ws.readyState === WebSocket.CLOSING,
      `Tried to set a new websocket in when the existing one was ${(_a = this._ws) == null ? void 0 : _a.readyState}`
    );
    let didOpen = false;
    ws.onopen = () => {
      debug("ws.onopen");
      assert(
        this._ws === ws,
        "sockets must only be orphaned when they are CLOSING or CLOSED, so they can't open"
      );
      didOpen = true;
      this._handleConnect();
    };
    ws.onclose = (event) => {
      debug("ws.onclose", event);
      if (this._ws === ws) {
        this._handleDisconnect("closed", event.code, didOpen, event.reason);
      } else {
        debug("ignoring onclose for an orphaned socket");
      }
    };
    ws.onerror = (event) => {
      debug("ws.onerror", event);
      if (this._ws === ws) {
        this._handleDisconnect("closed");
      } else {
        debug("ignoring onerror for an orphaned socket");
      }
    };
    ws.onmessage = (ev) => {
      assert(
        this._ws === ws,
        "sockets must only be orphaned when they are CLOSING or CLOSED, so they can't receive messages"
      );
      const parsed = JSON.parse(ev.data.toString());
      this.messageListeners.forEach((cb) => cb(parsed));
    };
    this._ws = ws;
  }
  _closeSocket() {
    if (this._ws === null)
      return;
    this._ws.close();
    this._ws = null;
    this._handleDisconnect("manual");
  }
  // eslint-disable-next-line no-restricted-syntax
  get connectionStatus() {
    const status = this._connectionStatus.get();
    return status === "initial" ? "offline" : status;
  }
  sendMessage(msg) {
    assert(!this.isDisposed, "Tried to send message on a disposed socket");
    if (!this._ws)
      return;
    if (this.connectionStatus === "online") {
      const chunks = chunk(JSON.stringify(msg));
      for (const part of chunks) {
        this._ws.send(part);
      }
    } else {
      console.warn("Tried to send message while " + this.connectionStatus);
    }
  }
  onReceiveMessage(cb) {
    assert(!this.isDisposed, "Tried to add message listener on a disposed socket");
    this.messageListeners.add(cb);
    return () => {
      this.messageListeners.delete(cb);
    };
  }
  onStatusChange(cb) {
    assert(!this.isDisposed, "Tried to add status listener on a disposed socket");
    this.statusListeners.add(cb);
    return () => {
      this.statusListeners.delete(cb);
    };
  }
  restart() {
    assert(!this.isDisposed, "Tried to restart a disposed socket");
    debug("restarting");
    this._closeSocket();
    this._reconnectManager.maybeReconnected();
  }
};
var ACTIVE_MIN_DELAY = 500;
var ACTIVE_MAX_DELAY = 2e3;
var INACTIVE_MIN_DELAY = 1e3;
var INACTIVE_MAX_DELAY = 1e3 * 60 * 5;
var DELAY_EXPONENT = 1.5;
var ATTEMPT_TIMEOUT = 1e3;
var ReconnectManager = class {
  constructor(socketAdapter, getUri) {
    __publicField(this, "isDisposed", false);
    __publicField(this, "disposables", [
      () => {
        if (this.reconnectTimeout)
          clearTimeout(this.reconnectTimeout);
        if (this.recheckConnectingTimeout)
          clearTimeout(this.recheckConnectingTimeout);
      }
    ]);
    __publicField(this, "reconnectTimeout", null);
    __publicField(this, "recheckConnectingTimeout", null);
    __publicField(this, "lastAttemptStart", null);
    __publicField(this, "intendedDelay", ACTIVE_MIN_DELAY);
    __publicField(this, "state");
    this.socketAdapter = socketAdapter;
    this.getUri = getUri;
    this.subscribeToReconnectHints();
    this.disposables.push(
      listenTo(window, "offline", () => {
        debug("window went offline");
        this.socketAdapter._closeSocket();
      })
    );
    this.state = "pendingAttempt";
    this.intendedDelay = ACTIVE_MIN_DELAY;
    this.scheduleAttempt();
  }
  subscribeToReconnectHints() {
    this.disposables.push(
      listenTo(window, "online", () => {
        debug("window went online");
        this.maybeReconnected();
      }),
      listenTo(document, "visibilitychange", () => {
        if (!document.hidden) {
          debug("document became visible");
          this.maybeReconnected();
        }
      })
    );
    if (Object.prototype.hasOwnProperty.call(navigator, "connection")) {
      const connection = navigator["connection"];
      this.disposables.push(
        listenTo(connection, "change", () => {
          debug("navigator.connection change");
          this.maybeReconnected();
        })
      );
    }
  }
  scheduleAttempt() {
    assert(this.state === "pendingAttempt");
    debug("scheduling a connection attempt");
    Promise.resolve(this.getUri()).then((uri) => {
      var _a;
      if (this.state !== "pendingAttempt" || this.isDisposed)
        return;
      assert(
        ((_a = this.socketAdapter._ws) == null ? void 0 : _a.readyState) !== WebSocket.OPEN,
        "There should be no connection attempts while already connected"
      );
      this.lastAttemptStart = Date.now();
      this.socketAdapter._setNewSocket(new WebSocket(httpToWs(uri)));
      this.state = "pendingAttemptResult";
    });
  }
  getMaxDelay() {
    return document.hidden ? INACTIVE_MAX_DELAY : ACTIVE_MAX_DELAY;
  }
  getMinDelay() {
    return document.hidden ? INACTIVE_MIN_DELAY : ACTIVE_MIN_DELAY;
  }
  clearReconnectTimeout() {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }
  }
  clearRecheckConnectingTimeout() {
    if (this.recheckConnectingTimeout) {
      clearTimeout(this.recheckConnectingTimeout);
      this.recheckConnectingTimeout = null;
    }
  }
  maybeReconnected() {
    var _a, _b;
    debug("ReconnectManager.maybeReconnected");
    this.clearRecheckConnectingTimeout();
    if (((_a = this.socketAdapter._ws) == null ? void 0 : _a.readyState) === WebSocket.OPEN) {
      debug("ReconnectManager.maybeReconnected: already connected");
      return;
    }
    if (((_b = this.socketAdapter._ws) == null ? void 0 : _b.readyState) === WebSocket.CONNECTING) {
      debug("ReconnectManager.maybeReconnected: connecting");
      assert(
        this.lastAttemptStart,
        "ReadyState=CONNECTING without lastAttemptStart should be impossible"
      );
      const sinceLastStart = Date.now() - this.lastAttemptStart;
      if (sinceLastStart < ATTEMPT_TIMEOUT) {
        debug("ReconnectManager.maybeReconnected: connecting, rechecking later");
        this.recheckConnectingTimeout = setTimeout(
          () => this.maybeReconnected(),
          ATTEMPT_TIMEOUT - sinceLastStart
        );
      } else {
        debug("ReconnectManager.maybeReconnected: connecting, but for too long, retry now");
        this.clearRecheckConnectingTimeout();
        this.socketAdapter._closeSocket();
      }
      return;
    }
    debug("ReconnectManager.maybeReconnected: closing/closed/null, retry now");
    this.intendedDelay = ACTIVE_MIN_DELAY;
    this.disconnected();
  }
  disconnected() {
    var _a, _b;
    debug("ReconnectManager.disconnected");
    if (((_a = this.socketAdapter._ws) == null ? void 0 : _a.readyState) !== WebSocket.OPEN && ((_b = this.socketAdapter._ws) == null ? void 0 : _b.readyState) !== WebSocket.CONNECTING) {
      debug("ReconnectManager.disconnected: websocket is not OPEN or CONNECTING");
      this.clearReconnectTimeout();
      let delayLeft;
      if (this.state === "connected") {
        this.intendedDelay = this.getMinDelay();
        delayLeft = this.intendedDelay;
      } else {
        delayLeft = this.lastAttemptStart !== null ? this.lastAttemptStart + this.intendedDelay - Date.now() : 0;
      }
      if (delayLeft > 0) {
        debug("ReconnectManager.disconnected: delaying, delayLeft", delayLeft);
        this.state = "delay";
        this.reconnectTimeout = setTimeout(() => this.disconnected(), delayLeft);
      } else {
        this.state = "pendingAttempt";
        this.intendedDelay = Math.min(
          this.getMaxDelay(),
          Math.max(this.getMinDelay(), this.intendedDelay) * DELAY_EXPONENT
        );
        debug(
          "ReconnectManager.disconnected: attempting a connection, next delay",
          this.intendedDelay
        );
        this.scheduleAttempt();
      }
    }
  }
  connected() {
    var _a;
    debug("ReconnectManager.connected");
    if (((_a = this.socketAdapter._ws) == null ? void 0 : _a.readyState) === WebSocket.OPEN) {
      debug("ReconnectManager.connected: websocket is OPEN");
      this.state = "connected";
      this.clearReconnectTimeout();
      this.intendedDelay = ACTIVE_MIN_DELAY;
    }
  }
  close() {
    this.disposables.forEach((d) => d());
    this.isDisposed = true;
  }
};
function httpToWs(url) {
  return url.replace(/^http(s)?:/, "ws$1:");
}

// node_modules/@tldraw/sync-core/dist-esm/lib/RoomSession.mjs
var RoomSessionState = {
  AwaitingConnectMessage: "awaiting-connect-message",
  AwaitingRemoval: "awaiting-removal",
  Connected: "connected"
};
var SESSION_START_WAIT_TIME = 1e4;
var SESSION_REMOVAL_WAIT_TIME = 5e3;
var SESSION_IDLE_TIMEOUT = 2e4;

// node_modules/@tldraw/sync-core/dist-esm/lib/TLRemoteSyncError.mjs
var TLRemoteSyncError = class extends Error {
  constructor(reason) {
    super(`sync error: ${reason}`);
    __publicField(this, "name", "RemoteSyncError");
    this.reason = reason;
  }
};

// node_modules/@tldraw/sync-core/dist-esm/lib/ServerSocketAdapter.mjs
var ServerSocketAdapter = class {
  constructor(opts) {
    this.opts = opts;
  }
  // eslint-disable-next-line no-restricted-syntax
  get isOpen() {
    return this.opts.ws.readyState === 1;
  }
  // see TLRoomSocket for details on why this accepts a union and not just arrays
  sendMessage(msg) {
    var _a, _b;
    const message = JSON.stringify(msg);
    (_b = (_a = this.opts).onBeforeSendMessage) == null ? void 0 : _b.call(_a, msg, message);
    this.opts.ws.send(message);
  }
  close(code, reason) {
    this.opts.ws.close(code, reason);
  }
};

// node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncRoom.mjs
var import_lodash3 = __toESM(require_lodash(), 1);

// node_modules/nanoevents/index.js
var createNanoEvents = () => ({
  events: {},
  emit(event, ...args) {
    let callbacks = this.events[event] || [];
    for (let i = 0, length = callbacks.length; i < length; i++) {
      callbacks[i](...args);
    }
  },
  on(event, cb) {
    var _a;
    ((_a = this.events[event]) == null ? void 0 : _a.push(cb)) || (this.events[event] = [cb]);
    return () => {
      var _a2;
      this.events[event] = (_a2 = this.events[event]) == null ? void 0 : _a2.filter((i) => cb !== i);
    };
  }
});

// node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncRoom.mjs
var MAX_TOMBSTONES = 3e3;
var TOMBSTONE_PRUNE_BUFFER_SIZE = 300;
var DATA_MESSAGE_DEBOUNCE_INTERVAL = 1e3 / 60;
var timeSince = (time) => Date.now() - time;
var DocumentState = class _DocumentState {
  constructor(state, lastChangedClock, recordType) {
    __publicField(this, "_atom");
    this.recordType = recordType;
    this._atom = atom("document:" + state.id, { state, lastChangedClock });
  }
  static createWithoutValidating(state, lastChangedClock, recordType) {
    return new _DocumentState(state, lastChangedClock, recordType);
  }
  static createAndValidate(state, lastChangedClock, recordType) {
    try {
      recordType.validate(state);
    } catch (error) {
      return Result.err(error);
    }
    return Result.ok(new _DocumentState(state, lastChangedClock, recordType));
  }
  // eslint-disable-next-line no-restricted-syntax
  get state() {
    return this._atom.get().state;
  }
  // eslint-disable-next-line no-restricted-syntax
  get lastChangedClock() {
    return this._atom.get().lastChangedClock;
  }
  replaceState(state, clock) {
    const diff = diffRecord(this.state, state);
    if (!diff)
      return Result.ok(null);
    try {
      this.recordType.validate(state);
    } catch (error) {
      return Result.err(error);
    }
    this._atom.set({ state, lastChangedClock: clock });
    return Result.ok(diff);
  }
  mergeDiff(diff, clock) {
    const newState = applyObjectDiff(this.state, diff);
    return this.replaceState(newState, clock);
  }
};
var TLSyncRoom = class {
  constructor(opts) {
    // A table of connected clients
    __publicField(this, "sessions", /* @__PURE__ */ new Map());
    // eslint-disable-next-line local/prefer-class-methods
    __publicField(this, "pruneSessions", () => {
      for (const client of this.sessions.values()) {
        switch (client.state) {
          case RoomSessionState.Connected: {
            const hasTimedOut = timeSince(client.lastInteractionTime) > SESSION_IDLE_TIMEOUT;
            if (hasTimedOut || !client.socket.isOpen) {
              this.cancelSession(client.sessionId);
            }
            break;
          }
          case RoomSessionState.AwaitingConnectMessage: {
            const hasTimedOut = timeSince(client.sessionStartTime) > SESSION_START_WAIT_TIME;
            if (hasTimedOut || !client.socket.isOpen) {
              this.removeSession(client.sessionId);
            }
            break;
          }
          case RoomSessionState.AwaitingRemoval: {
            const hasTimedOut = timeSince(client.cancellationTime) > SESSION_REMOVAL_WAIT_TIME;
            if (hasTimedOut) {
              this.removeSession(client.sessionId);
            }
            break;
          }
          default: {
            exhaustiveSwitchError(client);
          }
        }
      }
    });
    __publicField(this, "disposables", [interval(this.pruneSessions, 2e3)]);
    __publicField(this, "_isClosed", false);
    __publicField(this, "events", createNanoEvents());
    // Values associated with each uid (must be serializable).
    /** @internal */
    __publicField(this, "state", atom("room state", {
      documents: {},
      tombstones: {}
    }));
    // this clock should start higher than the client, to make sure that clients who sync with their
    // initial lastServerClock value get the full state
    // in this case clients will start with 0, and the server will start with 1
    __publicField(this, "clock", 1);
    __publicField(this, "documentClock", 1);
    __publicField(this, "tombstoneHistoryStartsAtClock", this.clock);
    // map from record id to clock upon deletion
    __publicField(this, "serializedSchema");
    __publicField(this, "documentTypes");
    __publicField(this, "presenceType");
    __publicField(this, "log");
    __publicField(this, "schema");
    // eslint-disable-next-line local/prefer-class-methods
    __publicField(this, "pruneTombstones", () => {
      this.state.update(({ tombstones, documents }) => {
        const entries = Object.entries(this.state.get().tombstones);
        if (entries.length > MAX_TOMBSTONES) {
          entries.sort((a, b) => a[1] - b[1]);
          const excessQuantity = entries.length - MAX_TOMBSTONES;
          tombstones = Object.fromEntries(entries.slice(excessQuantity + TOMBSTONE_PRUNE_BUFFER_SIZE));
        }
        return {
          documents,
          tombstones
        };
      });
    });
    var _a, _b;
    this.schema = opts.schema;
    let snapshot = opts.snapshot;
    this.log = opts.log;
    this.onDataChange = opts.onDataChange;
    this.onPresenceChange = opts.onPresenceChange;
    assert(
      isNativeStructuredClone,
      "TLSyncRoom is supposed to run either on Cloudflare Workersor on a 18+ version of Node.js, which both support the native structuredClone API"
    );
    this.serializedSchema = JSON.parse(JSON.stringify(this.schema.serialize()));
    this.documentTypes = new Set(
      Object.values(this.schema.types).filter((t) => t.scope === "document").map((t) => t.typeName)
    );
    const presenceTypes = new Set(
      Object.values(this.schema.types).filter((t) => t.scope === "presence")
    );
    if (presenceTypes.size > 1) {
      throw new Error(
        `TLSyncRoom: exactly zero or one presence type is expected, but found ${presenceTypes.size}`
      );
    }
    this.presenceType = ((_a = presenceTypes.values().next()) == null ? void 0 : _a.value) ?? null;
    if (!snapshot) {
      snapshot = {
        clock: 0,
        documents: [
          {
            state: DocumentRecordType.create({ id: TLDOCUMENT_ID }),
            lastChangedClock: 0
          },
          {
            state: PageRecordType.create({ name: "Page 1", index: "a1" }),
            lastChangedClock: 0
          }
        ]
      };
    }
    this.clock = snapshot.clock;
    let didIncrementClock = false;
    const ensureClockDidIncrement = (_reason) => {
      if (!didIncrementClock) {
        didIncrementClock = true;
        this.clock++;
      }
    };
    const tombstones = { ...snapshot.tombstones };
    const filteredDocuments = [];
    for (const doc of snapshot.documents) {
      if (this.documentTypes.has(doc.state.typeName)) {
        filteredDocuments.push(doc);
      } else {
        ensureClockDidIncrement("doc type was not doc type");
        tombstones[doc.state.id] = this.clock;
      }
    }
    const documents = Object.fromEntries(
      filteredDocuments.map((r) => [
        r.state.id,
        DocumentState.createWithoutValidating(
          r.state,
          r.lastChangedClock,
          assertExists(getOwnProperty(this.schema.types, r.state.typeName))
        )
      ])
    );
    const migrationResult = this.schema.migrateStoreSnapshot({
      store: Object.fromEntries(
        objectMapEntries(documents).map(([id, { state }]) => [id, state])
      ),
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      schema: snapshot.schema ?? this.schema.serializeEarliestVersion()
    });
    if (migrationResult.type === "error") {
      throw new Error("Failed to migrate: " + migrationResult.reason);
    }
    for (const [id, r] of objectMapEntries(migrationResult.value)) {
      const existing = documents[id];
      if (!existing) {
        ensureClockDidIncrement("record was added during migration");
        documents[id] = DocumentState.createWithoutValidating(
          r,
          this.clock,
          assertExists(getOwnProperty(this.schema.types, r.typeName))
        );
      } else if (!(0, import_lodash3.default)(existing.state, r)) {
        ensureClockDidIncrement("record was maybe updated during migration");
        existing.replaceState(r, this.clock);
      }
    }
    for (const id of objectMapKeys(documents)) {
      if (!migrationResult.value[id]) {
        ensureClockDidIncrement("record was removed during migration");
        tombstones[id] = this.clock;
        delete documents[id];
      }
    }
    this.state.set({ documents, tombstones });
    this.pruneTombstones();
    this.documentClock = this.clock;
    if (didIncrementClock) {
      (_b = opts.onDataChange) == null ? void 0 : _b.call(opts);
    }
  }
  close() {
    this.disposables.forEach((d) => d());
    this.sessions.forEach((session) => {
      session.socket.close();
    });
    this._isClosed = true;
  }
  isClosed() {
    return this._isClosed;
  }
  getDocument(id) {
    return this.state.get().documents[id];
  }
  addDocument(id, state, clock) {
    let { documents, tombstones } = this.state.get();
    if (hasOwnProperty(tombstones, id)) {
      tombstones = { ...tombstones };
      delete tombstones[id];
    }
    const createResult = DocumentState.createAndValidate(
      state,
      clock,
      assertExists(getOwnProperty(this.schema.types, state.typeName))
    );
    if (!createResult.ok)
      return createResult;
    documents = { ...documents, [id]: createResult.value };
    this.state.set({ documents, tombstones });
    return Result.ok(void 0);
  }
  removeDocument(id, clock) {
    this.state.update(({ documents, tombstones }) => {
      documents = { ...documents };
      delete documents[id];
      tombstones = { ...tombstones, [id]: clock };
      return { documents, tombstones };
    });
  }
  getSnapshot() {
    const { documents, tombstones } = this.state.get();
    return {
      clock: this.clock,
      tombstones,
      schema: this.serializedSchema,
      documents: Object.values(documents).filter((d) => this.documentTypes.has(d.state.typeName)).map((doc) => ({
        state: doc.state,
        lastChangedClock: doc.lastChangedClock
      }))
    };
  }
  /**
   * Send a message to a particular client. Debounces data events
   *
   * @param sessionId - The id of the session to send the message to.
   * @param message - The message to send.
   */
  sendMessage(sessionId, message) {
    var _a, _b, _c, _d;
    const session = this.sessions.get(sessionId);
    if (!session) {
      (_b = (_a = this.log) == null ? void 0 : _a.warn) == null ? void 0 : _b.call(_a, "Tried to send message to unknown session", message.type);
      return;
    }
    if (session.state !== RoomSessionState.Connected) {
      (_d = (_c = this.log) == null ? void 0 : _c.warn) == null ? void 0 : _d.call(_c, "Tried to send message to disconnected client", message.type);
      return;
    }
    if (session.socket.isOpen) {
      if (message.type !== "patch" && message.type !== "push_result") {
        if (message.type !== "pong") {
          this._flushDataMessages(sessionId);
        }
        session.socket.sendMessage(message);
      } else {
        if (session.debounceTimer === null) {
          session.socket.sendMessage({ type: "data", data: [message] });
          session.debounceTimer = setTimeout(
            () => this._flushDataMessages(sessionId),
            DATA_MESSAGE_DEBOUNCE_INTERVAL
          );
        } else {
          session.outstandingDataMessages.push(message);
        }
      }
    } else {
      this.cancelSession(session.sessionId);
    }
  }
  // needs to accept sessionId and not a session because the session might be dead by the time
  // the timer fires
  _flushDataMessages(sessionId) {
    const session = this.sessions.get(sessionId);
    if (!session || session.state !== RoomSessionState.Connected) {
      return;
    }
    session.debounceTimer = null;
    if (session.outstandingDataMessages.length > 0) {
      session.socket.sendMessage({ type: "data", data: session.outstandingDataMessages });
      session.outstandingDataMessages.length = 0;
    }
  }
  /** @internal */
  removeSession(sessionId, fatalReason) {
    var _a, _b;
    const session = this.sessions.get(sessionId);
    if (!session) {
      (_b = (_a = this.log) == null ? void 0 : _a.warn) == null ? void 0 : _b.call(_a, "Tried to remove unknown session");
      return;
    }
    this.sessions.delete(sessionId);
    const presence = this.getDocument(session.presenceId ?? "");
    try {
      if (fatalReason) {
        session.socket.close(TLSyncErrorCloseEventCode, fatalReason);
      } else {
        session.socket.close();
      }
    } catch {
    }
    if (presence) {
      this.state.update(({ tombstones, documents }) => {
        documents = { ...documents };
        delete documents[session.presenceId];
        return { documents, tombstones };
      });
      this.broadcastPatch({
        diff: { [session.presenceId]: [RecordOpType.Remove] },
        sourceSessionId: sessionId
      });
    }
    this.events.emit("session_removed", { sessionId, meta: session.meta });
    if (this.sessions.size === 0) {
      this.events.emit("room_became_empty");
    }
  }
  cancelSession(sessionId) {
    var _a, _b;
    const session = this.sessions.get(sessionId);
    if (!session) {
      return;
    }
    if (session.state === RoomSessionState.AwaitingRemoval) {
      (_b = (_a = this.log) == null ? void 0 : _a.warn) == null ? void 0 : _b.call(_a, "Tried to cancel session that is already awaiting removal");
      return;
    }
    this.sessions.set(sessionId, {
      state: RoomSessionState.AwaitingRemoval,
      sessionId,
      presenceId: session.presenceId,
      socket: session.socket,
      cancellationTime: Date.now(),
      meta: session.meta,
      isReadonly: session.isReadonly,
      requiresLegacyRejection: session.requiresLegacyRejection
    });
    try {
      session.socket.close();
    } catch {
    }
  }
  /**
   * Broadcast a message to all connected clients except the one with the sessionId provided.
   *
   * @param message - The message to broadcast.
   */
  broadcastPatch(message) {
    const { diff, sourceSessionId } = message;
    this.sessions.forEach((session) => {
      if (session.state !== RoomSessionState.Connected)
        return;
      if (sourceSessionId === session.sessionId)
        return;
      if (!session.socket.isOpen) {
        this.cancelSession(session.sessionId);
        return;
      }
      const res = this.migrateDiffForSession(session.serializedSchema, diff);
      if (!res.ok) {
        this.rejectSession(
          session.sessionId,
          res.error === MigrationFailureReason.TargetVersionTooNew ? TLSyncErrorCloseEventReason.SERVER_TOO_OLD : TLSyncErrorCloseEventReason.CLIENT_TOO_OLD
        );
        return;
      }
      this.sendMessage(session.sessionId, {
        type: "patch",
        diff: res.value,
        serverClock: this.clock
      });
    });
    return this;
  }
  /**
   * When a client connects to the room, add them to the list of clients and then merge the history
   * down into the snapshots.
   *
   * @internal
   */
  handleNewSession(opts) {
    var _a;
    const { sessionId, socket, meta, isReadonly } = opts;
    const existing = this.sessions.get(sessionId);
    this.sessions.set(sessionId, {
      state: RoomSessionState.AwaitingConnectMessage,
      sessionId,
      socket,
      presenceId: (existing == null ? void 0 : existing.presenceId) ?? ((_a = this.presenceType) == null ? void 0 : _a.createId()) ?? null,
      sessionStartTime: Date.now(),
      meta,
      isReadonly: isReadonly ?? false,
      // this gets set later during handleConnectMessage
      requiresLegacyRejection: false
    });
    return this;
  }
  /**
   * When we send a diff to a client, if that client is on a lower version than us, we need to make
   * the diff compatible with their version. At the moment this means migrating each affected record
   * to the client's version and sending the whole record again. We can optimize this later by
   * keeping the previous versions of records around long enough to recalculate these diffs for
   * older client versions.
   */
  migrateDiffForSession(serializedSchema, diff) {
    if (serializedSchema === this.serializedSchema) {
      return Result.ok(diff);
    }
    const result = {};
    for (const [id, op] of Object.entries(diff)) {
      if (op[0] === RecordOpType.Remove) {
        result[id] = op;
        continue;
      }
      const migrationResult = this.schema.migratePersistedRecord(
        this.getDocument(id).state,
        serializedSchema,
        "down"
      );
      if (migrationResult.type === "error") {
        return Result.err(migrationResult.reason);
      }
      result[id] = [RecordOpType.Put, migrationResult.value];
    }
    return Result.ok(result);
  }
  /**
   * When the server receives a message from the clients Currently, supports connect and patches.
   * Invalid messages types throws an error. Currently, doesn't validate data.
   *
   * @param sessionId - The session that sent the message
   * @param message - The message that was sent
   */
  async handleMessage(sessionId, message) {
    var _a, _b;
    const session = this.sessions.get(sessionId);
    if (!session) {
      (_b = (_a = this.log) == null ? void 0 : _a.warn) == null ? void 0 : _b.call(_a, "Received message from unknown session");
      return;
    }
    switch (message.type) {
      case "connect": {
        return this.handleConnectRequest(session, message);
      }
      case "push": {
        return this.handlePushRequest(session, message);
      }
      case "ping": {
        if (session.state === RoomSessionState.Connected) {
          session.lastInteractionTime = Date.now();
        }
        return this.sendMessage(session.sessionId, { type: "pong" });
      }
      default: {
        exhaustiveSwitchError(message);
      }
    }
  }
  /** If the client is out of date, or we are out of date, we need to let them know */
  rejectSession(sessionId, fatalReason) {
    const session = this.sessions.get(sessionId);
    if (!session)
      return;
    if (!fatalReason) {
      this.removeSession(sessionId);
      return;
    }
    if (session.requiresLegacyRejection) {
      try {
        if (session.socket.isOpen) {
          let legacyReason;
          switch (fatalReason) {
            case TLSyncErrorCloseEventReason.CLIENT_TOO_OLD:
              legacyReason = TLIncompatibilityReason.ClientTooOld;
              break;
            case TLSyncErrorCloseEventReason.SERVER_TOO_OLD:
              legacyReason = TLIncompatibilityReason.ServerTooOld;
              break;
            case TLSyncErrorCloseEventReason.INVALID_RECORD:
              legacyReason = TLIncompatibilityReason.InvalidRecord;
              break;
            default:
              legacyReason = TLIncompatibilityReason.InvalidOperation;
              break;
          }
          session.socket.sendMessage({
            type: "incompatibility_error",
            reason: legacyReason
          });
        }
      } catch {
      } finally {
        this.removeSession(sessionId);
      }
    } else {
      this.removeSession(sessionId, fatalReason);
    }
  }
  handleConnectRequest(session, message) {
    let theirProtocolVersion = message.protocolVersion;
    if (theirProtocolVersion === 5) {
      theirProtocolVersion = 6;
    }
    session.requiresLegacyRejection = theirProtocolVersion === 6;
    if (theirProtocolVersion === 6) {
      theirProtocolVersion++;
    }
    if (theirProtocolVersion == null || theirProtocolVersion < getTlsyncProtocolVersion()) {
      this.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD);
      return;
    } else if (theirProtocolVersion > getTlsyncProtocolVersion()) {
      this.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.SERVER_TOO_OLD);
      return;
    }
    if (message.schema == null) {
      this.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD);
      return;
    }
    const migrations = this.schema.getMigrationsSince(message.schema);
    if (!migrations.ok || migrations.value.some((m) => m.scope === "store" || !m.down)) {
      this.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD);
      return;
    }
    const sessionSchema = (0, import_lodash3.default)(message.schema, this.serializedSchema) ? this.serializedSchema : message.schema;
    const connect = (msg) => {
      this.sessions.set(session.sessionId, {
        state: RoomSessionState.Connected,
        sessionId: session.sessionId,
        presenceId: session.presenceId,
        socket: session.socket,
        serializedSchema: sessionSchema,
        lastInteractionTime: Date.now(),
        debounceTimer: null,
        outstandingDataMessages: [],
        meta: session.meta,
        isReadonly: session.isReadonly,
        requiresLegacyRejection: session.requiresLegacyRejection
      });
      this.sendMessage(session.sessionId, msg);
    };
    transaction((rollback) => {
      if (
        // if the client requests changes since a time before we have tombstone history, send them the full state
        message.lastServerClock < this.tombstoneHistoryStartsAtClock || // similarly, if they ask for a time we haven't reached yet, send them the full state
        // this will only happen if the DB is reset (or there is no db) and the server restarts
        // or if the server exits/crashes with unpersisted changes
        message.lastServerClock > this.clock
      ) {
        const diff = {};
        for (const [id, doc] of Object.entries(this.state.get().documents)) {
          if (id !== session.presenceId) {
            diff[id] = [RecordOpType.Put, doc.state];
          }
        }
        const migrated = this.migrateDiffForSession(sessionSchema, diff);
        if (!migrated.ok) {
          rollback();
          this.rejectSession(
            session.sessionId,
            migrated.error === MigrationFailureReason.TargetVersionTooNew ? TLSyncErrorCloseEventReason.SERVER_TOO_OLD : TLSyncErrorCloseEventReason.CLIENT_TOO_OLD
          );
          return;
        }
        connect({
          type: "connect",
          connectRequestId: message.connectRequestId,
          hydrationType: "wipe_all",
          protocolVersion: getTlsyncProtocolVersion(),
          schema: this.schema.serialize(),
          serverClock: this.clock,
          diff: migrated.value,
          isReadonly: session.isReadonly
        });
      } else {
        const diff = {};
        const updatedDocs = Object.values(this.state.get().documents).filter(
          (doc) => doc.lastChangedClock > message.lastServerClock
        );
        const presenceDocs = this.presenceType ? Object.values(this.state.get().documents).filter(
          (doc) => this.presenceType.typeName === doc.state.typeName && doc.state.id !== session.presenceId
        ) : [];
        const deletedDocsIds = Object.entries(this.state.get().tombstones).filter(([_id, deletedAtClock]) => deletedAtClock > message.lastServerClock).map(([id]) => id);
        for (const doc of updatedDocs) {
          diff[doc.state.id] = [RecordOpType.Put, doc.state];
        }
        for (const doc of presenceDocs) {
          diff[doc.state.id] = [RecordOpType.Put, doc.state];
        }
        for (const docId of deletedDocsIds) {
          diff[docId] = [RecordOpType.Remove];
        }
        const migrated = this.migrateDiffForSession(sessionSchema, diff);
        if (!migrated.ok) {
          rollback();
          this.rejectSession(
            session.sessionId,
            migrated.error === MigrationFailureReason.TargetVersionTooNew ? TLSyncErrorCloseEventReason.SERVER_TOO_OLD : TLSyncErrorCloseEventReason.CLIENT_TOO_OLD
          );
          return;
        }
        connect({
          type: "connect",
          connectRequestId: message.connectRequestId,
          hydrationType: "wipe_presence",
          schema: this.schema.serialize(),
          protocolVersion: getTlsyncProtocolVersion(),
          serverClock: this.clock,
          diff: migrated.value,
          isReadonly: session.isReadonly
        });
      }
    });
  }
  handlePushRequest(session, message) {
    var _a, _b;
    if (session && session.state !== RoomSessionState.Connected) {
      return;
    }
    if (session) {
      session.lastInteractionTime = Date.now();
    }
    this.clock++;
    const initialDocumentClock = this.documentClock;
    let didPresenceChange = false;
    transaction((rollback) => {
      const docChanges = { diff: null };
      const presenceChanges = { diff: null };
      const propagateOp = (changes, id, op) => {
        if (!changes.diff)
          changes.diff = {};
        changes.diff[id] = op;
      };
      const fail = (reason, underlyingError) => {
        var _a2, _b2;
        rollback();
        if (session) {
          this.rejectSession(session.sessionId, reason);
        } else {
          throw new Error("failed to apply changes: " + reason, underlyingError);
        }
        if (typeof process !== "undefined" && true) {
          (_b2 = (_a2 = this.log) == null ? void 0 : _a2.error) == null ? void 0 : _b2.call(_a2, "failed to apply push", reason, message, underlyingError);
        }
        return Result.err(void 0);
      };
      const addDocument = (changes, id, _state) => {
        const res = session ? this.schema.migratePersistedRecord(_state, session.serializedSchema, "up") : { type: "success", value: _state };
        if (res.type === "error") {
          return fail(
            res.reason === MigrationFailureReason.TargetVersionTooOld ? TLSyncErrorCloseEventReason.SERVER_TOO_OLD : TLSyncErrorCloseEventReason.CLIENT_TOO_OLD
          );
        }
        const { value: state } = res;
        const doc = this.getDocument(id);
        if (doc) {
          const diff = doc.replaceState(state, this.clock);
          if (!diff.ok) {
            return fail(TLSyncErrorCloseEventReason.INVALID_RECORD);
          }
          if (diff.value) {
            propagateOp(changes, id, [RecordOpType.Patch, diff.value]);
          }
        } else {
          const result = this.addDocument(id, state, this.clock);
          if (!result.ok) {
            return fail(TLSyncErrorCloseEventReason.INVALID_RECORD);
          }
          propagateOp(changes, id, [RecordOpType.Put, state]);
        }
        return Result.ok(void 0);
      };
      const patchDocument = (changes, id, patch) => {
        const doc = this.getDocument(id);
        if (!doc)
          return Result.ok(void 0);
        const downgraded = session ? this.schema.migratePersistedRecord(doc.state, session.serializedSchema, "down") : { type: "success", value: doc.state };
        if (downgraded.type === "error") {
          return fail(TLSyncErrorCloseEventReason.CLIENT_TOO_OLD);
        }
        if (downgraded.value === doc.state) {
          const diff = doc.mergeDiff(patch, this.clock);
          if (!diff.ok) {
            return fail(TLSyncErrorCloseEventReason.INVALID_RECORD);
          }
          if (diff.value) {
            propagateOp(changes, id, [RecordOpType.Patch, diff.value]);
          }
        } else {
          const patched = applyObjectDiff(downgraded.value, patch);
          const upgraded = session ? this.schema.migratePersistedRecord(patched, session.serializedSchema, "up") : { type: "success", value: patched };
          if (upgraded.type === "error") {
            return fail(TLSyncErrorCloseEventReason.CLIENT_TOO_OLD);
          }
          const diff = doc.replaceState(upgraded.value, this.clock);
          if (!diff.ok) {
            return fail(TLSyncErrorCloseEventReason.INVALID_RECORD);
          }
          if (diff.value) {
            propagateOp(changes, id, [RecordOpType.Patch, diff.value]);
          }
        }
        return Result.ok(void 0);
      };
      const { clientClock } = message;
      if (this.presenceType && (session == null ? void 0 : session.presenceId) && "presence" in message && message.presence) {
        if (!session)
          throw new Error("session is required for presence pushes");
        const id = session.presenceId;
        const [type, val] = message.presence;
        const { typeName } = this.presenceType;
        switch (type) {
          case RecordOpType.Put: {
            const res = addDocument(presenceChanges, id, { ...val, id, typeName });
            if (!res.ok)
              return;
            break;
          }
          case RecordOpType.Patch: {
            const res = patchDocument(presenceChanges, id, {
              ...val,
              id: [ValueOpType.Put, id],
              typeName: [ValueOpType.Put, typeName]
            });
            if (!res.ok)
              return;
            break;
          }
        }
      }
      if (message.diff && !(session == null ? void 0 : session.isReadonly)) {
        for (const [id, op] of Object.entries(message.diff)) {
          switch (op[0]) {
            case RecordOpType.Put: {
              if (!this.documentTypes.has(op[1].typeName)) {
                return fail(TLSyncErrorCloseEventReason.INVALID_RECORD);
              }
              const res = addDocument(docChanges, id, op[1]);
              if (!res.ok)
                return;
              break;
            }
            case RecordOpType.Patch: {
              const res = patchDocument(docChanges, id, op[1]);
              if (!res.ok)
                return;
              break;
            }
            case RecordOpType.Remove: {
              const doc = this.getDocument(id);
              if (!doc) {
                continue;
              }
              this.removeDocument(id, this.clock);
              setTimeout(this.pruneTombstones, 0);
              propagateOp(docChanges, id, op);
              break;
            }
          }
        }
      }
      if (
        // if there was only a presence push, the client doesn't need to do anything aside from
        // shift the push request.
        !message.diff || (0, import_lodash3.default)(docChanges.diff, message.diff)
      ) {
        if (session) {
          this.sendMessage(session.sessionId, {
            type: "push_result",
            serverClock: this.clock,
            clientClock,
            action: "commit"
          });
        }
      } else if (!docChanges.diff) {
        if (session) {
          this.sendMessage(session.sessionId, {
            type: "push_result",
            serverClock: this.clock,
            clientClock,
            action: "discard"
          });
        }
      } else {
        if (session) {
          const migrateResult = this.migrateDiffForSession(
            session.serializedSchema,
            docChanges.diff
          );
          if (!migrateResult.ok) {
            return fail(
              migrateResult.error === MigrationFailureReason.TargetVersionTooNew ? TLSyncErrorCloseEventReason.SERVER_TOO_OLD : TLSyncErrorCloseEventReason.CLIENT_TOO_OLD
            );
          }
          this.sendMessage(session.sessionId, {
            type: "push_result",
            serverClock: this.clock,
            clientClock,
            action: { rebaseWithDiff: migrateResult.value }
          });
        }
      }
      if (docChanges.diff || presenceChanges.diff) {
        this.broadcastPatch({
          sourceSessionId: session == null ? void 0 : session.sessionId,
          diff: {
            ...docChanges.diff,
            ...presenceChanges.diff
          }
        });
      }
      if (docChanges.diff) {
        this.documentClock = this.clock;
      }
      if (presenceChanges.diff) {
        didPresenceChange = true;
      }
      return;
    });
    if (this.documentClock !== initialDocumentClock) {
      (_a = this.onDataChange) == null ? void 0 : _a.call(this);
    }
    if (didPresenceChange) {
      (_b = this.onPresenceChange) == null ? void 0 : _b.call(this);
    }
  }
  /**
   * Handle the event when a client disconnects.
   *
   * @param sessionId - The session that disconnected.
   */
  handleClose(sessionId) {
    this.cancelSession(sessionId);
  }
  /**
   * Allow applying changes to the store in a transactional way.
   * @param updater - A function that will be called with a store object that can be used to make changes.
   * @returns A promise that resolves when the transaction is complete.
   */
  async updateStore(updater) {
    if (this._isClosed) {
      throw new Error("Cannot update store on a closed room");
    }
    const context = new StoreUpdateContext(
      Object.fromEntries(this.getSnapshot().documents.map((d) => [d.state.id, d.state]))
    );
    try {
      await updater(context);
    } finally {
      context.close();
    }
    const diff = context.toDiff();
    if (Object.keys(diff).length === 0) {
      return;
    }
    this.handlePushRequest(null, { type: "push", diff, clientClock: 0 });
  }
};
var StoreUpdateContext = class {
  constructor(snapshot) {
    __publicField(this, "updates", {
      puts: {},
      deletes: /* @__PURE__ */ new Set()
    });
    __publicField(this, "_isClosed", false);
    this.snapshot = snapshot;
  }
  put(record) {
    if (this._isClosed)
      throw new Error("StoreUpdateContext is closed");
    if (record.id in this.snapshot && (0, import_lodash3.default)(this.snapshot[record.id], record)) {
      delete this.updates.puts[record.id];
    } else {
      this.updates.puts[record.id] = structuredClone(record);
    }
    this.updates.deletes.delete(record.id);
  }
  delete(recordOrId) {
    if (this._isClosed)
      throw new Error("StoreUpdateContext is closed");
    const id = typeof recordOrId === "string" ? recordOrId : recordOrId.id;
    delete this.updates.puts[id];
    if (this.snapshot[id]) {
      this.updates.deletes.add(id);
    }
  }
  get(id) {
    if (this._isClosed)
      throw new Error("StoreUpdateContext is closed");
    if (hasOwnProperty(this.updates.puts, id)) {
      return structuredClone(this.updates.puts[id]);
    }
    if (this.updates.deletes.has(id)) {
      return null;
    }
    return structuredClone(this.snapshot[id] ?? null);
  }
  getAll() {
    if (this._isClosed)
      throw new Error("StoreUpdateContext is closed");
    const result = Object.values(this.updates.puts);
    for (const [id, record] of Object.entries(this.snapshot)) {
      if (!this.updates.deletes.has(id) && !hasOwnProperty(this.updates.puts, id)) {
        result.push(record);
      }
    }
    return structuredClone(result);
  }
  toDiff() {
    const diff = {};
    for (const [id, record] of Object.entries(this.updates.puts)) {
      diff[id] = [RecordOpType.Put, record];
    }
    for (const id of this.updates.deletes) {
      diff[id] = [RecordOpType.Remove];
    }
    return diff;
  }
  close() {
    this._isClosed = true;
  }
};

// node_modules/@tldraw/sync-core/dist-esm/lib/TLSocketRoom.mjs
var TLSocketRoom = class {
  constructor(opts) {
    __publicField(this, "room");
    __publicField(this, "sessions", /* @__PURE__ */ new Map());
    __publicField(this, "log");
    this.opts = opts;
    const initialSnapshot = opts.initialSnapshot && "store" in opts.initialSnapshot ? convertStoreSnapshotToRoomSnapshot(opts.initialSnapshot) : opts.initialSnapshot;
    this.room = new TLSyncRoom({
      schema: opts.schema ?? createTLSchema(),
      snapshot: initialSnapshot,
      onDataChange: opts.onDataChange,
      onPresenceChange: opts.onPresenceChange,
      log: opts.log
    });
    this.room.events.on("session_removed", (args) => {
      this.sessions.delete(args.sessionId);
      if (this.opts.onSessionRemoved) {
        this.opts.onSessionRemoved(this, {
          sessionId: args.sessionId,
          numSessionsRemaining: this.room.sessions.size,
          meta: args.meta
        });
      }
    });
    this.log = "log" in opts ? opts.log : { error: console.error };
  }
  /**
   * Returns the number of active sessions.
   * Note that this is not the same as the number of connected sockets!
   * Sessions time out a few moments after sockets close, to smooth over network hiccups.
   *
   * @returns the number of active sessions
   */
  getNumActiveSessions() {
    return this.room.sessions.size;
  }
  /**
   * Call this when a client establishes a new socket connection.
   *
   * - `sessionId` is a unique ID for a browser tab. This is passed as a query param by the useSync hook.
   * - `socket` is a WebSocket-like object that the server uses to communicate with the client.
   * - `isReadonly` is an optional boolean that can be set to true if the client should not be able to make changes to the document. They will still be able to send presence updates.
   * - `meta` is an optional object that can be used to store additional information about the session.
   *
   * @param opts - The options object
   */
  handleSocketConnect(opts) {
    var _a, _b, _c;
    const { sessionId, socket, isReadonly = false } = opts;
    const handleSocketMessage = (event) => this.handleSocketMessage(sessionId, event.data);
    const handleSocketError = this.handleSocketError.bind(this, sessionId);
    const handleSocketClose = this.handleSocketClose.bind(this, sessionId);
    this.sessions.set(sessionId, {
      assembler: new JsonChunkAssembler(),
      socket,
      unlisten: () => {
        var _a2, _b2, _c2;
        (_a2 = socket.removeEventListener) == null ? void 0 : _a2.call(socket, "message", handleSocketMessage);
        (_b2 = socket.removeEventListener) == null ? void 0 : _b2.call(socket, "close", handleSocketClose);
        (_c2 = socket.removeEventListener) == null ? void 0 : _c2.call(socket, "error", handleSocketError);
      }
    });
    this.room.handleNewSession({
      sessionId,
      isReadonly,
      socket: new ServerSocketAdapter({
        ws: socket,
        onBeforeSendMessage: this.opts.onBeforeSendMessage ? (message, stringified) => {
          var _a2;
          return this.opts.onBeforeSendMessage({
            sessionId,
            message,
            stringified,
            meta: (_a2 = this.room.sessions.get(sessionId)) == null ? void 0 : _a2.meta
          });
        } : void 0
      }),
      meta: "meta" in opts ? opts.meta : void 0
    });
    (_a = socket.addEventListener) == null ? void 0 : _a.call(socket, "message", handleSocketMessage);
    (_b = socket.addEventListener) == null ? void 0 : _b.call(socket, "close", handleSocketClose);
    (_c = socket.addEventListener) == null ? void 0 : _c.call(socket, "error", handleSocketError);
  }
  /**
   * If executing in a server environment where sockets do not have instance-level listeners
   * (e.g. Bun.serve, Cloudflare Worker with WebSocket hibernation), you should call this
   * method when messages are received. See our self-hosting example for Bun.serve for an example.
   *
   * @param sessionId - The id of the session. (should match the one used when calling handleSocketConnect)
   * @param message - The message received from the client.
   */
  handleSocketMessage(sessionId, message) {
    var _a, _b, _c, _d, _e, _f, _g;
    const assembler = (_a = this.sessions.get(sessionId)) == null ? void 0 : _a.assembler;
    if (!assembler) {
      (_c = (_b = this.log) == null ? void 0 : _b.warn) == null ? void 0 : _c.call(_b, "Received message from unknown session", sessionId);
      return;
    }
    try {
      const messageString = typeof message === "string" ? message : new TextDecoder().decode(message);
      const res = assembler.handleMessage(messageString);
      if (!res) {
        return;
      }
      if ("data" in res) {
        if (this.opts.onAfterReceiveMessage) {
          const session = this.room.sessions.get(sessionId);
          if (session) {
            this.opts.onAfterReceiveMessage({
              sessionId,
              message: res.data,
              stringified: res.stringified,
              meta: session.meta
            });
          }
        }
        this.room.handleMessage(sessionId, res.data);
      } else {
        (_e = (_d = this.log) == null ? void 0 : _d.error) == null ? void 0 : _e.call(_d, "Error assembling message", res.error);
        this.handleSocketError(sessionId);
      }
    } catch (e) {
      (_g = (_f = this.log) == null ? void 0 : _f.error) == null ? void 0 : _g.call(_f, e);
      this.room.rejectSession(sessionId, TLSyncErrorCloseEventReason.UNKNOWN_ERROR);
    }
  }
  /**
   * If executing in a server environment where sockets do not have instance-level listeners,
   * call this when a socket error occurs.
   * @param sessionId - The id of the session. (should match the one used when calling handleSocketConnect)
   */
  handleSocketError(sessionId) {
    this.room.handleClose(sessionId);
  }
  /**
   * If executing in a server environment where sockets do not have instance-level listeners,
   * call this when a socket is closed.
   * @param sessionId - The id of the session. (should match the one used when calling handleSocketConnect)
   */
  handleSocketClose(sessionId) {
    this.room.handleClose(sessionId);
  }
  /**
   * Returns the current 'clock' of the document.
   * The clock is an integer that increments every time the document changes.
   * The clock is stored as part of the snapshot of the document for consistency purposes.
   *
   * @returns The clock
   */
  getCurrentDocumentClock() {
    return this.room.documentClock;
  }
  /**
   * Returns a deeply cloned record from the store, if available.
   * @param id - The id of the record
   * @returns the cloned record
   */
  getRecord(id) {
    var _a;
    return structuredClone((_a = this.room.state.get().documents[id]) == null ? void 0 : _a.state);
  }
  /**
   * Returns a list of the sessions in the room.
   */
  getSessions() {
    return [...this.room.sessions.values()].map((session) => {
      return {
        sessionId: session.sessionId,
        isConnected: session.state === RoomSessionState.Connected,
        isReadonly: session.isReadonly,
        meta: session.meta
      };
    });
  }
  /**
   * Return a snapshot of the document state, including clock-related bookkeeping.
   * You can store this and load it later on when initializing a TLSocketRoom.
   * You can also pass a snapshot to {@link TLSocketRoom#loadSnapshot} if you need to revert to a previous state.
   * @returns The snapshot
   */
  getCurrentSnapshot() {
    return this.room.getSnapshot();
  }
  /**
   * @internal
   */
  getPresenceRecords() {
    var _a;
    const result = {};
    for (const document2 of Object.values(this.room.state.get().documents)) {
      if (document2.state.typeName === ((_a = this.room.presenceType) == null ? void 0 : _a.typeName)) {
        result[document2.state.id] = document2.state;
      }
    }
    return result;
  }
  /**
   * Return a serialized snapshot of the document state, including clock-related bookkeeping.
   * @returns The serialized snapshot
   * @internal
   */
  getCurrentSerializedSnapshot() {
    return JSON.stringify(this.room.getSnapshot());
  }
  /**
   * Load a snapshot of the document state, overwriting the current state.
   * @param snapshot - The snapshot to load
   */
  loadSnapshot(snapshot) {
    if ("store" in snapshot) {
      snapshot = convertStoreSnapshotToRoomSnapshot(snapshot);
    }
    const oldRoom = this.room;
    const oldIds = oldRoom.getSnapshot().documents.map((d) => d.state.id);
    const newIds = new Set(snapshot.documents.map((d) => d.state.id));
    const removedIds = oldIds.filter((id) => !newIds.has(id));
    const tombstones = { ...snapshot.tombstones };
    removedIds.forEach((id) => {
      tombstones[id] = oldRoom.clock + 1;
    });
    newIds.forEach((id) => {
      delete tombstones[id];
    });
    const newRoom = new TLSyncRoom({
      schema: oldRoom.schema,
      snapshot: {
        clock: oldRoom.clock + 1,
        documents: snapshot.documents.map((d) => ({
          lastChangedClock: oldRoom.clock + 1,
          state: d.state
        })),
        schema: snapshot.schema,
        tombstones
      },
      log: this.log
    });
    this.room = newRoom;
    oldRoom.close();
  }
  /**
   * Allow applying changes to the store inside of a transaction.
   *
   * You can get values from the store by id with `store.get(id)`.
   * These values are safe to mutate, but to commit the changes you must call `store.put(...)` with the updated value.
   * You can get all values in the store with `store.getAll()`.
   * You can also delete values with `store.delete(id)`.
   *
   * @example
   * ```ts
   * room.updateStore(store => {
   *   const shape = store.get('shape:abc123')
   *   shape.meta.approved = true
   *   store.put(shape)
   * })
   * ```
   *
   * Changes to the store inside the callback are isolated from changes made by other clients until the transaction commits.
   *
   * @param updater - A function that will be called with a store object that can be used to make changes.
   * @returns A promise that resolves when the transaction is complete.
   */
  async updateStore(updater) {
    return this.room.updateStore(updater);
  }
  /**
   * Immediately remove a session from the room, and close its socket if not already closed.
   *
   * The client will attempt to reconnect unless you provide a `fatalReason` parameter.
   *
   * The `fatalReason` parameter will be available in the return value of the `useSync` hook as `useSync().error.reason`.
   *
   * @param sessionId - The id of the session to remove
   * @param fatalReason - The reason message to use when calling .close on the underlying websocket
   */
  closeSession(sessionId, fatalReason) {
    this.room.rejectSession(sessionId, fatalReason);
  }
  /**
   * Close the room and disconnect all clients. Call this before discarding the room instance or shutting down the server.
   */
  close() {
    this.room.close();
  }
  /**
   * @returns true if the room is closed
   */
  isClosed() {
    return this.room.isClosed();
  }
};
function convertStoreSnapshotToRoomSnapshot(snapshot) {
  return {
    clock: 0,
    documents: objectMapValues(snapshot.store).map((state) => ({
      state,
      lastChangedClock: 0
    })),
    schema: snapshot.schema,
    tombstones: {}
  };
}

// node_modules/@tldraw/sync-core/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "@tldraw/sync-core",
  "3.13.1",
  "esm"
);

// node_modules/@tldraw/sync/dist-esm/useSync.mjs
var import_react = __toESM(require_react(), 1);
var MULTIPLAYER_EVENT_NAME = "multiplayer.client";
function useSync(opts) {
  const [state, setState] = useRefState(null);
  const {
    uri,
    roomId = "default",
    assets,
    onMount,
    trackAnalyticsEvent: track,
    userInfo,
    getUserPresence: _getUserPresence,
    ...schemaOpts
  } = opts;
  const __never__ = 0;
  const schema = useTLSchemaFromUtils(schemaOpts);
  const prefs = useShallowObjectIdentity(userInfo);
  const getUserPresence = useReactiveEvent(_getUserPresence ?? getDefaultUserPresence);
  const userAtom = useAtom(
    "userAtom",
    prefs
  );
  (0, import_react.useEffect)(() => {
    userAtom.set(prefs);
  }, [prefs, userAtom]);
  (0, import_react.useEffect)(() => {
    const storeId = uniqueId();
    const userPreferences = computed(
      "userPreferences",
      () => {
        const userStuff = userAtom.get();
        const user = (isSignal(userStuff) ? userStuff.get() : userStuff) ?? getUserPreferences();
        return {
          id: user.id,
          color: user.color ?? defaultUserPreferences.color,
          name: user.name ?? defaultUserPreferences.name
        };
      }
    );
    const socket = new ClientWebSocketAdapter(async () => {
      const uriString = typeof uri === "string" ? uri : await uri();
      const withParams = new URL(uriString);
      if (withParams.searchParams.has("sessionId")) {
        throw new Error(
          'useSync. "sessionId" is a reserved query param name. Please use a different name'
        );
      }
      if (withParams.searchParams.has("storeId")) {
        throw new Error(
          'useSync. "storeId" is a reserved query param name. Please use a different name'
        );
      }
      withParams.searchParams.set("sessionId", TAB_ID);
      withParams.searchParams.set("storeId", storeId);
      return withParams.toString();
    });
    let didCancel = false;
    const collaborationStatusSignal = computed(
      "collaboration status",
      () => socket.connectionStatus === "error" ? "offline" : socket.connectionStatus
    );
    const syncMode = atom("sync mode", "readwrite");
    const store = createTLStore({
      id: storeId,
      schema,
      assets,
      onMount,
      collaboration: {
        status: collaborationStatusSignal,
        mode: syncMode
      }
    });
    const presence = computed("instancePresence", () => {
      const presenceState = getUserPresence(store, userPreferences.get());
      if (!presenceState)
        return null;
      return InstancePresenceRecordType.create({
        ...presenceState,
        id: InstancePresenceRecordType.createId(store.id)
      });
    });
    const client = new TLSyncClient({
      store,
      socket,
      didCancel: () => didCancel,
      onLoad(client2) {
        track == null ? void 0 : track(MULTIPLAYER_EVENT_NAME, { name: "load", roomId });
        setState({ readyClient: client2 });
      },
      onSyncError(reason) {
        console.error("sync error", reason);
        switch (reason) {
          case TLSyncErrorCloseEventReason.NOT_FOUND:
            track == null ? void 0 : track(MULTIPLAYER_EVENT_NAME, { name: "room-not-found", roomId });
            break;
          case TLSyncErrorCloseEventReason.FORBIDDEN:
            track == null ? void 0 : track(MULTIPLAYER_EVENT_NAME, { name: "forbidden", roomId });
            break;
          case TLSyncErrorCloseEventReason.NOT_AUTHENTICATED:
            track == null ? void 0 : track(MULTIPLAYER_EVENT_NAME, { name: "not-authenticated", roomId });
            break;
          case TLSyncErrorCloseEventReason.RATE_LIMITED:
            track == null ? void 0 : track(MULTIPLAYER_EVENT_NAME, { name: "rate-limited", roomId });
            break;
          default:
            track == null ? void 0 : track(MULTIPLAYER_EVENT_NAME, { name: "sync-error:" + reason, roomId });
            break;
        }
        setState({ error: new TLRemoteSyncError(reason) });
        socket.close();
      },
      onAfterConnect(_, { isReadonly }) {
        transact(() => {
          syncMode.set(isReadonly ? "readonly" : "readwrite");
          store.ensureStoreIsUsable();
        });
      },
      presence
    });
    return () => {
      didCancel = true;
      client.close();
      socket.close();
      setState(null);
    };
  }, [assets, onMount, userAtom, roomId, schema, setState, track, uri, getUserPresence]);
  return useValue(
    "remote synced store",
    () => {
      if (!state)
        return { status: "loading" };
      if (state.error)
        return { status: "error", error: state.error };
      if (!state.readyClient)
        return { status: "loading" };
      const connectionStatus = state.readyClient.socket.connectionStatus;
      return {
        status: "synced-remote",
        connectionStatus: connectionStatus === "error" ? "offline" : connectionStatus,
        store: state.readyClient.store
      };
    },
    [state]
  );
}

// node_modules/@tldraw/sync/dist-esm/useSyncDemo.mjs
var import_react2 = __toESM(require_react(), 1);
function getEnv(cb) {
  try {
    return cb();
  } catch {
    return void 0;
  }
}
var DEMO_WORKER = getEnv(() => "https://demo.tldraw.xyz") ?? "https://demo.tldraw.xyz";
var IMAGE_WORKER = getEnv(() => process.env.TLDRAW_IMAGE_URL) ?? "https://images.tldraw.xyz";
function useSyncDemo(options) {
  const { roomId, host = DEMO_WORKER, ..._syncOpts } = options;
  const assets = (0, import_react2.useMemo)(() => createDemoAssetStore(host), [host]);
  const syncOpts = useShallowObjectIdentity(_syncOpts);
  const syncOptsWithDefaults = (0, import_react2.useMemo)(() => {
    if ("schema" in syncOpts && syncOpts.schema)
      return syncOpts;
    return {
      ...syncOpts,
      shapeUtils: "shapeUtils" in syncOpts ? [...defaultShapeUtils, ...syncOpts.shapeUtils ?? []] : defaultShapeUtils,
      bindingUtils: "bindingUtils" in syncOpts ? [...defaultBindingUtils, ...syncOpts.bindingUtils ?? []] : defaultBindingUtils
    };
  }, [syncOpts]);
  return useSync({
    uri: `${host}/connect/${encodeURIComponent(roomId)}`,
    roomId,
    assets,
    onMount: (0, import_react2.useCallback)(
      (editor) => {
        editor.registerExternalAssetHandler("url", async ({ url }) => {
          return await createAssetFromUrlUsingDemoServer(host, url);
        });
      },
      [host]
    ),
    ...syncOptsWithDefaults
  });
}
function createDemoAssetStore(host) {
  return {
    upload: async (asset, file) => {
      const id = uniqueId();
      const objectName = `${id}-${file.name}`.replace(/\W/g, "-");
      const url = `${host}/uploads/${objectName}`;
      await fetch(url, {
        method: "POST",
        body: file
      });
      return { src: url };
    },
    resolve(asset, context) {
      if (!asset.props.src)
        return null;
      if (asset.type === "video")
        return asset.props.src;
      if (asset.type !== "image")
        return null;
      if (!asset.props.src.startsWith("http:") && !asset.props.src.startsWith("https:"))
        return asset.props.src;
      if (context.shouldResolveToOriginal)
        return asset.props.src;
      if (MediaHelpers.isAnimatedImageType(asset == null ? void 0 : asset.props.mimeType) || asset.props.isAnimated)
        return asset.props.src;
      if (MediaHelpers.isVectorImageType(asset == null ? void 0 : asset.props.mimeType))
        return asset.props.src;
      const url = new URL(asset.props.src);
      const isTldrawImage = url.origin === host || /\.tldraw\.(?:com|xyz|dev|workers\.dev)$/.test(url.host);
      if (!isTldrawImage)
        return asset.props.src;
      const { fileSize = 0 } = asset.props;
      const isWorthResizing = fileSize >= 1024 * 1024 * 1.5;
      if (isWorthResizing) {
        const networkCompensation = !context.networkEffectiveType || context.networkEffectiveType === "4g" ? 1 : 0.5;
        const width = Math.ceil(
          Math.min(
            asset.props.w * clamp(context.steppedScreenScale, 1 / 32, 1) * networkCompensation * context.dpr,
            asset.props.w
          )
        );
        url.searchParams.set("w", width.toString());
      }
      const newUrl = `${IMAGE_WORKER}/${url.host}/${url.toString().slice(url.origin.length + 1)}`;
      return newUrl;
    }
  };
}
async function createAssetFromUrlUsingDemoServer(host, url) {
  const urlHash = getHashForString(url);
  try {
    const fetchUrl = new URL(`${host}/bookmarks/unfurl`);
    fetchUrl.searchParams.set("url", url);
    const meta = await (await fetch(fetchUrl, { method: "POST" })).json();
    return {
      id: AssetRecordType.createId(urlHash),
      typeName: "asset",
      type: "bookmark",
      props: {
        src: url,
        description: (meta == null ? void 0 : meta.description) ?? "",
        image: (meta == null ? void 0 : meta.image) ?? "",
        favicon: (meta == null ? void 0 : meta.favicon) ?? "",
        title: (meta == null ? void 0 : meta.title) ?? ""
      },
      meta: {}
    };
  } catch (error) {
    console.error(error);
    return {
      id: AssetRecordType.createId(urlHash),
      typeName: "asset",
      type: "bookmark",
      props: {
        src: url,
        description: "",
        image: "",
        favicon: "",
        title: ""
      },
      meta: {}
    };
  }
}

// node_modules/@tldraw/sync/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "@tldraw/sync",
  "3.13.1",
  "esm"
);
export {
  ClientWebSocketAdapter,
  DocumentState,
  ReconnectManager,
  RecordOpType,
  RoomSessionState,
  TLIncompatibilityReason,
  TLRemoteSyncError,
  TLSocketRoom,
  TLSyncClient,
  TLSyncErrorCloseEventCode,
  TLSyncErrorCloseEventReason,
  TLSyncRoom,
  ValueOpType,
  applyObjectDiff,
  chunk,
  diffRecord,
  getNetworkDiff,
  getTlsyncProtocolVersion,
  useSync,
  useSyncDemo
};
//# sourceMappingURL=@tldraw_sync.js.map
