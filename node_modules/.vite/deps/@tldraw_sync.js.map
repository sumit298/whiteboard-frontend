{
  "version": 3,
  "sources": ["../../@tldraw/sync-core/src/lib/chunk.ts", "../../@tldraw/sync-core/src/lib/TLSyncClient.ts", "../../@tldraw/sync-core/src/lib/diff.ts", "../../@tldraw/sync-core/src/lib/interval.ts", "../../@tldraw/sync-core/src/lib/protocol.ts", "../../@tldraw/sync-core/src/lib/ClientWebSocketAdapter.ts", "../../@tldraw/sync-core/src/lib/RoomSession.ts", "../../@tldraw/sync-core/src/lib/TLRemoteSyncError.ts", "../../@tldraw/sync-core/src/lib/ServerSocketAdapter.ts", "../../@tldraw/sync-core/src/lib/TLSyncRoom.ts", "../../nanoevents/index.js", "../../@tldraw/sync-core/src/lib/TLSocketRoom.ts", "../../@tldraw/sync-core/src/index.ts", "../../@tldraw/sync/src/useSync.ts", "../../@tldraw/sync/src/useSyncDemo.ts", "../../@tldraw/sync/src/index.ts"],
  "sourcesContent": ["// quarter of a megabyte, max possible utf-8 string size\n\n// cloudflare workers only accept messages of max 1mb\nconst MAX_CLIENT_SENT_MESSAGE_SIZE_BYTES = 1024 * 1024\n// utf-8 is max 4 bytes per char\nconst MAX_BYTES_PER_CHAR = 4\n\n// in the (admittedly impossible) worst case, the max size is 1/4 of a megabyte\nconst MAX_SAFE_MESSAGE_SIZE = MAX_CLIENT_SENT_MESSAGE_SIZE_BYTES / MAX_BYTES_PER_CHAR\n\n/** @internal */\nexport function chunk(msg: string, maxSafeMessageSize = MAX_SAFE_MESSAGE_SIZE) {\n\tif (msg.length < maxSafeMessageSize) {\n\t\treturn [msg]\n\t} else {\n\t\tconst chunks = []\n\t\tlet chunkNumber = 0\n\t\tlet offset = msg.length\n\t\twhile (offset > 0) {\n\t\t\tconst prefix = `${chunkNumber}_`\n\t\t\tconst chunkSize = Math.max(Math.min(maxSafeMessageSize - prefix.length, offset), 1)\n\t\t\tchunks.unshift(prefix + msg.slice(offset - chunkSize, offset))\n\t\t\toffset -= chunkSize\n\t\t\tchunkNumber++\n\t\t}\n\t\treturn chunks\n\t}\n}\n\nconst chunkRe = /^(\\d+)_(.*)$/\n\nexport class JsonChunkAssembler {\n\tstate:\n\t\t| 'idle'\n\t\t| {\n\t\t\t\tchunksReceived: string[]\n\t\t\t\ttotalChunks: number\n\t\t  } = 'idle'\n\n\thandleMessage(msg: string): { error: Error } | { stringified: string; data: object } | null {\n\t\tif (msg.startsWith('{')) {\n\t\t\tconst error = this.state === 'idle' ? undefined : new Error('Unexpected non-chunk message')\n\t\t\tthis.state = 'idle'\n\t\t\treturn error ? { error } : { data: JSON.parse(msg), stringified: msg }\n\t\t} else {\n\t\t\tconst match = chunkRe.exec(msg)!\n\t\t\tif (!match) {\n\t\t\t\tthis.state = 'idle'\n\t\t\t\treturn { error: new Error('Invalid chunk: ' + JSON.stringify(msg.slice(0, 20) + '...')) }\n\t\t\t}\n\t\t\tconst numChunksRemaining = Number(match[1])\n\t\t\tconst data = match[2]\n\n\t\t\tif (this.state === 'idle') {\n\t\t\t\tthis.state = {\n\t\t\t\t\tchunksReceived: [data],\n\t\t\t\t\ttotalChunks: numChunksRemaining + 1,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.state.chunksReceived.push(data)\n\t\t\t\tif (numChunksRemaining !== this.state.totalChunks - this.state.chunksReceived.length) {\n\t\t\t\t\tthis.state = 'idle'\n\t\t\t\t\treturn { error: new Error(`Chunks received in wrong order`) }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.state.chunksReceived.length === this.state.totalChunks) {\n\t\t\t\ttry {\n\t\t\t\t\tconst stringified = this.state.chunksReceived.join('')\n\t\t\t\t\tconst data = JSON.parse(stringified)\n\t\t\t\t\treturn { data, stringified }\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn { error: e as Error }\n\t\t\t\t} finally {\n\t\t\t\t\tthis.state = 'idle'\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null\n\t\t}\n\t}\n}\n", "import { Signal, react, transact } from '@tldraw/state'\nimport {\n\tRecordId,\n\tRecordsDiff,\n\tStore,\n\tUnknownRecord,\n\treverseRecordsDiff,\n\tsquashRecordDiffs,\n} from '@tldraw/store'\nimport { exhaustiveSwitchError, fpsThrottle, objectMapEntries, uniqueId } from '@tldraw/utils'\nimport isEqual from 'lodash.isequal'\nimport { NetworkDiff, RecordOpType, applyObjectDiff, diffRecord, getNetworkDiff } from './diff'\nimport { interval } from './interval'\nimport {\n\tTLPushRequest,\n\tTLSocketClientSentEvent,\n\tTLSocketServerSentDataEvent,\n\tTLSocketServerSentEvent,\n\tgetTlsyncProtocolVersion,\n} from './protocol'\n\n/** @internal */\nexport type SubscribingFn<T> = (cb: (val: T) => void) => () => void\n\n/**\n * This the close code that we use on the server to signal to a socket that\n * the connection is being closed because of a non-recoverable error.\n *\n * You should use this if you need to close a connection.\n *\n * @example\n * ```ts\n * socket.close(TLSyncErrorCloseEventCode, TLSyncErrorCloseEventReason.NOT_FOUND)\n * ```\n *\n * The `reason` parameter that you pass to `socket.close()` will be made available at `useSync().error.reason`\n *\n * @public\n */\nexport const TLSyncErrorCloseEventCode = 4099 as const\n\n/**\n * The set of reasons that a connection can be closed by the server\n * @public\n */\nexport const TLSyncErrorCloseEventReason = {\n\tNOT_FOUND: 'NOT_FOUND',\n\tFORBIDDEN: 'FORBIDDEN',\n\tNOT_AUTHENTICATED: 'NOT_AUTHENTICATED',\n\tUNKNOWN_ERROR: 'UNKNOWN_ERROR',\n\tCLIENT_TOO_OLD: 'CLIENT_TOO_OLD',\n\tSERVER_TOO_OLD: 'SERVER_TOO_OLD',\n\tINVALID_RECORD: 'INVALID_RECORD',\n\tRATE_LIMITED: 'RATE_LIMITED',\n\tROOM_FULL: 'ROOM_FULL',\n} as const\n/**\n * The set of reasons that a connection can be closed by the server\n * @public\n */\nexport type TLSyncErrorCloseEventReason =\n\t(typeof TLSyncErrorCloseEventReason)[keyof typeof TLSyncErrorCloseEventReason]\n\n/**\n * @internal\n */\nexport type TlSocketStatusChangeEvent =\n\t| {\n\t\t\tstatus: 'online' | 'offline'\n\t  }\n\t| {\n\t\t\tstatus: 'error'\n\t\t\treason: string\n\t  }\n/** @internal */\nexport type TLSocketStatusListener = (params: TlSocketStatusChangeEvent) => void\n\n/** @internal */\nexport type TLPersistentClientSocketStatus = 'online' | 'offline' | 'error'\n/**\n * A socket that can be used to send and receive messages to the server. It should handle staying\n * open and reconnecting when the connection is lost. In actual client code this will be a wrapper\n * around a websocket or socket.io or something similar.\n *\n * @internal\n */\nexport interface TLPersistentClientSocket<R extends UnknownRecord = UnknownRecord> {\n\t/** Whether there is currently an open connection to the server. */\n\tconnectionStatus: 'online' | 'offline' | 'error'\n\t/** Send a message to the server */\n\tsendMessage(msg: TLSocketClientSentEvent<R>): void\n\t/** Attach a listener for messages sent by the server */\n\tonReceiveMessage: SubscribingFn<TLSocketServerSentEvent<R>>\n\t/** Attach a listener for connection status changes */\n\tonStatusChange: SubscribingFn<TlSocketStatusChangeEvent>\n\t/** Restart the connection */\n\trestart(): void\n}\n\nconst PING_INTERVAL = 5000\nconst MAX_TIME_TO_WAIT_FOR_SERVER_INTERACTION_BEFORE_RESETTING_CONNECTION = PING_INTERVAL * 2\n\n// Should connect support chunking the response to allow for large payloads?\n\n/**\n * TLSyncClient manages syncing data in a local Store with a remote server.\n *\n * It uses a git-style push/pull/rebase model.\n *\n * @internal\n */\nexport class TLSyncClient<R extends UnknownRecord, S extends Store<R> = Store<R>> {\n\t/** The last clock time from the most recent server update */\n\tprivate lastServerClock = 0\n\tprivate lastServerInteractionTimestamp = Date.now()\n\n\t/** The queue of in-flight push requests that have not yet been acknowledged by the server */\n\tprivate pendingPushRequests: { request: TLPushRequest<R>; sent: boolean }[] = []\n\n\t/**\n\t * The diff of 'unconfirmed', 'optimistic' changes that have been made locally by the user if we\n\t * take this diff, reverse it, and apply that to the store, our store will match exactly the most\n\t * recent state of the server that we know about\n\t */\n\tprivate speculativeChanges: RecordsDiff<R> = {\n\t\tadded: {} as any,\n\t\tupdated: {} as any,\n\t\tremoved: {} as any,\n\t}\n\n\tprivate disposables: Array<() => void> = []\n\n\treadonly store: S\n\treadonly socket: TLPersistentClientSocket<R>\n\n\treadonly presenceState: Signal<R | null> | undefined\n\n\t// isOnline is true when we have an open socket connection and we have\n\t// established a connection with the server room (i.e. we have received a 'connect' message)\n\tisConnectedToRoom = false\n\n\t/**\n\t * The client clock is essentially a counter for push requests Each time a push request is created\n\t * the clock is incremented. This clock is sent with the push request to the server, and the\n\t * server returns it with the response so that we can match up the response with the request.\n\t *\n\t * The clock may also be used at one point in the future to allow the client to re-send push\n\t * requests idempotently (i.e. the server will keep track of each client's clock and not execute\n\t * requests it has already handled), but at the time of writing this is neither needed nor\n\t * implemented.\n\t */\n\tprivate clientClock = 0\n\n\t/**\n\t * Called immediately after a connect acceptance has been received and processed Use this to make\n\t * any changes to the store that are required to keep it operational\n\t */\n\tpublic readonly onAfterConnect?: (self: this, details: { isReadonly: boolean }) => void\n\n\tprivate isDebugging = false\n\tprivate debug(...args: any[]) {\n\t\tif (this.isDebugging) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.debug(...args)\n\t\t}\n\t}\n\n\tprivate readonly presenceType: R['typeName'] | null\n\n\tdidCancel?: () => boolean\n\n\tconstructor(config: {\n\t\tstore: S\n\t\tsocket: TLPersistentClientSocket<R>\n\t\tpresence: Signal<R | null>\n\t\tonLoad(self: TLSyncClient<R, S>): void\n\t\tonSyncError(reason: string): void\n\t\tonAfterConnect?(self: TLSyncClient<R, S>, details: { isReadonly: boolean }): void\n\t\tdidCancel?(): boolean\n\t}) {\n\t\tthis.didCancel = config.didCancel\n\n\t\tthis.presenceType = config.store.scopedTypes.presence.values().next().value ?? null\n\n\t\tif (typeof window !== 'undefined') {\n\t\t\t;(window as any).tlsync = this\n\t\t}\n\t\tthis.store = config.store\n\t\tthis.socket = config.socket\n\t\tthis.onAfterConnect = config.onAfterConnect\n\n\t\tlet didLoad = false\n\n\t\tthis.presenceState = config.presence\n\n\t\tthis.disposables.push(\n\t\t\t// when local 'user' changes are made, send them to the server\n\t\t\t// or stash them locally in offline mode\n\t\t\tthis.store.listen(\n\t\t\t\t({ changes }) => {\n\t\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\t\tthis.debug('received store changes', { changes })\n\t\t\t\t\tthis.push(changes)\n\t\t\t\t},\n\t\t\t\t{ source: 'user', scope: 'document' }\n\t\t\t),\n\t\t\t// when the server sends us events, handle them\n\t\t\tthis.socket.onReceiveMessage((msg) => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('received message from server', msg)\n\t\t\t\tthis.handleServerEvent(msg)\n\t\t\t\t// the first time we receive a message from the server, we should trigger\n\n\t\t\t\t// one of the load callbacks\n\t\t\t\tif (!didLoad) {\n\t\t\t\t\tdidLoad = true\n\t\t\t\t\tconfig.onLoad(this)\n\t\t\t\t}\n\t\t\t}),\n\t\t\t// handle switching between online and offline\n\t\t\tthis.socket.onStatusChange((ev) => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('socket status changed', ev.status)\n\t\t\t\tif (ev.status === 'online') {\n\t\t\t\t\tthis.sendConnectMessage()\n\t\t\t\t} else {\n\t\t\t\t\tthis.resetConnection()\n\t\t\t\t\tif (ev.status === 'error') {\n\t\t\t\t\t\tdidLoad = true\n\t\t\t\t\t\tconfig.onSyncError(ev.reason)\n\t\t\t\t\t\tthis.close()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t\t// Send a ping every PING_INTERVAL ms while online\n\t\t\tinterval(() => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('ping loop', { isConnectedToRoom: this.isConnectedToRoom })\n\t\t\t\tif (!this.isConnectedToRoom) return\n\t\t\t\ttry {\n\t\t\t\t\tthis.socket.sendMessage({ type: 'ping' })\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.warn('ping failed, resetting', error)\n\t\t\t\t\tthis.resetConnection()\n\t\t\t\t}\n\t\t\t}, PING_INTERVAL),\n\t\t\t// Check the server connection health, reset the connection if needed\n\t\t\tinterval(() => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('health check loop', { isConnectedToRoom: this.isConnectedToRoom })\n\t\t\t\tif (!this.isConnectedToRoom) return\n\t\t\t\tconst timeSinceLastServerInteraction = Date.now() - this.lastServerInteractionTimestamp\n\n\t\t\t\tif (\n\t\t\t\t\ttimeSinceLastServerInteraction <\n\t\t\t\t\tMAX_TIME_TO_WAIT_FOR_SERVER_INTERACTION_BEFORE_RESETTING_CONNECTION\n\t\t\t\t) {\n\t\t\t\t\tthis.debug('health check passed', { timeSinceLastServerInteraction })\n\t\t\t\t\t// last ping was recent, so no need to take any action\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconsole.warn(`Haven't heard from the server in a while, resetting connection...`)\n\t\t\t\tthis.resetConnection()\n\t\t\t}, PING_INTERVAL * 2)\n\t\t)\n\n\t\tif (this.presenceState) {\n\t\t\tthis.disposables.push(\n\t\t\t\treact('pushPresence', () => {\n\t\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\t\tthis.pushPresence(this.presenceState!.get())\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\n\t\t// if the socket is already online before this client was instantiated\n\t\t// then we should send a connect message right away\n\t\tif (this.socket.connectionStatus === 'online') {\n\t\t\tthis.sendConnectMessage()\n\t\t}\n\t}\n\n\tlatestConnectRequestId: string | null = null\n\n\t/**\n\t * This is the first message that is sent over a newly established socket connection. And we need\n\t * to wait for the response before this client can be used.\n\t */\n\tprivate sendConnectMessage() {\n\t\tif (this.isConnectedToRoom) {\n\t\t\tconsole.error('sendConnectMessage called while already connected')\n\t\t\treturn\n\t\t}\n\t\tthis.debug('sending connect message')\n\t\tthis.latestConnectRequestId = uniqueId()\n\t\tthis.socket.sendMessage({\n\t\t\ttype: 'connect',\n\t\t\tconnectRequestId: this.latestConnectRequestId,\n\t\t\tschema: this.store.schema.serialize(),\n\t\t\tprotocolVersion: getTlsyncProtocolVersion(),\n\t\t\tlastServerClock: this.lastServerClock,\n\t\t})\n\t}\n\n\t/** Switch to offline mode */\n\tprivate resetConnection(hard = false) {\n\t\tthis.debug('resetting connection')\n\t\tif (hard) {\n\t\t\tthis.lastServerClock = 0\n\t\t}\n\t\t// kill all presence state\n\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\tthis.store.remove(Object.keys(this.store.serialize('presence')) as any)\n\t\t})\n\t\tthis.lastPushedPresenceState = null\n\t\tthis.isConnectedToRoom = false\n\t\tthis.pendingPushRequests = []\n\t\tthis.incomingDiffBuffer = []\n\t\tif (this.socket.connectionStatus === 'online') {\n\t\t\tthis.socket.restart()\n\t\t}\n\t}\n\n\t/**\n\t * Invoked when the socket connection comes online, either for the first time or as the result of\n\t * a reconnect. The goal is to rebase on the server's state and fire off a new push request for\n\t * any local changes that were made while offline.\n\t */\n\tprivate didReconnect(event: Extract<TLSocketServerSentEvent<R>, { type: 'connect' }>) {\n\t\tthis.debug('did reconnect', event)\n\t\tif (event.connectRequestId !== this.latestConnectRequestId) {\n\t\t\t// ignore connect events for old connect requests\n\t\t\treturn\n\t\t}\n\t\tthis.latestConnectRequestId = null\n\n\t\tif (this.isConnectedToRoom) {\n\t\t\tconsole.error('didReconnect called while already connected')\n\t\t\tthis.resetConnection(true)\n\t\t\treturn\n\t\t}\n\t\tif (this.pendingPushRequests.length > 0) {\n\t\t\tconsole.error('pendingPushRequests should already be empty when we reconnect')\n\t\t\tthis.resetConnection(true)\n\t\t\treturn\n\t\t}\n\t\t// at the end of this process we want to have at most one pending push request\n\t\t// based on anything inside this.speculativeChanges\n\t\ttransact(() => {\n\t\t\t// Now our goal is to rebase on the server's state.\n\t\t\t// This means wiping away any peer presence data, which the server will replace in full on every connect.\n\t\t\t// If the server does not have enough history to give us a partial document state hydration we will\n\t\t\t// also need to wipe away all of our document state before hydrating with the server's state from scratch.\n\t\t\tconst stashedChanges = this.speculativeChanges\n\t\t\tthis.speculativeChanges = { added: {} as any, updated: {} as any, removed: {} as any }\n\n\t\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\t\t// gather records to delete in a NetworkDiff\n\t\t\t\tconst wipeDiff: NetworkDiff<R> = {}\n\t\t\t\tconst wipeAll = event.hydrationType === 'wipe_all'\n\t\t\t\tif (!wipeAll) {\n\t\t\t\t\t// if we're only wiping presence data, undo the speculative changes first\n\t\t\t\t\tthis.store.applyDiff(reverseRecordsDiff(stashedChanges), { runCallbacks: false })\n\t\t\t\t}\n\n\t\t\t\t// now wipe all presence data and, if needed, all document data\n\t\t\t\tfor (const [id, record] of objectMapEntries(this.store.serialize('all'))) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t(wipeAll && this.store.scopedTypes.document.has(record.typeName)) ||\n\t\t\t\t\t\trecord.typeName === this.presenceType\n\t\t\t\t\t) {\n\t\t\t\t\t\twipeDiff[id] = [RecordOpType.Remove]\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// then apply the upstream changes\n\t\t\t\tthis.applyNetworkDiff({ ...wipeDiff, ...event.diff }, true)\n\n\t\t\t\tthis.isConnectedToRoom = true\n\n\t\t\t\t// now re-apply the speculative changes creating a new push request with the\n\t\t\t\t// appropriate diff\n\t\t\t\tconst speculativeChanges = this.store.filterChangesByScope(\n\t\t\t\t\tthis.store.extractingChanges(() => {\n\t\t\t\t\t\tthis.store.applyDiff(stashedChanges)\n\t\t\t\t\t}),\n\t\t\t\t\t'document'\n\t\t\t\t)\n\t\t\t\tif (speculativeChanges) this.push(speculativeChanges)\n\t\t\t})\n\n\t\t\t// this.isConnectedToRoom = true\n\t\t\t// this.store.applyDiff(stashedChanges, false)\n\n\t\t\tthis.onAfterConnect?.(this, { isReadonly: event.isReadonly })\n\t\t})\n\n\t\tthis.lastServerClock = event.serverClock\n\t}\n\n\tincomingDiffBuffer: TLSocketServerSentDataEvent<R>[] = []\n\n\t/** Handle events received from the server */\n\tprivate handleServerEvent(event: TLSocketServerSentEvent<R>) {\n\t\tthis.debug('received server event', event)\n\t\tthis.lastServerInteractionTimestamp = Date.now()\n\t\t// always update the lastServerClock when it is present\n\t\tswitch (event.type) {\n\t\t\tcase 'connect':\n\t\t\t\tthis.didReconnect(event)\n\t\t\t\tbreak\n\t\t\t// legacy v4 events\n\t\t\tcase 'patch':\n\t\t\tcase 'push_result':\n\t\t\t\tif (!this.isConnectedToRoom) break\n\t\t\t\tthis.incomingDiffBuffer.push(event)\n\t\t\t\tthis.scheduleRebase()\n\t\t\t\tbreak\n\t\t\tcase 'data':\n\t\t\t\t// wait for a connect to succeed before processing more events\n\t\t\t\tif (!this.isConnectedToRoom) break\n\t\t\t\tthis.incomingDiffBuffer.push(...event.data)\n\t\t\t\tthis.scheduleRebase()\n\t\t\t\tbreak\n\t\t\tcase 'incompatibility_error':\n\t\t\t\t// legacy unrecoverable errors\n\t\t\t\tconsole.error('incompatibility error is legacy and should no longer be sent by the server')\n\t\t\t\tbreak\n\t\t\tcase 'pong':\n\t\t\t\t// noop, we only use ping/pong to set lastSeverInteractionTimestamp\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(event)\n\t\t}\n\t}\n\n\tclose() {\n\t\tthis.debug('closing')\n\t\tthis.disposables.forEach((dispose) => dispose())\n\t\tthis.flushPendingPushRequests.cancel?.()\n\t\tthis.scheduleRebase.cancel?.()\n\t}\n\n\tlastPushedPresenceState: R | null = null\n\n\tprivate pushPresence(nextPresence: R | null) {\n\t\t// make sure we push any document changes first\n\t\tthis.store._flushHistory()\n\n\t\tif (!this.isConnectedToRoom) {\n\t\t\t// if we're offline, don't do anything\n\t\t\treturn\n\t\t}\n\n\t\tlet presence: TLPushRequest<any>['presence'] = undefined\n\t\tif (!this.lastPushedPresenceState && nextPresence) {\n\t\t\t// we don't have a last presence state, so we need to push the full state\n\t\t\tpresence = [RecordOpType.Put, nextPresence]\n\t\t} else if (this.lastPushedPresenceState && nextPresence) {\n\t\t\t// we have a last presence state, so we need to push a diff if there is one\n\t\t\tconst diff = diffRecord(this.lastPushedPresenceState, nextPresence)\n\t\t\tif (diff) {\n\t\t\t\tpresence = [RecordOpType.Patch, diff]\n\t\t\t}\n\t\t}\n\n\t\tif (!presence) return\n\t\tthis.lastPushedPresenceState = nextPresence\n\n\t\t// if there is a pending push that has not been sent and does not already include a presence update,\n\t\t// then add this presence update to it\n\t\tconst lastPush = this.pendingPushRequests.at(-1)\n\t\tif (lastPush && !lastPush.sent && !lastPush.request.presence) {\n\t\t\tlastPush.request.presence = presence\n\t\t\treturn\n\t\t}\n\n\t\t// otherwise, create a new push request\n\t\tconst req: TLPushRequest<R> = {\n\t\t\ttype: 'push',\n\t\t\tclientClock: this.clientClock++,\n\t\t\tpresence,\n\t\t}\n\n\t\tif (req) {\n\t\t\tthis.pendingPushRequests.push({ request: req, sent: false })\n\t\t\tthis.flushPendingPushRequests()\n\t\t}\n\t}\n\n\t/** Push a change to the server, or stash it locally if we're offline */\n\tprivate push(change: RecordsDiff<any>) {\n\t\tthis.debug('push', change)\n\t\t// the Store doesn't do deep equality checks when making changes\n\t\t// so it's possible that the diff passed in here is actually a no-op.\n\t\t// either way, we also don't want to send whole objects over the wire if\n\t\t// only small parts of them have changed, so we'll do a shallow-ish diff\n\t\t// which also uses deep equality checks to see if the change is actually\n\t\t// a no-op.\n\t\tconst diff = getNetworkDiff(change)\n\t\tif (!diff) return\n\n\t\t// the change is not a no-op so we'll send it to the server\n\t\t// but first let's merge the records diff into the speculative changes\n\t\tthis.speculativeChanges = squashRecordDiffs([this.speculativeChanges, change])\n\n\t\tif (!this.isConnectedToRoom) {\n\t\t\t// don't sent push requests or even store them up while offline\n\t\t\t// when we come back online we'll generate another push request from\n\t\t\t// scratch based on the speculativeChanges diff\n\t\t\treturn\n\t\t}\n\n\t\tconst pushRequest: TLPushRequest<R> = {\n\t\t\ttype: 'push',\n\t\t\tdiff,\n\t\t\tclientClock: this.clientClock++,\n\t\t}\n\n\t\tthis.pendingPushRequests.push({ request: pushRequest, sent: false })\n\n\t\t// immediately calling .send on the websocket here was causing some interaction\n\t\t// slugishness when e.g. drawing or translating shapes. Seems like it blocks\n\t\t// until the send completes. So instead we'll schedule a send to happen on some\n\t\t// tick in the near future.\n\t\tthis.flushPendingPushRequests()\n\t}\n\n\t/** Send any unsent push requests to the server */\n\tprivate flushPendingPushRequests = fpsThrottle(() => {\n\t\tthis.debug('flushing pending push requests', {\n\t\t\tisConnectedToRoom: this.isConnectedToRoom,\n\t\t\tpendingPushRequests: this.pendingPushRequests,\n\t\t})\n\t\tif (!this.isConnectedToRoom || this.store.isPossiblyCorrupted()) {\n\t\t\treturn\n\t\t}\n\t\tfor (const pendingPushRequest of this.pendingPushRequests) {\n\t\t\tif (!pendingPushRequest.sent) {\n\t\t\t\tif (this.socket.connectionStatus !== 'online') {\n\t\t\t\t\t// we went offline, so don't send anything\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.socket.sendMessage(pendingPushRequest.request)\n\t\t\t\tpendingPushRequest.sent = true\n\t\t\t}\n\t\t}\n\t})\n\n\t/**\n\t * Applies a 'network' diff to the store this does value-based equality checking so that if the\n\t * data is the same (as opposed to merely identical with ===), then no change is made and no\n\t * changes will be propagated back to store listeners\n\t */\n\tprivate applyNetworkDiff(diff: NetworkDiff<R>, runCallbacks: boolean) {\n\t\tthis.debug('applyNetworkDiff', diff)\n\t\tconst changes: RecordsDiff<R> = { added: {} as any, updated: {} as any, removed: {} as any }\n\t\ttype k = keyof typeof changes.updated\n\t\tlet hasChanges = false\n\t\tfor (const [id, op] of objectMapEntries(diff)) {\n\t\t\tif (op[0] === RecordOpType.Put) {\n\t\t\t\tconst existing = this.store.get(id as RecordId<any>)\n\t\t\t\tif (existing && !isEqual(existing, op[1])) {\n\t\t\t\t\thasChanges = true\n\t\t\t\t\tchanges.updated[id as k] = [existing, op[1]]\n\t\t\t\t} else {\n\t\t\t\t\thasChanges = true\n\t\t\t\t\tchanges.added[id as k] = op[1]\n\t\t\t\t}\n\t\t\t} else if (op[0] === RecordOpType.Patch) {\n\t\t\t\tconst record = this.store.get(id as RecordId<any>)\n\t\t\t\tif (!record) {\n\t\t\t\t\t// the record was removed upstream\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst patched = applyObjectDiff(record, op[1])\n\t\t\t\thasChanges = true\n\t\t\t\tchanges.updated[id as k] = [record, patched]\n\t\t\t} else if (op[0] === RecordOpType.Remove) {\n\t\t\t\tif (this.store.has(id as RecordId<any>)) {\n\t\t\t\t\thasChanges = true\n\t\t\t\t\tchanges.removed[id as k] = this.store.get(id as RecordId<any>)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hasChanges) {\n\t\t\tthis.store.applyDiff(changes, { runCallbacks })\n\t\t}\n\t}\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\tprivate rebase = () => {\n\t\t// need to make sure that our speculative changes are in sync with the actual store instance before\n\t\t// proceeding, to avoid inconsistency bugs.\n\t\tthis.store._flushHistory()\n\t\tif (this.incomingDiffBuffer.length === 0) return\n\n\t\tconst diffs = this.incomingDiffBuffer\n\t\tthis.incomingDiffBuffer = []\n\n\t\ttry {\n\t\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\t\t// first undo speculative changes\n\t\t\t\tthis.store.applyDiff(reverseRecordsDiff(this.speculativeChanges), { runCallbacks: false })\n\n\t\t\t\t// then apply network diffs on top of known-to-be-synced data\n\t\t\t\tfor (const diff of diffs) {\n\t\t\t\t\tif (diff.type === 'patch') {\n\t\t\t\t\t\tthis.applyNetworkDiff(diff.diff, true)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// handling push_result\n\t\t\t\t\tif (this.pendingPushRequests.length === 0) {\n\t\t\t\t\t\tthrow new Error('Received push_result but there are no pending push requests')\n\t\t\t\t\t}\n\t\t\t\t\tif (this.pendingPushRequests[0].request.clientClock !== diff.clientClock) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Received push_result for a push request that is not at the front of the queue'\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.action === 'discard') {\n\t\t\t\t\t\tthis.pendingPushRequests.shift()\n\t\t\t\t\t} else if (diff.action === 'commit') {\n\t\t\t\t\t\tconst { request } = this.pendingPushRequests.shift()!\n\t\t\t\t\t\tif ('diff' in request && request.diff) {\n\t\t\t\t\t\t\tthis.applyNetworkDiff(request.diff, true)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.applyNetworkDiff(diff.action.rebaseWithDiff, true)\n\t\t\t\t\t\tthis.pendingPushRequests.shift()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// update the speculative diff while re-applying pending changes\n\t\t\t\ttry {\n\t\t\t\t\tthis.speculativeChanges = this.store.extractingChanges(() => {\n\t\t\t\t\t\tfor (const { request } of this.pendingPushRequests) {\n\t\t\t\t\t\t\tif (!('diff' in request) || !request.diff) continue\n\t\t\t\t\t\t\tthis.applyNetworkDiff(request.diff, true)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(e)\n\t\t\t\t\t// throw away the speculative changes and start over\n\t\t\t\t\tthis.speculativeChanges = { added: {} as any, updated: {} as any, removed: {} as any }\n\t\t\t\t\tthis.resetConnection()\n\t\t\t\t}\n\t\t\t})\n\t\t\tthis.lastServerClock = diffs.at(-1)?.serverClock ?? this.lastServerClock\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\tthis.resetConnection()\n\t\t}\n\t}\n\n\tprivate scheduleRebase = fpsThrottle(this.rebase)\n}\n", "import { RecordsDiff, UnknownRecord } from '@tldraw/store'\nimport { objectMapEntries, objectMapValues } from '@tldraw/utils'\nimport isEqual from 'lodash.isequal'\n\n/** @internal */\nexport const RecordOpType = {\n\tPut: 'put',\n\tPatch: 'patch',\n\tRemove: 'remove',\n} as const\n\n/** @internal */\nexport type RecordOpType = (typeof RecordOpType)[keyof typeof RecordOpType]\n\n/** @internal */\nexport type RecordOp<R extends UnknownRecord> =\n\t| [typeof RecordOpType.Put, R]\n\t| [typeof RecordOpType.Patch, ObjectDiff]\n\t| [typeof RecordOpType.Remove]\n\n/**\n * A one-way (non-reversible) diff designed for small json footprint. These are mainly intended to\n * be sent over the wire. Either as push requests from the client to the server, or as patch\n * operations in the opposite direction.\n *\n * Each key in this object is the id of a record that has been added, updated, or removed.\n *\n * @internal\n */\nexport interface NetworkDiff<R extends UnknownRecord> {\n\t[id: string]: RecordOp<R>\n}\n\n/**\n * Converts a (reversible, verbose) RecordsDiff into a (non-reversible, concise) NetworkDiff\n *\n *@internal\n */\nexport function getNetworkDiff<R extends UnknownRecord>(\n\tdiff: RecordsDiff<R>\n): NetworkDiff<R> | null {\n\tlet res: NetworkDiff<R> | null = null\n\n\tfor (const [k, v] of objectMapEntries(diff.added)) {\n\t\tif (!res) res = {}\n\t\tres[k] = [RecordOpType.Put, v]\n\t}\n\n\tfor (const [from, to] of objectMapValues(diff.updated)) {\n\t\tconst diff = diffRecord(from, to)\n\t\tif (diff) {\n\t\t\tif (!res) res = {}\n\t\t\tres[to.id] = [RecordOpType.Patch, diff]\n\t\t}\n\t}\n\n\tfor (const removed of Object.keys(diff.removed)) {\n\t\tif (!res) res = {}\n\t\tres[removed] = [RecordOpType.Remove]\n\t}\n\n\treturn res\n}\n\n/** @internal */\nexport const ValueOpType = {\n\tPut: 'put',\n\tDelete: 'delete',\n\tAppend: 'append',\n\tPatch: 'patch',\n} as const\n/** @internal */\nexport type ValueOpType = (typeof ValueOpType)[keyof typeof ValueOpType]\n\n/** @internal */\nexport type PutOp = [type: typeof ValueOpType.Put, value: unknown]\n/** @internal */\nexport type AppendOp = [type: typeof ValueOpType.Append, values: unknown[], offset: number]\n/** @internal */\nexport type PatchOp = [type: typeof ValueOpType.Patch, diff: ObjectDiff]\n/** @internal */\nexport type DeleteOp = [type: typeof ValueOpType.Delete]\n\n/** @internal */\nexport type ValueOp = PutOp | AppendOp | PatchOp | DeleteOp\n\n/** @internal */\nexport interface ObjectDiff {\n\t[k: string]: ValueOp\n}\n\n/** @internal */\nexport function diffRecord(prev: object, next: object): ObjectDiff | null {\n\treturn diffObject(prev, next, new Set(['props']))\n}\n\nfunction diffObject(prev: object, next: object, nestedKeys?: Set<string>): ObjectDiff | null {\n\tif (prev === next) {\n\t\treturn null\n\t}\n\tlet result: ObjectDiff | null = null\n\tfor (const key of Object.keys(prev)) {\n\t\t// if key is not in next then it was deleted\n\t\tif (!(key in next)) {\n\t\t\tif (!result) result = {}\n\t\t\tresult[key] = [ValueOpType.Delete]\n\t\t\tcontinue\n\t\t}\n\t\t// if key is in both places, then compare values\n\t\tconst prevVal = (prev as any)[key]\n\t\tconst nextVal = (next as any)[key]\n\t\tif (!isEqual(prevVal, nextVal)) {\n\t\t\tif (nestedKeys?.has(key) && prevVal && nextVal) {\n\t\t\t\tconst diff = diffObject(prevVal, nextVal)\n\t\t\t\tif (diff) {\n\t\t\t\t\tif (!result) result = {}\n\t\t\t\t\tresult[key] = [ValueOpType.Patch, diff]\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(nextVal) && Array.isArray(prevVal)) {\n\t\t\t\tconst op = diffArray(prevVal, nextVal)\n\t\t\t\tif (op) {\n\t\t\t\t\tif (!result) result = {}\n\t\t\t\t\tresult[key] = op\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!result) result = {}\n\t\t\t\tresult[key] = [ValueOpType.Put, nextVal]\n\t\t\t}\n\t\t}\n\t}\n\tfor (const key of Object.keys(next)) {\n\t\t// if key is in next but not in prev then it was added\n\t\tif (!(key in prev)) {\n\t\t\tif (!result) result = {}\n\t\t\tresult[key] = [ValueOpType.Put, (next as any)[key]]\n\t\t}\n\t}\n\treturn result\n}\n\nfunction diffValue(valueA: unknown, valueB: unknown): ValueOp | null {\n\tif (Object.is(valueA, valueB)) return null\n\tif (Array.isArray(valueA) && Array.isArray(valueB)) {\n\t\treturn diffArray(valueA, valueB)\n\t} else if (!valueA || !valueB || typeof valueA !== 'object' || typeof valueB !== 'object') {\n\t\treturn isEqual(valueA, valueB) ? null : [ValueOpType.Put, valueB]\n\t} else {\n\t\tconst diff = diffObject(valueA, valueB)\n\t\treturn diff ? [ValueOpType.Patch, diff] : null\n\t}\n}\n\nfunction diffArray(prevArray: unknown[], nextArray: unknown[]): PutOp | AppendOp | PatchOp | null {\n\tif (Object.is(prevArray, nextArray)) return null\n\t// if lengths are equal, check for patch operation\n\tif (prevArray.length === nextArray.length) {\n\t\t// bail out if more than len/5 items need patching\n\t\tconst maxPatchIndexes = Math.max(prevArray.length / 5, 1)\n\t\tconst toPatchIndexes = []\n\t\tfor (let i = 0; i < prevArray.length; i++) {\n\t\t\tif (!isEqual(prevArray[i], nextArray[i])) {\n\t\t\t\ttoPatchIndexes.push(i)\n\t\t\t\tif (toPatchIndexes.length > maxPatchIndexes) {\n\t\t\t\t\treturn [ValueOpType.Put, nextArray]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (toPatchIndexes.length === 0) {\n\t\t\t// same length and no items changed, so no diff\n\t\t\treturn null\n\t\t}\n\t\tconst diff: ObjectDiff = {}\n\t\tfor (const i of toPatchIndexes) {\n\t\t\tconst prevItem = prevArray[i]\n\t\t\tconst nextItem = nextArray[i]\n\t\t\tif (!prevItem || !nextItem) {\n\t\t\t\tdiff[i] = [ValueOpType.Put, nextItem]\n\t\t\t} else if (typeof prevItem === 'object' && typeof nextItem === 'object') {\n\t\t\t\tconst op = diffValue(prevItem, nextItem)\n\t\t\t\tif (op) {\n\t\t\t\t\tdiff[i] = op\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdiff[i] = [ValueOpType.Put, nextItem]\n\t\t\t}\n\t\t}\n\t\treturn [ValueOpType.Patch, diff]\n\t}\n\n\t// if lengths are not equal, check for append operation, and bail out\n\t// to replace whole array if any shared elems changed\n\tfor (let i = 0; i < prevArray.length; i++) {\n\t\tif (!isEqual(prevArray[i], nextArray[i])) {\n\t\t\treturn [ValueOpType.Put, nextArray]\n\t\t}\n\t}\n\n\treturn [ValueOpType.Append, nextArray.slice(prevArray.length), prevArray.length]\n}\n\n/** @internal */\nexport function applyObjectDiff<T extends object>(object: T, objectDiff: ObjectDiff): T {\n\t// don't patch nulls\n\tif (!object || typeof object !== 'object') return object\n\tconst isArray = Array.isArray(object)\n\tlet newObject: any | undefined = undefined\n\tconst set = (k: any, v: any) => {\n\t\tif (!newObject) {\n\t\t\tif (isArray) {\n\t\t\t\tnewObject = [...object]\n\t\t\t} else {\n\t\t\t\tnewObject = { ...object }\n\t\t\t}\n\t\t}\n\t\tif (isArray) {\n\t\t\tnewObject[Number(k)] = v\n\t\t} else {\n\t\t\tnewObject[k] = v\n\t\t}\n\t}\n\tfor (const [key, op] of Object.entries(objectDiff)) {\n\t\tswitch (op[0]) {\n\t\t\tcase ValueOpType.Put: {\n\t\t\t\tconst value = op[1]\n\t\t\t\tif (!isEqual(object[key as keyof T], value)) {\n\t\t\t\t\tset(key, value)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase ValueOpType.Append: {\n\t\t\t\tconst values = op[1]\n\t\t\t\tconst offset = op[2]\n\t\t\t\tconst arr = object[key as keyof T]\n\t\t\t\tif (Array.isArray(arr) && arr.length === offset) {\n\t\t\t\t\tset(key, [...arr, ...values])\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase ValueOpType.Patch: {\n\t\t\t\tif (object[key as keyof T] && typeof object[key as keyof T] === 'object') {\n\t\t\t\t\tconst diff = op[1]\n\t\t\t\t\tconst patched = applyObjectDiff(object[key as keyof T] as object, diff)\n\t\t\t\t\tif (patched !== object[key as keyof T]) {\n\t\t\t\t\t\tset(key, patched)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase ValueOpType.Delete: {\n\t\t\t\tif (key in object) {\n\t\t\t\t\tif (!newObject) {\n\t\t\t\t\t\tif (isArray) {\n\t\t\t\t\t\t\tconsole.error(\"Can't delete array item yet (this should never happen)\")\n\t\t\t\t\t\t\tnewObject = [...object]\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewObject = { ...object }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdelete newObject[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newObject ?? object\n}\n", "export function interval(cb: () => void, timeout: number) {\n\tconst i = setInterval(cb, timeout)\n\treturn () => clearInterval(i)\n}\n", "import { SerializedSchema, UnknownRecord } from '@tldraw/store'\nimport { NetworkDiff, ObjectDiff, RecordOpType } from './diff'\n\nconst TLSYNC_PROTOCOL_VERSION = 7\n\n/** @internal */\nexport function getTlsyncProtocolVersion() {\n\treturn TLSYNC_PROTOCOL_VERSION\n}\n\n/**\n * @internal\n * @deprecated Replaced by websocket .close status/reason\n */\nexport const TLIncompatibilityReason = {\n\tClientTooOld: 'clientTooOld',\n\tServerTooOld: 'serverTooOld',\n\tInvalidRecord: 'invalidRecord',\n\tInvalidOperation: 'invalidOperation',\n} as const\n\n/**\n * @internal\n * @deprecated replaced by websocket .close status/reason\n */\nexport type TLIncompatibilityReason =\n\t(typeof TLIncompatibilityReason)[keyof typeof TLIncompatibilityReason]\n\n/** @internal */\nexport type TLSocketServerSentEvent<R extends UnknownRecord> =\n\t| {\n\t\t\ttype: 'connect'\n\t\t\thydrationType: 'wipe_all' | 'wipe_presence'\n\t\t\tconnectRequestId: string\n\t\t\tprotocolVersion: number\n\t\t\tschema: SerializedSchema\n\t\t\tdiff: NetworkDiff<R>\n\t\t\tserverClock: number\n\t\t\tisReadonly: boolean\n\t  }\n\t| {\n\t\t\ttype: 'incompatibility_error'\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\treason: TLIncompatibilityReason\n\t  }\n\t| {\n\t\t\ttype: 'pong'\n\t  }\n\t| { type: 'data'; data: TLSocketServerSentDataEvent<R>[] }\n\t| TLSocketServerSentDataEvent<R>\n\n/** @internal */\nexport type TLSocketServerSentDataEvent<R extends UnknownRecord> =\n\t| {\n\t\t\ttype: 'patch'\n\t\t\tdiff: NetworkDiff<R>\n\t\t\tserverClock: number\n\t  }\n\t| {\n\t\t\ttype: 'push_result'\n\t\t\tclientClock: number\n\t\t\tserverClock: number\n\t\t\taction: 'discard' | 'commit' | { rebaseWithDiff: NetworkDiff<R> }\n\t  }\n\n/** @internal */\nexport interface TLPushRequest<R extends UnknownRecord> {\n\ttype: 'push'\n\tclientClock: number\n\tdiff?: NetworkDiff<R>\n\tpresence?: [typeof RecordOpType.Patch, ObjectDiff] | [typeof RecordOpType.Put, R]\n}\n\n/** @internal */\nexport interface TLConnectRequest {\n\ttype: 'connect'\n\tconnectRequestId: string\n\tlastServerClock: number\n\tprotocolVersion: number\n\tschema: SerializedSchema\n}\n\n/** @internal */\nexport interface TLPingRequest {\n\ttype: 'ping'\n}\n\n/** @internal */\nexport type TLSocketClientSentEvent<R extends UnknownRecord> =\n\t| TLPushRequest<R>\n\t| TLConnectRequest\n\t| TLPingRequest\n", "import { atom, Atom } from '@tldraw/state'\nimport { TLRecord } from '@tldraw/tlschema'\nimport { assert, warnOnce } from '@tldraw/utils'\nimport { chunk } from './chunk'\nimport { TLSocketClientSentEvent, TLSocketServerSentEvent } from './protocol'\nimport {\n\tTLPersistentClientSocket,\n\tTLPersistentClientSocketStatus,\n\tTLSocketStatusListener,\n\tTLSyncErrorCloseEventCode,\n\tTLSyncErrorCloseEventReason,\n} from './TLSyncClient'\n\nfunction listenTo<T extends EventTarget>(target: T, event: string, handler: () => void) {\n\ttarget.addEventListener(event, handler)\n\treturn () => {\n\t\ttarget.removeEventListener(event, handler)\n\t}\n}\n\nfunction debug(...args: any[]) {\n\t// @ts-ignore\n\tif (typeof window !== 'undefined' && window.__tldraw_socket_debug) {\n\t\tconst now = new Date()\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log(\n\t\t\t`${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}.${now.getMilliseconds()}`,\n\t\t\t...args\n\t\t\t//, new Error().stack\n\t\t)\n\t}\n}\n\n// NOTE: ClientWebSocketAdapter requires its users to implement their own connection loss\n//       detection, for example by regularly pinging the server and .restart()ing\n//       the connection when a number of pings goes unanswered. Without this mechanism,\n//       we might not be able to detect the websocket connection going down in a timely manner\n//       (it will probably time out on outgoing data packets at some point).\n//\n//       This is by design. While the Websocket protocol specifies protocol-level pings,\n//       they don't seem to be surfaced in browser APIs and can't be relied on. Therefore,\n//       pings need to be implemented one level up, on the application API side, which for our\n//       codebase means whatever code that uses ClientWebSocketAdapter.\n/** @internal */\nexport class ClientWebSocketAdapter implements TLPersistentClientSocket<TLRecord> {\n\t_ws: WebSocket | null = null\n\n\tisDisposed = false\n\n\t/** @internal */\n\treadonly _reconnectManager: ReconnectManager\n\n\t// TODO: .close should be a project-wide interface with a common contract (.close()d thing\n\t//       can only be garbage collected, and can't be used anymore)\n\tclose() {\n\t\tthis.isDisposed = true\n\t\tthis._reconnectManager.close()\n\t\t//  WebSocket.close() is idempotent\n\t\tthis._ws?.close()\n\t}\n\n\tconstructor(getUri: () => Promise<string> | string) {\n\t\tthis._reconnectManager = new ReconnectManager(this, getUri)\n\t}\n\n\tprivate _handleConnect() {\n\t\tdebug('handleConnect')\n\n\t\tthis._connectionStatus.set('online')\n\t\tthis.statusListeners.forEach((cb) => cb({ status: 'online' }))\n\n\t\tthis._reconnectManager.connected()\n\t}\n\n\tprivate _handleDisconnect(\n\t\treason: 'closed' | 'manual',\n\t\tcloseCode?: number,\n\t\tdidOpen?: boolean,\n\t\tcloseReason?: string\n\t) {\n\t\tcloseReason = closeReason || TLSyncErrorCloseEventReason.UNKNOWN_ERROR\n\n\t\tdebug('handleDisconnect', {\n\t\t\tcurrentStatus: this.connectionStatus,\n\t\t\tcloseCode,\n\t\t\treason,\n\t\t})\n\n\t\tlet newStatus: 'offline' | 'error'\n\t\tswitch (reason) {\n\t\t\tcase 'closed':\n\t\t\t\tif (closeCode === TLSyncErrorCloseEventCode) {\n\t\t\t\t\tnewStatus = 'error'\n\t\t\t\t} else {\n\t\t\t\t\tnewStatus = 'offline'\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase 'manual':\n\t\t\t\tnewStatus = 'offline'\n\t\t\t\tbreak\n\t\t}\n\n\t\tif (closeCode === 1006 && !didOpen) {\n\t\t\twarnOnce(\n\t\t\t\t\"Could not open WebSocket connection. This might be because you're trying to load a URL that doesn't support websockets. Check the URL you're trying to connect to.\"\n\t\t\t)\n\t\t}\n\n\t\tif (\n\t\t\t// it the status changed\n\t\t\tthis.connectionStatus !== newStatus &&\n\t\t\t// ignore errors if we're already in the offline state\n\t\t\t!(newStatus === 'error' && this.connectionStatus === 'offline')\n\t\t) {\n\t\t\tthis._connectionStatus.set(newStatus)\n\t\t\tthis.statusListeners.forEach((cb) =>\n\t\t\t\tcb(newStatus === 'error' ? { status: 'error', reason: closeReason } : { status: newStatus })\n\t\t\t)\n\t\t}\n\n\t\tthis._reconnectManager.disconnected()\n\t}\n\n\t_setNewSocket(ws: WebSocket) {\n\t\tassert(!this.isDisposed, 'Tried to set a new websocket on a disposed socket')\n\t\tassert(\n\t\t\tthis._ws === null ||\n\t\t\t\tthis._ws.readyState === WebSocket.CLOSED ||\n\t\t\t\tthis._ws.readyState === WebSocket.CLOSING,\n\t\t\t`Tried to set a new websocket in when the existing one was ${this._ws?.readyState}`\n\t\t)\n\n\t\tlet didOpen = false\n\n\t\t// NOTE: Sockets can stay for quite a while in the CLOSING state. This is because the transition\n\t\t//       between CLOSING and CLOSED happens either after the closing handshake, or after a\n\t\t//       timeout, but in either case those sockets don't need any special handling, the browser\n\t\t//       will close them eventually. We just \"orphan\" such sockets and ignore their onclose/onerror.\n\t\tws.onopen = () => {\n\t\t\tdebug('ws.onopen')\n\t\t\tassert(\n\t\t\t\tthis._ws === ws,\n\t\t\t\t\"sockets must only be orphaned when they are CLOSING or CLOSED, so they can't open\"\n\t\t\t)\n\t\t\tdidOpen = true\n\t\t\tthis._handleConnect()\n\t\t}\n\t\tws.onclose = (event: CloseEvent) => {\n\t\t\tdebug('ws.onclose', event)\n\t\t\tif (this._ws === ws) {\n\t\t\t\tthis._handleDisconnect('closed', event.code, didOpen, event.reason)\n\t\t\t} else {\n\t\t\t\tdebug('ignoring onclose for an orphaned socket')\n\t\t\t}\n\t\t}\n\t\tws.onerror = (event) => {\n\t\t\tdebug('ws.onerror', event)\n\t\t\tif (this._ws === ws) {\n\t\t\t\tthis._handleDisconnect('closed')\n\t\t\t} else {\n\t\t\t\tdebug('ignoring onerror for an orphaned socket')\n\t\t\t}\n\t\t}\n\t\tws.onmessage = (ev) => {\n\t\t\tassert(\n\t\t\t\tthis._ws === ws,\n\t\t\t\t\"sockets must only be orphaned when they are CLOSING or CLOSED, so they can't receive messages\"\n\t\t\t)\n\t\t\tconst parsed = JSON.parse(ev.data.toString())\n\t\t\tthis.messageListeners.forEach((cb) => cb(parsed))\n\t\t}\n\n\t\tthis._ws = ws\n\t}\n\n\t_closeSocket() {\n\t\tif (this._ws === null) return\n\n\t\tthis._ws.close()\n\t\t// explicitly orphan the socket to ignore its onclose/onerror, because onclose can be delayed\n\t\tthis._ws = null\n\t\tthis._handleDisconnect('manual')\n\t}\n\n\t// TLPersistentClientSocket stuff\n\n\t_connectionStatus: Atom<TLPersistentClientSocketStatus | 'initial'> = atom(\n\t\t'websocket connection status',\n\t\t'initial'\n\t)\n\n\t// eslint-disable-next-line no-restricted-syntax\n\tget connectionStatus(): TLPersistentClientSocketStatus {\n\t\tconst status = this._connectionStatus.get()\n\t\treturn status === 'initial' ? 'offline' : status\n\t}\n\n\tsendMessage(msg: TLSocketClientSentEvent<TLRecord>) {\n\t\tassert(!this.isDisposed, 'Tried to send message on a disposed socket')\n\n\t\tif (!this._ws) return\n\t\tif (this.connectionStatus === 'online') {\n\t\t\tconst chunks = chunk(JSON.stringify(msg))\n\t\t\tfor (const part of chunks) {\n\t\t\t\tthis._ws.send(part)\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn('Tried to send message while ' + this.connectionStatus)\n\t\t}\n\t}\n\n\tprivate messageListeners = new Set<(msg: TLSocketServerSentEvent<TLRecord>) => void>()\n\tonReceiveMessage(cb: (val: TLSocketServerSentEvent<TLRecord>) => void) {\n\t\tassert(!this.isDisposed, 'Tried to add message listener on a disposed socket')\n\n\t\tthis.messageListeners.add(cb)\n\t\treturn () => {\n\t\t\tthis.messageListeners.delete(cb)\n\t\t}\n\t}\n\n\tprivate statusListeners = new Set<TLSocketStatusListener>()\n\tonStatusChange(cb: TLSocketStatusListener) {\n\t\tassert(!this.isDisposed, 'Tried to add status listener on a disposed socket')\n\n\t\tthis.statusListeners.add(cb)\n\t\treturn () => {\n\t\t\tthis.statusListeners.delete(cb)\n\t\t}\n\t}\n\n\trestart() {\n\t\tassert(!this.isDisposed, 'Tried to restart a disposed socket')\n\t\tdebug('restarting')\n\n\t\tthis._closeSocket()\n\t\tthis._reconnectManager.maybeReconnected()\n\t}\n}\n\n// Those constants are exported primarily for tests\n// ACTIVE_ means the tab is active, document.hidden is false\nexport const ACTIVE_MIN_DELAY = 500\nexport const ACTIVE_MAX_DELAY = 2000\n// Correspondingly, here document.hidden is true. It's intended to reduce the load and battery drain\n// on client devices somewhat when they aren't looking at the tab. We don't disconnect completely\n// to minimise issues with reconnection/sync when the tab becomes visible again\nexport const INACTIVE_MIN_DELAY = 1000\nexport const INACTIVE_MAX_DELAY = 1000 * 60 * 5\nexport const DELAY_EXPONENT = 1.5\n// this is a tradeoff between quickly detecting connections stuck in the CONNECTING state and\n// not needlessly reconnecting if the connection is just slow to establish\nexport const ATTEMPT_TIMEOUT = 1000\n\n/** @internal */\nexport class ReconnectManager {\n\tprivate isDisposed = false\n\tprivate disposables: (() => void)[] = [\n\t\t() => {\n\t\t\tif (this.reconnectTimeout) clearTimeout(this.reconnectTimeout)\n\t\t\tif (this.recheckConnectingTimeout) clearTimeout(this.recheckConnectingTimeout)\n\t\t},\n\t]\n\tprivate reconnectTimeout: ReturnType<typeof setTimeout> | null = null\n\tprivate recheckConnectingTimeout: ReturnType<typeof setTimeout> | null = null\n\n\tprivate lastAttemptStart: number | null = null\n\tintendedDelay: number = ACTIVE_MIN_DELAY\n\tprivate state: 'pendingAttempt' | 'pendingAttemptResult' | 'delay' | 'connected'\n\n\tconstructor(\n\t\tprivate socketAdapter: ClientWebSocketAdapter,\n\t\tprivate getUri: () => Promise<string> | string\n\t) {\n\t\tthis.subscribeToReconnectHints()\n\n\t\tthis.disposables.push(\n\t\t\tlistenTo(window, 'offline', () => {\n\t\t\t\tdebug('window went offline')\n\t\t\t\t// On the one hand, 'offline' event is not really reliable; on the other, the only\n\t\t\t\t// alternative is to wait for pings not being delivered, which takes more than 20 seconds,\n\t\t\t\t// which means we won't see the ClientWebSocketAdapter status change for more than\n\t\t\t\t// 20 seconds after the tab goes offline. Our application layer must be resistent to\n\t\t\t\t// connection restart anyway, so we can just try to reconnect and see if\n\t\t\t\t// we're truly offline.\n\t\t\t\tthis.socketAdapter._closeSocket()\n\t\t\t})\n\t\t)\n\n\t\tthis.state = 'pendingAttempt'\n\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\tthis.scheduleAttempt()\n\t}\n\n\tprivate subscribeToReconnectHints() {\n\t\tthis.disposables.push(\n\t\t\tlistenTo(window, 'online', () => {\n\t\t\t\tdebug('window went online')\n\t\t\t\tthis.maybeReconnected()\n\t\t\t}),\n\t\t\tlistenTo(document, 'visibilitychange', () => {\n\t\t\t\tif (!document.hidden) {\n\t\t\t\t\tdebug('document became visible')\n\t\t\t\t\tthis.maybeReconnected()\n\t\t\t\t}\n\t\t\t})\n\t\t)\n\n\t\tif (Object.prototype.hasOwnProperty.call(navigator, 'connection')) {\n\t\t\tconst connection = (navigator as any)['connection'] as EventTarget\n\t\t\tthis.disposables.push(\n\t\t\t\tlistenTo(connection, 'change', () => {\n\t\t\t\t\tdebug('navigator.connection change')\n\t\t\t\t\tthis.maybeReconnected()\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\t}\n\n\tprivate scheduleAttempt() {\n\t\tassert(this.state === 'pendingAttempt')\n\t\tdebug('scheduling a connection attempt')\n\t\tPromise.resolve(this.getUri()).then((uri) => {\n\t\t\t// this can happen if the promise gets resolved too late\n\t\t\tif (this.state !== 'pendingAttempt' || this.isDisposed) return\n\t\t\tassert(\n\t\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.OPEN,\n\t\t\t\t'There should be no connection attempts while already connected'\n\t\t\t)\n\n\t\t\tthis.lastAttemptStart = Date.now()\n\t\t\tthis.socketAdapter._setNewSocket(new WebSocket(httpToWs(uri)))\n\t\t\tthis.state = 'pendingAttemptResult'\n\t\t})\n\t}\n\n\tprivate getMaxDelay() {\n\t\treturn document.hidden ? INACTIVE_MAX_DELAY : ACTIVE_MAX_DELAY\n\t}\n\n\tprivate getMinDelay() {\n\t\treturn document.hidden ? INACTIVE_MIN_DELAY : ACTIVE_MIN_DELAY\n\t}\n\n\tprivate clearReconnectTimeout() {\n\t\tif (this.reconnectTimeout) {\n\t\t\tclearTimeout(this.reconnectTimeout)\n\t\t\tthis.reconnectTimeout = null\n\t\t}\n\t}\n\n\tprivate clearRecheckConnectingTimeout() {\n\t\tif (this.recheckConnectingTimeout) {\n\t\t\tclearTimeout(this.recheckConnectingTimeout)\n\t\t\tthis.recheckConnectingTimeout = null\n\t\t}\n\t}\n\n\tmaybeReconnected() {\n\t\tdebug('ReconnectManager.maybeReconnected')\n\t\t// It doesn't make sense to have another check scheduled if we're already checking it now.\n\t\t// If we have a CONNECTING check scheduled and relevant, it'll be recreated below anyway\n\t\tthis.clearRecheckConnectingTimeout()\n\n\t\t// readyState can be CONNECTING, OPEN, CLOSING, CLOSED, or null (if getUri() is still pending)\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.OPEN) {\n\t\t\tdebug('ReconnectManager.maybeReconnected: already connected')\n\t\t\t// nothing to do, we're already OK\n\t\t\treturn\n\t\t}\n\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.CONNECTING) {\n\t\t\tdebug('ReconnectManager.maybeReconnected: connecting')\n\t\t\t// We might be waiting for a TCP connection that sent SYN out and will never get it back,\n\t\t\t// while a new connection appeared. On the other hand, we might have just started connecting\n\t\t\t// and will succeed in a bit. Thus, we're checking how old the attempt is and retry anew\n\t\t\t// if it's old enough. This by itself can delay the connection a bit, but shouldn't prevent\n\t\t\t// new connections as long as `maybeReconnected` is not looped itself\n\t\t\tassert(\n\t\t\t\tthis.lastAttemptStart,\n\t\t\t\t'ReadyState=CONNECTING without lastAttemptStart should be impossible'\n\t\t\t)\n\t\t\tconst sinceLastStart = Date.now() - this.lastAttemptStart\n\t\t\tif (sinceLastStart < ATTEMPT_TIMEOUT) {\n\t\t\t\tdebug('ReconnectManager.maybeReconnected: connecting, rechecking later')\n\t\t\t\tthis.recheckConnectingTimeout = setTimeout(\n\t\t\t\t\t() => this.maybeReconnected(),\n\t\t\t\t\tATTEMPT_TIMEOUT - sinceLastStart\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tdebug('ReconnectManager.maybeReconnected: connecting, but for too long, retry now')\n\t\t\t\t// Last connection attempt was started a while ago, it's possible that network conditions\n\t\t\t\t// changed, and it's worth retrying to connect. `disconnected` will handle reconnection\n\t\t\t\t//\n\t\t\t\t// NOTE: The danger here is looping in connection attemps if connections are slow.\n\t\t\t\t//       Make sure that `maybeReconnected` is not called in the `disconnected` codepath!\n\t\t\t\tthis.clearRecheckConnectingTimeout()\n\t\t\t\tthis.socketAdapter._closeSocket()\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tdebug('ReconnectManager.maybeReconnected: closing/closed/null, retry now')\n\t\t// readyState is CLOSING or CLOSED, or the websocket is null\n\t\t// Restart the backoff and retry ASAP (honouring the min delay)\n\t\t// this.state doesn't really matter, because disconnected() will handle any state correctly\n\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\tthis.disconnected()\n\t}\n\n\tdisconnected() {\n\t\tdebug('ReconnectManager.disconnected')\n\t\t// This either means we're freshly disconnected, or the last connection attempt failed;\n\t\t// either way, time to try again.\n\n\t\t// Guard against delayed notifications and recheck synchronously\n\t\tif (\n\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.OPEN &&\n\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.CONNECTING\n\t\t) {\n\t\t\tdebug('ReconnectManager.disconnected: websocket is not OPEN or CONNECTING')\n\t\t\tthis.clearReconnectTimeout()\n\n\t\t\tlet delayLeft\n\t\t\tif (this.state === 'connected') {\n\t\t\t\t// it's the first sign that we got disconnected; the state will be updated below,\n\t\t\t\t// just set the appropriate delay for now\n\t\t\t\tthis.intendedDelay = this.getMinDelay()\n\t\t\t\tdelayLeft = this.intendedDelay\n\t\t\t} else {\n\t\t\t\tdelayLeft =\n\t\t\t\t\tthis.lastAttemptStart !== null\n\t\t\t\t\t\t? this.lastAttemptStart + this.intendedDelay - Date.now()\n\t\t\t\t\t\t: 0\n\t\t\t}\n\n\t\t\tif (delayLeft > 0) {\n\t\t\t\tdebug('ReconnectManager.disconnected: delaying, delayLeft', delayLeft)\n\t\t\t\t// try again later\n\t\t\t\tthis.state = 'delay'\n\n\t\t\t\tthis.reconnectTimeout = setTimeout(() => this.disconnected(), delayLeft)\n\t\t\t} else {\n\t\t\t\t// not connected and not delayed, time to retry\n\t\t\t\tthis.state = 'pendingAttempt'\n\n\t\t\t\tthis.intendedDelay = Math.min(\n\t\t\t\t\tthis.getMaxDelay(),\n\t\t\t\t\tMath.max(this.getMinDelay(), this.intendedDelay) * DELAY_EXPONENT\n\t\t\t\t)\n\t\t\t\tdebug(\n\t\t\t\t\t'ReconnectManager.disconnected: attempting a connection, next delay',\n\t\t\t\t\tthis.intendedDelay\n\t\t\t\t)\n\t\t\t\tthis.scheduleAttempt()\n\t\t\t}\n\t\t}\n\t}\n\n\tconnected() {\n\t\tdebug('ReconnectManager.connected')\n\t\t// this notification could've been delayed, recheck synchronously\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.OPEN) {\n\t\t\tdebug('ReconnectManager.connected: websocket is OPEN')\n\t\t\tthis.state = 'connected'\n\t\t\tthis.clearReconnectTimeout()\n\t\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\t}\n\t}\n\n\tclose() {\n\t\tthis.disposables.forEach((d) => d())\n\t\tthis.isDisposed = true\n\t}\n}\n\nfunction httpToWs(url: string) {\n\treturn url.replace(/^http(s)?:/, 'ws$1:')\n}\n", "import { SerializedSchema, UnknownRecord } from '@tldraw/store'\nimport { TLRoomSocket } from './TLSyncRoom'\nimport { TLSocketServerSentDataEvent } from './protocol'\n\n/** @internal */\nexport const RoomSessionState = {\n\tAwaitingConnectMessage: 'awaiting-connect-message',\n\tAwaitingRemoval: 'awaiting-removal',\n\tConnected: 'connected',\n} as const\n\n/** @internal */\nexport type RoomSessionState = (typeof RoomSessionState)[keyof typeof RoomSessionState]\n\nexport const SESSION_START_WAIT_TIME = 10000\nexport const SESSION_REMOVAL_WAIT_TIME = 5000\nexport const SESSION_IDLE_TIMEOUT = 20000\n\n/** @internal */\nexport type RoomSession<R extends UnknownRecord, Meta> =\n\t| {\n\t\t\tstate: typeof RoomSessionState.AwaitingConnectMessage\n\t\t\tsessionId: string\n\t\t\tpresenceId: string | null\n\t\t\tsocket: TLRoomSocket<R>\n\t\t\tsessionStartTime: number\n\t\t\tmeta: Meta\n\t\t\tisReadonly: boolean\n\t\t\trequiresLegacyRejection: boolean\n\t  }\n\t| {\n\t\t\tstate: typeof RoomSessionState.AwaitingRemoval\n\t\t\tsessionId: string\n\t\t\tpresenceId: string | null\n\t\t\tsocket: TLRoomSocket<R>\n\t\t\tcancellationTime: number\n\t\t\tmeta: Meta\n\t\t\tisReadonly: boolean\n\t\t\trequiresLegacyRejection: boolean\n\t  }\n\t| {\n\t\t\tstate: typeof RoomSessionState.Connected\n\t\t\tsessionId: string\n\t\t\tpresenceId: string | null\n\t\t\tsocket: TLRoomSocket<R>\n\t\t\tserializedSchema: SerializedSchema\n\t\t\tlastInteractionTime: number\n\t\t\tdebounceTimer: ReturnType<typeof setTimeout> | null\n\t\t\toutstandingDataMessages: TLSocketServerSentDataEvent<R>[]\n\t\t\tmeta: Meta\n\t\t\tisReadonly: boolean\n\t\t\trequiresLegacyRejection: boolean\n\t  }\n", "import { TLSyncErrorCloseEventReason } from './TLSyncClient'\n\n/** @public */\nexport class TLRemoteSyncError extends Error {\n\toverride name = 'RemoteSyncError'\n\tconstructor(public readonly reason: TLSyncErrorCloseEventReason | string) {\n\t\tsuper(`sync error: ${reason}`)\n\t}\n}\n", "import { UnknownRecord } from '@tldraw/store'\nimport { TLRoomSocket } from './TLSyncRoom'\nimport { TLSocketServerSentEvent } from './protocol'\n\n/**\n * Minimal server-side WebSocket interface that is compatible with\n *\n * - The standard WebSocket interface (cloudflare, deno, some node setups)\n * - The 'ws' WebSocket interface (some node setups)\n * - The Bun.serve socket implementation\n *\n * @public\n */\nexport interface WebSocketMinimal {\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\taddEventListener?: (type: 'message' | 'close' | 'error', listener: (event: any) => void) => void\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tremoveEventListener?: (\n\t\ttype: 'message' | 'close' | 'error',\n\t\tlistener: (event: any) => void\n\t) => void\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tsend: (data: string) => void\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tclose: (code?: number, reason?: string) => void\n\treadyState: number\n}\n\n/** @internal */\nexport interface ServerSocketAdapterOptions<R extends UnknownRecord> {\n\treadonly ws: WebSocketMinimal\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\treadonly onBeforeSendMessage?: (msg: TLSocketServerSentEvent<R>, stringified: string) => void\n}\n\n/** @internal */\nexport class ServerSocketAdapter<R extends UnknownRecord> implements TLRoomSocket<R> {\n\tconstructor(public readonly opts: ServerSocketAdapterOptions<R>) {}\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isOpen(): boolean {\n\t\treturn this.opts.ws.readyState === 1 // ready state open\n\t}\n\t// see TLRoomSocket for details on why this accepts a union and not just arrays\n\tsendMessage(msg: TLSocketServerSentEvent<R>) {\n\t\tconst message = JSON.stringify(msg)\n\t\tthis.opts.onBeforeSendMessage?.(msg, message)\n\t\tthis.opts.ws.send(message)\n\t}\n\tclose(code?: number, reason?: string) {\n\t\tthis.opts.ws.close(code, reason)\n\t}\n}\n", "import { Atom, atom, transaction } from '@tldraw/state'\nimport {\n\tIdOf,\n\tMigrationFailureReason,\n\tRecordType,\n\tSerializedSchema,\n\tStoreSchema,\n\tUnknownRecord,\n} from '@tldraw/store'\nimport { DocumentRecordType, PageRecordType, TLDOCUMENT_ID } from '@tldraw/tlschema'\nimport {\n\tIndexKey,\n\tResult,\n\tassert,\n\tassertExists,\n\texhaustiveSwitchError,\n\tgetOwnProperty,\n\thasOwnProperty,\n\tisNativeStructuredClone,\n\tobjectMapEntries,\n\tobjectMapKeys,\n\tstructuredClone,\n} from '@tldraw/utils'\nimport isEqual from 'lodash.isequal'\nimport { createNanoEvents } from 'nanoevents'\nimport {\n\tRoomSession,\n\tRoomSessionState,\n\tSESSION_IDLE_TIMEOUT,\n\tSESSION_REMOVAL_WAIT_TIME,\n\tSESSION_START_WAIT_TIME,\n} from './RoomSession'\nimport { TLSyncLog } from './TLSocketRoom'\nimport { TLSyncErrorCloseEventCode, TLSyncErrorCloseEventReason } from './TLSyncClient'\nimport {\n\tNetworkDiff,\n\tObjectDiff,\n\tRecordOp,\n\tRecordOpType,\n\tValueOpType,\n\tapplyObjectDiff,\n\tdiffRecord,\n} from './diff'\nimport { interval } from './interval'\nimport {\n\tTLIncompatibilityReason,\n\tTLSocketClientSentEvent,\n\tTLSocketServerSentDataEvent,\n\tTLSocketServerSentEvent,\n\tgetTlsyncProtocolVersion,\n} from './protocol'\n\n/** @internal */\nexport interface TLRoomSocket<R extends UnknownRecord> {\n\tisOpen: boolean\n\tsendMessage(msg: TLSocketServerSentEvent<R>): void\n\tclose(code?: number, reason?: string): void\n}\n\n// the max number of tombstones to keep in the store\nexport const MAX_TOMBSTONES = 3000\n// the number of tombstones to delete when the max is reached\nexport const TOMBSTONE_PRUNE_BUFFER_SIZE = 300\n// the minimum time between data-related messages to the clients\nexport const DATA_MESSAGE_DEBOUNCE_INTERVAL = 1000 / 60\n\nconst timeSince = (time: number) => Date.now() - time\n\n/** @internal */\nexport class DocumentState<R extends UnknownRecord> {\n\t_atom: Atom<{ state: R; lastChangedClock: number }>\n\n\tstatic createWithoutValidating<R extends UnknownRecord>(\n\t\tstate: R,\n\t\tlastChangedClock: number,\n\t\trecordType: RecordType<R, any>\n\t): DocumentState<R> {\n\t\treturn new DocumentState(state, lastChangedClock, recordType)\n\t}\n\n\tstatic createAndValidate<R extends UnknownRecord>(\n\t\tstate: R,\n\t\tlastChangedClock: number,\n\t\trecordType: RecordType<R, any>\n\t): Result<DocumentState<R>, Error> {\n\t\ttry {\n\t\t\trecordType.validate(state)\n\t\t} catch (error: any) {\n\t\t\treturn Result.err(error)\n\t\t}\n\t\treturn Result.ok(new DocumentState(state, lastChangedClock, recordType))\n\t}\n\n\tprivate constructor(\n\t\tstate: R,\n\t\tlastChangedClock: number,\n\t\tprivate readonly recordType: RecordType<R, any>\n\t) {\n\t\tthis._atom = atom('document:' + state.id, { state, lastChangedClock })\n\t}\n\t// eslint-disable-next-line no-restricted-syntax\n\tget state() {\n\t\treturn this._atom.get().state\n\t}\n\t// eslint-disable-next-line no-restricted-syntax\n\tget lastChangedClock() {\n\t\treturn this._atom.get().lastChangedClock\n\t}\n\treplaceState(state: R, clock: number): Result<ObjectDiff | null, Error> {\n\t\tconst diff = diffRecord(this.state, state)\n\t\tif (!diff) return Result.ok(null)\n\t\ttry {\n\t\t\tthis.recordType.validate(state)\n\t\t} catch (error: any) {\n\t\t\treturn Result.err(error)\n\t\t}\n\t\tthis._atom.set({ state, lastChangedClock: clock })\n\t\treturn Result.ok(diff)\n\t}\n\tmergeDiff(diff: ObjectDiff, clock: number): Result<ObjectDiff | null, Error> {\n\t\tconst newState = applyObjectDiff(this.state, diff)\n\t\treturn this.replaceState(newState, clock)\n\t}\n}\n\n/** @public */\nexport interface RoomSnapshot {\n\tclock: number\n\tdocuments: Array<{ state: UnknownRecord; lastChangedClock: number }>\n\ttombstones?: Record<string, number>\n\tschema?: SerializedSchema\n}\n\n/**\n * A room is a workspace for a group of clients. It allows clients to collaborate on documents\n * within that workspace.\n *\n * @internal\n */\nexport class TLSyncRoom<R extends UnknownRecord, SessionMeta> {\n\t// A table of connected clients\n\treadonly sessions = new Map<string, RoomSession<R, SessionMeta>>()\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\tpruneSessions = () => {\n\t\tfor (const client of this.sessions.values()) {\n\t\t\tswitch (client.state) {\n\t\t\t\tcase RoomSessionState.Connected: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.lastInteractionTime) > SESSION_IDLE_TIMEOUT\n\t\t\t\t\tif (hasTimedOut || !client.socket.isOpen) {\n\t\t\t\t\t\tthis.cancelSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase RoomSessionState.AwaitingConnectMessage: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.sessionStartTime) > SESSION_START_WAIT_TIME\n\t\t\t\t\tif (hasTimedOut || !client.socket.isOpen) {\n\t\t\t\t\t\t// remove immediately\n\t\t\t\t\t\tthis.removeSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase RoomSessionState.AwaitingRemoval: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.cancellationTime) > SESSION_REMOVAL_WAIT_TIME\n\t\t\t\t\tif (hasTimedOut) {\n\t\t\t\t\t\tthis.removeSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\texhaustiveSwitchError(client)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate disposables: Array<() => void> = [interval(this.pruneSessions, 2000)]\n\n\tprivate _isClosed = false\n\n\tclose() {\n\t\tthis.disposables.forEach((d) => d())\n\t\tthis.sessions.forEach((session) => {\n\t\t\tsession.socket.close()\n\t\t})\n\t\tthis._isClosed = true\n\t}\n\n\tisClosed() {\n\t\treturn this._isClosed\n\t}\n\n\treadonly events = createNanoEvents<{\n\t\troom_became_empty(): void\n\t\tsession_removed(args: { sessionId: string; meta: SessionMeta }): void\n\t}>()\n\n\t// Values associated with each uid (must be serializable).\n\t/** @internal */\n\tstate = atom<{\n\t\tdocuments: Record<string, DocumentState<R>>\n\t\ttombstones: Record<string, number>\n\t}>('room state', {\n\t\tdocuments: {},\n\t\ttombstones: {},\n\t})\n\n\t// this clock should start higher than the client, to make sure that clients who sync with their\n\t// initial lastServerClock value get the full state\n\t// in this case clients will start with 0, and the server will start with 1\n\tclock = 1\n\tdocumentClock = 1\n\ttombstoneHistoryStartsAtClock = this.clock\n\t// map from record id to clock upon deletion\n\n\treadonly serializedSchema: SerializedSchema\n\n\treadonly documentTypes: Set<string>\n\treadonly presenceType: RecordType<R, any> | null\n\tprivate log?: TLSyncLog\n\tpublic readonly schema: StoreSchema<R, any>\n\tprivate onDataChange?(): void\n\tprivate onPresenceChange?(): void\n\n\tconstructor(opts: {\n\t\tlog?: TLSyncLog\n\t\tschema: StoreSchema<R, any>\n\t\tsnapshot?: RoomSnapshot\n\t\tonDataChange?(): void\n\t\tonPresenceChange?(): void\n\t}) {\n\t\tthis.schema = opts.schema\n\t\tlet snapshot = opts.snapshot\n\t\tthis.log = opts.log\n\t\tthis.onDataChange = opts.onDataChange\n\t\tthis.onPresenceChange = opts.onPresenceChange\n\n\t\tassert(\n\t\t\tisNativeStructuredClone,\n\t\t\t'TLSyncRoom is supposed to run either on Cloudflare Workers' +\n\t\t\t\t'or on a 18+ version of Node.js, which both support the native structuredClone API'\n\t\t)\n\n\t\t// do a json serialization cycle to make sure the schema has no 'undefined' values\n\t\tthis.serializedSchema = JSON.parse(JSON.stringify(this.schema.serialize()))\n\n\t\tthis.documentTypes = new Set(\n\t\t\tObject.values<RecordType<R, any>>(this.schema.types)\n\t\t\t\t.filter((t) => t.scope === 'document')\n\t\t\t\t.map((t) => t.typeName)\n\t\t)\n\n\t\tconst presenceTypes = new Set(\n\t\t\tObject.values<RecordType<R, any>>(this.schema.types).filter((t) => t.scope === 'presence')\n\t\t)\n\n\t\tif (presenceTypes.size > 1) {\n\t\t\tthrow new Error(\n\t\t\t\t`TLSyncRoom: exactly zero or one presence type is expected, but found ${presenceTypes.size}`\n\t\t\t)\n\t\t}\n\n\t\tthis.presenceType = presenceTypes.values().next()?.value ?? null\n\n\t\tif (!snapshot) {\n\t\t\tsnapshot = {\n\t\t\t\tclock: 0,\n\t\t\t\tdocuments: [\n\t\t\t\t\t{\n\t\t\t\t\t\tstate: DocumentRecordType.create({ id: TLDOCUMENT_ID }),\n\t\t\t\t\t\tlastChangedClock: 0,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tstate: PageRecordType.create({ name: 'Page 1', index: 'a1' as IndexKey }),\n\t\t\t\t\t\tlastChangedClock: 0,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t}\n\t\t}\n\n\t\tthis.clock = snapshot.clock\n\t\tlet didIncrementClock = false\n\t\tconst ensureClockDidIncrement = (_reason: string) => {\n\t\t\tif (!didIncrementClock) {\n\t\t\t\tdidIncrementClock = true\n\t\t\t\tthis.clock++\n\t\t\t}\n\t\t}\n\n\t\tconst tombstones = { ...snapshot.tombstones }\n\t\tconst filteredDocuments = []\n\t\tfor (const doc of snapshot.documents) {\n\t\t\tif (this.documentTypes.has(doc.state.typeName)) {\n\t\t\t\tfilteredDocuments.push(doc)\n\t\t\t} else {\n\t\t\t\tensureClockDidIncrement('doc type was not doc type')\n\t\t\t\ttombstones[doc.state.id] = this.clock\n\t\t\t}\n\t\t}\n\n\t\tconst documents: Record<string, DocumentState<R>> = Object.fromEntries(\n\t\t\tfilteredDocuments.map((r) => [\n\t\t\t\tr.state.id,\n\t\t\t\tDocumentState.createWithoutValidating<R>(\n\t\t\t\t\tr.state as R,\n\t\t\t\t\tr.lastChangedClock,\n\t\t\t\t\tassertExists(getOwnProperty(this.schema.types, r.state.typeName))\n\t\t\t\t),\n\t\t\t])\n\t\t)\n\n\t\tconst migrationResult = this.schema.migrateStoreSnapshot({\n\t\t\tstore: Object.fromEntries(\n\t\t\t\tobjectMapEntries(documents).map(([id, { state }]) => [id, state as R])\n\t\t\t) as Record<IdOf<R>, R>,\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\tschema: snapshot.schema ?? this.schema.serializeEarliestVersion(),\n\t\t})\n\n\t\tif (migrationResult.type === 'error') {\n\t\t\t// TODO: Fault tolerance\n\t\t\tthrow new Error('Failed to migrate: ' + migrationResult.reason)\n\t\t}\n\n\t\tfor (const [id, r] of objectMapEntries(migrationResult.value)) {\n\t\t\tconst existing = documents[id]\n\t\t\tif (!existing) {\n\t\t\t\t// record was added during migration\n\t\t\t\tensureClockDidIncrement('record was added during migration')\n\t\t\t\tdocuments[id] = DocumentState.createWithoutValidating(\n\t\t\t\t\tr,\n\t\t\t\t\tthis.clock,\n\t\t\t\t\tassertExists(getOwnProperty(this.schema.types, r.typeName)) as any\n\t\t\t\t)\n\t\t\t} else if (!isEqual(existing.state, r)) {\n\t\t\t\t// record was maybe updated during migration\n\t\t\t\tensureClockDidIncrement('record was maybe updated during migration')\n\t\t\t\texisting.replaceState(r, this.clock)\n\t\t\t}\n\t\t}\n\n\t\tfor (const id of objectMapKeys(documents)) {\n\t\t\tif (!migrationResult.value[id as keyof typeof migrationResult.value]) {\n\t\t\t\t// record was removed during migration\n\t\t\t\tensureClockDidIncrement('record was removed during migration')\n\t\t\t\ttombstones[id] = this.clock\n\t\t\t\tdelete documents[id]\n\t\t\t}\n\t\t}\n\n\t\tthis.state.set({ documents, tombstones })\n\n\t\tthis.pruneTombstones()\n\t\tthis.documentClock = this.clock\n\t\tif (didIncrementClock) {\n\t\t\topts.onDataChange?.()\n\t\t}\n\t}\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\tprivate pruneTombstones = () => {\n\t\t// avoid blocking any pending responses\n\t\tthis.state.update(({ tombstones, documents }) => {\n\t\t\tconst entries = Object.entries(this.state.get().tombstones)\n\t\t\tif (entries.length > MAX_TOMBSTONES) {\n\t\t\t\t// sort entries in ascending order by clock\n\t\t\t\tentries.sort((a, b) => a[1] - b[1])\n\t\t\t\t// trim off the first bunch\n\t\t\t\tconst excessQuantity = entries.length - MAX_TOMBSTONES\n\t\t\t\ttombstones = Object.fromEntries(entries.slice(excessQuantity + TOMBSTONE_PRUNE_BUFFER_SIZE))\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tdocuments,\n\t\t\t\ttombstones,\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate getDocument(id: string) {\n\t\treturn this.state.get().documents[id]\n\t}\n\n\tprivate addDocument(id: string, state: R, clock: number): Result<void, Error> {\n\t\tlet { documents, tombstones } = this.state.get()\n\t\tif (hasOwnProperty(tombstones, id)) {\n\t\t\ttombstones = { ...tombstones }\n\t\t\tdelete tombstones[id]\n\t\t}\n\t\tconst createResult = DocumentState.createAndValidate(\n\t\t\tstate,\n\t\t\tclock,\n\t\t\tassertExists(getOwnProperty(this.schema.types, state.typeName))\n\t\t)\n\t\tif (!createResult.ok) return createResult\n\t\tdocuments = { ...documents, [id]: createResult.value }\n\t\tthis.state.set({ documents, tombstones })\n\t\treturn Result.ok(undefined)\n\t}\n\n\tprivate removeDocument(id: string, clock: number) {\n\t\tthis.state.update(({ documents, tombstones }) => {\n\t\t\tdocuments = { ...documents }\n\t\t\tdelete documents[id]\n\t\t\ttombstones = { ...tombstones, [id]: clock }\n\t\t\treturn { documents, tombstones }\n\t\t})\n\t}\n\n\tgetSnapshot(): RoomSnapshot {\n\t\tconst { documents, tombstones } = this.state.get()\n\t\treturn {\n\t\t\tclock: this.clock,\n\t\t\ttombstones,\n\t\t\tschema: this.serializedSchema,\n\t\t\tdocuments: Object.values(documents)\n\t\t\t\t.filter((d) => this.documentTypes.has(d.state.typeName))\n\t\t\t\t.map((doc) => ({\n\t\t\t\t\tstate: doc.state,\n\t\t\t\t\tlastChangedClock: doc.lastChangedClock,\n\t\t\t\t})),\n\t\t}\n\t}\n\n\t/**\n\t * Send a message to a particular client. Debounces data events\n\t *\n\t * @param sessionId - The id of the session to send the message to.\n\t * @param message - The message to send.\n\t */\n\tprivate sendMessage(\n\t\tsessionId: string,\n\t\tmessage: TLSocketServerSentEvent<R> | TLSocketServerSentDataEvent<R>\n\t) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Tried to send message to unknown session', message.type)\n\t\t\treturn\n\t\t}\n\t\tif (session.state !== RoomSessionState.Connected) {\n\t\t\tthis.log?.warn?.('Tried to send message to disconnected client', message.type)\n\t\t\treturn\n\t\t}\n\t\tif (session.socket.isOpen) {\n\t\t\tif (message.type !== 'patch' && message.type !== 'push_result') {\n\t\t\t\t// this is not a data message\n\t\t\t\tif (message.type !== 'pong') {\n\t\t\t\t\t// non-data messages like \"connect\" might still need to be ordered correctly with\n\t\t\t\t\t// respect to data messages, so it's better to flush just in case\n\t\t\t\t\tthis._flushDataMessages(sessionId)\n\t\t\t\t}\n\t\t\t\tsession.socket.sendMessage(message)\n\t\t\t} else {\n\t\t\t\tif (session.debounceTimer === null) {\n\t\t\t\t\t// this is the first message since the last flush, don't delay it\n\t\t\t\t\tsession.socket.sendMessage({ type: 'data', data: [message] })\n\n\t\t\t\t\tsession.debounceTimer = setTimeout(\n\t\t\t\t\t\t() => this._flushDataMessages(sessionId),\n\t\t\t\t\t\tDATA_MESSAGE_DEBOUNCE_INTERVAL\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tsession.outstandingDataMessages.push(message)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.cancelSession(session.sessionId)\n\t\t}\n\t}\n\n\t// needs to accept sessionId and not a session because the session might be dead by the time\n\t// the timer fires\n\t_flushDataMessages(sessionId: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\n\t\tif (!session || session.state !== RoomSessionState.Connected) {\n\t\t\treturn\n\t\t}\n\n\t\tsession.debounceTimer = null\n\n\t\tif (session.outstandingDataMessages.length > 0) {\n\t\t\tsession.socket.sendMessage({ type: 'data', data: session.outstandingDataMessages })\n\t\t\tsession.outstandingDataMessages.length = 0\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate removeSession(sessionId: string, fatalReason?: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Tried to remove unknown session')\n\t\t\treturn\n\t\t}\n\n\t\tthis.sessions.delete(sessionId)\n\n\t\tconst presence = this.getDocument(session.presenceId ?? '')\n\n\t\ttry {\n\t\t\tif (fatalReason) {\n\t\t\t\tsession.socket.close(TLSyncErrorCloseEventCode, fatalReason)\n\t\t\t} else {\n\t\t\t\tsession.socket.close()\n\t\t\t}\n\t\t} catch {\n\t\t\t// noop, calling .close() multiple times is fine\n\t\t}\n\n\t\tif (presence) {\n\t\t\tthis.state.update(({ tombstones, documents }) => {\n\t\t\t\tdocuments = { ...documents }\n\t\t\t\tdelete documents[session.presenceId!]\n\t\t\t\treturn { documents, tombstones }\n\t\t\t})\n\n\t\t\tthis.broadcastPatch({\n\t\t\t\tdiff: { [session.presenceId!]: [RecordOpType.Remove] },\n\t\t\t\tsourceSessionId: sessionId,\n\t\t\t})\n\t\t}\n\n\t\tthis.events.emit('session_removed', { sessionId, meta: session.meta })\n\t\tif (this.sessions.size === 0) {\n\t\t\tthis.events.emit('room_became_empty')\n\t\t}\n\t}\n\n\tprivate cancelSession(sessionId: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\treturn\n\t\t}\n\n\t\tif (session.state === RoomSessionState.AwaitingRemoval) {\n\t\t\tthis.log?.warn?.('Tried to cancel session that is already awaiting removal')\n\t\t\treturn\n\t\t}\n\n\t\tthis.sessions.set(sessionId, {\n\t\t\tstate: RoomSessionState.AwaitingRemoval,\n\t\t\tsessionId,\n\t\t\tpresenceId: session.presenceId,\n\t\t\tsocket: session.socket,\n\t\t\tcancellationTime: Date.now(),\n\t\t\tmeta: session.meta,\n\t\t\tisReadonly: session.isReadonly,\n\t\t\trequiresLegacyRejection: session.requiresLegacyRejection,\n\t\t})\n\n\t\ttry {\n\t\t\tsession.socket.close()\n\t\t} catch {\n\t\t\t// noop, calling .close() multiple times is fine\n\t\t}\n\t}\n\n\t/**\n\t * Broadcast a message to all connected clients except the one with the sessionId provided.\n\t *\n\t * @param message - The message to broadcast.\n\t */\n\tbroadcastPatch(message: { diff: NetworkDiff<R>; sourceSessionId?: string }) {\n\t\tconst { diff, sourceSessionId } = message\n\t\tthis.sessions.forEach((session) => {\n\t\t\tif (session.state !== RoomSessionState.Connected) return\n\t\t\tif (sourceSessionId === session.sessionId) return\n\t\t\tif (!session.socket.isOpen) {\n\t\t\t\tthis.cancelSession(session.sessionId)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst res = this.migrateDiffForSession(session.serializedSchema, diff)\n\n\t\t\tif (!res.ok) {\n\t\t\t\t// disconnect client and send incompatibility error\n\t\t\t\tthis.rejectSession(\n\t\t\t\t\tsession.sessionId,\n\t\t\t\t\tres.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\ttype: 'patch',\n\t\t\t\tdiff: res.value,\n\t\t\t\tserverClock: this.clock,\n\t\t\t})\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * When a client connects to the room, add them to the list of clients and then merge the history\n\t * down into the snapshots.\n\t *\n\t * @internal\n\t */\n\thandleNewSession(opts: {\n\t\tsessionId: string\n\t\tsocket: TLRoomSocket<R>\n\t\tmeta: SessionMeta\n\t\tisReadonly: boolean\n\t}) {\n\t\tconst { sessionId, socket, meta, isReadonly } = opts\n\t\tconst existing = this.sessions.get(sessionId)\n\t\tthis.sessions.set(sessionId, {\n\t\t\tstate: RoomSessionState.AwaitingConnectMessage,\n\t\t\tsessionId,\n\t\t\tsocket,\n\t\t\tpresenceId: existing?.presenceId ?? this.presenceType?.createId() ?? null,\n\t\t\tsessionStartTime: Date.now(),\n\t\t\tmeta,\n\t\t\tisReadonly: isReadonly ?? false,\n\t\t\t// this gets set later during handleConnectMessage\n\t\t\trequiresLegacyRejection: false,\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * When we send a diff to a client, if that client is on a lower version than us, we need to make\n\t * the diff compatible with their version. At the moment this means migrating each affected record\n\t * to the client's version and sending the whole record again. We can optimize this later by\n\t * keeping the previous versions of records around long enough to recalculate these diffs for\n\t * older client versions.\n\t */\n\tprivate migrateDiffForSession(\n\t\tserializedSchema: SerializedSchema,\n\t\tdiff: NetworkDiff<R>\n\t): Result<NetworkDiff<R>, MigrationFailureReason> {\n\t\t// TODO: optimize this by recalculating patches using the previous versions of records\n\n\t\t// when the client connects we check whether the schema is identical and make sure\n\t\t// to use the same object reference so that === works on this line\n\t\tif (serializedSchema === this.serializedSchema) {\n\t\t\treturn Result.ok(diff)\n\t\t}\n\n\t\tconst result: NetworkDiff<R> = {}\n\t\tfor (const [id, op] of Object.entries(diff)) {\n\t\t\tif (op[0] === RecordOpType.Remove) {\n\t\t\t\tresult[id] = op\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst migrationResult = this.schema.migratePersistedRecord(\n\t\t\t\tthis.getDocument(id).state,\n\t\t\t\tserializedSchema,\n\t\t\t\t'down'\n\t\t\t)\n\n\t\t\tif (migrationResult.type === 'error') {\n\t\t\t\treturn Result.err(migrationResult.reason)\n\t\t\t}\n\n\t\t\tresult[id] = [RecordOpType.Put, migrationResult.value]\n\t\t}\n\n\t\treturn Result.ok(result)\n\t}\n\n\t/**\n\t * When the server receives a message from the clients Currently, supports connect and patches.\n\t * Invalid messages types throws an error. Currently, doesn't validate data.\n\t *\n\t * @param sessionId - The session that sent the message\n\t * @param message - The message that was sent\n\t */\n\tasync handleMessage(sessionId: string, message: TLSocketClientSentEvent<R>) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Received message from unknown session')\n\t\t\treturn\n\t\t}\n\t\tswitch (message.type) {\n\t\t\tcase 'connect': {\n\t\t\t\treturn this.handleConnectRequest(session, message)\n\t\t\t}\n\t\t\tcase 'push': {\n\t\t\t\treturn this.handlePushRequest(session, message)\n\t\t\t}\n\t\t\tcase 'ping': {\n\t\t\t\tif (session.state === RoomSessionState.Connected) {\n\t\t\t\t\tsession.lastInteractionTime = Date.now()\n\t\t\t\t}\n\t\t\t\treturn this.sendMessage(session.sessionId, { type: 'pong' })\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\texhaustiveSwitchError(message)\n\t\t\t}\n\t\t}\n\t}\n\n\t/** If the client is out of date, or we are out of date, we need to let them know */\n\trejectSession(sessionId: string, fatalReason?: TLSyncErrorCloseEventReason | string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) return\n\t\tif (!fatalReason) {\n\t\t\tthis.removeSession(sessionId)\n\t\t\treturn\n\t\t}\n\t\tif (session.requiresLegacyRejection) {\n\t\t\ttry {\n\t\t\t\tif (session.socket.isOpen) {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\tlet legacyReason: TLIncompatibilityReason\n\t\t\t\t\tswitch (fatalReason) {\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.CLIENT_TOO_OLD:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.ClientTooOld\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.SERVER_TOO_OLD:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.ServerTooOld\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.INVALID_RECORD:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.InvalidRecord\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.InvalidOperation\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tsession.socket.sendMessage({\n\t\t\t\t\t\ttype: 'incompatibility_error',\n\t\t\t\t\t\treason: legacyReason,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// noop\n\t\t\t} finally {\n\t\t\t\tthis.removeSession(sessionId)\n\t\t\t}\n\t\t} else {\n\t\t\tthis.removeSession(sessionId, fatalReason)\n\t\t}\n\t}\n\n\tprivate handleConnectRequest(\n\t\tsession: RoomSession<R, SessionMeta>,\n\t\tmessage: Extract<TLSocketClientSentEvent<R>, { type: 'connect' }>\n\t) {\n\t\t// if the protocol versions don't match, disconnect the client\n\t\t// we will eventually want to try to make our protocol backwards compatible to some degree\n\t\t// and have a MIN_PROTOCOL_VERSION constant that the TLSyncRoom implements support for\n\t\tlet theirProtocolVersion = message.protocolVersion\n\t\t// 5 is the same as 6\n\t\tif (theirProtocolVersion === 5) {\n\t\t\ttheirProtocolVersion = 6\n\t\t}\n\t\t// 6 is almost the same as 7\n\t\tsession.requiresLegacyRejection = theirProtocolVersion === 6\n\t\tif (theirProtocolVersion === 6) {\n\t\t\ttheirProtocolVersion++\n\t\t}\n\t\tif (theirProtocolVersion == null || theirProtocolVersion < getTlsyncProtocolVersion()) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t} else if (theirProtocolVersion > getTlsyncProtocolVersion()) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.SERVER_TOO_OLD)\n\t\t\treturn\n\t\t}\n\t\t// If the client's store is at a different version to ours, it could cause corruption.\n\t\t// We should disconnect the client and ask them to refresh.\n\t\tif (message.schema == null) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t}\n\t\tconst migrations = this.schema.getMigrationsSince(message.schema)\n\t\t// if the client's store is at a different version to ours, we can't support them\n\t\tif (!migrations.ok || migrations.value.some((m) => m.scope === 'store' || !m.down)) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t}\n\n\t\tconst sessionSchema = isEqual(message.schema, this.serializedSchema)\n\t\t\t? this.serializedSchema\n\t\t\t: message.schema\n\n\t\tconst connect = (msg: TLSocketServerSentEvent<R>) => {\n\t\t\tthis.sessions.set(session.sessionId, {\n\t\t\t\tstate: RoomSessionState.Connected,\n\t\t\t\tsessionId: session.sessionId,\n\t\t\t\tpresenceId: session.presenceId,\n\t\t\t\tsocket: session.socket,\n\t\t\t\tserializedSchema: sessionSchema,\n\t\t\t\tlastInteractionTime: Date.now(),\n\t\t\t\tdebounceTimer: null,\n\t\t\t\toutstandingDataMessages: [],\n\t\t\t\tmeta: session.meta,\n\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\trequiresLegacyRejection: session.requiresLegacyRejection,\n\t\t\t})\n\t\t\tthis.sendMessage(session.sessionId, msg)\n\t\t}\n\n\t\ttransaction((rollback) => {\n\t\t\tif (\n\t\t\t\t// if the client requests changes since a time before we have tombstone history, send them the full state\n\t\t\t\tmessage.lastServerClock < this.tombstoneHistoryStartsAtClock ||\n\t\t\t\t// similarly, if they ask for a time we haven't reached yet, send them the full state\n\t\t\t\t// this will only happen if the DB is reset (or there is no db) and the server restarts\n\t\t\t\t// or if the server exits/crashes with unpersisted changes\n\t\t\t\tmessage.lastServerClock > this.clock\n\t\t\t) {\n\t\t\t\tconst diff: NetworkDiff<R> = {}\n\t\t\t\tfor (const [id, doc] of Object.entries(this.state.get().documents)) {\n\t\t\t\t\tif (id !== session.presenceId) {\n\t\t\t\t\t\tdiff[id] = [RecordOpType.Put, doc.state]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst migrated = this.migrateDiffForSession(sessionSchema, diff)\n\t\t\t\tif (!migrated.ok) {\n\t\t\t\t\trollback()\n\t\t\t\t\tthis.rejectSession(\n\t\t\t\t\t\tsession.sessionId,\n\t\t\t\t\t\tmigrated.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconnect({\n\t\t\t\t\ttype: 'connect',\n\t\t\t\t\tconnectRequestId: message.connectRequestId,\n\t\t\t\t\thydrationType: 'wipe_all',\n\t\t\t\t\tprotocolVersion: getTlsyncProtocolVersion(),\n\t\t\t\t\tschema: this.schema.serialize(),\n\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\tdiff: migrated.value,\n\t\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// calculate the changes since the time the client last saw\n\t\t\t\tconst diff: NetworkDiff<R> = {}\n\t\t\t\tconst updatedDocs = Object.values(this.state.get().documents).filter(\n\t\t\t\t\t(doc) => doc.lastChangedClock > message.lastServerClock\n\t\t\t\t)\n\t\t\t\tconst presenceDocs = this.presenceType\n\t\t\t\t\t? Object.values(this.state.get().documents).filter(\n\t\t\t\t\t\t\t(doc) =>\n\t\t\t\t\t\t\t\tthis.presenceType!.typeName === doc.state.typeName &&\n\t\t\t\t\t\t\t\tdoc.state.id !== session.presenceId\n\t\t\t\t\t\t)\n\t\t\t\t\t: []\n\t\t\t\tconst deletedDocsIds = Object.entries(this.state.get().tombstones)\n\t\t\t\t\t.filter(([_id, deletedAtClock]) => deletedAtClock > message.lastServerClock)\n\t\t\t\t\t.map(([id]) => id)\n\n\t\t\t\tfor (const doc of updatedDocs) {\n\t\t\t\t\tdiff[doc.state.id] = [RecordOpType.Put, doc.state]\n\t\t\t\t}\n\t\t\t\tfor (const doc of presenceDocs) {\n\t\t\t\t\tdiff[doc.state.id] = [RecordOpType.Put, doc.state]\n\t\t\t\t}\n\n\t\t\t\tfor (const docId of deletedDocsIds) {\n\t\t\t\t\tdiff[docId] = [RecordOpType.Remove]\n\t\t\t\t}\n\t\t\t\tconst migrated = this.migrateDiffForSession(sessionSchema, diff)\n\t\t\t\tif (!migrated.ok) {\n\t\t\t\t\trollback()\n\t\t\t\t\tthis.rejectSession(\n\t\t\t\t\t\tsession.sessionId,\n\t\t\t\t\t\tmigrated.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconnect({\n\t\t\t\t\ttype: 'connect',\n\t\t\t\t\tconnectRequestId: message.connectRequestId,\n\t\t\t\t\thydrationType: 'wipe_presence',\n\t\t\t\t\tschema: this.schema.serialize(),\n\t\t\t\t\tprotocolVersion: getTlsyncProtocolVersion(),\n\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\tdiff: migrated.value,\n\t\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate handlePushRequest(\n\t\tsession: RoomSession<R, SessionMeta> | null,\n\t\tmessage: Extract<TLSocketClientSentEvent<R>, { type: 'push' }>\n\t) {\n\t\t// We must be connected to handle push requests\n\t\tif (session && session.state !== RoomSessionState.Connected) {\n\t\t\treturn\n\t\t}\n\n\t\t// update the last interaction time\n\t\tif (session) {\n\t\t\tsession.lastInteractionTime = Date.now()\n\t\t}\n\n\t\t// increment the clock for this push\n\t\tthis.clock++\n\n\t\tconst initialDocumentClock = this.documentClock\n\t\tlet didPresenceChange = false\n\t\ttransaction((rollback) => {\n\t\t\t// collect actual ops that resulted from the push\n\t\t\t// these will be broadcast to other users\n\t\t\tinterface ActualChanges {\n\t\t\t\tdiff: NetworkDiff<R> | null\n\t\t\t}\n\t\t\tconst docChanges: ActualChanges = { diff: null }\n\t\t\tconst presenceChanges: ActualChanges = { diff: null }\n\n\t\t\tconst propagateOp = (changes: ActualChanges, id: string, op: RecordOp<R>) => {\n\t\t\t\tif (!changes.diff) changes.diff = {}\n\t\t\t\tchanges.diff[id] = op\n\t\t\t}\n\n\t\t\tconst fail = (\n\t\t\t\treason: TLSyncErrorCloseEventReason,\n\t\t\t\tunderlyingError?: Error\n\t\t\t): Result<void, void> => {\n\t\t\t\trollback()\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.rejectSession(session.sessionId, reason)\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('failed to apply changes: ' + reason, underlyingError)\n\t\t\t\t}\n\t\t\t\tif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n\t\t\t\t\tthis.log?.error?.('failed to apply push', reason, message, underlyingError)\n\t\t\t\t}\n\t\t\t\treturn Result.err(undefined)\n\t\t\t}\n\n\t\t\tconst addDocument = (changes: ActualChanges, id: string, _state: R): Result<void, void> => {\n\t\t\t\tconst res = session\n\t\t\t\t\t? this.schema.migratePersistedRecord(_state, session.serializedSchema, 'up')\n\t\t\t\t\t: { type: 'success' as const, value: _state }\n\t\t\t\tif (res.type === 'error') {\n\t\t\t\t\treturn fail(\n\t\t\t\t\t\tres.reason === MigrationFailureReason.TargetVersionTooOld // target version is our version\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tconst { value: state } = res\n\n\t\t\t\t// Get the existing document, if any\n\t\t\t\tconst doc = this.getDocument(id)\n\n\t\t\t\tif (doc) {\n\t\t\t\t\t// If there's an existing document, replace it with the new state\n\t\t\t\t\t// but propagate a diff rather than the entire value\n\t\t\t\t\tconst diff = doc.replaceState(state, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, if we don't already have a document with this id\n\t\t\t\t\t// create the document and propagate the put op\n\t\t\t\t\tconst result = this.addDocument(id, state, this.clock)\n\t\t\t\t\tif (!result.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Put, state])\n\t\t\t\t}\n\n\t\t\t\treturn Result.ok(undefined)\n\t\t\t}\n\n\t\t\tconst patchDocument = (\n\t\t\t\tchanges: ActualChanges,\n\t\t\t\tid: string,\n\t\t\t\tpatch: ObjectDiff\n\t\t\t): Result<void, void> => {\n\t\t\t\t// if it was already deleted, there's no need to apply the patch\n\t\t\t\tconst doc = this.getDocument(id)\n\t\t\t\tif (!doc) return Result.ok(undefined)\n\t\t\t\t// If the client's version of the record is older than ours,\n\t\t\t\t// we apply the patch to the downgraded version of the record\n\t\t\t\tconst downgraded = session\n\t\t\t\t\t? this.schema.migratePersistedRecord(doc.state, session.serializedSchema, 'down')\n\t\t\t\t\t: { type: 'success' as const, value: doc.state }\n\t\t\t\tif (downgraded.type === 'error') {\n\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\t\t}\n\n\t\t\t\tif (downgraded.value === doc.state) {\n\t\t\t\t\t// If the versions are compatible, apply the patch and propagate the patch op\n\t\t\t\t\tconst diff = doc.mergeDiff(patch, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// need to apply the patch to the downgraded version and then upgrade it\n\n\t\t\t\t\t// apply the patch to the downgraded version\n\t\t\t\t\tconst patched = applyObjectDiff(downgraded.value, patch)\n\t\t\t\t\t// then upgrade the patched version and use that as the new state\n\t\t\t\t\tconst upgraded = session\n\t\t\t\t\t\t? this.schema.migratePersistedRecord(patched, session.serializedSchema, 'up')\n\t\t\t\t\t\t: { type: 'success' as const, value: patched }\n\t\t\t\t\t// If the client's version is too old, we'll hit an error\n\t\t\t\t\tif (upgraded.type === 'error') {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\t\t\t}\n\t\t\t\t\t// replace the state with the upgraded version and propagate the patch op\n\t\t\t\t\tconst diff = doc.replaceState(upgraded.value, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value])\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Result.ok(undefined)\n\t\t\t}\n\n\t\t\tconst { clientClock } = message\n\n\t\t\tif (this.presenceType && session?.presenceId && 'presence' in message && message.presence) {\n\t\t\t\tif (!session) throw new Error('session is required for presence pushes')\n\t\t\t\t// The push request was for the presence scope.\n\t\t\t\tconst id = session.presenceId\n\t\t\t\tconst [type, val] = message.presence\n\t\t\t\tconst { typeName } = this.presenceType\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase RecordOpType.Put: {\n\t\t\t\t\t\t// Try to put the document. If it fails, stop here.\n\t\t\t\t\t\tconst res = addDocument(presenceChanges, id, { ...val, id, typeName })\n\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase RecordOpType.Patch: {\n\t\t\t\t\t\t// Try to patch the document. If it fails, stop here.\n\t\t\t\t\t\tconst res = patchDocument(presenceChanges, id, {\n\t\t\t\t\t\t\t...val,\n\t\t\t\t\t\t\tid: [ValueOpType.Put, id],\n\t\t\t\t\t\t\ttypeName: [ValueOpType.Put, typeName],\n\t\t\t\t\t\t})\n\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (message.diff && !session?.isReadonly) {\n\t\t\t\t// The push request was for the document scope.\n\t\t\t\tfor (const [id, op] of Object.entries(message.diff!)) {\n\t\t\t\t\tswitch (op[0]) {\n\t\t\t\t\t\tcase RecordOpType.Put: {\n\t\t\t\t\t\t\t// Try to add the document.\n\t\t\t\t\t\t\t// If we're putting a record with a type that we don't recognize, fail\n\t\t\t\t\t\t\tif (!this.documentTypes.has(op[1].typeName)) {\n\t\t\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst res = addDocument(docChanges, id, op[1])\n\t\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RecordOpType.Patch: {\n\t\t\t\t\t\t\t// Try to patch the document. If it fails, stop here.\n\t\t\t\t\t\t\tconst res = patchDocument(docChanges, id, op[1])\n\t\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RecordOpType.Remove: {\n\t\t\t\t\t\t\tconst doc = this.getDocument(id)\n\t\t\t\t\t\t\tif (!doc) {\n\t\t\t\t\t\t\t\t// If the doc was already deleted, don't do anything, no need to propagate a delete op\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Delete the document and propagate the delete op\n\t\t\t\t\t\t\tthis.removeDocument(id, this.clock)\n\t\t\t\t\t\t\t// Schedule a pruneTombstones call to happen on the next call stack\n\t\t\t\t\t\t\tsetTimeout(this.pruneTombstones, 0)\n\t\t\t\t\t\t\tpropagateOp(docChanges, id, op)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Let the client know what action to take based on the results of the push\n\t\t\tif (\n\t\t\t\t// if there was only a presence push, the client doesn't need to do anything aside from\n\t\t\t\t// shift the push request.\n\t\t\t\t!message.diff ||\n\t\t\t\tisEqual(docChanges.diff, message.diff)\n\t\t\t) {\n\t\t\t\t// COMMIT\n\t\t\t\t// Applying the client's changes had the exact same effect on the server as\n\t\t\t\t// they had on the client, so the client should keep the diff\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: 'commit',\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else if (!docChanges.diff) {\n\t\t\t\t// DISCARD\n\t\t\t\t// Applying the client's changes had no effect, so the client should drop the diff\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: 'discard',\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// REBASE\n\t\t\t\t// Applying the client's changes had a different non-empty effect on the server,\n\t\t\t\t// so the client should rebase with our gold-standard / authoritative diff.\n\t\t\t\t// First we need to migrate the diff to the client's version\n\t\t\t\tif (session) {\n\t\t\t\t\tconst migrateResult = this.migrateDiffForSession(\n\t\t\t\t\t\tsession.serializedSchema,\n\t\t\t\t\t\tdocChanges.diff\n\t\t\t\t\t)\n\t\t\t\t\tif (!migrateResult.ok) {\n\t\t\t\t\t\treturn fail(\n\t\t\t\t\t\t\tmigrateResult.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\t// If the migration worked, send the rebased diff to the client\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: { rebaseWithDiff: migrateResult.value },\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there are merged changes, broadcast them to all other clients\n\t\t\tif (docChanges.diff || presenceChanges.diff) {\n\t\t\t\tthis.broadcastPatch({\n\t\t\t\t\tsourceSessionId: session?.sessionId,\n\t\t\t\t\tdiff: {\n\t\t\t\t\t\t...docChanges.diff,\n\t\t\t\t\t\t...presenceChanges.diff,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (docChanges.diff) {\n\t\t\t\tthis.documentClock = this.clock\n\t\t\t}\n\t\t\tif (presenceChanges.diff) {\n\t\t\t\tdidPresenceChange = true\n\t\t\t}\n\n\t\t\treturn\n\t\t})\n\n\t\t// if it threw the changes will have been rolled back and the document clock will not have been incremented\n\t\tif (this.documentClock !== initialDocumentClock) {\n\t\t\tthis.onDataChange?.()\n\t\t}\n\n\t\tif (didPresenceChange) {\n\t\t\tthis.onPresenceChange?.()\n\t\t}\n\t}\n\n\t/**\n\t * Handle the event when a client disconnects.\n\t *\n\t * @param sessionId - The session that disconnected.\n\t */\n\thandleClose(sessionId: string) {\n\t\tthis.cancelSession(sessionId)\n\t}\n\n\t/**\n\t * Allow applying changes to the store in a transactional way.\n\t * @param updater - A function that will be called with a store object that can be used to make changes.\n\t * @returns A promise that resolves when the transaction is complete.\n\t */\n\tasync updateStore(updater: (store: RoomStoreMethods<R>) => void | Promise<void>) {\n\t\tif (this._isClosed) {\n\t\t\tthrow new Error('Cannot update store on a closed room')\n\t\t}\n\t\tconst context = new StoreUpdateContext<R>(\n\t\t\tObject.fromEntries(this.getSnapshot().documents.map((d) => [d.state.id, d.state]))\n\t\t)\n\t\ttry {\n\t\t\tawait updater(context)\n\t\t} finally {\n\t\t\tcontext.close()\n\t\t}\n\n\t\tconst diff = context.toDiff()\n\t\tif (Object.keys(diff).length === 0) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.handlePushRequest(null, { type: 'push', diff, clientClock: 0 })\n\t}\n}\n\n/**\n * @public\n */\nexport interface RoomStoreMethods<R extends UnknownRecord = UnknownRecord> {\n\tput(record: R): void\n\tdelete(recordOrId: R | string): void\n\tget(id: string): R | null\n\tgetAll(): R[]\n}\n\nclass StoreUpdateContext<R extends UnknownRecord> implements RoomStoreMethods<R> {\n\tconstructor(private readonly snapshot: Record<string, UnknownRecord>) {}\n\tprivate readonly updates = {\n\t\tputs: {} as Record<string, UnknownRecord>,\n\t\tdeletes: new Set<string>(),\n\t}\n\tput(record: R): void {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tif (record.id in this.snapshot && isEqual(this.snapshot[record.id], record)) {\n\t\t\tdelete this.updates.puts[record.id]\n\t\t} else {\n\t\t\tthis.updates.puts[record.id] = structuredClone(record)\n\t\t}\n\t\tthis.updates.deletes.delete(record.id)\n\t}\n\tdelete(recordOrId: R | string): void {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tconst id = typeof recordOrId === 'string' ? recordOrId : recordOrId.id\n\t\tdelete this.updates.puts[id]\n\t\tif (this.snapshot[id]) {\n\t\t\tthis.updates.deletes.add(id)\n\t\t}\n\t}\n\tget(id: string): R | null {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tif (hasOwnProperty(this.updates.puts, id)) {\n\t\t\treturn structuredClone(this.updates.puts[id]) as R\n\t\t}\n\t\tif (this.updates.deletes.has(id)) {\n\t\t\treturn null\n\t\t}\n\t\treturn structuredClone(this.snapshot[id] ?? null) as R\n\t}\n\n\tgetAll(): R[] {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tconst result = Object.values(this.updates.puts)\n\t\tfor (const [id, record] of Object.entries(this.snapshot)) {\n\t\t\tif (!this.updates.deletes.has(id) && !hasOwnProperty(this.updates.puts, id)) {\n\t\t\t\tresult.push(record)\n\t\t\t}\n\t\t}\n\t\treturn structuredClone(result) as R[]\n\t}\n\n\ttoDiff(): NetworkDiff<any> {\n\t\tconst diff: NetworkDiff<R> = {}\n\t\tfor (const [id, record] of Object.entries(this.updates.puts)) {\n\t\t\tdiff[id] = [RecordOpType.Put, record as R]\n\t\t}\n\t\tfor (const id of this.updates.deletes) {\n\t\t\tdiff[id] = [RecordOpType.Remove]\n\t\t}\n\t\treturn diff\n\t}\n\n\tprivate _isClosed = false\n\tclose() {\n\t\tthis._isClosed = true\n\t}\n}\n", "export let createNanoEvents = () => ({\n  events: {},\n  emit(event, ...args) {\n    let callbacks = this.events[event] || []\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i](...args)\n    }\n  },\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\n    return () => {\n      this.events[event] = this.events[event]?.filter(i => cb !== i)\n    }\n  }\n})\n", "import type { StoreSchema, UnknownRecord } from '@tldraw/store'\nimport { TLStoreSnapshot, createTLSchema } from '@tldraw/tlschema'\nimport { objectMapValues, structuredClone } from '@tldraw/utils'\nimport { RoomSessionState } from './RoomSession'\nimport { ServerSocketAdapter, WebSocketMinimal } from './ServerSocketAdapter'\nimport { TLSyncErrorCloseEventReason } from './TLSyncClient'\nimport { RoomSnapshot, RoomStoreMethods, TLSyncRoom } from './TLSyncRoom'\nimport { JsonChunkAssembler } from './chunk'\nimport { TLSocketServerSentEvent } from './protocol'\n\n// TODO: structured logging support\n/** @public */\nexport interface TLSyncLog {\n\twarn?(...args: any[]): void\n\terror?(...args: any[]): void\n}\n\n/** @public */\nexport class TLSocketRoom<R extends UnknownRecord = UnknownRecord, SessionMeta = void> {\n\tprivate room: TLSyncRoom<R, SessionMeta>\n\tprivate readonly sessions = new Map<\n\t\tstring,\n\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t{ assembler: JsonChunkAssembler; socket: WebSocketMinimal; unlisten: () => void }\n\t>()\n\treadonly log?: TLSyncLog\n\n\tconstructor(\n\t\tpublic readonly opts: {\n\t\t\tinitialSnapshot?: RoomSnapshot | TLStoreSnapshot\n\t\t\tschema?: StoreSchema<R, any>\n\t\t\t// how long to wait for a client to communicate before disconnecting them\n\t\t\tclientTimeout?: number\n\t\t\tlog?: TLSyncLog\n\t\t\t// a callback that is called when a client is disconnected\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\tonSessionRemoved?: (\n\t\t\t\troom: TLSocketRoom<R, SessionMeta>,\n\t\t\t\targs: { sessionId: string; numSessionsRemaining: number; meta: SessionMeta }\n\t\t\t) => void\n\t\t\t// a callback that is called whenever a message is sent\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\tonBeforeSendMessage?: (args: {\n\t\t\t\tsessionId: string\n\t\t\t\t/** @internal keep the protocol private for now */\n\t\t\t\tmessage: TLSocketServerSentEvent<R>\n\t\t\t\tstringified: string\n\t\t\t\tmeta: SessionMeta\n\t\t\t}) => void\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\tonAfterReceiveMessage?: (args: {\n\t\t\t\tsessionId: string\n\t\t\t\t/** @internal keep the protocol private for now */\n\t\t\t\tmessage: TLSocketServerSentEvent<R>\n\t\t\t\tstringified: string\n\t\t\t\tmeta: SessionMeta\n\t\t\t}) => void\n\t\t\tonDataChange?(): void\n\t\t\t/** @internal */\n\t\t\tonPresenceChange?(): void\n\t\t}\n\t) {\n\t\tconst initialSnapshot =\n\t\t\topts.initialSnapshot && 'store' in opts.initialSnapshot\n\t\t\t\t? convertStoreSnapshotToRoomSnapshot(opts.initialSnapshot!)\n\t\t\t\t: opts.initialSnapshot\n\n\t\tthis.room = new TLSyncRoom<R, SessionMeta>({\n\t\t\tschema: opts.schema ?? (createTLSchema() as any),\n\t\t\tsnapshot: initialSnapshot,\n\t\t\tonDataChange: opts.onDataChange,\n\t\t\tonPresenceChange: opts.onPresenceChange,\n\t\t\tlog: opts.log,\n\t\t})\n\t\tthis.room.events.on('session_removed', (args) => {\n\t\t\tthis.sessions.delete(args.sessionId)\n\t\t\tif (this.opts.onSessionRemoved) {\n\t\t\t\tthis.opts.onSessionRemoved(this, {\n\t\t\t\t\tsessionId: args.sessionId,\n\t\t\t\t\tnumSessionsRemaining: this.room.sessions.size,\n\t\t\t\t\tmeta: args.meta,\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t\tthis.log = 'log' in opts ? opts.log : { error: console.error }\n\t}\n\n\t/**\n\t * Returns the number of active sessions.\n\t * Note that this is not the same as the number of connected sockets!\n\t * Sessions time out a few moments after sockets close, to smooth over network hiccups.\n\t *\n\t * @returns the number of active sessions\n\t */\n\tgetNumActiveSessions() {\n\t\treturn this.room.sessions.size\n\t}\n\n\t/**\n\t * Call this when a client establishes a new socket connection.\n\t *\n\t * - `sessionId` is a unique ID for a browser tab. This is passed as a query param by the useSync hook.\n\t * - `socket` is a WebSocket-like object that the server uses to communicate with the client.\n\t * - `isReadonly` is an optional boolean that can be set to true if the client should not be able to make changes to the document. They will still be able to send presence updates.\n\t * - `meta` is an optional object that can be used to store additional information about the session.\n\t *\n\t * @param opts - The options object\n\t */\n\thandleSocketConnect(\n\t\topts: {\n\t\t\tsessionId: string\n\t\t\tsocket: WebSocketMinimal\n\t\t\tisReadonly?: boolean\n\t\t} & (SessionMeta extends void ? object : { meta: SessionMeta })\n\t) {\n\t\tconst { sessionId, socket, isReadonly = false } = opts\n\t\tconst handleSocketMessage = (event: MessageEvent) =>\n\t\t\tthis.handleSocketMessage(sessionId, event.data)\n\t\tconst handleSocketError = this.handleSocketError.bind(this, sessionId)\n\t\tconst handleSocketClose = this.handleSocketClose.bind(this, sessionId)\n\n\t\tthis.sessions.set(sessionId, {\n\t\t\tassembler: new JsonChunkAssembler(),\n\t\t\tsocket,\n\t\t\tunlisten: () => {\n\t\t\t\tsocket.removeEventListener?.('message', handleSocketMessage)\n\t\t\t\tsocket.removeEventListener?.('close', handleSocketClose)\n\t\t\t\tsocket.removeEventListener?.('error', handleSocketError)\n\t\t\t},\n\t\t})\n\n\t\tthis.room.handleNewSession({\n\t\t\tsessionId,\n\t\t\tisReadonly,\n\t\t\tsocket: new ServerSocketAdapter({\n\t\t\t\tws: socket,\n\t\t\t\tonBeforeSendMessage: this.opts.onBeforeSendMessage\n\t\t\t\t\t? (message, stringified) =>\n\t\t\t\t\t\t\tthis.opts.onBeforeSendMessage!({\n\t\t\t\t\t\t\t\tsessionId,\n\t\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\t\tstringified,\n\t\t\t\t\t\t\t\tmeta: this.room.sessions.get(sessionId)?.meta as SessionMeta,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t: undefined,\n\t\t\t}),\n\t\t\tmeta: 'meta' in opts ? (opts.meta as any) : undefined,\n\t\t})\n\n\t\tsocket.addEventListener?.('message', handleSocketMessage)\n\t\tsocket.addEventListener?.('close', handleSocketClose)\n\t\tsocket.addEventListener?.('error', handleSocketError)\n\t}\n\n\t/**\n\t * If executing in a server environment where sockets do not have instance-level listeners\n\t * (e.g. Bun.serve, Cloudflare Worker with WebSocket hibernation), you should call this\n\t * method when messages are received. See our self-hosting example for Bun.serve for an example.\n\t *\n\t * @param sessionId - The id of the session. (should match the one used when calling handleSocketConnect)\n\t * @param message - The message received from the client.\n\t */\n\thandleSocketMessage(sessionId: string, message: string | AllowSharedBufferSource) {\n\t\tconst assembler = this.sessions.get(sessionId)?.assembler\n\t\tif (!assembler) {\n\t\t\tthis.log?.warn?.('Received message from unknown session', sessionId)\n\t\t\treturn\n\t\t}\n\n\t\ttry {\n\t\t\tconst messageString =\n\t\t\t\ttypeof message === 'string' ? message : new TextDecoder().decode(message)\n\t\t\tconst res = assembler.handleMessage(messageString)\n\t\t\tif (!res) {\n\t\t\t\t// not enough chunks yet\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif ('data' in res) {\n\t\t\t\t// need to do this first in case the session gets removed as a result of handling the message\n\t\t\t\tif (this.opts.onAfterReceiveMessage) {\n\t\t\t\t\tconst session = this.room.sessions.get(sessionId)\n\t\t\t\t\tif (session) {\n\t\t\t\t\t\tthis.opts.onAfterReceiveMessage({\n\t\t\t\t\t\t\tsessionId,\n\t\t\t\t\t\t\tmessage: res.data as any,\n\t\t\t\t\t\t\tstringified: res.stringified,\n\t\t\t\t\t\t\tmeta: session.meta,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.room.handleMessage(sessionId, res.data as any)\n\t\t\t} else {\n\t\t\t\tthis.log?.error?.('Error assembling message', res.error)\n\t\t\t\t// close the socket to reset the connection\n\t\t\t\tthis.handleSocketError(sessionId)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis.log?.error?.(e)\n\t\t\t// here we use rejectSession rather than removeSession to support legacy clients\n\t\t\t// that use the old incompatibility_error close event\n\t\t\tthis.room.rejectSession(sessionId, TLSyncErrorCloseEventReason.UNKNOWN_ERROR)\n\t\t}\n\t}\n\n\t/**\n\t * If executing in a server environment where sockets do not have instance-level listeners,\n\t * call this when a socket error occurs.\n\t * @param sessionId - The id of the session. (should match the one used when calling handleSocketConnect)\n\t */\n\thandleSocketError(sessionId: string) {\n\t\tthis.room.handleClose(sessionId)\n\t}\n\n\t/**\n\t * If executing in a server environment where sockets do not have instance-level listeners,\n\t * call this when a socket is closed.\n\t * @param sessionId - The id of the session. (should match the one used when calling handleSocketConnect)\n\t */\n\thandleSocketClose(sessionId: string) {\n\t\tthis.room.handleClose(sessionId)\n\t}\n\n\t/**\n\t * Returns the current 'clock' of the document.\n\t * The clock is an integer that increments every time the document changes.\n\t * The clock is stored as part of the snapshot of the document for consistency purposes.\n\t *\n\t * @returns The clock\n\t */\n\tgetCurrentDocumentClock() {\n\t\treturn this.room.documentClock\n\t}\n\n\t/**\n\t * Returns a deeply cloned record from the store, if available.\n\t * @param id - The id of the record\n\t * @returns the cloned record\n\t */\n\tgetRecord(id: string) {\n\t\treturn structuredClone(this.room.state.get().documents[id]?.state)\n\t}\n\n\t/**\n\t * Returns a list of the sessions in the room.\n\t */\n\tgetSessions(): Array<{\n\t\tsessionId: string\n\t\tisConnected: boolean\n\t\tisReadonly: boolean\n\t\tmeta: SessionMeta\n\t}> {\n\t\treturn [...this.room.sessions.values()].map((session) => {\n\t\t\treturn {\n\t\t\t\tsessionId: session.sessionId,\n\t\t\t\tisConnected: session.state === RoomSessionState.Connected,\n\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\tmeta: session.meta,\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Return a snapshot of the document state, including clock-related bookkeeping.\n\t * You can store this and load it later on when initializing a TLSocketRoom.\n\t * You can also pass a snapshot to {@link TLSocketRoom#loadSnapshot} if you need to revert to a previous state.\n\t * @returns The snapshot\n\t */\n\tgetCurrentSnapshot() {\n\t\treturn this.room.getSnapshot()\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tgetPresenceRecords() {\n\t\tconst result = {} as Record<string, UnknownRecord>\n\t\tfor (const document of Object.values(this.room.state.get().documents)) {\n\t\t\tif (document.state.typeName === this.room.presenceType?.typeName) {\n\t\t\t\tresult[document.state.id] = document.state\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Return a serialized snapshot of the document state, including clock-related bookkeeping.\n\t * @returns The serialized snapshot\n\t * @internal\n\t */\n\tgetCurrentSerializedSnapshot() {\n\t\treturn JSON.stringify(this.room.getSnapshot())\n\t}\n\n\t/**\n\t * Load a snapshot of the document state, overwriting the current state.\n\t * @param snapshot - The snapshot to load\n\t */\n\tloadSnapshot(snapshot: RoomSnapshot | TLStoreSnapshot) {\n\t\tif ('store' in snapshot) {\n\t\t\tsnapshot = convertStoreSnapshotToRoomSnapshot(snapshot)\n\t\t}\n\t\tconst oldRoom = this.room\n\t\tconst oldIds = oldRoom.getSnapshot().documents.map((d) => d.state.id)\n\t\tconst newIds = new Set(snapshot.documents.map((d) => d.state.id))\n\t\tconst removedIds = oldIds.filter((id) => !newIds.has(id))\n\n\t\tconst tombstones = { ...snapshot.tombstones }\n\t\tremovedIds.forEach((id) => {\n\t\t\ttombstones[id] = oldRoom.clock + 1\n\t\t})\n\t\tnewIds.forEach((id) => {\n\t\t\tdelete tombstones[id]\n\t\t})\n\n\t\tconst newRoom = new TLSyncRoom<R, SessionMeta>({\n\t\t\tschema: oldRoom.schema,\n\t\t\tsnapshot: {\n\t\t\t\tclock: oldRoom.clock + 1,\n\t\t\t\tdocuments: snapshot.documents.map((d) => ({\n\t\t\t\t\tlastChangedClock: oldRoom.clock + 1,\n\t\t\t\t\tstate: d.state,\n\t\t\t\t})),\n\t\t\t\tschema: snapshot.schema,\n\t\t\t\ttombstones,\n\t\t\t},\n\t\t\tlog: this.log,\n\t\t})\n\t\t// replace room with new one and kick out all the clients\n\t\tthis.room = newRoom\n\t\toldRoom.close()\n\t}\n\n\t/**\n\t * Allow applying changes to the store inside of a transaction.\n\t *\n\t * You can get values from the store by id with `store.get(id)`.\n\t * These values are safe to mutate, but to commit the changes you must call `store.put(...)` with the updated value.\n\t * You can get all values in the store with `store.getAll()`.\n\t * You can also delete values with `store.delete(id)`.\n\t *\n\t * @example\n\t * ```ts\n\t * room.updateStore(store => {\n\t *   const shape = store.get('shape:abc123')\n\t *   shape.meta.approved = true\n\t *   store.put(shape)\n\t * })\n\t * ```\n\t *\n\t * Changes to the store inside the callback are isolated from changes made by other clients until the transaction commits.\n\t *\n\t * @param updater - A function that will be called with a store object that can be used to make changes.\n\t * @returns A promise that resolves when the transaction is complete.\n\t */\n\tasync updateStore(updater: (store: RoomStoreMethods<R>) => void | Promise<void>) {\n\t\treturn this.room.updateStore(updater)\n\t}\n\n\t/**\n\t * Immediately remove a session from the room, and close its socket if not already closed.\n\t *\n\t * The client will attempt to reconnect unless you provide a `fatalReason` parameter.\n\t *\n\t * The `fatalReason` parameter will be available in the return value of the `useSync` hook as `useSync().error.reason`.\n\t *\n\t * @param sessionId - The id of the session to remove\n\t * @param fatalReason - The reason message to use when calling .close on the underlying websocket\n\t */\n\tcloseSession(sessionId: string, fatalReason?: TLSyncErrorCloseEventReason | string) {\n\t\tthis.room.rejectSession(sessionId, fatalReason)\n\t}\n\n\t/**\n\t * Close the room and disconnect all clients. Call this before discarding the room instance or shutting down the server.\n\t */\n\tclose() {\n\t\tthis.room.close()\n\t}\n\n\t/**\n\t * @returns true if the room is closed\n\t */\n\tisClosed() {\n\t\treturn this.room.isClosed()\n\t}\n}\n\n/** @public */\nexport type OmitVoid<T, KS extends keyof T = keyof T> = {\n\t[K in KS extends any ? (void extends T[KS] ? never : KS) : never]: T[K]\n}\n\nfunction convertStoreSnapshotToRoomSnapshot(snapshot: TLStoreSnapshot): RoomSnapshot {\n\treturn {\n\t\tclock: 0,\n\t\tdocuments: objectMapValues(snapshot.store).map((state) => ({\n\t\t\tstate,\n\t\t\tlastChangedClock: 0,\n\t\t})),\n\t\tschema: snapshot.schema,\n\t\ttombstones: {},\n\t}\n}\n", "import { registerTldrawLibraryVersion } from '@tldraw/utils'\nexport { ClientWebSocketAdapter, ReconnectManager } from './lib/ClientWebSocketAdapter'\nexport { RoomSessionState, type RoomSession } from './lib/RoomSession'\nexport type { WebSocketMinimal } from './lib/ServerSocketAdapter'\nexport { TLRemoteSyncError } from './lib/TLRemoteSyncError'\nexport { TLSocketRoom, type OmitVoid, type TLSyncLog } from './lib/TLSocketRoom'\nexport {\n\tTLSyncClient,\n\tTLSyncErrorCloseEventCode,\n\tTLSyncErrorCloseEventReason,\n\ttype SubscribingFn,\n\ttype TLPersistentClientSocket,\n\ttype TLPersistentClientSocketStatus,\n\ttype TLSocketStatusListener,\n\ttype TlSocketStatusChangeEvent,\n} from './lib/TLSyncClient'\nexport {\n\tDocumentState,\n\tTLSyncRoom,\n\ttype RoomSnapshot,\n\ttype RoomStoreMethods,\n\ttype TLRoomSocket,\n} from './lib/TLSyncRoom'\nexport { chunk } from './lib/chunk'\nexport {\n\tRecordOpType,\n\tValueOpType,\n\tapplyObjectDiff,\n\tdiffRecord,\n\tgetNetworkDiff,\n\ttype AppendOp,\n\ttype DeleteOp,\n\ttype NetworkDiff,\n\ttype ObjectDiff,\n\ttype PatchOp,\n\ttype PutOp,\n\ttype RecordOp,\n\ttype ValueOp,\n} from './lib/diff'\nexport {\n\tTLIncompatibilityReason,\n\tgetTlsyncProtocolVersion,\n\ttype TLConnectRequest,\n\ttype TLPingRequest,\n\ttype TLPushRequest,\n\ttype TLSocketClientSentEvent,\n\ttype TLSocketServerSentDataEvent,\n\ttype TLSocketServerSentEvent,\n} from './lib/protocol'\nexport type { PersistedRoomSnapshotForSupabase } from './lib/server-types'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n", "import { atom, isSignal, transact } from '@tldraw/state'\nimport { useAtom } from '@tldraw/state-react'\nimport {\n\tClientWebSocketAdapter,\n\tTLRemoteSyncError,\n\tTLSyncClient,\n\tTLSyncErrorCloseEventReason,\n} from '@tldraw/sync-core'\nimport { useEffect } from 'react'\nimport {\n\tEditor,\n\tInstancePresenceRecordType,\n\tSignal,\n\tTAB_ID,\n\tTLAssetStore,\n\tTLPresenceStateInfo,\n\tTLPresenceUserInfo,\n\tTLRecord,\n\tTLStore,\n\tTLStoreSchemaOptions,\n\tTLStoreWithStatus,\n\tcomputed,\n\tcreateTLStore,\n\tdefaultUserPreferences,\n\tgetDefaultUserPresence,\n\tgetUserPreferences,\n\tuniqueId,\n\tuseReactiveEvent,\n\tuseRefState,\n\tuseShallowObjectIdentity,\n\tuseTLSchemaFromUtils,\n\tuseValue,\n} from 'tldraw'\n\nconst MULTIPLAYER_EVENT_NAME = 'multiplayer.client'\n\n/** @public */\nexport type RemoteTLStoreWithStatus = Exclude<\n\tTLStoreWithStatus,\n\t{ status: 'synced-local' } | { status: 'not-synced' }\n>\n\n/**\n * useSync creates a store that is synced with a multiplayer server.\n *\n * The store can be passed directly into the `<Tldraw />` component to enable multiplayer features.\n * It will handle loading states, and enable multiplayer UX like user cursors and following.\n *\n * To enable external blob storage, you should also pass in an `assets` object that implements the {@link tldraw#TLAssetStore} interface.\n * If you don't do this, adding large images and videos to rooms will cause performance issues at serialization boundaries.\n *\n * @example\n * ```tsx\n * function MyApp() {\n *     const store = useSync({\n *         uri: 'wss://myapp.com/sync/my-test-room',\n *         assets: myAssetStore\n *     })\n *     return <Tldraw store={store} />\n * }\n *\n * ```\n * @param opts - Options for the multiplayer sync store. See {@link UseSyncOptions} and {@link tldraw#TLStoreSchemaOptions}.\n *\n * @public\n */\nexport function useSync(opts: UseSyncOptions & TLStoreSchemaOptions): RemoteTLStoreWithStatus {\n\tconst [state, setState] = useRefState<{\n\t\treadyClient?: TLSyncClient<TLRecord, TLStore>\n\t\terror?: Error\n\t} | null>(null)\n\tconst {\n\t\turi,\n\t\troomId = 'default',\n\t\tassets,\n\t\tonMount,\n\t\ttrackAnalyticsEvent: track,\n\t\tuserInfo,\n\t\tgetUserPresence: _getUserPresence,\n\t\t...schemaOpts\n\t} = opts\n\n\t// This line will throw a type error if we add any new options to the useSync hook but we don't destructure them\n\t// This is required because otherwise the useTLSchemaFromUtils might return a new schema on every render if the newly-added option\n\t// is allowed to be unstable (e.g. userInfo)\n\tconst __never__: never = 0 as any as keyof Omit<typeof schemaOpts, keyof TLStoreSchemaOptions>\n\n\tconst schema = useTLSchemaFromUtils(schemaOpts)\n\n\tconst prefs = useShallowObjectIdentity(userInfo)\n\tconst getUserPresence = useReactiveEvent(_getUserPresence ?? getDefaultUserPresence)\n\n\tconst userAtom = useAtom<TLPresenceUserInfo | Signal<TLPresenceUserInfo> | undefined>(\n\t\t'userAtom',\n\t\tprefs\n\t)\n\n\tuseEffect(() => {\n\t\tuserAtom.set(prefs)\n\t}, [prefs, userAtom])\n\n\tuseEffect(() => {\n\t\tconst storeId = uniqueId()\n\n\t\tconst userPreferences = computed<{ id: string; color: string; name: string }>(\n\t\t\t'userPreferences',\n\t\t\t() => {\n\t\t\t\tconst userStuff = userAtom.get()\n\t\t\t\tconst user = (isSignal(userStuff) ? userStuff.get() : userStuff) ?? getUserPreferences()\n\t\t\t\treturn {\n\t\t\t\t\tid: user.id,\n\t\t\t\t\tcolor: user.color ?? defaultUserPreferences.color,\n\t\t\t\t\tname: user.name ?? defaultUserPreferences.name,\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\tconst socket = new ClientWebSocketAdapter(async () => {\n\t\t\tconst uriString = typeof uri === 'string' ? uri : await uri()\n\n\t\t\t// set sessionId as a query param on the uri\n\t\t\tconst withParams = new URL(uriString)\n\t\t\tif (withParams.searchParams.has('sessionId')) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'useSync. \"sessionId\" is a reserved query param name. Please use a different name'\n\t\t\t\t)\n\t\t\t}\n\t\t\tif (withParams.searchParams.has('storeId')) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'useSync. \"storeId\" is a reserved query param name. Please use a different name'\n\t\t\t\t)\n\t\t\t}\n\n\t\t\twithParams.searchParams.set('sessionId', TAB_ID)\n\t\t\twithParams.searchParams.set('storeId', storeId)\n\t\t\treturn withParams.toString()\n\t\t})\n\n\t\tlet didCancel = false\n\n\t\tconst collaborationStatusSignal = computed('collaboration status', () =>\n\t\t\tsocket.connectionStatus === 'error' ? 'offline' : socket.connectionStatus\n\t\t)\n\n\t\tconst syncMode = atom('sync mode', 'readwrite' as 'readonly' | 'readwrite')\n\n\t\tconst store = createTLStore({\n\t\t\tid: storeId,\n\t\t\tschema,\n\t\t\tassets,\n\t\t\tonMount,\n\t\t\tcollaboration: {\n\t\t\t\tstatus: collaborationStatusSignal,\n\t\t\t\tmode: syncMode,\n\t\t\t},\n\t\t})\n\n\t\tconst presence = computed('instancePresence', () => {\n\t\t\tconst presenceState = getUserPresence(store, userPreferences.get())\n\t\t\tif (!presenceState) return null\n\n\t\t\treturn InstancePresenceRecordType.create({\n\t\t\t\t...presenceState,\n\t\t\t\tid: InstancePresenceRecordType.createId(store.id),\n\t\t\t})\n\t\t})\n\n\t\tconst client = new TLSyncClient({\n\t\t\tstore,\n\t\t\tsocket,\n\t\t\tdidCancel: () => didCancel,\n\t\t\tonLoad(client) {\n\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'load', roomId })\n\t\t\t\tsetState({ readyClient: client })\n\t\t\t},\n\t\t\tonSyncError(reason) {\n\t\t\t\tconsole.error('sync error', reason)\n\n\t\t\t\tswitch (reason) {\n\t\t\t\t\tcase TLSyncErrorCloseEventReason.NOT_FOUND:\n\t\t\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'room-not-found', roomId })\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase TLSyncErrorCloseEventReason.FORBIDDEN:\n\t\t\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'forbidden', roomId })\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase TLSyncErrorCloseEventReason.NOT_AUTHENTICATED:\n\t\t\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'not-authenticated', roomId })\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase TLSyncErrorCloseEventReason.RATE_LIMITED:\n\t\t\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'rate-limited', roomId })\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'sync-error:' + reason, roomId })\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tsetState({ error: new TLRemoteSyncError(reason) })\n\t\t\t\tsocket.close()\n\t\t\t},\n\t\t\tonAfterConnect(_, { isReadonly }) {\n\t\t\t\ttransact(() => {\n\t\t\t\t\tsyncMode.set(isReadonly ? 'readonly' : 'readwrite')\n\t\t\t\t\t// if the server crashes and loses all data it can return an empty document\n\t\t\t\t\t// when it comes back up. This is a safety check to make sure that if something like\n\t\t\t\t\t// that happens, it won't render the app broken and require a restart. The user will\n\t\t\t\t\t// most likely lose all their changes though since they'll have been working with pages\n\t\t\t\t\t// that won't exist. There's certainly something we can do to make this better.\n\t\t\t\t\t// but the likelihood of this happening is very low and maybe not worth caring about beyond this.\n\t\t\t\t\tstore.ensureStoreIsUsable()\n\t\t\t\t})\n\t\t\t},\n\t\t\tpresence,\n\t\t})\n\n\t\treturn () => {\n\t\t\tdidCancel = true\n\t\t\tclient.close()\n\t\t\tsocket.close()\n\t\t\tsetState(null)\n\t\t}\n\t}, [assets, onMount, userAtom, roomId, schema, setState, track, uri, getUserPresence])\n\n\treturn useValue<RemoteTLStoreWithStatus>(\n\t\t'remote synced store',\n\t\t() => {\n\t\t\tif (!state) return { status: 'loading' }\n\t\t\tif (state.error) return { status: 'error', error: state.error }\n\t\t\tif (!state.readyClient) return { status: 'loading' }\n\t\t\tconst connectionStatus = state.readyClient.socket.connectionStatus\n\t\t\treturn {\n\t\t\t\tstatus: 'synced-remote',\n\t\t\t\tconnectionStatus: connectionStatus === 'error' ? 'offline' : connectionStatus,\n\t\t\t\tstore: state.readyClient.store,\n\t\t\t}\n\t\t},\n\t\t[state]\n\t)\n}\n\n/**\n * Options for the {@link useSync} hook.\n * @public\n */\nexport interface UseSyncOptions {\n\t/**\n\t * The URI of the multiplayer server. This must include the protocol,\n\t *\n\t *   e.g. `wss://server.example.com/my-room` or `ws://localhost:5858/my-room`.\n\t *\n\t * Note that the protocol can also be `https` or `http` and it will upgrade to a websocket\n\t * connection.\n\t *\n\t * Optionally, you can pass a function which will be called each time a connection is\n\t * established to get the URI. This is useful if you need to include e.g. a short-lived session\n\t * token for authentication.\n\t */\n\turi: string | (() => string | Promise<string>)\n\t/**\n\t * A signal that contains the user information needed for multiplayer features.\n\t * This should be synchronized with the `userPreferences` configuration for the main `<Tldraw />` component.\n\t * If not provided, a default implementation based on localStorage will be used.\n\t */\n\tuserInfo?: TLPresenceUserInfo | Signal<TLPresenceUserInfo>\n\t/**\n\t * The asset store for blob storage. See {@link tldraw#TLAssetStore}.\n\t *\n\t * If you don't have time to implement blob storage and just want to get started, you can use the inline base64 asset store. {@link tldraw#inlineBase64AssetStore}\n\t * Note that storing base64 blobs inline in JSON is very inefficient and will cause performance issues quickly with large images and videos.\n\t */\n\tassets: TLAssetStore\n\n\t/** @internal */\n\tonMount?(editor: Editor): void\n\t/** @internal used for analytics only, we should refactor this away */\n\troomId?: string\n\t/** @internal */\n\ttrackAnalyticsEvent?(name: string, data: { [key: string]: any }): void\n\n\t/**\n\t * A reactive function that returns a {@link @tldraw/tlschema#TLInstancePresence} object. The\n\t * result of this function will be synchronized across all clients to display presence\n\t * indicators such as cursors. See {@link @tldraw/tlschema#getDefaultUserPresence} for\n\t * the default implementation of this function.\n\t */\n\tgetUserPresence?(store: TLStore, user: TLPresenceUserInfo): TLPresenceStateInfo | null\n}\n", "import { useCallback, useMemo } from 'react'\nimport {\n\tAssetRecordType,\n\tEditor,\n\tMediaHelpers,\n\tSignal,\n\tTLAsset,\n\tTLAssetStore,\n\tTLPresenceStateInfo,\n\tTLPresenceUserInfo,\n\tTLStore,\n\tTLStoreSchemaOptions,\n\tclamp,\n\tdefaultBindingUtils,\n\tdefaultShapeUtils,\n\tgetHashForString,\n\tuniqueId,\n\tuseShallowObjectIdentity,\n} from 'tldraw'\nimport { RemoteTLStoreWithStatus, useSync } from './useSync'\n\n/** @public */\nexport interface UseSyncDemoOptions {\n\t/**\n\t * The room ID to sync with. Make sure the room ID is unique. The namespace is shared by\n\t * everyone using the demo server. Consider prefixing it with your company or project name.\n\t */\n\troomId: string\n\t/**\n\t * A signal that contains the user information needed for multiplayer features.\n\t * This should be synchronized with the `userPreferences` configuration for the main `<Tldraw />` component.\n\t * If not provided, a default implementation based on localStorage will be used.\n\t */\n\tuserInfo?: TLPresenceUserInfo | Signal<TLPresenceUserInfo>\n\n\t/** @internal */\n\thost?: string\n\n\t/**\n\t * {@inheritdoc UseSyncOptions.getUserPresence}\n\t * @public\n\t */\n\tgetUserPresence?(store: TLStore, user: TLPresenceUserInfo): TLPresenceStateInfo | null\n}\n\n/**\n * Depending on the environment this package is used in, process.env may not be available. Wrap\n * `process.env` accesses in this to make sure they don't fail.\n *\n * The reason that this is just a try/catch and not a dynamic check e.g. `process &&\n * process.env[key]` is that many bundlers implement `process.env.WHATEVER` using compile-time\n * string replacement, rather than actually creating a runtime implementation of a `process` object.\n */\nfunction getEnv(cb: () => string | undefined): string | undefined {\n\ttry {\n\t\treturn cb()\n\t} catch {\n\t\treturn undefined\n\t}\n}\n\nconst DEMO_WORKER = getEnv(() => process.env.TLDRAW_BEMO_URL) ?? 'https://demo.tldraw.xyz'\nconst IMAGE_WORKER = getEnv(() => process.env.TLDRAW_IMAGE_URL) ?? 'https://images.tldraw.xyz'\n\n/**\n * Creates a tldraw store synced with a multiplayer room hosted on tldraw's demo server `https://demo.tldraw.xyz`.\n *\n * The store can be passed directly into the `<Tldraw />` component to enable multiplayer features.\n * It will handle loading states, and enable multiplayer UX like user cursors and following.\n *\n * All data on the demo server is\n *\n * - Deleted after a day or so.\n * - Publicly accessible to anyone who knows the room ID. Use your company name as a prefix to help avoid collisions, or generate UUIDs for maximum privacy.\n *\n * @example\n * ```tsx\n * function MyApp() {\n *     const store = useSyncDemo({roomId: 'my-app-test-room'})\n *     return <Tldraw store={store} />\n * }\n * ```\n *\n * @param options - Options for the multiplayer demo sync store. See {@link UseSyncDemoOptions} and {@link tldraw#TLStoreSchemaOptions}.\n *\n * @public\n */\nexport function useSyncDemo(\n\toptions: UseSyncDemoOptions & TLStoreSchemaOptions\n): RemoteTLStoreWithStatus {\n\tconst { roomId, host = DEMO_WORKER, ..._syncOpts } = options\n\tconst assets = useMemo(() => createDemoAssetStore(host), [host])\n\n\tconst syncOpts = useShallowObjectIdentity(_syncOpts)\n\tconst syncOptsWithDefaults = useMemo(() => {\n\t\tif ('schema' in syncOpts && syncOpts.schema) return syncOpts\n\n\t\treturn {\n\t\t\t...syncOpts,\n\t\t\tshapeUtils:\n\t\t\t\t'shapeUtils' in syncOpts\n\t\t\t\t\t? [...defaultShapeUtils, ...(syncOpts.shapeUtils ?? [])]\n\t\t\t\t\t: defaultShapeUtils,\n\t\t\tbindingUtils:\n\t\t\t\t'bindingUtils' in syncOpts\n\t\t\t\t\t? [...defaultBindingUtils, ...(syncOpts.bindingUtils ?? [])]\n\t\t\t\t\t: defaultBindingUtils,\n\t\t}\n\t}, [syncOpts])\n\n\treturn useSync({\n\t\turi: `${host}/connect/${encodeURIComponent(roomId)}`,\n\t\troomId,\n\t\tassets,\n\t\tonMount: useCallback(\n\t\t\t(editor: Editor) => {\n\t\t\t\teditor.registerExternalAssetHandler('url', async ({ url }) => {\n\t\t\t\t\treturn await createAssetFromUrlUsingDemoServer(host, url)\n\t\t\t\t})\n\t\t\t},\n\t\t\t[host]\n\t\t),\n\t\t...syncOptsWithDefaults,\n\t})\n}\n\nfunction createDemoAssetStore(host: string): TLAssetStore {\n\treturn {\n\t\tupload: async (asset, file) => {\n\t\t\tconst id = uniqueId()\n\n\t\t\tconst objectName = `${id}-${file.name}`.replace(/\\W/g, '-')\n\t\t\tconst url = `${host}/uploads/${objectName}`\n\n\t\t\tawait fetch(url, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\tbody: file,\n\t\t\t})\n\n\t\t\treturn { src: url }\n\t\t},\n\n\t\tresolve(asset, context) {\n\t\t\tif (!asset.props.src) return null\n\n\t\t\t// We don't deal with videos at the moment.\n\t\t\tif (asset.type === 'video') return asset.props.src\n\n\t\t\t// Assert it's an image to make TS happy.\n\t\t\tif (asset.type !== 'image') return null\n\n\t\t\t// Don't try to transform data: URLs, yikes.\n\t\t\tif (!asset.props.src.startsWith('http:') && !asset.props.src.startsWith('https:'))\n\t\t\t\treturn asset.props.src\n\n\t\t\tif (context.shouldResolveToOriginal) return asset.props.src\n\n\t\t\t// Don't try to transform animated images.\n\t\t\tif (MediaHelpers.isAnimatedImageType(asset?.props.mimeType) || asset.props.isAnimated)\n\t\t\t\treturn asset.props.src\n\n\t\t\t// Don't try to transform vector images.\n\t\t\tif (MediaHelpers.isVectorImageType(asset?.props.mimeType)) return asset.props.src\n\n\t\t\tconst url = new URL(asset.props.src)\n\n\t\t\t// we only transform images that are hosted on domains we control\n\t\t\tconst isTldrawImage =\n\t\t\t\turl.origin === host || /\\.tldraw\\.(?:com|xyz|dev|workers\\.dev)$/.test(url.host)\n\n\t\t\tif (!isTldrawImage) return asset.props.src\n\n\t\t\t// Assets that are under a certain file size aren't worth transforming (and incurring cost).\n\t\t\t// We still send them through the image worker to get them optimized though.\n\t\t\tconst { fileSize = 0 } = asset.props\n\t\t\tconst isWorthResizing = fileSize >= 1024 * 1024 * 1.5\n\n\t\t\tif (isWorthResizing) {\n\t\t\t\t// N.B. navigator.connection is only available in certain browsers (mainly Blink-based browsers)\n\t\t\t\t// 4g is as high the 'effectiveType' goes and we can pick a lower effective image quality for slower connections.\n\t\t\t\tconst networkCompensation =\n\t\t\t\t\t!context.networkEffectiveType || context.networkEffectiveType === '4g' ? 1 : 0.5\n\n\t\t\t\tconst width = Math.ceil(\n\t\t\t\t\tMath.min(\n\t\t\t\t\t\tasset.props.w *\n\t\t\t\t\t\t\tclamp(context.steppedScreenScale, 1 / 32, 1) *\n\t\t\t\t\t\t\tnetworkCompensation *\n\t\t\t\t\t\t\tcontext.dpr,\n\t\t\t\t\t\tasset.props.w\n\t\t\t\t\t)\n\t\t\t\t)\n\n\t\t\t\turl.searchParams.set('w', width.toString())\n\t\t\t}\n\n\t\t\tconst newUrl = `${IMAGE_WORKER}/${url.host}/${url.toString().slice(url.origin.length + 1)}`\n\t\t\treturn newUrl\n\t\t},\n\t}\n}\n\nasync function createAssetFromUrlUsingDemoServer(host: string, url: string): Promise<TLAsset> {\n\tconst urlHash = getHashForString(url)\n\ttry {\n\t\t// First, try to get the meta data from our endpoint\n\t\tconst fetchUrl = new URL(`${host}/bookmarks/unfurl`)\n\t\tfetchUrl.searchParams.set('url', url)\n\n\t\tconst meta = (await (await fetch(fetchUrl, { method: 'POST' })).json()) as {\n\t\t\tdescription?: string\n\t\t\timage?: string\n\t\t\tfavicon?: string\n\t\t\ttitle?: string\n\t\t} | null\n\n\t\treturn {\n\t\t\tid: AssetRecordType.createId(urlHash),\n\t\t\ttypeName: 'asset',\n\t\t\ttype: 'bookmark',\n\t\t\tprops: {\n\t\t\t\tsrc: url,\n\t\t\t\tdescription: meta?.description ?? '',\n\t\t\t\timage: meta?.image ?? '',\n\t\t\t\tfavicon: meta?.favicon ?? '',\n\t\t\t\ttitle: meta?.title ?? '',\n\t\t\t},\n\t\t\tmeta: {},\n\t\t}\n\t} catch (error) {\n\t\t// Otherwise, fallback to a blank bookmark\n\t\tconsole.error(error)\n\t\treturn {\n\t\t\tid: AssetRecordType.createId(urlHash),\n\t\t\ttypeName: 'asset',\n\t\t\ttype: 'bookmark',\n\t\t\tprops: {\n\t\t\t\tsrc: url,\n\t\t\t\tdescription: '',\n\t\t\t\timage: '',\n\t\t\t\tfavicon: '',\n\t\t\t\ttitle: '',\n\t\t\t},\n\t\t\tmeta: {},\n\t\t}\n\t}\n}\n", "import { registerTldrawLibraryVersion } from '@tldraw/utils'\n// eslint-disable-next-line local/no-export-star\nexport * from '@tldraw/sync-core'\n\nexport { useSync, type RemoteTLStoreWithStatus, type UseSyncOptions } from './useSync'\nexport { useSyncDemo, type UseSyncDemoOptions } from './useSyncDemo'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],
  "mappings": "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",
  "names": ["data", "import_lodash", "diff", "isEqual", "isEqual", "import_lodash", "_a", "isEqual", "_a", "_b", "_a", "_b", "_c", "document", "client", "import_react"]
}
