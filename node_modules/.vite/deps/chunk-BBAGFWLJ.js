import {
  require_a_callable,
  require_add_to_unscopables,
  require_es_regexp_exec,
  require_es_string_replace,
  require_export,
  require_fails,
  require_function_bind_context,
  require_function_call,
  require_function_uncurry_this,
  require_get_method,
  require_get_substitution,
  require_global_this,
  require_is_array,
  require_is_callable,
  require_is_constructor,
  require_is_object,
  require_is_pure,
  require_is_regexp,
  require_length_of_array_like,
  require_regexp_get_flags,
  require_require_object_coercible,
  require_to_integer_or_infinity,
  require_to_object,
  require_to_string,
  require_well_known_symbol
} from "./chunk-PYALTNEL.js";
import {
  require_jsx_runtime
} from "./chunk-272GJBO6.js";
import {
  require_client
} from "./chunk-36ZHPXHK.js";
import {
  require_react_dom
} from "./chunk-5EGB6KUH.js";
import {
  require_react
} from "./chunk-EFGKP4NK.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-NNPG3NYD.js";

// node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce4(func, wait, options2) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options2)) {
        leading = !!options2.leading;
        maxing = "maxWait" in options2;
        maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options2 ? !!options2.trailing : trailing;
      }
      function invokeFunc(time2) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time2;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time2) {
        lastInvokeTime = time2;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time2) : result;
      }
      function remainingWait(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time2 = now();
        if (shouldInvoke(time2)) {
          return trailingEdge(time2);
        }
        timerId = setTimeout(timerExpired, remainingWait(time2));
      }
      function trailingEdge(time2) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time2);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush2() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time2 = now(), isInvoking = shouldInvoke(time2);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time2;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush2;
      return debounced;
    }
    function throttle(func, wait, options2) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options2)) {
        leading = "leading" in options2 ? !!options2.leading : leading;
        trailing = "trailing" in options2 ? !!options2.trailing : trailing;
      }
      return debounce4(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle;
  }
});

// node_modules/lodash.uniq/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.uniq/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayIncludes(array2, value) {
      var length = array2 ? array2.length : 0;
      return !!length && baseIndexOf(array2, value, 0) > -1;
    }
    function arrayIncludesWith(array2, value, comparator) {
      var index3 = -1, length = array2 ? array2.length : 0;
      while (++index3 < length) {
        if (comparator(value, array2[index3])) {
          return true;
        }
      }
      return false;
    }
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      var length = array2.length, index3 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index3-- : ++index3 < length) {
        if (predicate(array2[index3], index3, array2)) {
          return index3;
        }
      }
      return -1;
    }
    function baseIndexOf(array2, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      var index3 = fromIndex - 1, length = array2.length;
      while (++index3 < length) {
        if (array2[index3] === value) {
          return index3;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function setToArray(set) {
      var index3 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index3] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var Set2 = getNative(root, "Set");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index3 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index3 < length) {
        var entry2 = entries[index3];
        this.set(entry2[0], entry2[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty3.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty3.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index3 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index3 < length) {
        var entry2 = entries[index3];
        this.set(entry2[0], entry2[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index3 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index3, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      return index3 < 0 ? void 0 : data[index3][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        data.push([key, value]);
      } else {
        data[index3][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index3 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index3 < length) {
        var entry2 = entries[index3];
        this.set(entry2[0], entry2[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index3 = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index3 < length) {
        this.add(values[index3]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction4(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseUniq(array2, iteratee, comparator) {
      var index3 = -1, includes = arrayIncludes, length = array2.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array2);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index3 < length) {
          var value = array2[index3], computed2 = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed2 === computed2) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed2) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed2);
            }
            result.push(value);
          } else if (!includes(seen, computed2, comparator)) {
            if (seen !== result) {
              seen.push(computed2);
            }
            result.push(value);
          }
        }
      return result;
    }
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop6 : function(values) {
      return new Set2(values);
    };
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function uniq2(array2) {
      return array2 && array2.length ? baseUniq(array2) : [];
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isFunction4(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function noop6() {
    }
    module.exports = uniq2;
  }
});

// node_modules/core-js/modules/es.array.at.js
var require_es_array_at = __commonJS({
  "node_modules/core-js/modules/es.array.at.js"() {
    "use strict";
    var $ = require_export();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var addToUnscopables = require_add_to_unscopables();
    $({ target: "Array", proto: true }, {
      at: function at2(index3) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var relativeIndex = toIntegerOrInfinity(index3);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? void 0 : O[k];
      }
    });
    addToUnscopables("at");
  }
});

// node_modules/core-js/internals/entry-unbind.js
var require_entry_unbind = __commonJS({
  "node_modules/core-js/internals/entry-unbind.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(CONSTRUCTOR, METHOD) {
      return uncurryThis(globalThis2[CONSTRUCTOR].prototype[METHOD]);
    };
  }
});

// node_modules/core-js/es/array/at.js
var require_at = __commonJS({
  "node_modules/core-js/es/array/at.js"(exports, module) {
    "use strict";
    require_es_array_at();
    var entryUnbind = require_entry_unbind();
    module.exports = entryUnbind("Array", "at");
  }
});

// node_modules/core-js/stable/array/at.js
var require_at2 = __commonJS({
  "node_modules/core-js/stable/array/at.js"(exports, module) {
    "use strict";
    var parent = require_at();
    module.exports = parent;
  }
});

// node_modules/core-js/internals/does-not-exceed-safe-integer.js
var require_does_not_exceed_safe_integer = __commonJS({
  "node_modules/core-js/internals/does-not-exceed-safe-integer.js"(exports, module) {
    "use strict";
    var $TypeError = TypeError;
    var MAX_SAFE_INTEGER = 9007199254740991;
    module.exports = function(it) {
      if (it > MAX_SAFE_INTEGER)
        throw $TypeError("Maximum allowed index exceeded");
      return it;
    };
  }
});

// node_modules/core-js/internals/flatten-into-array.js
var require_flatten_into_array = __commonJS({
  "node_modules/core-js/internals/flatten-into-array.js"(exports, module) {
    "use strict";
    var isArray = require_is_array();
    var lengthOfArrayLike = require_length_of_array_like();
    var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
    var bind3 = require_function_bind_context();
    var flattenIntoArray = function(target, original, source, sourceLen, start2, depth, mapper, thisArg) {
      var targetIndex = start2;
      var sourceIndex = 0;
      var mapFn = mapper ? bind3(mapper, thisArg) : false;
      var element, elementLen;
      while (sourceIndex < sourceLen) {
        if (sourceIndex in source) {
          element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
          if (depth > 0 && isArray(element)) {
            elementLen = lengthOfArrayLike(element);
            targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
          } else {
            doesNotExceedSafeInteger(targetIndex + 1);
            target[targetIndex] = element;
          }
          targetIndex++;
        }
        sourceIndex++;
      }
      return targetIndex;
    };
    module.exports = flattenIntoArray;
  }
});

// node_modules/core-js/internals/array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "node_modules/core-js/internals/array-species-constructor.js"(exports, module) {
    "use strict";
    var isArray = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject = require_is_object();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    var $Array = Array;
    module.exports = function(originalArray) {
      var C;
      if (isArray(originalArray)) {
        C = originalArray.constructor;
        if (isConstructor(C) && (C === $Array || isArray(C.prototype)))
          C = void 0;
        else if (isObject(C)) {
          C = C[SPECIES];
          if (C === null)
            C = void 0;
        }
      }
      return C === void 0 ? $Array : C;
    };
  }
});

// node_modules/core-js/internals/array-species-create.js
var require_array_species_create = __commonJS({
  "node_modules/core-js/internals/array-species-create.js"(exports, module) {
    "use strict";
    var arraySpeciesConstructor = require_array_species_constructor();
    module.exports = function(originalArray, length) {
      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };
  }
});

// node_modules/core-js/modules/es.array.flat-map.js
var require_es_array_flat_map = __commonJS({
  "node_modules/core-js/modules/es.array.flat-map.js"() {
    "use strict";
    var $ = require_export();
    var flattenIntoArray = require_flatten_into_array();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var arraySpeciesCreate = require_array_species_create();
    $({ target: "Array", proto: true }, {
      flatMap: function flatMap(callbackfn) {
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A;
        aCallable(callbackfn);
        A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return A;
      }
    });
  }
});

// node_modules/core-js/modules/es.array.unscopables.flat-map.js
var require_es_array_unscopables_flat_map = __commonJS({
  "node_modules/core-js/modules/es.array.unscopables.flat-map.js"() {
    "use strict";
    var addToUnscopables = require_add_to_unscopables();
    addToUnscopables("flatMap");
  }
});

// node_modules/core-js/es/array/flat-map.js
var require_flat_map = __commonJS({
  "node_modules/core-js/es/array/flat-map.js"(exports, module) {
    "use strict";
    require_es_array_flat_map();
    require_es_array_unscopables_flat_map();
    var entryUnbind = require_entry_unbind();
    module.exports = entryUnbind("Array", "flatMap");
  }
});

// node_modules/core-js/stable/array/flat-map.js
var require_flat_map2 = __commonJS({
  "node_modules/core-js/stable/array/flat-map.js"(exports, module) {
    "use strict";
    var parent = require_flat_map();
    module.exports = parent;
  }
});

// node_modules/core-js/modules/es.array.flat.js
var require_es_array_flat = __commonJS({
  "node_modules/core-js/modules/es.array.flat.js"() {
    "use strict";
    var $ = require_export();
    var flattenIntoArray = require_flatten_into_array();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var arraySpeciesCreate = require_array_species_create();
    $({ target: "Array", proto: true }, {
      flat: function flat() {
        var depthArg = arguments.length ? arguments[0] : void 0;
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity(depthArg));
        return A;
      }
    });
  }
});

// node_modules/core-js/modules/es.array.unscopables.flat.js
var require_es_array_unscopables_flat = __commonJS({
  "node_modules/core-js/modules/es.array.unscopables.flat.js"() {
    "use strict";
    var addToUnscopables = require_add_to_unscopables();
    addToUnscopables("flat");
  }
});

// node_modules/core-js/es/array/flat.js
var require_flat = __commonJS({
  "node_modules/core-js/es/array/flat.js"(exports, module) {
    "use strict";
    require_es_array_flat();
    require_es_array_unscopables_flat();
    var entryUnbind = require_entry_unbind();
    module.exports = entryUnbind("Array", "flat");
  }
});

// node_modules/core-js/stable/array/flat.js
var require_flat2 = __commonJS({
  "node_modules/core-js/stable/array/flat.js"(exports, module) {
    "use strict";
    var parent = require_flat();
    module.exports = parent;
  }
});

// node_modules/core-js/modules/es.string.at-alternative.js
var require_es_string_at_alternative = __commonJS({
  "node_modules/core-js/modules/es.string.at-alternative.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString = require_to_string();
    var fails = require_fails();
    var charAt = uncurryThis("".charAt);
    var FORCED = fails(function() {
      return "𠮷".at(-2) !== "\uD842";
    });
    $({ target: "String", proto: true, forced: FORCED }, {
      at: function at2(index3) {
        var S = toString(requireObjectCoercible(this));
        var len = S.length;
        var relativeIndex = toIntegerOrInfinity(index3);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? void 0 : charAt(S, k);
      }
    });
  }
});

// node_modules/core-js/es/string/at.js
var require_at3 = __commonJS({
  "node_modules/core-js/es/string/at.js"(exports, module) {
    "use strict";
    require_es_string_at_alternative();
    var entryUnbind = require_entry_unbind();
    module.exports = entryUnbind("String", "at");
  }
});

// node_modules/core-js/stable/string/at.js
var require_at4 = __commonJS({
  "node_modules/core-js/stable/string/at.js"(exports, module) {
    "use strict";
    var parent = require_at3();
    module.exports = parent;
  }
});

// node_modules/core-js/modules/es.string.replace-all.js
var require_es_string_replace_all = __commonJS({
  "node_modules/core-js/modules/es.string.replace-all.js"() {
    "use strict";
    var $ = require_export();
    var call2 = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var isRegExp2 = require_is_regexp();
    var toString = require_to_string();
    var getMethod2 = require_get_method();
    var getRegExpFlags = require_regexp_get_flags();
    var getSubstitution = require_get_substitution();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var REPLACE = wellKnownSymbol("replace");
    var $TypeError = TypeError;
    var indexOf = uncurryThis("".indexOf);
    var replace3 = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var max3 = Math.max;
    $({ target: "String", proto: true }, {
      replaceAll: function replaceAll(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var IS_REG_EXP, flags, replacer, string2, searchString, functionalReplace, searchLength, advanceBy, position, replacement;
        var endOfLastMatch = 0;
        var result = "";
        if (isObject(searchValue)) {
          IS_REG_EXP = isRegExp2(searchValue);
          if (IS_REG_EXP) {
            flags = toString(requireObjectCoercible(getRegExpFlags(searchValue)));
            if (!~indexOf(flags, "g"))
              throw new $TypeError("`.replaceAll` does not allow non-global regexes");
          }
          replacer = getMethod2(searchValue, REPLACE);
          if (replacer)
            return call2(replacer, searchValue, O, replaceValue);
          if (IS_PURE && IS_REG_EXP)
            return replace3(toString(O), searchValue, replaceValue);
        }
        string2 = toString(O);
        searchString = toString(searchValue);
        functionalReplace = isCallable(replaceValue);
        if (!functionalReplace)
          replaceValue = toString(replaceValue);
        searchLength = searchString.length;
        advanceBy = max3(1, searchLength);
        position = indexOf(string2, searchString);
        while (position !== -1) {
          replacement = functionalReplace ? toString(replaceValue(searchString, position, string2)) : getSubstitution(searchString, string2, position, [], void 0, replaceValue);
          result += stringSlice(string2, endOfLastMatch, position) + replacement;
          endOfLastMatch = position + searchLength;
          position = position + advanceBy > string2.length ? -1 : indexOf(string2, searchString, position + advanceBy);
        }
        if (endOfLastMatch < string2.length) {
          result += stringSlice(string2, endOfLastMatch);
        }
        return result;
      }
    });
  }
});

// node_modules/core-js/es/string/replace-all.js
var require_replace_all = __commonJS({
  "node_modules/core-js/es/string/replace-all.js"(exports, module) {
    "use strict";
    require_es_regexp_exec();
    require_es_string_replace();
    require_es_string_replace_all();
    var entryUnbind = require_entry_unbind();
    module.exports = entryUnbind("String", "replaceAll");
  }
});

// node_modules/core-js/stable/string/replace-all.js
var require_replace_all2 = __commonJS({
  "node_modules/core-js/stable/string/replace-all.js"(exports, module) {
    "use strict";
    var parent = require_replace_all();
    module.exports = parent;
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array2, predicate) {
      var index3 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index3 < length) {
        var value = array2[index3];
        if (predicate(value, index3, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array2, values) {
      var index3 = -1, length = values.length, offset5 = array2.length;
      while (++index3 < length) {
        array2[offset5 + index3] = values[index3];
      }
      return array2;
    }
    function arraySome(array2, predicate) {
      var index3 = -1, length = array2 == null ? 0 : array2.length;
      while (++index3 < length) {
        if (predicate(array2[index3], index3, array2)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index3 = -1, result = Array(n);
      while (++index3 < n) {
        result[index3] = iteratee(index3);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function mapToArray(map2) {
      var index3 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index3] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index3 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index3] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index3 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length) {
        var entry2 = entries[index3];
        this.set(entry2[0], entry2[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty3.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty3.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index3 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length) {
        var entry2 = entries[index3];
        this.set(entry2[0], entry2[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index3 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index3, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      return index3 < 0 ? void 0 : data[index3][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index3][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index3 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length) {
        var entry2 = entries[index3];
        this.set(entry2[0], entry2[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size4 = data.size;
      data.set(key, value);
      this.size += data.size == size4 ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index3 = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index3 < length) {
        this.add(values[index3]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
    }
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty3.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction4(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty3.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack2.get(array2);
      if (stacked && stack2.get(other)) {
        return stacked == other;
      }
      var index3 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack2.set(array2, other);
      stack2.set(other, array2);
      while (++index3 < arrLength) {
        var arrValue = array2[index3], othValue = other[index3];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index3, other, array2, stack2) : customizer(arrValue, othValue, index3, array2, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array2);
      stack2["delete"](other);
      return result;
    }
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack2.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index3 = objLength;
      while (index3--) {
        var key = objProps[index3];
        if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
          return false;
        }
      }
      var stacked = stack2.get(object2);
      if (stacked && stack2.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack2.set(object2, other);
      stack2.set(other, object2);
      var skipCtor = isPartial;
      while (++index3 < objLength) {
        key = objProps[index3];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object2);
      stack2["delete"](other);
      return result;
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys2, getSymbols);
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction4(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual7(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction4(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual7;
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames35() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames35.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames35.default = classNames35;
        module.exports = classNames35;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames35;
        });
      } else {
        window.classNames = classNames35;
      }
    })();
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers2 = this._events[evt];
      if (!handlers2)
        return [];
      if (handlers2.fn)
        return [handlers2.fn];
      for (var i = 0, l = handlers2.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers2[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn2 || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is2(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      function useSyncExternalStore$2(subscribe2, getSnapshot2) {
        didWarnOld18Alpha || void 0 === React105.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot2();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot2();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState76({
          inst: { value, getSnapshot: getSnapshot2 }
        });
        var inst3 = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect25(
          function() {
            inst3.value = value;
            inst3.getSnapshot = getSnapshot2;
            checkIfSnapshotChanged(inst3) && forceUpdate({ inst: inst3 });
          },
          [subscribe2, value, getSnapshot2]
        );
        useEffect89(
          function() {
            checkIfSnapshotChanged(inst3) && forceUpdate({ inst: inst3 });
            return subscribe2(function() {
              checkIfSnapshotChanged(inst3) && forceUpdate({ inst: inst3 });
            });
          },
          [subscribe2]
        );
        useDebugValue3(value);
        return value;
      }
      function checkIfSnapshotChanged(inst3) {
        var latestGetSnapshot = inst3.getSnapshot;
        inst3 = inst3.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst3, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe2, getSnapshot2) {
        return getSnapshot2();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React105 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is2, useState76 = React105.useState, useEffect89 = React105.useEffect, useLayoutEffect25 = React105.useLayoutEffect, useDebugValue3 = React105.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React105.useSyncExternalStore ? React105.useSyncExternalStore : shim2;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/lz-string/libs/lz-string.js
var require_lz_string = __commonJS({
  "node_modules/lz-string/libs/lz-string.js"(exports, module) {
    var LZString = function() {
      var f = String.fromCharCode;
      var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      var baseReverseDic = {};
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (var i = 0; i < alphabet.length; i++) {
            baseReverseDic[alphabet][alphabet.charAt(i)] = i;
          }
        }
        return baseReverseDic[alphabet][character];
      }
      var LZString2 = {
        compressToBase64: function(input) {
          if (input == null)
            return "";
          var res = LZString2._compress(input, 6, function(a) {
            return keyStrBase64.charAt(a);
          });
          switch (res.length % 4) {
            default:
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        },
        decompressFromBase64: function(input) {
          if (input == null)
            return "";
          if (input == "")
            return null;
          return LZString2._decompress(input.length, 32, function(index3) {
            return getBaseValue(keyStrBase64, input.charAt(index3));
          });
        },
        compressToUTF16: function(input) {
          if (input == null)
            return "";
          return LZString2._compress(input, 15, function(a) {
            return f(a + 32);
          }) + " ";
        },
        decompressFromUTF16: function(compressed) {
          if (compressed == null)
            return "";
          if (compressed == "")
            return null;
          return LZString2._decompress(compressed.length, 16384, function(index3) {
            return compressed.charCodeAt(index3) - 32;
          });
        },
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: function(uncompressed) {
          var compressed = LZString2.compress(uncompressed);
          var buf = new Uint8Array(compressed.length * 2);
          for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
            var current_value = compressed.charCodeAt(i);
            buf[i * 2] = current_value >>> 8;
            buf[i * 2 + 1] = current_value % 256;
          }
          return buf;
        },
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: function(compressed) {
          if (compressed === null || compressed === void 0) {
            return LZString2.decompress(compressed);
          } else {
            var buf = new Array(compressed.length / 2);
            for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
              buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
            }
            var result = [];
            buf.forEach(function(c) {
              result.push(f(c));
            });
            return LZString2.decompress(result.join(""));
          }
        },
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: function(input) {
          if (input == null)
            return "";
          return LZString2._compress(input, 6, function(a) {
            return keyStrUriSafe.charAt(a);
          });
        },
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: function(input) {
          if (input == null)
            return "";
          if (input == "")
            return null;
          input = input.replace(/ /g, "+");
          return LZString2._decompress(input.length, 32, function(index3) {
            return getBaseValue(keyStrUriSafe, input.charAt(index3));
          });
        },
        compress: function(uncompressed) {
          return LZString2._compress(uncompressed, 16, function(a) {
            return f(a);
          });
        },
        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null)
            return "";
          var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
          for (ii = 0; ii < uncompressed.length; ii += 1) {
            context_c = uncompressed.charAt(ii);
            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
              context_dictionary[context_c] = context_dictSize++;
              context_dictionaryToCreate[context_c] = true;
            }
            context_wc = context_w + context_c;
            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
              context_w = context_wc;
            } else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 8; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 16; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              context_dictionary[context_wc] = context_dictSize++;
              context_w = String(context_c);
            }
          }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
          }
          value = 2;
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
          while (true) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else
              context_data_position++;
          }
          return context_data.join("");
        },
        decompress: function(compressed) {
          if (compressed == null)
            return "";
          if (compressed == "")
            return null;
          return LZString2._decompress(compressed.length, 32768, function(index3) {
            return compressed.charCodeAt(index3);
          });
        },
        _decompress: function(length, resetValue, getNextValue) {
          var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry2 = "", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
          for (i = 0; i < 3; i += 1) {
            dictionary[i] = i;
          }
          bits = 0;
          maxpower = Math.pow(2, 2);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (next = bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 2:
              return "";
          }
          dictionary[3] = c;
          w = c;
          result.push(c);
          while (true) {
            if (data.index > length) {
              return "";
            }
            bits = 0;
            maxpower = Math.pow(2, numBits);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (c = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 2:
                return result.join("");
            }
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
            if (dictionary[c]) {
              entry2 = dictionary[c];
            } else {
              if (c === dictSize) {
                entry2 = w + w.charAt(0);
              } else {
                return null;
              }
            }
            result.push(entry2);
            dictionary[dictSize++] = w + entry2.charAt(0);
            enlargeIn--;
            w = entry2;
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
          }
        }
      };
      return LZString2;
    }();
    if (typeof define === "function" && define.amd) {
      define(function() {
        return LZString;
      });
    } else if (typeof module !== "undefined" && module != null) {
      module.exports = LZString;
    } else if (typeof angular !== "undefined" && angular != null) {
      angular.module("LZString", []).factory("LZString", function() {
        return LZString;
      });
    }
  }
});

// node_modules/@tldraw/utils/dist-esm/lib/version.mjs
var TLDRAW_LIBRARY_VERSION_KEY = "__TLDRAW_LIBRARY_VERSIONS__";
function getLibraryVersions() {
  if (globalThis[TLDRAW_LIBRARY_VERSION_KEY]) {
    return globalThis[TLDRAW_LIBRARY_VERSION_KEY];
  }
  const info = {
    versions: [],
    didWarn: false,
    scheduledNotice: null
  };
  Object.defineProperty(globalThis, TLDRAW_LIBRARY_VERSION_KEY, {
    value: info,
    writable: false,
    configurable: false,
    enumerable: false
  });
  return info;
}
function registerTldrawLibraryVersion(name, version2, modules) {
  if (!name || !version2 || !modules) {
    if (true) {
      throw new Error("Missing name/version/module system in built version of tldraw library");
    }
    return;
  }
  const info = getLibraryVersions();
  info.versions.push({ name, version: version2, modules });
  if (!info.scheduledNotice) {
    try {
      info.scheduledNotice = setTimeout(() => {
        info.scheduledNotice = null;
        checkLibraryVersions(info);
      }, 100);
    } catch {
      checkLibraryVersions(info);
    }
  }
}
function checkLibraryVersions(info) {
  if (!info.versions.length)
    return;
  if (info.didWarn)
    return;
  const sorted = info.versions.sort((a, b) => compareVersions(a.version, b.version));
  const latestVersion = sorted[sorted.length - 1].version;
  const matchingVersions = /* @__PURE__ */ new Set();
  const nonMatchingVersions = /* @__PURE__ */ new Map();
  for (const lib of sorted) {
    if (nonMatchingVersions.has(lib.name)) {
      matchingVersions.delete(lib.name);
      entry(nonMatchingVersions, lib.name, /* @__PURE__ */ new Set()).add(lib.version);
      continue;
    }
    if (lib.version === latestVersion) {
      matchingVersions.add(lib.name);
    } else {
      matchingVersions.delete(lib.name);
      entry(nonMatchingVersions, lib.name, /* @__PURE__ */ new Set()).add(lib.version);
    }
  }
  if (nonMatchingVersions.size > 0) {
    const message = [
      `${format("[tldraw]", ["bold", "bgRed", "textWhite"])} ${format("You have multiple versions of tldraw libraries installed. This can lead to bugs and unexpected behavior.", ["textRed", "bold"])}`,
      "",
      `The latest version you have installed is ${format(`v${latestVersion}`, ["bold", "textBlue"])}. The following libraries are on the latest version:`,
      ...Array.from(matchingVersions, (name) => `  • ✅ ${format(name, ["bold"])}`),
      "",
      `The following libraries are not on the latest version, or have multiple versions installed:`,
      ...Array.from(nonMatchingVersions, ([name, versions]) => {
        const sortedVersions = Array.from(versions).sort(compareVersions).map((v) => format(`v${v}`, v === latestVersion ? ["textGreen"] : ["textRed"]));
        return `  • ❌ ${format(name, ["bold"])} (${sortedVersions.join(", ")})`;
      })
    ];
    console.log(message.join("\n"));
    info.didWarn = true;
    return;
  }
  const potentialDuplicates = /* @__PURE__ */ new Map();
  for (const lib of sorted) {
    entry(potentialDuplicates, lib.name, { version: lib.version, modules: [] }).modules.push(
      lib.modules
    );
  }
  const duplicates = /* @__PURE__ */ new Map();
  for (const [name, lib] of potentialDuplicates) {
    if (lib.modules.length > 1)
      duplicates.set(name, lib);
  }
  if (duplicates.size > 0) {
    const message = [
      `${format("[tldraw]", ["bold", "bgRed", "textWhite"])} ${format("You have multiple instances of some tldraw libraries active. This can lead to bugs and unexpected behavior. ", ["textRed", "bold"])}`,
      "",
      "This usually means that your bundler is misconfigured, and is importing the same library multiple times - usually once as an ES Module, and once as a CommonJS module.",
      "",
      "The following libraries have been imported multiple times:",
      ...Array.from(duplicates, ([name, lib]) => {
        const modules = lib.modules.map((m, i) => m === "esm" ? `      ${i + 1}. ES Modules` : `      ${i + 1}. CommonJS`).join("\n");
        return `  • ❌ ${format(name, ["bold"])} v${lib.version}: 
${modules}`;
      }),
      "",
      "You should configure your bundler to only import one version of each library."
    ];
    console.log(message.join("\n"));
    info.didWarn = true;
    return;
  }
}
function compareVersions(a, b) {
  const aMatch = a.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/);
  const bMatch = b.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/);
  if (!aMatch || !bMatch)
    return a.localeCompare(b);
  if (aMatch[1] !== bMatch[1])
    return Number(aMatch[1]) - Number(bMatch[1]);
  if (aMatch[2] !== bMatch[2])
    return Number(aMatch[2]) - Number(bMatch[2]);
  if (aMatch[3] !== bMatch[3])
    return Number(aMatch[3]) - Number(bMatch[3]);
  if (aMatch[4] && bMatch[4])
    return aMatch[4].localeCompare(bMatch[4]);
  if (aMatch[4])
    return 1;
  if (bMatch[4])
    return -1;
  return 0;
}
var formats = {
  bold: "1",
  textBlue: "94",
  textRed: "31",
  textGreen: "32",
  bgRed: "41",
  textWhite: "97"
};
function format(value, formatters = []) {
  return `\x1B[${formatters.map((f) => formats[f]).join(";")}m${value}\x1B[m`;
}
function entry(map2, key, defaultValue) {
  if (map2.has(key)) {
    return map2.get(key);
  }
  map2.set(key, defaultValue);
  return defaultValue;
}

// node_modules/@tldraw/utils/dist-esm/index.mjs
var import_lodash = __toESM(require_lodash(), 1);
var import_lodash2 = __toESM(require_lodash2(), 1);

// node_modules/@tldraw/utils/dist-esm/lib/function.mjs
function omitFromStackTrace(fn2) {
  const wrappedFn = (...args) => {
    try {
      return fn2(...args);
    } catch (error) {
      if (error instanceof Error && Error.captureStackTrace) {
        Error.captureStackTrace(error, wrappedFn);
      }
      throw error;
    }
  };
  return wrappedFn;
}
var noop = () => {
};

// node_modules/@tldraw/utils/dist-esm/lib/control.mjs
var Result = {
  ok(value) {
    return { ok: true, value };
  },
  err(error) {
    return { ok: false, error };
  }
};
function exhaustiveSwitchError(value, property) {
  const debugValue = property && value && typeof value === "object" && property in value ? value[property] : value;
  throw new Error(`Unknown switch case ${debugValue}`);
}
var assert = omitFromStackTrace(
  (value, message) => {
    if (!value) {
      throw new Error(message || "Assertion Error");
    }
  }
);
var assertExists = omitFromStackTrace((value, message) => {
  if (value == null) {
    throw new Error(message ?? "value must be defined");
  }
  return value;
});
function promiseWithResolve() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return Object.assign(promise, {
    resolve,
    reject
  });
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// node_modules/@tldraw/utils/dist-esm/lib/ExecutionQueue.mjs
var ExecutionQueue = class {
  constructor(timeout) {
    __publicField(this, "queue", []);
    __publicField(this, "running", false);
    this.timeout = timeout;
  }
  isEmpty() {
    return this.queue.length === 0 && !this.running;
  }
  async run() {
    if (this.running)
      return;
    try {
      this.running = true;
      while (this.queue.length) {
        const task = this.queue.shift();
        await task();
        if (this.timeout) {
          await sleep(this.timeout);
        }
      }
    } finally {
      this.running = false;
    }
  }
  async push(task) {
    return new Promise((resolve, reject) => {
      this.queue.push(() => Promise.resolve(task()).then(resolve).catch(reject));
      this.run();
    });
  }
  close() {
    this.queue = [];
  }
};

// node_modules/@tldraw/utils/dist-esm/lib/perf.mjs
var PERFORMANCE_COLORS = {
  Good: "#40C057",
  Mid: "#FFC078",
  Poor: "#E03131"
};
var PERFORMANCE_PREFIX_COLOR = PERFORMANCE_COLORS.Good;
function measureCbDuration(name, cb) {
  const start2 = performance.now();
  const result = cb();
  console.debug(
    `%cPerf%c ${name} took ${performance.now() - start2}ms`,
    `color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,
    "font-weight: normal"
  );
  return result;
}
function measureDuration(_target, propertyKey, descriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function(...args) {
    const start2 = performance.now();
    const result = originalMethod.apply(this, args);
    console.debug(
      `%cPerf%c ${propertyKey} took: ${performance.now() - start2}ms`,
      `color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,
      "font-weight: normal"
    );
    return result;
  };
  return descriptor;
}
var averages = /* @__PURE__ */ new Map();
function measureAverageDuration(_target, propertyKey, descriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function(...args) {
    const start2 = performance.now();
    const result = originalMethod.apply(this, args);
    const end2 = performance.now();
    const length = end2 - start2;
    if (length !== 0) {
      const value = averages.get(descriptor.value);
      const total = value.total + length;
      const count3 = value.count + 1;
      averages.set(descriptor.value, { total, count: count3 });
      console.debug(
        `%cPerf%c ${propertyKey} took ${(end2 - start2).toFixed(2)}ms | average ${(total / count3).toFixed(2)}ms`,
        `color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,
        "font-weight: normal"
      );
    }
    return result;
  };
  averages.set(descriptor.value, { total: 0, count: 0 });
  return descriptor;
}

// node_modules/@tldraw/utils/dist-esm/lib/PerformanceTracker.mjs
var PerformanceTracker = class {
  constructor() {
    __publicField(this, "startTime", 0);
    __publicField(this, "name", "");
    __publicField(this, "frames", 0);
    __publicField(this, "started", false);
    __publicField(this, "frame", null);
    // eslint-disable-next-line local/prefer-class-methods
    __publicField(this, "recordFrame", () => {
      this.frames++;
      if (!this.started)
        return;
      this.frame = requestAnimationFrame(this.recordFrame);
    });
  }
  start(name) {
    this.name = name;
    this.frames = 0;
    this.started = true;
    if (this.frame !== null)
      cancelAnimationFrame(this.frame);
    this.frame = requestAnimationFrame(this.recordFrame);
    this.startTime = performance.now();
  }
  stop() {
    this.started = false;
    if (this.frame !== null)
      cancelAnimationFrame(this.frame);
    const duration = (performance.now() - this.startTime) / 1e3;
    const fps = duration === 0 ? 0 : Math.floor(this.frames / duration);
    const background = fps > 55 ? PERFORMANCE_COLORS.Good : fps > 30 ? PERFORMANCE_COLORS.Mid : PERFORMANCE_COLORS.Poor;
    const color = background === PERFORMANCE_COLORS.Mid ? "black" : "white";
    const capitalized = this.name[0].toUpperCase() + this.name.slice(1);
    console.debug(
      `%cPerf%c ${capitalized} %c${fps}%c fps`,
      `color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,
      "font-weight: normal",
      `font-weight: bold; padding: 2px; background: ${background};color: ${color};`,
      "font-weight: normal"
    );
  }
  isStarted() {
    return this.started;
  }
};

// node_modules/@tldraw/utils/dist-esm/lib/array.mjs
function rotateArray(arr, offset5) {
  return arr.map((_, i) => arr[(i + offset5) % arr.length]);
}
function dedupe(input, equals2) {
  const result = [];
  mainLoop:
    for (const item of input) {
      for (const existing of result) {
        if (equals2 ? equals2(item, existing) : item === existing) {
          continue mainLoop;
        }
      }
      result.push(item);
    }
  return result;
}
function compact(arr) {
  return arr.filter((i) => i !== void 0 && i !== null);
}
function last(arr) {
  return arr[arr.length - 1];
}
function minBy(arr, fn2) {
  let min4;
  let minVal = Infinity;
  for (const item of arr) {
    const val = fn2(item);
    if (val < minVal) {
      min4 = item;
      minVal = val;
    }
  }
  return min4;
}
function maxBy(arr, fn2) {
  let max3;
  let maxVal = -Infinity;
  for (const item of arr) {
    const val = fn2(item);
    if (val > maxVal) {
      max3 = item;
      maxVal = val;
    }
  }
  return max3;
}
function partition(arr, predicate) {
  const satisfies = [];
  const doesNotSatisfy = [];
  for (const item of arr) {
    if (predicate(item)) {
      satisfies.push(item);
    } else {
      doesNotSatisfy.push(item);
    }
  }
  return [satisfies, doesNotSatisfy];
}
function areArraysShallowEqual(arr1, arr2) {
  if (arr1 === arr2)
    return true;
  if (arr1.length !== arr2.length)
    return false;
  for (let i = 0; i < arr1.length; i++) {
    if (!Object.is(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
}
function mergeArraysAndReplaceDefaults(key, customEntries, defaults2) {
  const overrideTypes = new Set(customEntries.map((entry2) => entry2[key]));
  const result = [];
  for (const defaultEntry of defaults2) {
    if (overrideTypes.has(defaultEntry[key]))
      continue;
    result.push(defaultEntry);
  }
  for (const customEntry of customEntries) {
    result.push(customEntry);
  }
  return result;
}

// node_modules/@tldraw/utils/dist-esm/lib/bind.mjs
function bind(...args) {
  if (args.length === 2) {
    const [originalMethod, context] = args;
    context.addInitializer(function initializeMethod() {
      assert(Reflect.isExtensible(this), "Cannot bind to a non-extensible class.");
      const value = originalMethod.bind(this);
      const ok = Reflect.defineProperty(this, context.name, {
        value,
        writable: true,
        configurable: true
      });
      assert(ok, "Cannot bind a non-configurable class method.");
    });
  } else {
    const [_target, propertyKey, descriptor] = args;
    if (!descriptor || typeof descriptor.value !== "function") {
      throw new TypeError(
        `Only methods can be decorated with @bind. <${propertyKey}> is not a method!`
      );
    }
    return {
      configurable: true,
      get() {
        const bound = descriptor.value.bind(this);
        Object.defineProperty(this, propertyKey, {
          value: bound,
          configurable: true,
          writable: true
        });
        return bound;
      }
    };
  }
}

// node_modules/@tldraw/utils/dist-esm/lib/cache.mjs
var WeakCache = class {
  constructor() {
    /** The map of items to their cached values. */
    __publicField(this, "items", /* @__PURE__ */ new WeakMap());
  }
  /**
   * Get the cached value for a given record. If the record is not present in the map, the callback
   * will be used to create the value (with the result being stored in the cache for next time).
   *
   * @param item - The item to get.
   * @param cb - The callback to use to create the value when a cached value is not found.
   */
  get(item, cb) {
    if (!this.items.has(item)) {
      this.items.set(item, cb(item));
    }
    return this.items.get(item);
  }
};

// node_modules/@tldraw/utils/dist-esm/lib/debounce.mjs
function debounce(callback, wait) {
  let state = void 0;
  const fn2 = (...args) => {
    if (!state) {
      state = {};
      state.promise = new Promise((resolve, reject) => {
        state.resolve = resolve;
        state.reject = reject;
      });
    }
    clearTimeout(state.timeout);
    state.latestArgs = args;
    state.timeout = setTimeout(() => {
      const s = state;
      state = void 0;
      try {
        s.resolve(callback(...s.latestArgs));
      } catch (e) {
        s.reject(e);
      }
    }, wait);
    return state.promise;
  };
  fn2.cancel = () => {
    if (!state)
      return;
    clearTimeout(state.timeout);
  };
  return fn2;
}

// node_modules/@tldraw/utils/dist-esm/lib/error.mjs
var annotationsByError = /* @__PURE__ */ new WeakMap();
function annotateError(error, annotations) {
  if (typeof error !== "object" || error === null)
    return;
  let currentAnnotations = annotationsByError.get(error);
  if (!currentAnnotations) {
    currentAnnotations = { tags: {}, extras: {} };
    annotationsByError.set(error, currentAnnotations);
  }
  if (annotations.tags) {
    currentAnnotations.tags = {
      ...currentAnnotations.tags,
      ...annotations.tags
    };
  }
  if (annotations.extras) {
    currentAnnotations.extras = {
      ...currentAnnotations.extras,
      ...annotations.extras
    };
  }
}
function getErrorAnnotations(error) {
  return annotationsByError.get(error) ?? { tags: {}, extras: {} };
}

// node_modules/@tldraw/utils/dist-esm/lib/network.mjs
async function fetch(input, init2) {
  return window.fetch(input, {
    // We want to make sure that the referrer is not sent to other domains.
    referrerPolicy: "strict-origin-when-cross-origin",
    ...init2
  });
}
var Image = (width, height) => {
  const img = new window.Image(width, height);
  img.referrerPolicy = "strict-origin-when-cross-origin";
  return img;
};

// node_modules/@tldraw/utils/dist-esm/lib/file.mjs
var FileHelpers = class _FileHelpers {
  /**
   * @deprecated Use `urlToArrayBuffer` instead.
   */
  static async dataUrlToArrayBuffer(dataURL) {
    return fetch(dataURL).then(function(result) {
      return result.arrayBuffer();
    });
  }
  /**
   * @param url - The url of the file.
   */
  static async urlToArrayBuffer(url) {
    const response = await fetch(url);
    return await response.arrayBuffer();
  }
  static async urlToBlob(url) {
    const response = await fetch(url);
    return await response.blob();
  }
  static async urlToDataUrl(url) {
    if (url.startsWith("data:"))
      return url;
    const blob = await _FileHelpers.urlToBlob(url);
    return await _FileHelpers.blobToDataUrl(blob);
  }
  /**
   * Convert a file to a base64 encoded data url.
   *
   * @example
   *
   * ```ts
   * const A = FileHelpers.toDataUrl(myImageFile)
   * ```
   *
   * @param file - The file as a blob.
   */
  static async blobToDataUrl(file) {
    return await new Promise((resolve, reject) => {
      if (file) {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = (error) => reject(error);
        reader.onabort = (error) => reject(error);
        reader.readAsDataURL(file);
      }
    });
  }
  /**
   * Convert a file to a unicode text string.
   *
   * @example
   *
   * ```ts
   * const A = FileHelpers.fileToDataUrl(myTextFile)
   * ```
   *
   * @param file - The file as a blob.
   */
  static async blobToText(file) {
    return await new Promise((resolve, reject) => {
      if (file) {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = (error) => reject(error);
        reader.onabort = (error) => reject(error);
        reader.readAsText(file);
      }
    });
  }
  static rewriteMimeType(blob, newMimeType) {
    if (blob.type === newMimeType)
      return blob;
    if (blob instanceof File) {
      return new File([blob], blob.name, { type: newMimeType });
    }
    return new Blob([blob], { type: newMimeType });
  }
};

// node_modules/@tldraw/utils/dist-esm/lib/hash.mjs
function getHashForString(string2) {
  let hash4 = 0;
  for (let i = 0; i < string2.length; i++) {
    hash4 = (hash4 << 5) - hash4 + string2.charCodeAt(i);
    hash4 |= 0;
  }
  return hash4 + "";
}
function getHashForObject(obj) {
  return getHashForString(JSON.stringify(obj));
}
function getHashForBuffer(buffer) {
  const view = new DataView(buffer);
  let hash4 = 0;
  for (let i = 0; i < view.byteLength; i++) {
    hash4 = (hash4 << 5) - hash4 + view.getUint8(i);
    hash4 |= 0;
  }
  return hash4 + "";
}
function lns(str) {
  const result = str.split("");
  result.push(...result.splice(0, Math.round(result.length / 5)));
  result.push(...result.splice(0, Math.round(result.length / 4)));
  result.push(...result.splice(0, Math.round(result.length / 3)));
  result.push(...result.splice(0, Math.round(result.length / 2)));
  return result.reverse().map((n) => +n ? +n < 5 ? 5 + +n : +n > 5 ? +n - 5 : n : n).join("");
}

// node_modules/@tldraw/utils/dist-esm/lib/id.mjs
var crypto2 = globalThis.crypto;
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = new Uint8Array(bytes * POOL_SIZE_MULTIPLIER);
    crypto2.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto2.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function nanoid(size4 = 21) {
  fillPool(size4 -= 0);
  let id = "";
  for (let i = poolOffset - size4; i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63];
  }
  return id;
}
var impl = nanoid;
function mockUniqueId(fn2) {
  impl = fn2;
}
function restoreUniqueId() {
  impl = nanoid;
}
function uniqueId(size4) {
  return impl(size4);
}

// node_modules/@tldraw/utils/dist-esm/lib/iterable.mjs
function getFirstFromIterable(set) {
  return set.values().next().value;
}

// node_modules/@tldraw/utils/dist-esm/lib/media/apng.mjs
function isApngAnimated(buffer) {
  const view = new Uint8Array(buffer);
  if (!view || !(typeof Buffer !== "undefined" && Buffer.isBuffer(view) || view instanceof Uint8Array) || view.length < 16) {
    return false;
  }
  const isPNG = view[0] === 137 && view[1] === 80 && view[2] === 78 && view[3] === 71 && view[4] === 13 && view[5] === 10 && view[6] === 26 && view[7] === 10;
  if (!isPNG) {
    return false;
  }
  function indexOfSubstring(haystack, needle, fromIndex, upToIndex, chunksize = 1024) {
    if (!needle) {
      return -1;
    }
    needle = new RegExp(needle, "g");
    const needle_length = needle.source.length;
    const decoder = new TextDecoder();
    const full_haystack_length = haystack.length;
    if (typeof upToIndex === "undefined") {
      upToIndex = full_haystack_length;
    }
    if (fromIndex >= full_haystack_length || upToIndex <= 0 || fromIndex >= upToIndex) {
      return -1;
    }
    haystack = haystack.subarray(fromIndex, upToIndex);
    let position = -1;
    let current_index = 0;
    let full_length = 0;
    let needle_buffer = "";
    outer:
      while (current_index < haystack.length) {
        const next_index = current_index + chunksize;
        const chunk = haystack.subarray(current_index, next_index);
        const decoded = decoder.decode(chunk, { stream: true });
        const text = needle_buffer + decoded;
        let match;
        let last_index = -1;
        while ((match = needle.exec(text)) !== null) {
          last_index = match.index - needle_buffer.length;
          position = full_length + last_index;
          break outer;
        }
        current_index = next_index;
        full_length += decoded.length;
        const needle_index = last_index > -1 ? last_index + needle_length : decoded.length - needle_length;
        needle_buffer = decoded.slice(needle_index);
      }
    if (position >= 0) {
      position += fromIndex >= 0 ? fromIndex : full_haystack_length + fromIndex;
    }
    return position;
  }
  const idatIdx = indexOfSubstring(view, "IDAT", 12);
  if (idatIdx >= 12) {
    const actlIdx = indexOfSubstring(view, "acTL", 8, idatIdx);
    return actlIdx >= 8;
  }
  return false;
}

// node_modules/@tldraw/utils/dist-esm/lib/media/avif.mjs
var isAvifAnimated = (buffer) => {
  const view = new Uint8Array(buffer);
  return view[3] === 44;
};

// node_modules/@tldraw/utils/dist-esm/lib/media/gif.mjs
function getDataBlocksLength(buffer, offset5) {
  let length = 0;
  while (buffer[offset5 + length]) {
    length += buffer[offset5 + length] + 1;
  }
  return length + 1;
}
function isGIF(buffer) {
  const enc = new TextDecoder("ascii");
  const header = enc.decode(buffer.slice(0, 3));
  return header === "GIF";
}
function isGifAnimated(buffer) {
  const view = new Uint8Array(buffer);
  let hasColorTable, colorTableSize;
  let offset5 = 0;
  let imagesCount = 0;
  if (!isGIF(buffer)) {
    return false;
  }
  hasColorTable = view[10] & 128;
  colorTableSize = view[10] & 7;
  offset5 += 6;
  offset5 += 7;
  offset5 += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0;
  while (imagesCount < 2 && offset5 < view.length) {
    switch (view[offset5]) {
      case 44:
        imagesCount += 1;
        hasColorTable = view[offset5 + 9] & 128;
        colorTableSize = view[offset5 + 9] & 7;
        offset5 += 10;
        offset5 += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0;
        offset5 += getDataBlocksLength(view, offset5 + 1) + 1;
        break;
      case 33:
        offset5 += 2;
        offset5 += getDataBlocksLength(view, offset5);
        break;
      case 59:
        offset5 = view.length;
        break;
      default:
        offset5 = view.length;
        break;
    }
  }
  return imagesCount > 1;
}

// node_modules/@tldraw/utils/dist-esm/lib/media/png.mjs
var TABLE = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
if (typeof Int32Array !== "undefined") {
  TABLE = new Int32Array(TABLE);
}
var crc = (current, previous) => {
  let crc2 = previous === 0 ? 0 : ~~previous ^ -1;
  for (let index3 = 0; index3 < current.length; index3++) {
    crc2 = TABLE[(crc2 ^ current[index3]) & 255] ^ crc2 >>> 8;
  }
  return crc2 ^ -1;
};
var LEN_SIZE = 4;
var CRC_SIZE = 4;
var PngHelpers = class _PngHelpers {
  static isPng(view, offset5) {
    if (view.getUint8(offset5 + 0) === 137 && view.getUint8(offset5 + 1) === 80 && view.getUint8(offset5 + 2) === 78 && view.getUint8(offset5 + 3) === 71 && view.getUint8(offset5 + 4) === 13 && view.getUint8(offset5 + 5) === 10 && view.getUint8(offset5 + 6) === 26 && view.getUint8(offset5 + 7) === 10) {
      return true;
    }
    return false;
  }
  static getChunkType(view, offset5) {
    return [
      String.fromCharCode(view.getUint8(offset5)),
      String.fromCharCode(view.getUint8(offset5 + 1)),
      String.fromCharCode(view.getUint8(offset5 + 2)),
      String.fromCharCode(view.getUint8(offset5 + 3))
    ].join("");
  }
  static readChunks(view, offset5 = 0) {
    const chunks = {};
    if (!_PngHelpers.isPng(view, offset5)) {
      throw new Error("Not a PNG");
    }
    offset5 += 8;
    while (offset5 <= view.buffer.byteLength) {
      const start2 = offset5;
      const len = view.getInt32(offset5);
      offset5 += 4;
      const chunkType = _PngHelpers.getChunkType(view, offset5);
      if (chunkType === "IDAT" && chunks[chunkType]) {
        offset5 += len + LEN_SIZE + CRC_SIZE;
        continue;
      }
      if (chunkType === "IEND") {
        break;
      }
      chunks[chunkType] = {
        start: start2,
        dataOffset: offset5 + 4,
        size: len
      };
      offset5 += len + LEN_SIZE + CRC_SIZE;
    }
    return chunks;
  }
  static parsePhys(view, offset5) {
    return {
      ppux: view.getUint32(offset5),
      ppuy: view.getUint32(offset5 + 4),
      unit: view.getUint8(offset5 + 4)
    };
  }
  static findChunk(view, type) {
    const chunks = _PngHelpers.readChunks(view);
    return chunks[type];
  }
  static setPhysChunk(view, dpr = 1, options2) {
    let offset5 = 46;
    let size4 = 0;
    const res1 = _PngHelpers.findChunk(view, "pHYs");
    if (res1) {
      offset5 = res1.start;
      size4 = res1.size;
    }
    const res2 = _PngHelpers.findChunk(view, "IDAT");
    if (res2) {
      offset5 = res2.start;
      size4 = 0;
    }
    const pHYsData = new ArrayBuffer(21);
    const pHYsDataView = new DataView(pHYsData);
    pHYsDataView.setUint32(0, 9);
    pHYsDataView.setUint8(4, "p".charCodeAt(0));
    pHYsDataView.setUint8(5, "H".charCodeAt(0));
    pHYsDataView.setUint8(6, "Y".charCodeAt(0));
    pHYsDataView.setUint8(7, "s".charCodeAt(0));
    const DPI_96 = 2835.5;
    pHYsDataView.setInt32(8, DPI_96 * dpr);
    pHYsDataView.setInt32(12, DPI_96 * dpr);
    pHYsDataView.setInt8(16, 1);
    const crcBit = new Uint8Array(pHYsData.slice(4, 17));
    pHYsDataView.setInt32(17, crc(crcBit));
    const startBuf = view.buffer.slice(0, offset5);
    const endBuf = view.buffer.slice(offset5 + size4);
    return new Blob([startBuf, pHYsData, endBuf], options2);
  }
};

// node_modules/@tldraw/utils/dist-esm/lib/media/webp.mjs
function isWebp(view) {
  if (!view || view.length < 12) {
    return false;
  }
  return view[8] === 87 && view[9] === 69 && view[10] === 66 && view[11] === 80;
}
function isWebpAnimated(buffer) {
  const view = new Uint8Array(buffer);
  if (!isWebp(view)) {
    return false;
  }
  if (!view || view.length < 21) {
    return false;
  }
  return (view[20] >> 1 & 1) === 1;
}

// node_modules/@tldraw/utils/dist-esm/lib/media/media.mjs
var DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES = Object.freeze(["image/svg+xml"]);
var DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES = Object.freeze([
  "image/jpeg",
  "image/png",
  "image/webp"
]);
var DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES = Object.freeze([
  "image/gif",
  "image/apng",
  "image/avif"
]);
var DEFAULT_SUPPORTED_IMAGE_TYPES = Object.freeze([
  ...DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES,
  ...DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES,
  ...DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES
]);
var DEFAULT_SUPPORT_VIDEO_TYPES = Object.freeze([
  "video/mp4",
  "video/webm",
  "video/quicktime"
]);
var DEFAULT_SUPPORTED_MEDIA_TYPES = Object.freeze([
  ...DEFAULT_SUPPORTED_IMAGE_TYPES,
  ...DEFAULT_SUPPORT_VIDEO_TYPES
]);
var DEFAULT_SUPPORTED_MEDIA_TYPE_LIST = DEFAULT_SUPPORTED_MEDIA_TYPES.join(",");
var MediaHelpers = class _MediaHelpers {
  /**
   * Load a video from a url.
   * @public
   */
  static loadVideo(src) {
    return new Promise((resolve, reject) => {
      const video = document.createElement("video");
      video.onloadeddata = () => resolve(video);
      video.onerror = (e) => {
        console.error(e);
        reject(new Error("Could not load video"));
      };
      video.crossOrigin = "anonymous";
      video.src = src;
    });
  }
  static async getVideoFrameAsDataUrl(video, time2 = 0) {
    const promise = promiseWithResolve();
    let didSetTime = false;
    const onReadyStateChanged = () => {
      if (!didSetTime) {
        if (video.readyState >= video.HAVE_METADATA) {
          didSetTime = true;
          video.currentTime = time2;
        } else {
          return;
        }
      }
      if (video.readyState >= video.HAVE_CURRENT_DATA) {
        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          throw new Error("Could not get 2d context");
        }
        ctx.drawImage(video, 0, 0);
        promise.resolve(canvas.toDataURL());
      }
    };
    const onError = (e) => {
      console.error(e);
      promise.reject(new Error("Could not get video frame"));
    };
    video.addEventListener("loadedmetadata", onReadyStateChanged);
    video.addEventListener("loadeddata", onReadyStateChanged);
    video.addEventListener("canplay", onReadyStateChanged);
    video.addEventListener("seeked", onReadyStateChanged);
    video.addEventListener("error", onError);
    video.addEventListener("stalled", onError);
    onReadyStateChanged();
    try {
      return await promise;
    } finally {
      video.removeEventListener("loadedmetadata", onReadyStateChanged);
      video.removeEventListener("loadeddata", onReadyStateChanged);
      video.removeEventListener("canplay", onReadyStateChanged);
      video.removeEventListener("seeked", onReadyStateChanged);
      video.removeEventListener("error", onError);
      video.removeEventListener("stalled", onError);
    }
  }
  /**
   * Load an image from a url.
   * @public
   */
  static getImageAndDimensions(src) {
    return new Promise((resolve, reject) => {
      const img = Image();
      img.onload = () => {
        let dimensions;
        if (img.naturalWidth) {
          dimensions = {
            w: img.naturalWidth,
            h: img.naturalHeight
          };
        } else {
          document.body.appendChild(img);
          dimensions = {
            w: img.clientWidth,
            h: img.clientHeight
          };
          document.body.removeChild(img);
        }
        resolve({ ...dimensions, image: img });
      };
      img.onerror = (e) => {
        console.error(e);
        reject(new Error("Could not load image"));
      };
      img.crossOrigin = "anonymous";
      img.referrerPolicy = "strict-origin-when-cross-origin";
      img.style.visibility = "hidden";
      img.style.position = "absolute";
      img.style.opacity = "0";
      img.style.zIndex = "-9999";
      img.src = src;
    });
  }
  /**
   * Get the size of a video blob
   *
   * @param blob - A SharedBlob containing the video
   * @public
   */
  static async getVideoSize(blob) {
    return _MediaHelpers.usingObjectURL(blob, async (url) => {
      const video = await _MediaHelpers.loadVideo(url);
      return { w: video.videoWidth, h: video.videoHeight };
    });
  }
  /**
   * Get the size of an image blob
   *
   * @param blob - A Blob containing the image.
   * @public
   */
  static async getImageSize(blob) {
    const { w, h } = await _MediaHelpers.usingObjectURL(blob, _MediaHelpers.getImageAndDimensions);
    try {
      if (blob.type === "image/png") {
        const view = new DataView(await blob.arrayBuffer());
        if (PngHelpers.isPng(view, 0)) {
          const physChunk = PngHelpers.findChunk(view, "pHYs");
          if (physChunk) {
            const physData = PngHelpers.parsePhys(view, physChunk.dataOffset);
            if (physData.unit === 0 && physData.ppux === physData.ppuy) {
              const pixelsPerMeter = 72 / 0.0254;
              const pixelRatio = Math.max(physData.ppux / pixelsPerMeter, 1);
              return {
                w: Math.round(w / pixelRatio),
                h: Math.round(h / pixelRatio)
              };
            }
          }
        }
      }
    } catch (err) {
      console.error(err);
      return { w, h };
    }
    return { w, h };
  }
  static async isAnimated(file) {
    if (file.type === "image/gif") {
      return isGifAnimated(await file.arrayBuffer());
    }
    if (file.type === "image/avif") {
      return isAvifAnimated(await file.arrayBuffer());
    }
    if (file.type === "image/webp") {
      return isWebpAnimated(await file.arrayBuffer());
    }
    if (file.type === "image/apng") {
      return isApngAnimated(await file.arrayBuffer());
    }
    return false;
  }
  static isAnimatedImageType(mimeType) {
    return DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES.includes(mimeType || "");
  }
  static isStaticImageType(mimeType) {
    return DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES.includes(mimeType || "");
  }
  static isVectorImageType(mimeType) {
    return DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES.includes(mimeType || "");
  }
  static isImageType(mimeType) {
    return DEFAULT_SUPPORTED_IMAGE_TYPES.includes(mimeType || "");
  }
  static async usingObjectURL(blob, fn2) {
    const url = URL.createObjectURL(blob);
    try {
      return await fn2(url);
    } finally {
      URL.revokeObjectURL(url);
    }
  }
};

// node_modules/@tldraw/utils/dist-esm/lib/number.mjs
function lerp(a, b, t2) {
  return a + (b - a) * t2;
}
function invLerp(a, b, t2) {
  return (t2 - a) / (b - a);
}
function rng(seed = "") {
  let x = 0;
  let y = 0;
  let z = 0;
  let w = 0;
  function next() {
    const t2 = x ^ x << 11;
    x = y;
    y = z;
    z = w;
    w ^= (w >>> 19 ^ t2 ^ t2 >>> 8) >>> 0;
    return w / 4294967296 * 2;
  }
  for (let k = 0; k < seed.length + 64; k++) {
    x ^= seed.charCodeAt(k) | 0;
    next();
  }
  return next;
}
function modulate(value, rangeA, rangeB, clamp5 = false) {
  const [fromLow, fromHigh] = rangeA;
  const [v0, v1] = rangeB;
  const result = v0 + (value - fromLow) / (fromHigh - fromLow) * (v1 - v0);
  return clamp5 ? v0 < v1 ? Math.max(Math.min(result, v1), v0) : Math.max(Math.min(result, v0), v1) : result;
}

// node_modules/@tldraw/utils/dist-esm/lib/object.mjs
function hasOwnProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function getOwnProperty(obj, key) {
  if (!hasOwnProperty(obj, key)) {
    return void 0;
  }
  return obj[key];
}
function objectMapKeys(object2) {
  return Object.keys(object2);
}
function objectMapValues(object2) {
  return Object.values(object2);
}
function objectMapEntries(object2) {
  return Object.entries(object2);
}
function objectMapFromEntries(entries) {
  return Object.fromEntries(entries);
}
function filterEntries(object2, predicate) {
  const result = {};
  let didChange = false;
  for (const [key, value] of objectMapEntries(object2)) {
    if (predicate(key, value)) {
      result[key] = value;
    } else {
      didChange = true;
    }
  }
  return didChange ? result : object2;
}
function mapObjectMapValues(object2, mapper) {
  const result = {};
  for (const [key, value] of objectMapEntries(object2)) {
    const newValue = mapper(key, value);
    result[key] = newValue;
  }
  return result;
}
function areObjectsShallowEqual(obj1, obj2) {
  if (obj1 === obj2)
    return true;
  const keys1 = new Set(Object.keys(obj1));
  const keys2 = new Set(Object.keys(obj2));
  if (keys1.size !== keys2.size)
    return false;
  for (const key of keys1) {
    if (!keys2.has(key))
      return false;
    if (!Object.is(obj1[key], obj2[key]))
      return false;
  }
  return true;
}
function groupBy(array2, keySelector) {
  const result = {};
  for (const value of array2) {
    const key = keySelector(value);
    if (!result[key])
      result[key] = [];
    result[key].push(value);
  }
  return result;
}
function omit(obj, keys2) {
  const result = { ...obj };
  for (const key of keys2) {
    delete result[key];
  }
  return result;
}

// node_modules/fractional-indexing-jittered/lib/index.js
function indexCharacterSet(options2) {
  const dicts = createCharSetDicts(options2.chars);
  const limits = integerLimits(
    dicts,
    options2.firstPositive,
    options2.mostPositive,
    options2.mostNegative
  );
  const jitterRange = options2.jitterRange ?? Math.floor(Math.pow(dicts.length, 3) / 5);
  const paddingRange = paddingDict(jitterRange, dicts.length);
  return {
    chars: options2.chars,
    byChar: dicts.byChar,
    byCode: dicts.byCode,
    length: dicts.length,
    first: dicts.byCode[0],
    last: dicts.byCode[dicts.length - 1],
    firstPositive: limits.firstPositive,
    mostPositive: limits.mostPositive,
    firstNegative: limits.firstNegative,
    mostNegative: limits.mostNegative,
    jitterRange,
    paddingDict: paddingRange
  };
}
function createCharSetDicts(charSet) {
  const byCode = {};
  const byChar = {};
  const length = charSet.length;
  for (let i = 0; i < length; i++) {
    const char = charSet[i];
    byCode[i] = char;
    byChar[char] = i;
  }
  return {
    byCode,
    byChar,
    length
  };
}
function integerLimits(dicts, firstPositive, mostPositive, mostNegative) {
  const firstPositiveIndex = firstPositive ? dicts.byChar[firstPositive] : Math.ceil(dicts.length / 2);
  const mostPositiveIndex = mostPositive ? dicts.byChar[mostPositive] : dicts.length - 1;
  const mostNegativeIndex = mostNegative ? dicts.byChar[mostNegative] : 0;
  if (firstPositiveIndex === void 0 || mostPositiveIndex === void 0 || mostNegativeIndex === void 0) {
    throw new Error("invalid charSet");
  }
  if (mostPositiveIndex - firstPositiveIndex < 3) {
    throw new Error(
      "mostPositive must be at least 3 characters away from neutral"
    );
  }
  if (firstPositiveIndex - mostNegativeIndex < 3) {
    throw new Error(
      "mostNegative must be at least 3 characters away from neutral"
    );
  }
  return {
    firstPositive: dicts.byCode[firstPositiveIndex],
    mostPositive: dicts.byCode[mostPositiveIndex],
    firstNegative: dicts.byCode[firstPositiveIndex - 1],
    mostNegative: dicts.byCode[mostNegativeIndex]
  };
}
function paddingDict(jitterRange, charSetLength) {
  const paddingDict2 = {};
  let distance = 0;
  for (let i = 0; i < 100; i++) {
    paddingDict2[i] = Math.pow(charSetLength, i);
    if (paddingDict2[i] > jitterRange) {
      break;
    }
  }
  return paddingDict2;
}
var _base62CharSet = null;
function base62CharSet() {
  if (_base62CharSet)
    return _base62CharSet;
  return _base62CharSet = indexCharacterSet({
    // Base62 are all the alphanumeric characters, database and user friendly
    // For shorter strings and more room you could opt for more characters
    chars: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    // This gives us nice human readable keys to start with a0 a1 etc
    firstPositive: "a",
    mostPositive: "z",
    mostNegative: "A"
  });
}
function distanceBetween(a, b, charSet) {
  const indexA = charSet.byChar[a];
  const indexB = charSet.byChar[b];
  return Math.abs(indexA - indexB);
}
function integerLength(head, charSet) {
  const firstChar = head[0];
  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {
    throw new Error("invalid firstChar on key");
  }
  if (firstChar === charSet.mostPositive) {
    const firstLevel = distanceBetween(firstChar, charSet.firstPositive, charSet) + 1;
    return firstLevel + integerLengthFromSecondLevel(head.slice(1), "positive", charSet);
  }
  if (firstChar === charSet.mostNegative) {
    const firstLevel = distanceBetween(firstChar, charSet.firstNegative, charSet) + 1;
    return firstLevel + integerLengthFromSecondLevel(head.slice(1), "negative", charSet);
  }
  const isPositiveRange = firstChar >= charSet.firstPositive;
  if (isPositiveRange) {
    return distanceBetween(firstChar, charSet.firstPositive, charSet) + 2;
  } else {
    return distanceBetween(firstChar, charSet.firstNegative, charSet) + 2;
  }
}
function integerLengthFromSecondLevel(key, direction, charSet) {
  const firstChar = key[0];
  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {
    throw new Error("invalid firstChar on key");
  }
  if (firstChar === charSet.mostPositive && direction === "positive") {
    const totalPositiveRoom = distanceBetween(firstChar, charSet.mostNegative, charSet) + 1;
    return totalPositiveRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);
  }
  if (firstChar === charSet.mostNegative && direction === "negative") {
    const totalNegativeRoom = distanceBetween(firstChar, charSet.mostPositive, charSet) + 1;
    return totalNegativeRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);
  }
  if (direction === "positive") {
    return distanceBetween(firstChar, charSet.mostNegative, charSet) + 2;
  } else {
    return distanceBetween(firstChar, charSet.mostPositive, charSet) + 2;
  }
}
function makeSameLength(a, b, pad, fillChar, forceLength) {
  const max3 = forceLength ?? Math.max(a.length, b.length);
  if (pad === "start") {
    return [a.padStart(max3, fillChar), b.padStart(max3, fillChar)];
  }
  return [a.padEnd(max3, fillChar), b.padEnd(max3, fillChar)];
}
function midPoint(lower, upper, charSet) {
  let [paddedLower, paddedUpper] = makeSameLength(
    lower,
    upper,
    "end",
    charSet.first
  );
  let distance = lexicalDistance(paddedLower, paddedUpper, charSet);
  if (distance === 1) {
    paddedLower = paddedLower.padEnd(paddedLower.length + 1, charSet.first);
    distance = charSet.length;
  }
  const mid = encodeToCharSet(Math.floor(distance / 2), charSet);
  return addCharSetKeys(paddedLower, mid, charSet);
}
function lexicalDistance(a, b, charSet) {
  const [lower, upper] = makeSameLength(a, b, "end", charSet.first).sort();
  const distance = subtractCharSetKeys(upper, lower, charSet);
  return decodeCharSetToNumber(distance, charSet);
}
function addCharSetKeys(a, b, charSet) {
  const base2 = charSet.length;
  const [paddedA, paddedB] = makeSameLength(a, b, "start", charSet.first);
  const result = [];
  let carry = 0;
  for (let i = paddedA.length - 1; i >= 0; i--) {
    const digitA = charSet.byChar[paddedA[i]];
    const digitB = charSet.byChar[paddedB[i]];
    const sum = digitA + digitB + carry;
    carry = Math.floor(sum / base2);
    const remainder = sum % base2;
    result.unshift(charSet.byCode[remainder]);
  }
  if (carry > 0) {
    result.unshift(charSet.byCode[carry]);
  }
  return result.join("");
}
function subtractCharSetKeys(a, b, charSet) {
  const base2 = charSet.length;
  const [paddedA, paddedB] = makeSameLength(a, b, "start", charSet.first);
  const result = [];
  let borrow = 0;
  for (let i = paddedA.length - 1; i >= 0; i--) {
    let digitA = charSet.byChar[paddedA[i]];
    const digitB = charSet.byChar[paddedB[i]] + borrow;
    if (digitA < digitB) {
      borrow = 1;
      digitA += base2;
    } else {
      borrow = 0;
    }
    const difference = digitA - digitB;
    result.unshift(charSet.byCode[difference]);
  }
  if (borrow > 0) {
    throw new Error(
      "Subtraction result is negative. Ensure a is greater than or equal to b."
    );
  }
  while (result.length > 1 && result[0] === charSet.byCode[0]) {
    result.shift();
  }
  return result.join("");
}
function incrementKey(key, charSet) {
  return addCharSetKeys(key, charSet.byCode[1], charSet);
}
function decrementKey(key, charSet) {
  return subtractCharSetKeys(key, charSet.byCode[1], charSet);
}
function encodeToCharSet(int, charSet) {
  if (int === 0) {
    return charSet.byCode[0];
  }
  let res = "";
  const max3 = charSet.length;
  while (int > 0) {
    res = charSet.byCode[int % max3] + res;
    int = Math.floor(int / max3);
  }
  return res;
}
function decodeCharSetToNumber(key, charSet) {
  let res = 0;
  const length = key.length;
  const max3 = charSet.length;
  for (let i = 0; i < length; i++) {
    res += charSet.byChar[key[i]] * Math.pow(max3, length - i - 1);
  }
  return res;
}
function startKey(charSet) {
  return charSet.firstPositive + charSet.byCode[0];
}
function validInteger(integer2, charSet) {
  const length = integerLength(integer2, charSet);
  return length === integer2.length;
}
function validateOrderKey(orderKey, charSet) {
  getIntegerPart(orderKey, charSet);
}
function getIntegerPart(orderKey, charSet) {
  const head = integerHead(orderKey, charSet);
  const integerPartLength = integerLength(head, charSet);
  if (integerPartLength > orderKey.length) {
    throw new Error("invalid order key length: " + orderKey);
  }
  return orderKey.slice(0, integerPartLength);
}
function validateInteger(integer2, charSet) {
  if (!validInteger(integer2, charSet)) {
    throw new Error("invalid integer length: " + integer2);
  }
}
function incrementInteger(integer2, charSet) {
  validateInteger(integer2, charSet);
  const [head, digs] = splitInteger(integer2, charSet);
  const anyNonMaxedDigit = digs.split("").some((d) => d !== charSet.byCode[charSet.length - 1]);
  if (anyNonMaxedDigit) {
    const newDigits = incrementKey(digs, charSet);
    return head + newDigits;
  }
  const nextHead = incrementIntegerHead(head, charSet);
  return startOnNewHead(nextHead, "lower", charSet);
}
function decrementInteger(integer2, charSet) {
  validateInteger(integer2, charSet);
  const [head, digs] = splitInteger(integer2, charSet);
  const anyNonLimitDigit = digs.split("").some((d) => d !== charSet.byCode[0]);
  if (anyNonLimitDigit) {
    const newDigits = decrementKey(digs, charSet);
    return head + newDigits;
  }
  const nextHead = decrementIntegerHead(head, charSet);
  return startOnNewHead(nextHead, "upper", charSet);
}
function integerHead(integer2, charSet) {
  let i = 0;
  if (integer2[0] === charSet.mostPositive) {
    while (integer2[i] === charSet.mostPositive) {
      i = i + 1;
    }
  }
  if (integer2[0] === charSet.mostNegative) {
    while (integer2[i] === charSet.mostNegative) {
      i = i + 1;
    }
  }
  return integer2.slice(0, i + 1);
}
function splitInteger(integer2, charSet) {
  const head = integerHead(integer2, charSet);
  const tail = integer2.slice(head.length);
  return [head, tail];
}
function incrementIntegerHead(head, charSet) {
  const inPositiveRange = head >= charSet.firstPositive;
  const nextHead = incrementKey(head, charSet);
  const headIsLimitMax = head[head.length - 1] === charSet.mostPositive;
  const nextHeadIsLimitMax = nextHead[nextHead.length - 1] === charSet.mostPositive;
  if (inPositiveRange && nextHeadIsLimitMax) {
    return nextHead + charSet.mostNegative;
  }
  if (!inPositiveRange && headIsLimitMax) {
    return head.slice(0, head.length - 1);
  }
  return nextHead;
}
function decrementIntegerHead(head, charSet) {
  const inPositiveRange = head >= charSet.firstPositive;
  const headIsLimitMin = head[head.length - 1] === charSet.mostNegative;
  if (inPositiveRange && headIsLimitMin) {
    const nextLevel = head.slice(0, head.length - 1);
    return decrementKey(nextLevel, charSet);
  }
  if (!inPositiveRange && headIsLimitMin) {
    return head + charSet.mostPositive;
  }
  return decrementKey(head, charSet);
}
function startOnNewHead(head, limit, charSet) {
  const newLength = integerLength(head, charSet);
  const fillChar = limit === "upper" ? charSet.byCode[charSet.length - 1] : charSet.byCode[0];
  return head + fillChar.repeat(newLength - head.length);
}
function jitterString(orderKey, charSet) {
  const shift5 = encodeToCharSet(
    Math.floor(Math.random() * charSet.jitterRange),
    charSet
  );
  return addCharSetKeys(orderKey, shift5, charSet);
}
function padAndJitterString(orderKey, numberOfChars, charSet) {
  const paddedKey = orderKey.padEnd(
    orderKey.length + numberOfChars,
    charSet.first
  );
  return jitterString(paddedKey, charSet);
}
function paddingNeededForJitter(orderKey, b, charSet) {
  const integer2 = getIntegerPart(orderKey, charSet);
  const nextInteger = incrementInteger(integer2, charSet);
  let needed = 0;
  if (b !== null) {
    const distanceToB = lexicalDistance(orderKey, b, charSet);
    if (distanceToB < charSet.jitterRange + 1) {
      needed = Math.max(needed, paddingNeededForDistance(distanceToB, charSet));
    }
  }
  const distanceToNextInteger = lexicalDistance(orderKey, nextInteger, charSet);
  if (distanceToNextInteger < charSet.jitterRange + 1) {
    needed = Math.max(
      needed,
      paddingNeededForDistance(distanceToNextInteger, charSet)
    );
  }
  return needed;
}
function paddingNeededForDistance(distance, charSet) {
  const gap = charSet.jitterRange - distance;
  const firstBigger = Object.entries(charSet.paddingDict).find(
    ([_key, value]) => {
      return value > gap;
    }
  );
  return firstBigger ? parseInt(firstBigger[0]) : 0;
}
function generateKeyBetween(lower, upper, charSet = base62CharSet()) {
  if (lower !== null) {
    validateOrderKey(lower, charSet);
  }
  if (upper !== null) {
    validateOrderKey(upper, charSet);
  }
  if (lower === null && upper === null) {
    return startKey(charSet);
  }
  if (lower === null) {
    const integer2 = getIntegerPart(upper, charSet);
    return decrementInteger(integer2, charSet);
  }
  if (upper === null) {
    const integer2 = getIntegerPart(lower, charSet);
    return incrementInteger(integer2, charSet);
  }
  if (lower >= upper) {
    throw new Error(lower + " >= " + upper);
  }
  return midPoint(lower, upper, charSet);
}
function generateJitteredKeyBetween(lower, upper, charSet = base62CharSet()) {
  const key = generateKeyBetween(lower, upper, charSet);
  const paddingNeeded = paddingNeededForJitter(key, upper, charSet);
  if (paddingNeeded) {
    return padAndJitterString(key, paddingNeeded, charSet);
  }
  return jitterString(key, charSet);
}
function generateNJitteredKeysBetween(lower, upper, n, charSet = base62CharSet()) {
  return spreadGeneratorResults(
    lower,
    upper,
    n,
    charSet,
    generateJitteredKeyBetween,
    generateNJitteredKeysBetween
  );
}
function spreadGeneratorResults(lower, upper, n, charSet, generateKey, generateNKeys) {
  if (n === 0) {
    return [];
  }
  if (n === 1) {
    return [generateKey(lower, upper, charSet)];
  }
  if (upper == null) {
    let newUpper = generateKey(lower, upper, charSet);
    const result = [newUpper];
    for (let i = 0; i < n - 1; i++) {
      newUpper = generateKey(newUpper, upper, charSet);
      result.push(newUpper);
    }
    return result;
  }
  if (lower == null) {
    let newLower = generateKey(lower, upper, charSet);
    const result = [newLower];
    for (let i = 0; i < n - 1; i++) {
      newLower = generateKey(lower, newLower, charSet);
      result.push(newLower);
    }
    result.reverse();
    return result;
  }
  const mid = Math.floor(n / 2);
  const midOrderKey = generateKey(lower, upper, charSet);
  return [
    ...generateNKeys(lower, midOrderKey, mid, charSet),
    midOrderKey,
    ...generateNKeys(midOrderKey, upper, n - mid - 1, charSet)
  ];
}

// node_modules/@tldraw/utils/dist-esm/lib/reordering.mjs
var generateKeysFn = false ? generateNKeysBetween : generateNJitteredKeysBetween;
var ZERO_INDEX_KEY = "a0";
function validateIndexKey(index3) {
  try {
    generateJitteredKeyBetween(index3, null);
  } catch {
    throw new Error("invalid index: " + index3);
  }
}
function getIndicesBetween(below, above, n) {
  return generateKeysFn(below ?? null, above ?? null, n);
}
function getIndicesAbove(below, n) {
  return generateKeysFn(below ?? null, null, n);
}
function getIndicesBelow(above, n) {
  return generateKeysFn(null, above ?? null, n);
}
function getIndexBetween(below, above) {
  return generateKeysFn(below ?? null, above ?? null, 1)[0];
}
function getIndexAbove(below = null) {
  return generateKeysFn(below, null, 1)[0];
}
function getIndexBelow(above = null) {
  return generateKeysFn(null, above, 1)[0];
}
function getIndices(n, start2 = "a1") {
  return [start2, ...generateKeysFn(start2, null, n)];
}
function sortByIndex(a, b) {
  if (a.index < b.index) {
    return -1;
  } else if (a.index > b.index) {
    return 1;
  }
  return 0;
}

// node_modules/@tldraw/utils/dist-esm/lib/retry.mjs
async function retry(fn2, {
  attempts = 3,
  waitDuration = 1e3,
  abortSignal,
  matchError
} = {}) {
  let error = null;
  for (let i = 0; i < attempts; i++) {
    if (abortSignal == null ? void 0 : abortSignal.aborted)
      throw new Error("aborted");
    try {
      return await fn2();
    } catch (e) {
      if (matchError && !matchError(e))
        throw e;
      error = e;
      await sleep(waitDuration);
    }
  }
  throw error;
}

// node_modules/@tldraw/utils/dist-esm/lib/sort.mjs
function sortById(a, b) {
  return a.id > b.id ? 1 : -1;
}

// node_modules/@tldraw/utils/dist-esm/lib/storage.mjs
function getFromLocalStorage(key) {
  try {
    return localStorage.getItem(key);
  } catch {
    return null;
  }
}
function setInLocalStorage(key, value) {
  try {
    localStorage.setItem(key, value);
  } catch {
  }
}
function deleteFromLocalStorage(key) {
  try {
    localStorage.removeItem(key);
  } catch {
  }
}
function clearLocalStorage() {
  try {
    localStorage.clear();
  } catch {
  }
}
function getFromSessionStorage(key) {
  try {
    return sessionStorage.getItem(key);
  } catch {
    return null;
  }
}
function setInSessionStorage(key, value) {
  try {
    sessionStorage.setItem(key, value);
  } catch {
  }
}
function deleteFromSessionStorage(key) {
  try {
    sessionStorage.removeItem(key);
  } catch {
  }
}
function clearSessionStorage() {
  try {
    sessionStorage.clear();
  } catch {
  }
}

// node_modules/@tldraw/utils/dist-esm/lib/stringEnum.mjs
function stringEnum(...values) {
  const obj = {};
  for (const value of values) {
    obj[value] = value;
  }
  return obj;
}

// node_modules/@tldraw/utils/dist-esm/lib/throttle.mjs
var isTest = () => typeof process !== "undefined" && false;
var fpsQueue = [];
var targetFps = 60;
var targetTimePerFrame = Math.ceil(1e3 / targetFps);
var frame;
var time = 0;
var last2 = 0;
var flush = () => {
  const queue = fpsQueue.splice(0, fpsQueue.length);
  for (const fn2 of queue) {
    fn2();
  }
};
function tick() {
  if (frame) {
    return;
  }
  const now = Date.now();
  const elapsed = now - last2;
  if (time + elapsed < targetTimePerFrame) {
    frame = requestAnimationFrame(() => {
      frame = void 0;
      tick();
    });
    return;
  }
  frame = requestAnimationFrame(() => {
    frame = void 0;
    last2 = now;
    time = Math.min(time + elapsed - targetTimePerFrame, targetTimePerFrame * 10);
    flush();
  });
}
var started = false;
function fpsThrottle(fn2) {
  if (isTest()) {
    fn2.cancel = () => frame && cancelAnimationFrame(frame);
    return fn2;
  }
  const throttledFn = () => {
    if (fpsQueue.includes(fn2)) {
      return;
    }
    fpsQueue.push(fn2);
    if (!started) {
      started = true;
      last2 = Date.now() - targetTimePerFrame - 1;
    }
    tick();
  };
  throttledFn.cancel = () => {
    const index3 = fpsQueue.indexOf(fn2);
    if (index3 > -1) {
      fpsQueue.splice(index3, 1);
    }
  };
  return throttledFn;
}
function throttleToNextFrame(fn2) {
  if (isTest()) {
    fn2();
    return () => {
    };
  }
  if (!fpsQueue.includes(fn2)) {
    fpsQueue.push(fn2);
    if (!started) {
      started = true;
      last2 = Date.now() - targetTimePerFrame - 1;
    }
    tick();
  }
  return () => {
    const index3 = fpsQueue.indexOf(fn2);
    if (index3 > -1) {
      fpsQueue.splice(index3, 1);
    }
  };
}

// node_modules/@tldraw/utils/dist-esm/lib/timers.mjs
var Timers = class {
  constructor() {
    __publicField(this, "timeouts", /* @__PURE__ */ new Map());
    __publicField(this, "intervals", /* @__PURE__ */ new Map());
    __publicField(this, "rafs", /* @__PURE__ */ new Map());
    this.setTimeout = this.setTimeout.bind(this);
    this.setInterval = this.setInterval.bind(this);
    this.requestAnimationFrame = this.requestAnimationFrame.bind(this);
    this.dispose = this.dispose.bind(this);
  }
  /** @public */
  setTimeout(contextId, handler, timeout, ...args) {
    const id = window.setTimeout(handler, timeout, args);
    const current = this.timeouts.get(contextId) ?? [];
    this.timeouts.set(contextId, [...current, id]);
    return id;
  }
  /** @public */
  setInterval(contextId, handler, timeout, ...args) {
    const id = window.setInterval(handler, timeout, args);
    const current = this.intervals.get(contextId) ?? [];
    this.intervals.set(contextId, [...current, id]);
    return id;
  }
  /** @public */
  requestAnimationFrame(contextId, callback) {
    const id = window.requestAnimationFrame(callback);
    const current = this.rafs.get(contextId) ?? [];
    this.rafs.set(contextId, [...current, id]);
    return id;
  }
  /** @public */
  dispose(contextId) {
    var _a5, _b, _c;
    (_a5 = this.timeouts.get(contextId)) == null ? void 0 : _a5.forEach((id) => clearTimeout(id));
    (_b = this.intervals.get(contextId)) == null ? void 0 : _b.forEach((id) => clearInterval(id));
    (_c = this.rafs.get(contextId)) == null ? void 0 : _c.forEach((id) => cancelAnimationFrame(id));
    this.timeouts.delete(contextId);
    this.intervals.delete(contextId);
    this.rafs.delete(contextId);
  }
  disposeAll() {
    for (const contextId of this.timeouts.keys()) {
      this.dispose(contextId);
    }
  }
  forContext(contextId) {
    return {
      setTimeout: (handler, timeout, ...args) => this.setTimeout(contextId, handler, timeout, args),
      setInterval: (handler, timeout, ...args) => this.setInterval(contextId, handler, timeout, args),
      requestAnimationFrame: (callback) => this.requestAnimationFrame(contextId, callback),
      dispose: () => this.dispose(contextId)
    };
  }
};

// node_modules/@tldraw/utils/dist-esm/lib/url.mjs
var safeParseUrl = (url, baseUrl) => {
  try {
    return new URL(url, baseUrl);
  } catch {
    return;
  }
};

// node_modules/@tldraw/utils/dist-esm/lib/value.mjs
function isDefined(value) {
  return value !== void 0;
}
function isNonNull(value) {
  return value !== null;
}
function isNonNullish(value) {
  return value !== null && value !== void 0;
}
function getStructuredClone() {
  if (typeof globalThis !== "undefined" && globalThis.structuredClone) {
    return [globalThis.structuredClone, true];
  }
  if (typeof global !== "undefined" && global.structuredClone) {
    return [global.structuredClone, true];
  }
  if (typeof window !== "undefined" && window.structuredClone) {
    return [window.structuredClone, true];
  }
  return [(i) => i ? JSON.parse(JSON.stringify(i)) : i, false];
}
var _structuredClone = getStructuredClone();
var structuredClone = _structuredClone[0];
var isNativeStructuredClone = _structuredClone[1];
var STRUCTURED_CLONE_OBJECT_PROTOTYPE = Object.getPrototypeOf(structuredClone({}));

// node_modules/@tldraw/utils/dist-esm/lib/warn.mjs
var usedWarnings = /* @__PURE__ */ new Set();
function warnDeprecatedGetter(name) {
  warnOnce(
    `Using '${name}' is deprecated and will be removed in the near future. Please refactor to use 'get${name[0].toLocaleUpperCase()}${name.slice(
      1
    )}' instead.`
  );
}
function warnOnce(message) {
  if (usedWarnings.has(message))
    return;
  usedWarnings.add(message);
  console.warn(`[tldraw] ${message}`);
}

// node_modules/@tldraw/utils/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "@tldraw/utils",
  "3.13.1",
  "esm"
);

// node_modules/@tldraw/editor/dist-esm/index.mjs
var import_at = __toESM(require_at2(), 1);
var import_flat_map = __toESM(require_flat_map2(), 1);
var import_flat = __toESM(require_flat2(), 1);
var import_at2 = __toESM(require_at4(), 1);
var import_replace_all = __toESM(require_replace_all2(), 1);

// node_modules/@tldraw/state/dist-esm/lib/helpers.mjs
function isChild(x) {
  return x && typeof x === "object" && "parents" in x;
}
function haveParentsChanged(child) {
  for (let i = 0, n = child.parents.length; i < n; i++) {
    child.parents[i].__unsafe__getWithoutCapture(true);
    if (child.parents[i].lastChangedEpoch !== child.parentEpochs[i]) {
      return true;
    }
  }
  return false;
}
function detach(parent, child) {
  if (!parent.children.remove(child)) {
    return;
  }
  if (parent.children.isEmpty && isChild(parent)) {
    for (let i = 0, n = parent.parents.length; i < n; i++) {
      detach(parent.parents[i], parent);
    }
  }
}
function attach(parent, child) {
  if (!parent.children.add(child)) {
    return;
  }
  if (isChild(parent)) {
    for (let i = 0, n = parent.parents.length; i < n; i++) {
      attach(parent.parents[i], parent);
    }
  }
}
function equals(a, b) {
  const shallowEquals = a === b || Object.is(a, b) || Boolean(a && b && typeof a.equals === "function" && a.equals(b));
  return shallowEquals;
}
function singleton(key, init2) {
  const symbol = Symbol.for(`com.tldraw.state/${key}`);
  const global2 = globalThis;
  global2[symbol] ?? (global2[symbol] = init2());
  return global2[symbol];
}
var EMPTY_ARRAY = singleton("empty_array", () => Object.freeze([]));

// node_modules/@tldraw/state/dist-esm/lib/ArraySet.mjs
var ARRAY_SIZE_THRESHOLD = 8;
var ArraySet = class {
  constructor() {
    __publicField(this, "arraySize", 0);
    __publicField(this, "array", Array(ARRAY_SIZE_THRESHOLD));
    __publicField(this, "set", null);
  }
  /**
   * Get whether this ArraySet has any elements.
   *
   * @returns True if this ArraySet has any elements, false otherwise.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isEmpty() {
    if (this.array) {
      return this.arraySize === 0;
    }
    if (this.set) {
      return this.set.size === 0;
    }
    throw new Error("no set or array");
  }
  /**
   * Add an item to the ArraySet if it is not already present.
   *
   * @param elem - The element to add.
   */
  add(elem) {
    if (this.array) {
      const idx = this.array.indexOf(elem);
      if (idx !== -1) {
        return false;
      }
      if (this.arraySize < ARRAY_SIZE_THRESHOLD) {
        this.array[this.arraySize] = elem;
        this.arraySize++;
        return true;
      } else {
        this.set = new Set(this.array);
        this.array = null;
        this.set.add(elem);
        return true;
      }
    }
    if (this.set) {
      if (this.set.has(elem)) {
        return false;
      }
      this.set.add(elem);
      return true;
    }
    throw new Error("no set or array");
  }
  /**
   * Remove an item from the ArraySet if it is present.
   *
   * @param elem - The element to remove
   */
  remove(elem) {
    if (this.array) {
      const idx = this.array.indexOf(elem);
      if (idx === -1) {
        return false;
      }
      this.array[idx] = void 0;
      this.arraySize--;
      if (idx !== this.arraySize) {
        this.array[idx] = this.array[this.arraySize];
        this.array[this.arraySize] = void 0;
      }
      return true;
    }
    if (this.set) {
      if (!this.set.has(elem)) {
        return false;
      }
      this.set.delete(elem);
      return true;
    }
    throw new Error("no set or array");
  }
  /**
   * Run a callback for each element in the ArraySet.
   *
   * @param visitor - The callback to run for each element.
   */
  visit(visitor) {
    if (this.array) {
      for (let i = 0; i < this.arraySize; i++) {
        const elem = this.array[i];
        if (typeof elem !== "undefined") {
          visitor(elem);
        }
      }
      return;
    }
    if (this.set) {
      this.set.forEach(visitor);
      return;
    }
    throw new Error("no set or array");
  }
  *[Symbol.iterator]() {
    if (this.array) {
      for (let i = 0; i < this.arraySize; i++) {
        const elem = this.array[i];
        if (typeof elem !== "undefined") {
          yield elem;
        }
      }
    } else if (this.set) {
      yield* this.set;
    } else {
      throw new Error("no set or array");
    }
  }
  has(elem) {
    if (this.array) {
      return this.array.indexOf(elem) !== -1;
    } else {
      return this.set.has(elem);
    }
  }
  clear() {
    if (this.set) {
      this.set.clear();
    } else {
      this.arraySize = 0;
      this.array = [];
    }
  }
  size() {
    if (this.set) {
      return this.set.size;
    } else {
      return this.arraySize;
    }
  }
};

// node_modules/@tldraw/state/dist-esm/lib/types.mjs
var RESET_VALUE = Symbol.for("com.tldraw.state/RESET_VALUE");

// node_modules/@tldraw/state/dist-esm/lib/HistoryBuffer.mjs
var HistoryBuffer = class {
  constructor(capacity) {
    __publicField(this, "index", 0);
    // use a wrap around buffer to store the last N values
    __publicField(this, "buffer");
    this.capacity = capacity;
    this.buffer = new Array(capacity);
  }
  /**
   * Add a diff to the history buffer.
   *
   * @param lastComputedEpoch - The epoch when the diff was computed.
   * @param currentEpoch - The current epoch.
   * @param diff - The diff to add, or else a reset value.
   */
  pushEntry(lastComputedEpoch, currentEpoch, diff) {
    if (diff === void 0) {
      return;
    }
    if (diff === RESET_VALUE) {
      this.clear();
      return;
    }
    this.buffer[this.index] = [lastComputedEpoch, currentEpoch, diff];
    this.index = (this.index + 1) % this.capacity;
  }
  /**
   * Clear the history buffer.
   */
  clear() {
    this.index = 0;
    this.buffer.fill(void 0);
  }
  /**
   * Get the diffs since the given epoch.
   *
   * @param sinceEpoch - The epoch to get diffs since.
   * @returns An array of diffs or a flag to reset the history buffer.
   */
  getChangesSince(sinceEpoch) {
    const { index: index3, capacity, buffer } = this;
    for (let i = 0; i < capacity; i++) {
      const offset5 = (index3 - 1 + capacity - i) % capacity;
      const elem = buffer[offset5];
      if (!elem) {
        return RESET_VALUE;
      }
      const [fromEpoch, toEpoch] = elem;
      if (i === 0 && sinceEpoch >= toEpoch) {
        return [];
      }
      if (fromEpoch <= sinceEpoch && sinceEpoch < toEpoch) {
        const len = i + 1;
        const result = new Array(len);
        for (let j = 0; j < len; j++) {
          result[j] = buffer[(offset5 + j) % capacity][2];
        }
        return result;
      }
    }
    return RESET_VALUE;
  }
};

// node_modules/@tldraw/state/dist-esm/lib/constants.mjs
var GLOBAL_START_EPOCH = -1;

// node_modules/@tldraw/state/dist-esm/lib/EffectScheduler.mjs
var __EffectScheduler__ = class {
  constructor(name, runEffect, options2) {
    __publicField(this, "_isActivelyListening", false);
    /** @internal */
    __publicField(this, "lastTraversedEpoch", GLOBAL_START_EPOCH);
    __publicField(this, "lastReactedEpoch", GLOBAL_START_EPOCH);
    __publicField(this, "_scheduleCount", 0);
    __publicField(this, "__debug_ancestor_epochs__", null);
    /** @internal */
    __publicField(this, "parentSet", new ArraySet());
    /** @internal */
    __publicField(this, "parentEpochs", []);
    /** @internal */
    __publicField(this, "parents", []);
    __publicField(this, "_scheduleEffect");
    /** @internal */
    // eslint-disable-next-line local/prefer-class-methods
    __publicField(this, "maybeExecute", () => {
      if (!this._isActivelyListening)
        return;
      this.execute();
    });
    this.name = name;
    this.runEffect = runEffect;
    this._scheduleEffect = options2 == null ? void 0 : options2.scheduleEffect;
  }
  /**
   * Whether this scheduler is attached and actively listening to its parents.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return this._isActivelyListening;
  }
  /**
   * The number of times this effect has been scheduled.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get scheduleCount() {
    return this._scheduleCount;
  }
  /** @internal */
  maybeScheduleEffect() {
    if (!this._isActivelyListening)
      return;
    if (this.lastReactedEpoch === getGlobalEpoch())
      return;
    if (this.parents.length && !haveParentsChanged(this)) {
      this.lastReactedEpoch = getGlobalEpoch();
      return;
    }
    this.scheduleEffect();
  }
  /** @internal */
  scheduleEffect() {
    this._scheduleCount++;
    if (this._scheduleEffect) {
      this._scheduleEffect(this.maybeExecute);
    } else {
      this.execute();
    }
  }
  /**
   * Makes this scheduler become 'actively listening' to its parents.
   * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.
   * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling `EffectScheduler.execute`.
   * @public
   */
  attach() {
    this._isActivelyListening = true;
    for (let i = 0, n = this.parents.length; i < n; i++) {
      attach(this.parents[i], this);
    }
  }
  /**
   * Makes this scheduler stop 'actively listening' to its parents.
   * It will no longer be eligible to receive 'maybeScheduleEffect' calls until `EffectScheduler.attach` is called again.
   */
  detach() {
    this._isActivelyListening = false;
    for (let i = 0, n = this.parents.length; i < n; i++) {
      detach(this.parents[i], this);
    }
  }
  /**
   * Executes the effect immediately and returns the result.
   * @returns The result of the effect.
   */
  execute() {
    try {
      startCapturingParents(this);
      const currentEpoch = getGlobalEpoch();
      const result = this.runEffect(this.lastReactedEpoch);
      this.lastReactedEpoch = currentEpoch;
      return result;
    } finally {
      stopCapturingParents();
    }
  }
};
var EffectScheduler = singleton(
  "EffectScheduler",
  () => __EffectScheduler__
);
function react(name, fn2, options2) {
  const scheduler = new EffectScheduler(name, fn2, options2);
  scheduler.attach();
  scheduler.scheduleEffect();
  return () => {
    scheduler.detach();
  };
}
function reactor(name, fn2, options2) {
  const scheduler = new EffectScheduler(name, fn2, options2);
  return {
    scheduler,
    start: (options22) => {
      const force = (options22 == null ? void 0 : options22.force) ?? false;
      scheduler.attach();
      if (force) {
        scheduler.scheduleEffect();
      } else {
        scheduler.maybeScheduleEffect();
      }
    },
    stop: () => {
      scheduler.detach();
    }
  };
}

// node_modules/@tldraw/state/dist-esm/lib/transactions.mjs
var Transaction = class {
  constructor(parent) {
    __publicField(this, "initialAtomValues", /* @__PURE__ */ new Map());
    this.parent = parent;
  }
  /**
   * Get whether this transaction is a root (no parents).
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isRoot() {
    return this.parent === null;
  }
  /**
   * Commit the transaction's changes.
   *
   * @public
   */
  commit() {
    if (inst.globalIsReacting) {
      for (const atom2 of this.initialAtomValues.keys()) {
        traverseAtomForCleanup(atom2);
      }
    } else if (this.isRoot) {
      flushChanges(this.initialAtomValues.keys());
    } else {
      this.initialAtomValues.forEach((value, atom2) => {
        if (!this.parent.initialAtomValues.has(atom2)) {
          this.parent.initialAtomValues.set(atom2, value);
        }
      });
    }
  }
  /**
   * Abort the transaction.
   *
   * @public
   */
  abort() {
    inst.globalEpoch++;
    this.initialAtomValues.forEach((value, atom2) => {
      var _a5;
      atom2.set(value);
      (_a5 = atom2.historyBuffer) == null ? void 0 : _a5.clear();
    });
    this.commit();
  }
};
var inst = singleton("transactions", () => ({
  // The current epoch (global to all atoms).
  globalEpoch: GLOBAL_START_EPOCH + 1,
  // Whether any transaction is reacting.
  globalIsReacting: false,
  currentTransaction: null,
  cleanupReactors: null,
  reactionEpoch: GLOBAL_START_EPOCH + 1
}));
function getReactionEpoch() {
  return inst.reactionEpoch;
}
function getGlobalEpoch() {
  return inst.globalEpoch;
}
function getIsReacting() {
  return inst.globalIsReacting;
}
function traverse(reactors, child) {
  if (child.lastTraversedEpoch === inst.globalEpoch) {
    return;
  }
  child.lastTraversedEpoch = inst.globalEpoch;
  if (child instanceof EffectScheduler) {
    reactors.add(child);
  } else {
    ;
    child.children.visit((c) => traverse(reactors, c));
  }
}
function flushChanges(atoms) {
  var _a5;
  if (inst.globalIsReacting) {
    throw new Error("flushChanges cannot be called during a reaction");
  }
  const outerTxn = inst.currentTransaction;
  try {
    inst.currentTransaction = null;
    inst.globalIsReacting = true;
    inst.reactionEpoch = inst.globalEpoch;
    const reactors = /* @__PURE__ */ new Set();
    for (const atom2 of atoms) {
      atom2.children.visit((child) => traverse(reactors, child));
    }
    for (const r of reactors) {
      r.maybeScheduleEffect();
    }
    let updateDepth = 0;
    while ((_a5 = inst.cleanupReactors) == null ? void 0 : _a5.size) {
      if (updateDepth++ > 1e3) {
        throw new Error("Reaction update depth limit exceeded");
      }
      const reactors2 = inst.cleanupReactors;
      inst.cleanupReactors = null;
      for (const r of reactors2) {
        r.maybeScheduleEffect();
      }
    }
  } finally {
    inst.cleanupReactors = null;
    inst.globalIsReacting = false;
    inst.currentTransaction = outerTxn;
  }
}
function atomDidChange(atom2, previousValue) {
  if (inst.currentTransaction) {
    if (!inst.currentTransaction.initialAtomValues.has(atom2)) {
      inst.currentTransaction.initialAtomValues.set(atom2, previousValue);
    }
  } else if (inst.globalIsReacting) {
    traverseAtomForCleanup(atom2);
  } else {
    flushChanges([atom2]);
  }
}
function traverseAtomForCleanup(atom2) {
  const rs = inst.cleanupReactors ?? (inst.cleanupReactors = /* @__PURE__ */ new Set());
  atom2.children.visit((child) => traverse(rs, child));
}
function advanceGlobalEpoch() {
  inst.globalEpoch++;
}
function transaction(fn2) {
  const txn = new Transaction(inst.currentTransaction);
  inst.currentTransaction = txn;
  try {
    let result = void 0;
    let rollback = false;
    try {
      result = fn2(() => rollback = true);
    } catch (e) {
      txn.abort();
      throw e;
    }
    if (rollback) {
      txn.abort();
    } else {
      txn.commit();
    }
    return result;
  } finally {
    inst.currentTransaction = inst.currentTransaction.parent;
  }
}
function transact(fn2) {
  if (inst.currentTransaction) {
    return fn2();
  }
  return transaction(fn2);
}

// node_modules/@tldraw/state/dist-esm/lib/warnings.mjs
var didWarnComputedGetter = false;
function logComputedGetterWarning() {
  if (didWarnComputedGetter)
    return;
  didWarnComputedGetter = true;
  console.warn(
    `Using \`@computed\` as a decorator for getters is deprecated and will be removed in the near future. Please refactor to use \`@computed\` as a decorator for methods.

// Before
@computed
get foo() {
	return 'foo'
}

// After
@computed
getFoo() {
	return 'foo'
}
`
  );
}

// node_modules/@tldraw/state/dist-esm/lib/Computed.mjs
var UNINITIALIZED = Symbol.for("com.tldraw.state/UNINITIALIZED");
function isUninitialized(value) {
  return value === UNINITIALIZED;
}
var WithDiff = singleton(
  "WithDiff",
  () => class WithDiff {
    constructor(value, diff) {
      this.value = value;
      this.diff = diff;
    }
  }
);
function withDiff(value, diff) {
  return new WithDiff(value, diff);
}
var __UNSAFE__Computed = class {
  constructor(name, derive, options2) {
    __publicField(this, "lastChangedEpoch", GLOBAL_START_EPOCH);
    __publicField(this, "lastTraversedEpoch", GLOBAL_START_EPOCH);
    __publicField(this, "__debug_ancestor_epochs__", null);
    /**
     * The epoch when the reactor was last checked.
     */
    __publicField(this, "lastCheckedEpoch", GLOBAL_START_EPOCH);
    __publicField(this, "parentSet", new ArraySet());
    __publicField(this, "parents", []);
    __publicField(this, "parentEpochs", []);
    __publicField(this, "children", new ArraySet());
    __publicField(this, "historyBuffer");
    // The last-computed value of this signal.
    __publicField(this, "state", UNINITIALIZED);
    // If the signal throws an error we stash it so we can rethrow it on the next get()
    __publicField(this, "error", null);
    __publicField(this, "computeDiff");
    __publicField(this, "isEqual");
    this.name = name;
    this.derive = derive;
    if (options2 == null ? void 0 : options2.historyLength) {
      this.historyBuffer = new HistoryBuffer(options2.historyLength);
    }
    this.computeDiff = options2 == null ? void 0 : options2.computeDiff;
    this.isEqual = (options2 == null ? void 0 : options2.isEqual) ?? equals;
  }
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return !this.children.isEmpty;
  }
  __unsafe__getWithoutCapture(ignoreErrors) {
    var _a5;
    const isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH;
    const globalEpoch = getGlobalEpoch();
    if (!isNew && (this.lastCheckedEpoch === globalEpoch || this.isActivelyListening && getIsReacting() && this.lastTraversedEpoch < getReactionEpoch() || !haveParentsChanged(this))) {
      this.lastCheckedEpoch = globalEpoch;
      if (this.error) {
        if (!ignoreErrors) {
          throw this.error.thrownValue;
        } else {
          return this.state;
        }
      } else {
        return this.state;
      }
    }
    try {
      startCapturingParents(this);
      const result = this.derive(this.state, this.lastCheckedEpoch);
      const newState = result instanceof WithDiff ? result.value : result;
      const isUninitialized2 = this.state === UNINITIALIZED;
      if (isUninitialized2 || !this.isEqual(newState, this.state)) {
        if (this.historyBuffer && !isUninitialized2) {
          const diff = result instanceof WithDiff ? result.diff : void 0;
          this.historyBuffer.pushEntry(
            this.lastChangedEpoch,
            getGlobalEpoch(),
            diff ?? ((_a5 = this.computeDiff) == null ? void 0 : _a5.call(this, this.state, newState, this.lastCheckedEpoch, getGlobalEpoch())) ?? RESET_VALUE
          );
        }
        this.lastChangedEpoch = getGlobalEpoch();
        this.state = newState;
      }
      this.error = null;
      this.lastCheckedEpoch = getGlobalEpoch();
      return this.state;
    } catch (e) {
      if (this.state !== UNINITIALIZED) {
        this.state = UNINITIALIZED;
        this.lastChangedEpoch = getGlobalEpoch();
      }
      this.lastCheckedEpoch = getGlobalEpoch();
      if (this.historyBuffer) {
        this.historyBuffer.clear();
      }
      this.error = { thrownValue: e };
      if (!ignoreErrors)
        throw e;
      return this.state;
    } finally {
      stopCapturingParents();
    }
  }
  get() {
    try {
      return this.__unsafe__getWithoutCapture();
    } finally {
      maybeCaptureParent(this);
    }
  }
  getDiffSince(epoch) {
    var _a5;
    this.__unsafe__getWithoutCapture(true);
    maybeCaptureParent(this);
    if (epoch >= this.lastChangedEpoch) {
      return EMPTY_ARRAY;
    }
    return ((_a5 = this.historyBuffer) == null ? void 0 : _a5.getChangesSince(epoch)) ?? RESET_VALUE;
  }
};
var _Computed = singleton("Computed", () => __UNSAFE__Computed);
function computedMethodLegacyDecorator(options2 = {}, _target, key, descriptor) {
  const originalMethod = descriptor.value;
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + key);
  descriptor.value = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(key, originalMethod.bind(this), options2);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  descriptor.value[isComputedMethodKey] = true;
  return descriptor;
}
function computedGetterLegacyDecorator(options2 = {}, _target, key, descriptor) {
  const originalMethod = descriptor.get;
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + key);
  descriptor.get = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(key, originalMethod.bind(this), options2);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  return descriptor;
}
function computedMethodTc39Decorator(options2, compute, context) {
  assert(context.kind === "method", "@computed can only be used on methods");
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + String(context.name));
  const fn2 = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(String(context.name), compute.bind(this), options2);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  fn2[isComputedMethodKey] = true;
  return fn2;
}
function computedDecorator(options2 = {}, args) {
  if (args.length === 2) {
    const [originalMethod, context] = args;
    return computedMethodTc39Decorator(options2, originalMethod, context);
  } else {
    const [_target, key, descriptor] = args;
    if (descriptor.get) {
      logComputedGetterWarning();
      return computedGetterLegacyDecorator(options2, _target, key, descriptor);
    } else {
      return computedMethodLegacyDecorator(options2, _target, key, descriptor);
    }
  }
}
var isComputedMethodKey = "@@__isComputedMethod__@@";
function getComputedInstance(obj, propertyName) {
  const key = Symbol.for("__@tldraw/state__computed__" + propertyName.toString());
  let inst3 = obj[key];
  if (!inst3) {
    const val = obj[propertyName];
    if (typeof val === "function" && val[isComputedMethodKey]) {
      val.call(obj);
    }
    inst3 = obj[key];
  }
  return inst3;
}
function computed() {
  if (arguments.length === 1) {
    const options2 = arguments[0];
    return (...args) => computedDecorator(options2, args);
  } else if (typeof arguments[0] === "string") {
    return new _Computed(arguments[0], arguments[1], arguments[2]);
  } else {
    return computedDecorator(void 0, arguments);
  }
}
function isComputed(value) {
  return value && value instanceof _Computed;
}

// node_modules/@tldraw/state/dist-esm/lib/capture.mjs
var CaptureStackFrame = class {
  constructor(below, child) {
    __publicField(this, "offset", 0);
    __publicField(this, "maybeRemoved");
    this.below = below;
    this.child = child;
  }
};
var inst2 = singleton("capture", () => ({ stack: null }));
function unsafe__withoutCapture(fn2) {
  const oldStack = inst2.stack;
  inst2.stack = null;
  try {
    return fn2();
  } finally {
    inst2.stack = oldStack;
  }
}
function startCapturingParents(child) {
  inst2.stack = new CaptureStackFrame(inst2.stack, child);
  if (child.__debug_ancestor_epochs__) {
    const previousAncestorEpochs = child.__debug_ancestor_epochs__;
    child.__debug_ancestor_epochs__ = null;
    for (const p of child.parents) {
      p.__unsafe__getWithoutCapture(true);
    }
    logChangedAncestors(child, previousAncestorEpochs);
  }
  child.parentSet.clear();
}
function stopCapturingParents() {
  const frame2 = inst2.stack;
  inst2.stack = frame2.below;
  if (frame2.offset < frame2.child.parents.length) {
    for (let i = frame2.offset; i < frame2.child.parents.length; i++) {
      const maybeRemovedParent = frame2.child.parents[i];
      if (!frame2.child.parentSet.has(maybeRemovedParent)) {
        detach(maybeRemovedParent, frame2.child);
      }
    }
    frame2.child.parents.length = frame2.offset;
    frame2.child.parentEpochs.length = frame2.offset;
  }
  if (frame2.maybeRemoved) {
    for (let i = 0; i < frame2.maybeRemoved.length; i++) {
      const maybeRemovedParent = frame2.maybeRemoved[i];
      if (!frame2.child.parentSet.has(maybeRemovedParent)) {
        detach(maybeRemovedParent, frame2.child);
      }
    }
  }
  if (frame2.child.__debug_ancestor_epochs__) {
    captureAncestorEpochs(frame2.child, frame2.child.__debug_ancestor_epochs__);
  }
}
function maybeCaptureParent(p) {
  if (inst2.stack) {
    const wasCapturedAlready = inst2.stack.child.parentSet.has(p);
    if (wasCapturedAlready) {
      return;
    }
    inst2.stack.child.parentSet.add(p);
    if (inst2.stack.child.isActivelyListening) {
      attach(p, inst2.stack.child);
    }
    if (inst2.stack.offset < inst2.stack.child.parents.length) {
      const maybeRemovedParent = inst2.stack.child.parents[inst2.stack.offset];
      if (maybeRemovedParent !== p) {
        if (!inst2.stack.maybeRemoved) {
          inst2.stack.maybeRemoved = [maybeRemovedParent];
        } else {
          inst2.stack.maybeRemoved.push(maybeRemovedParent);
        }
      }
    }
    inst2.stack.child.parents[inst2.stack.offset] = p;
    inst2.stack.child.parentEpochs[inst2.stack.offset] = p.lastChangedEpoch;
    inst2.stack.offset++;
  }
}
function whyAmIRunning() {
  var _a5;
  const child = (_a5 = inst2.stack) == null ? void 0 : _a5.child;
  if (!child) {
    throw new Error("whyAmIRunning() called outside of a reactive context");
  }
  child.__debug_ancestor_epochs__ = /* @__PURE__ */ new Map();
}
function captureAncestorEpochs(child, ancestorEpochs) {
  for (let i = 0; i < child.parents.length; i++) {
    const parent = child.parents[i];
    const epoch = child.parentEpochs[i];
    ancestorEpochs.set(parent, epoch);
    if (isComputed(parent)) {
      captureAncestorEpochs(parent, ancestorEpochs);
    }
  }
  return ancestorEpochs;
}
function collectChangedAncestors(child, ancestorEpochs) {
  const changeTree = {};
  for (let i = 0; i < child.parents.length; i++) {
    const parent = child.parents[i];
    if (!ancestorEpochs.has(parent)) {
      continue;
    }
    const prevEpoch = ancestorEpochs.get(parent);
    const currentEpoch = parent.lastChangedEpoch;
    if (currentEpoch !== prevEpoch) {
      if (isComputed(parent)) {
        changeTree[parent.name] = collectChangedAncestors(parent, ancestorEpochs);
      } else {
        changeTree[parent.name] = null;
      }
    }
  }
  return changeTree;
}
function logChangedAncestors(child, ancestorEpochs) {
  const changeTree = collectChangedAncestors(child, ancestorEpochs);
  if (Object.keys(changeTree).length === 0) {
    console.log(`Effect(${child.name}) was executed manually.`);
    return;
  }
  let str = isComputed(child) ? `Computed(${child.name}) is recomputing because:` : `Effect(${child.name}) is executing because:`;
  function logParent(tree, indent) {
    const indentStr = "\n" + " ".repeat(indent) + "↳ ";
    for (const [name, val] of Object.entries(tree)) {
      if (val) {
        str += `${indentStr}Computed(${name}) changed`;
        logParent(val, indent + 2);
      } else {
        str += `${indentStr}Atom(${name}) changed`;
      }
    }
  }
  logParent(changeTree, 1);
  console.log(str);
}

// node_modules/@tldraw/state/dist-esm/lib/Atom.mjs
var __Atom__ = class {
  constructor(name, current, options2) {
    __publicField(this, "isEqual");
    __publicField(this, "computeDiff");
    __publicField(this, "lastChangedEpoch", getGlobalEpoch());
    __publicField(this, "children", new ArraySet());
    __publicField(this, "historyBuffer");
    this.name = name;
    this.current = current;
    this.isEqual = (options2 == null ? void 0 : options2.isEqual) ?? null;
    if (!options2)
      return;
    if (options2.historyLength) {
      this.historyBuffer = new HistoryBuffer(options2.historyLength);
    }
    this.computeDiff = options2.computeDiff;
  }
  __unsafe__getWithoutCapture(_ignoreErrors) {
    return this.current;
  }
  get() {
    maybeCaptureParent(this);
    return this.current;
  }
  set(value, diff) {
    var _a5, _b;
    if (((_a5 = this.isEqual) == null ? void 0 : _a5.call(this, this.current, value)) ?? equals(this.current, value)) {
      return this.current;
    }
    advanceGlobalEpoch();
    if (this.historyBuffer) {
      this.historyBuffer.pushEntry(
        this.lastChangedEpoch,
        getGlobalEpoch(),
        diff ?? ((_b = this.computeDiff) == null ? void 0 : _b.call(this, this.current, value, this.lastChangedEpoch, getGlobalEpoch())) ?? RESET_VALUE
      );
    }
    this.lastChangedEpoch = getGlobalEpoch();
    const oldValue = this.current;
    this.current = value;
    atomDidChange(this, oldValue);
    return value;
  }
  update(updater) {
    return this.set(updater(this.current));
  }
  getDiffSince(epoch) {
    var _a5;
    maybeCaptureParent(this);
    if (epoch >= this.lastChangedEpoch) {
      return EMPTY_ARRAY;
    }
    return ((_a5 = this.historyBuffer) == null ? void 0 : _a5.getChangesSince(epoch)) ?? RESET_VALUE;
  }
};
var _Atom = singleton("Atom", () => __Atom__);
function atom(name, initialValue, options2) {
  return new _Atom(name, initialValue, options2);
}
function isAtom(value) {
  return value instanceof _Atom;
}

// node_modules/@tldraw/state/dist-esm/lib/isSignal.mjs
function isSignal(value) {
  return value instanceof _Atom || value instanceof _Computed;
}

// node_modules/@tldraw/state/dist-esm/index.mjs
var currentApiVersion = 1;
var actualApiVersion = singleton("apiVersion", () => currentApiVersion);
if (actualApiVersion !== currentApiVersion) {
  throw new Error(
    `You have multiple incompatible versions of @tldraw/state in your app. Please deduplicate the package.`
  );
}
registerTldrawLibraryVersion(
  "@tldraw/state",
  "3.13.1",
  "esm"
);

// node_modules/@tldraw/state-react/dist-esm/lib/track.mjs
var import_react2 = __toESM(require_react(), 1);

// node_modules/@tldraw/state-react/dist-esm/lib/useStateTracking.mjs
var import_react = __toESM(require_react(), 1);
function useStateTracking(name, render2, deps = []) {
  const renderRef = import_react.default.useRef(render2);
  renderRef.current = render2;
  const [scheduler, subscribe2, getSnapshot2] = import_react.default.useMemo(() => {
    let scheduleUpdate = null;
    const subscribe22 = (cb) => {
      scheduleUpdate = cb;
      return () => {
        scheduleUpdate = null;
      };
    };
    const scheduler2 = new EffectScheduler(
      `useStateTracking(${name})`,
      // this is what `scheduler.execute()` will call
      () => {
        var _a5;
        return (_a5 = renderRef.current) == null ? void 0 : _a5.call(renderRef);
      },
      // this is what will be invoked when @tldraw/state detects a change in an upstream reactive value
      {
        scheduleEffect() {
          scheduleUpdate == null ? void 0 : scheduleUpdate();
        }
      }
    );
    const getSnapshot22 = () => scheduler2.scheduleCount;
    return [scheduler2, subscribe22, getSnapshot22];
  }, [name, ...deps]);
  import_react.default.useSyncExternalStore(subscribe2, getSnapshot2, getSnapshot2);
  import_react.default.useEffect(() => {
    scheduler.attach();
    scheduler.maybeScheduleEffect();
    return () => {
      scheduler.detach();
    };
  }, [scheduler]);
  return scheduler.execute();
}

// node_modules/@tldraw/state-react/dist-esm/lib/track.mjs
var ProxyHandlers = {
  /**
   * This is a function call trap for functional components. When this is called, we know it means
   * React did run 'Component()', that means we can use any hooks here to setup our effect and
   * store.
   *
   * With the native Proxy, all other calls such as access/setting to/of properties will be
   * forwarded to the target Component, so we don't need to copy the Component's own or inherited
   * properties.
   *
   * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460
   */
  apply(Component2, thisArg, argumentsList) {
    return useStateTracking(
      Component2.displayName ?? Component2.name ?? "tracked(???)",
      () => Component2.apply(thisArg, argumentsList)
    );
  }
};
var ReactMemoSymbol = Symbol.for("react.memo");
var ReactForwardRefSymbol = Symbol.for("react.forward_ref");
function track(baseComponent) {
  let compare = null;
  const $$typeof = baseComponent["$$typeof"];
  if ($$typeof === ReactMemoSymbol) {
    baseComponent = baseComponent.type;
    compare = baseComponent.compare;
  }
  if ($$typeof === ReactForwardRefSymbol) {
    return (0, import_react2.memo)((0, import_react2.forwardRef)(new Proxy(baseComponent.render, ProxyHandlers)));
  }
  return (0, import_react2.memo)(new Proxy(baseComponent, ProxyHandlers), compare);
}

// node_modules/@tldraw/state-react/dist-esm/lib/useAtom.mjs
var import_react3 = __toESM(require_react(), 1);
function useAtom(name, valueOrInitialiser, options2) {
  return (0, import_react3.useState)(() => {
    const initialValue = typeof valueOrInitialiser === "function" ? valueOrInitialiser() : valueOrInitialiser;
    return atom(`useAtom(${name})`, initialValue, options2);
  })[0];
}

// node_modules/@tldraw/state-react/dist-esm/lib/useComputed.mjs
var import_react4 = __toESM(require_react(), 1);
function useComputed() {
  const name = arguments[0];
  const compute = arguments[1];
  const opts = arguments.length === 3 ? void 0 : arguments[2];
  const deps = arguments.length === 3 ? arguments[2] : arguments[3];
  return (0, import_react4.useMemo)(() => computed(`useComputed(${name})`, compute, opts), deps);
}

// node_modules/@tldraw/state-react/dist-esm/lib/useQuickReactor.mjs
var import_react5 = __toESM(require_react(), 1);
function useQuickReactor(name, reactFn, deps = EMPTY_ARRAY) {
  (0, import_react5.useEffect)(() => {
    const scheduler = new EffectScheduler(name, reactFn);
    scheduler.attach();
    scheduler.execute();
    return () => {
      scheduler.detach();
    };
  }, deps);
}

// node_modules/@tldraw/state-react/dist-esm/lib/useReactor.mjs
var import_react6 = __toESM(require_react(), 1);
function useReactor(name, reactFn, deps = []) {
  const raf = (0, import_react6.useRef)(-1);
  const scheduler = (0, import_react6.useMemo)(
    () => new EffectScheduler(name, reactFn, {
      scheduleEffect: (cb) => {
        const rafId = requestAnimationFrame(cb);
        raf.current = rafId;
        return rafId;
      }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  (0, import_react6.useEffect)(() => {
    scheduler.attach();
    scheduler.execute();
    return () => {
      scheduler.detach();
      cancelAnimationFrame(raf.current);
    };
  }, [scheduler]);
}

// node_modules/@tldraw/state-react/dist-esm/lib/useValue.mjs
var import_react7 = __toESM(require_react(), 1);
function useValue() {
  const args = arguments;
  const deps = args.length === 3 ? args[2] : [args[0]];
  const name = args.length === 3 ? args[0] : `useValue(${args[0].name})`;
  const isInRender = (0, import_react7.useRef)(true);
  isInRender.current = true;
  const $val = (0, import_react7.useMemo)(() => {
    if (args.length === 1) {
      return args[0];
    }
    return computed(name, () => {
      if (isInRender.current) {
        return args[1]();
      } else {
        try {
          return args[1]();
        } catch {
          return {};
        }
      }
    });
  }, deps);
  try {
    const { subscribe: subscribe2, getSnapshot: getSnapshot2 } = (0, import_react7.useMemo)(() => {
      return {
        subscribe: (listen) => {
          return react(`useValue(${name})`, () => {
            $val.get();
            listen();
          });
        },
        getSnapshot: () => $val.get()
      };
    }, [$val]);
    return (0, import_react7.useSyncExternalStore)(subscribe2, getSnapshot2, getSnapshot2);
  } finally {
    isInRender.current = false;
  }
}

// node_modules/@tldraw/state-react/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "@tldraw/state-react",
  "3.13.1",
  "esm"
);

// node_modules/@tldraw/store/dist-esm/lib/ImmutableMap.mjs
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
var defaultValueOf = Object.prototype.valueOf;
function hash(o) {
  if (o == null) {
    return hashNullish(o);
  }
  if (typeof o.hashCode === "function") {
    return smi(o.hashCode(o));
  }
  const v = valueOf(o);
  if (v == null) {
    return hashNullish(v);
  }
  switch (typeof v) {
    case "boolean":
      return v ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v);
    case "string":
      return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
    case "object":
    case "function":
      return hashJSObj(v);
    case "symbol":
      return hashSymbol(v);
    default:
      if (typeof v.toString === "function") {
        return hashString(v.toString());
      }
      throw new Error("Value type " + typeof v + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function hashNumber(n) {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let hash22 = n | 0;
  if (hash22 !== n) {
    hash22 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    n /= 4294967295;
    hash22 ^= n;
  }
  return smi(hash22);
}
function cachedHashString(string2) {
  let hashed = stringHashCache[string2];
  if (hashed === void 0) {
    hashed = hashString(string2);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string2] = hashed;
  }
  return hashed;
}
function hashString(string2) {
  let hashed = 0;
  for (let ii = 0; ii < string2.length; ii++) {
    hashed = 31 * hashed + string2.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  let hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  let hashed = weakMap.get(obj);
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  weakMap.set(obj, hashed);
  return hashed;
}
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
  const nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
var weakMap = /* @__PURE__ */ new WeakMap();
var symbolMap = /* @__PURE__ */ Object.create(null);
var _objHashUID = 0;
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};
var SHIFT = 5;
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;
var NOT_SET = {};
function MakeRef() {
  return { value: false };
}
function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}
function arrCopy(arr, offset5) {
  offset5 = offset5 || 0;
  const len = Math.max(0, arr.length - offset5);
  const newArr = new Array(len);
  for (let ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset5];
  }
  return newArr;
}
var is = Object.is;
var OwnerID = class {
};
var ImmutableMap = class _ImmutableMap {
  constructor(value) {
    // @pragma Construction
    // @ts-ignore
    __publicField(this, "_root");
    // @ts-ignore
    __publicField(this, "size");
    // @ts-ignore
    __publicField(this, "__ownerID");
    // @ts-ignore
    __publicField(this, "__hash");
    // @ts-ignore
    __publicField(this, "__altered");
    return value === void 0 || value === null ? emptyMap() : value instanceof _ImmutableMap ? value : emptyMap().withMutations((map2) => {
      for (const [k, v] of value) {
        map2.set(k, v);
      }
    });
  }
  get(k, notSetValue) {
    return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
  }
  set(k, v) {
    return updateMap(this, k, v);
  }
  delete(k) {
    return updateMap(this, k, NOT_SET);
  }
  deleteAll(keys2) {
    return this.withMutations((map2) => {
      for (const key of keys2) {
        map2.delete(key);
      }
    });
  }
  __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  }
  withMutations(fn2) {
    const mutable = this.asMutable();
    fn2(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  }
  wasAltered() {
    return this.__altered;
  }
  asMutable() {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  }
  [Symbol.iterator]() {
    return this.entries()[Symbol.iterator]();
  }
  entries() {
    return new MapIterator(this, ITERATE_ENTRIES, false);
  }
  keys() {
    return new MapIterator(this, ITERATE_KEYS, false);
  }
  values() {
    return new MapIterator(this, ITERATE_VALUES, false);
  }
};
var ArrayMapNode = class _ArrayMapNode {
  constructor(ownerID, entries) {
    this.ownerID = ownerID;
    this.entries = entries;
  }
  get(_shift, _keyHash, key, notSetValue) {
    const entries = this.entries;
    for (let ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  }
  update(ownerID, _shift, _keyHash, key, value, didChangeSize, didAlter) {
    const removed = value === NOT_SET;
    const entries = this.entries;
    let idx = 0;
    const len = entries.length;
    for (; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    const exists = idx < len;
    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }
    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);
    if (removed && entries.length === 1) {
      return;
    }
    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
      return createNodes(ownerID, entries, key, value);
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }
    if (isEditable) {
      this.entries = newEntries;
      return this;
    }
    return new _ArrayMapNode(ownerID, newEntries);
  }
};
var BitmapIndexedNode = class _BitmapIndexedNode {
  constructor(ownerID, bitmap, nodes) {
    this.ownerID = ownerID;
    this.bitmap = bitmap;
    this.nodes = nodes;
  }
  get(shift5, keyHash, key, notSetValue) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const bit = 1 << ((shift5 === 0 ? keyHash : keyHash >>> shift5) & MASK);
    const bitmap = this.bitmap;
    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift5 + SHIFT, keyHash, key, notSetValue);
  }
  update(ownerID, shift5, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const keyHashFrag = (shift5 === 0 ? keyHash : keyHash >>> shift5) & MASK;
    const bit = 1 << keyHashFrag;
    const bitmap = this.bitmap;
    const exists = (bitmap & bit) !== 0;
    if (!exists && value === NOT_SET) {
      return this;
    }
    const idx = popCount(bitmap & bit - 1);
    const nodes = this.nodes;
    const node = exists ? nodes[idx] : void 0;
    const newNode = updateNode(
      node,
      ownerID,
      shift5 + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
    if (newNode === node) {
      return this;
    }
    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
    }
    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
      return nodes[idx ^ 1];
    }
    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
      return newNode;
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
    const newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.bitmap = newBitmap;
      this.nodes = newNodes;
      return this;
    }
    return new _BitmapIndexedNode(ownerID, newBitmap, newNodes);
  }
};
var HashArrayMapNode = class _HashArrayMapNode {
  constructor(ownerID, count3, nodes) {
    this.ownerID = ownerID;
    this.count = count3;
    this.nodes = nodes;
  }
  get(shift5, keyHash, key, notSetValue) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const idx = (shift5 === 0 ? keyHash : keyHash >>> shift5) & MASK;
    const node = this.nodes[idx];
    return node ? node.get(shift5 + SHIFT, keyHash, key, notSetValue) : notSetValue;
  }
  update(ownerID, shift5, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const idx = (shift5 === 0 ? keyHash : keyHash >>> shift5) & MASK;
    const removed = value === NOT_SET;
    const nodes = this.nodes;
    const node = nodes[idx];
    if (removed && !node) {
      return this;
    }
    const newNode = updateNode(
      node,
      ownerID,
      shift5 + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
    if (newNode === node) {
      return this;
    }
    let newCount = this.count;
    if (!node) {
      newCount++;
    } else if (!newNode) {
      newCount--;
      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
        return packNodes(ownerID, nodes, newCount, idx);
      }
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newNodes = setAt(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.count = newCount;
      this.nodes = newNodes;
      return this;
    }
    return new _HashArrayMapNode(ownerID, newCount, newNodes);
  }
};
var HashCollisionNode = class _HashCollisionNode {
  constructor(ownerID, keyHash, entries) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entries = entries;
  }
  get(shift5, keyHash, key, notSetValue) {
    const entries = this.entries;
    for (let ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  }
  update(ownerID, shift5, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const removed = value === NOT_SET;
    if (keyHash !== this.keyHash) {
      if (removed) {
        return this;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift5, keyHash, [key, value]);
    }
    const entries = this.entries;
    let idx = 0;
    const len = entries.length;
    for (; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    const exists = idx < len;
    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }
    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);
    if (removed && len === 2) {
      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }
    if (isEditable) {
      this.entries = newEntries;
      return this;
    }
    return new _HashCollisionNode(ownerID, this.keyHash, newEntries);
  }
};
var ValueNode = class _ValueNode {
  constructor(ownerID, keyHash, entry2) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entry = entry2;
  }
  get(shift5, keyHash, key, notSetValue) {
    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
  }
  update(ownerID, shift5, keyHash, key, value, didChangeSize, didAlter) {
    const removed = value === NOT_SET;
    const keyMatch = is(key, this.entry[0]);
    if (keyMatch ? value === this.entry[1] : removed) {
      return this;
    }
    SetRef(didAlter);
    if (removed) {
      SetRef(didChangeSize);
      return;
    }
    if (keyMatch) {
      if (ownerID && ownerID === this.ownerID) {
        this.entry[1] = value;
        return this;
      }
      return new _ValueNode(ownerID, this.keyHash, [key, value]);
    }
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift5, hash(key), [key, value]);
  }
};
var MapIterator = class {
  constructor(map2, _type, _reverse) {
    __publicField(this, "_stack");
    this._type = _type;
    this._reverse = _reverse;
    this._stack = map2._root && mapIteratorFrame(map2._root);
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const type = this._type;
    let stack2 = this._stack;
    while (stack2) {
      const node = stack2.node;
      const index3 = stack2.index++;
      let maxIndex;
      if (node.entry) {
        if (index3 === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if ("entries" in node && node.entries) {
        maxIndex = node.entries.length - 1;
        if (index3 <= maxIndex) {
          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index3 : index3]);
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index3 <= maxIndex) {
          const subNode = node.nodes[this._reverse ? maxIndex - index3 : index3];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack2 = this._stack = mapIteratorFrame(subNode, stack2);
          }
          continue;
        }
      }
      stack2 = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  }
};
function mapIteratorValue(type, entry2) {
  return iteratorValue(type, entry2[0], entry2[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;
function iteratorValue(type, k, v, iteratorResult) {
  const value = type === ITERATE_KEYS ? k : type === ITERATE_VALUES ? v : [k, v];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    value,
    done: false
  };
  return iteratorResult;
}
function iteratorDone() {
  return { value: void 0, done: true };
}
function makeMap(size4, root, ownerID, hash22) {
  const map2 = Object.create(ImmutableMap.prototype);
  map2.size = size4;
  map2._root = root;
  map2.__ownerID = ownerID;
  map2.__hash = hash22;
  map2.__altered = false;
  return map2;
}
var EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map2, k, v) {
  let newRoot;
  let newSize;
  if (!map2._root) {
    if (v === NOT_SET) {
      return map2;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map2.__ownerID, [[k, v]]);
  } else {
    const didChangeSize = MakeRef();
    const didAlter = MakeRef();
    newRoot = updateNode(map2._root, map2.__ownerID, 0, void 0, k, v, didChangeSize, didAlter);
    if (!didAlter.value) {
      return map2;
    }
    newSize = map2.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }
  if (map2.__ownerID) {
    map2.size = newSize;
    map2._root = newRoot;
    map2.__hash = void 0;
    map2.__altered = true;
    return map2;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift5, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(ownerID, shift5, keyHash, key, value, didChangeSize, didAlter);
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift5, keyHash, entry2) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry2]);
  }
  const idx1 = (shift5 === 0 ? node.keyHash : node.keyHash >>> shift5) & MASK;
  const idx2 = (shift5 === 0 ? keyHash : keyHash >>> shift5) & MASK;
  let newNode;
  const nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift5 + SHIFT, keyHash, entry2)] : (newNode = new ValueNode(ownerID, keyHash, entry2), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  let node = new ValueNode(ownerID, hash(key), [key, value]);
  for (let ii = 0; ii < entries.length; ii++) {
    const entry2 = entries[ii];
    node = node.update(ownerID, 0, void 0, entry2[0], entry2[1]);
  }
  return node;
}
function packNodes(ownerID, nodes, count3, excluding) {
  let bitmap = 0;
  let packedII = 0;
  const packedNodes = new Array(count3);
  for (let ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    const node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  let count3 = 0;
  const expandedNodes = new Array(SIZE);
  for (let ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count3++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count3 + 1, expandedNodes);
}
function popCount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function setAt(array2, idx, val, canEdit) {
  const newArray = canEdit ? array2 : arrCopy(array2);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array2, idx, val, canEdit) {
  const newLen = array2.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array2[idx] = val;
    return array2;
  }
  const newArray = new Array(newLen);
  let after = 0;
  for (let ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array2[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array2, idx, canEdit) {
  const newLen = array2.length - 1;
  if (canEdit && idx === newLen) {
    array2.pop();
    return array2;
  }
  const newArray = new Array(newLen);
  let after = 0;
  for (let ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array2[ii + after];
  }
  return newArray;
}
var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

// node_modules/@tldraw/store/dist-esm/lib/AtomMap.mjs
var _a;
var AtomMap = class {
  constructor(name, entries) {
    __publicField(this, "atoms");
    __publicField(this, _a, "AtomMap");
    this.name = name;
    let atoms = emptyMap();
    if (entries) {
      atoms = atoms.withMutations((atoms2) => {
        for (const [k, v] of entries) {
          atoms2.set(k, atom(`${name}:${String(k)}`, v));
        }
      });
    }
    this.atoms = atom(`${name}:atoms`, atoms);
  }
  /** @internal */
  getAtom(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      this.atoms.get();
      return void 0;
    }
    return valueAtom;
  }
  get(key) {
    var _a5;
    const value = (_a5 = this.getAtom(key)) == null ? void 0 : _a5.get();
    assert(value !== UNINITIALIZED);
    return value;
  }
  __unsafe__getWithoutCapture(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom)
      return void 0;
    const value = valueAtom.__unsafe__getWithoutCapture();
    assert(value !== UNINITIALIZED);
    return value;
  }
  has(key) {
    const valueAtom = this.getAtom(key);
    if (!valueAtom) {
      return false;
    }
    return valueAtom.get() !== UNINITIALIZED;
  }
  __unsafe__hasWithoutCapture(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom)
      return false;
    assert(valueAtom.__unsafe__getWithoutCapture() !== UNINITIALIZED);
    return true;
  }
  set(key, value) {
    const existingAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (existingAtom) {
      existingAtom.set(value);
    } else {
      this.atoms.update((atoms) => {
        return atoms.set(key, atom(`${this.name}:${String(key)}`, value));
      });
    }
    return this;
  }
  update(key, updater) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      throw new Error(`AtomMap: key ${key} not found`);
    }
    const value = valueAtom.__unsafe__getWithoutCapture();
    assert(value !== UNINITIALIZED);
    valueAtom.set(updater(value));
  }
  delete(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      return false;
    }
    transact(() => {
      valueAtom.set(UNINITIALIZED);
      this.atoms.update((atoms) => {
        return atoms.delete(key);
      });
    });
    return true;
  }
  deleteMany(keys2) {
    return transact(() => {
      const deleted = [];
      const newAtoms = this.atoms.get().withMutations((atoms) => {
        for (const key of keys2) {
          const valueAtom = atoms.get(key);
          if (!valueAtom)
            continue;
          const oldValue = valueAtom.get();
          assert(oldValue !== UNINITIALIZED);
          deleted.push([key, oldValue]);
          atoms.delete(key);
          valueAtom.set(UNINITIALIZED);
        }
      });
      if (deleted.length) {
        this.atoms.set(newAtoms);
      }
      return deleted;
    });
  }
  clear() {
    return transact(() => {
      for (const valueAtom of this.atoms.__unsafe__getWithoutCapture().values()) {
        valueAtom.set(UNINITIALIZED);
      }
      this.atoms.set(emptyMap());
    });
  }
  *entries() {
    for (const [key, valueAtom] of this.atoms.get()) {
      const value = valueAtom.get();
      assert(value !== UNINITIALIZED);
      yield [key, value];
    }
  }
  *keys() {
    for (const key of this.atoms.get().keys()) {
      yield key;
    }
  }
  *values() {
    for (const valueAtom of this.atoms.get().values()) {
      const value = valueAtom.get();
      assert(value !== UNINITIALIZED);
      yield value;
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.atoms.get().size;
  }
  forEach(callbackfn, thisArg) {
    for (const [key, value] of this.entries()) {
      callbackfn.call(thisArg, value, key, this);
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
_a = Symbol.toStringTag;

// node_modules/@tldraw/store/dist-esm/lib/IncrementalSetConstructor.mjs
var IncrementalSetConstructor = class {
  constructor(previousValue) {
    /**
     * The next value of the set.
     *
     * @internal
     */
    __publicField(this, "nextValue");
    /**
     * The diff of the set.
     *
     * @internal
     */
    __publicField(this, "diff");
    this.previousValue = previousValue;
  }
  /**
   * Get the next value of the set.
   *
   * @public
   */
  get() {
    var _a5, _b, _c, _d;
    const numRemoved = ((_b = (_a5 = this.diff) == null ? void 0 : _a5.removed) == null ? void 0 : _b.size) ?? 0;
    const numAdded = ((_d = (_c = this.diff) == null ? void 0 : _c.added) == null ? void 0 : _d.size) ?? 0;
    if (numRemoved === 0 && numAdded === 0) {
      return void 0;
    }
    return { value: this.nextValue, diff: this.diff };
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _add(item, wasAlreadyPresent) {
    var _a5, _b;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue));
    this.nextValue.add(item);
    this.diff ?? (this.diff = {});
    if (wasAlreadyPresent) {
      (_a5 = this.diff.removed) == null ? void 0 : _a5.delete(item);
    } else {
      (_b = this.diff).added ?? (_b.added = /* @__PURE__ */ new Set());
      this.diff.added.add(item);
    }
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @public
   */
  add(item) {
    var _a5, _b, _c;
    const wasAlreadyPresent = this.previousValue.has(item);
    if (wasAlreadyPresent) {
      const wasRemoved = (_b = (_a5 = this.diff) == null ? void 0 : _a5.removed) == null ? void 0 : _b.has(item);
      if (!wasRemoved)
        return;
      return this._add(item, wasAlreadyPresent);
    }
    const isCurrentlyPresent = (_c = this.nextValue) == null ? void 0 : _c.has(item);
    if (isCurrentlyPresent)
      return;
    this._add(item, wasAlreadyPresent);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _remove(item, wasAlreadyPresent) {
    var _a5, _b;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue));
    this.nextValue.delete(item);
    this.diff ?? (this.diff = {});
    if (wasAlreadyPresent) {
      (_a5 = this.diff).removed ?? (_a5.removed = /* @__PURE__ */ new Set());
      this.diff.removed.add(item);
    } else {
      (_b = this.diff.added) == null ? void 0 : _b.delete(item);
    }
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @public
   */
  remove(item) {
    var _a5, _b, _c, _d;
    const wasAlreadyPresent = this.previousValue.has(item);
    if (!wasAlreadyPresent) {
      const wasAdded = (_b = (_a5 = this.diff) == null ? void 0 : _a5.added) == null ? void 0 : _b.has(item);
      if (!wasAdded)
        return;
      return this._remove(item, wasAlreadyPresent);
    }
    const hasAlreadyBeenRemoved = (_d = (_c = this.diff) == null ? void 0 : _c.removed) == null ? void 0 : _d.has(item);
    if (hasAlreadyBeenRemoved)
      return;
    this._remove(item, wasAlreadyPresent);
  }
};

// node_modules/@tldraw/store/dist-esm/lib/RecordType.mjs
var RecordType = class _RecordType {
  constructor(typeName, config) {
    __publicField(this, "createDefaultProperties");
    __publicField(this, "validator");
    __publicField(this, "ephemeralKeys");
    __publicField(this, "ephemeralKeySet");
    __publicField(this, "scope");
    this.typeName = typeName;
    this.createDefaultProperties = config.createDefaultProperties;
    this.validator = config.validator ?? { validate: (r) => r };
    this.scope = config.scope ?? "document";
    this.ephemeralKeys = config.ephemeralKeys;
    const ephemeralKeySet = /* @__PURE__ */ new Set();
    if (config.ephemeralKeys) {
      for (const [key, isEphemeral] of objectMapEntries(config.ephemeralKeys)) {
        if (isEphemeral)
          ephemeralKeySet.add(key);
      }
    }
    this.ephemeralKeySet = ephemeralKeySet;
  }
  /**
   * Create a new record of this type.
   *
   * @param properties - The properties of the record.
   * @returns The new record.
   */
  create(properties) {
    const result = {
      ...this.createDefaultProperties(),
      id: "id" in properties ? properties.id : this.createId()
    };
    for (const [k, v] of Object.entries(properties)) {
      if (v !== void 0) {
        result[k] = v;
      }
    }
    result.typeName = this.typeName;
    return result;
  }
  /**
   * Clone a record of this type.
   *
   * @param record - The record to clone.
   * @returns The cloned record.
   * @public
   */
  clone(record) {
    return { ...structuredClone(record), id: this.createId() };
  }
  /**
   * Create a new ID for this record type.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createId()
   * ```
   *
   * @returns The new ID.
   * @public
   */
  createId(customUniquePart) {
    return this.typeName + ":" + (customUniquePart ?? uniqueId());
  }
  /**
   * Create a new ID for this record type based on the given ID.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createCustomId('myId')
   * ```
   *
   * @deprecated - Use `createId` instead.
   * @param id - The ID to base the new ID on.
   * @returns The new ID.
   */
  createCustomId(id) {
    return this.typeName + ":" + id;
  }
  /**
   * Takes an id like `user:123` and returns the part after the colon `123`
   *
   * @param id - The id
   * @returns
   */
  parseId(id) {
    if (!this.isId(id)) {
      throw new Error(`ID "${id}" is not a valid ID for type "${this.typeName}"`);
    }
    return id.slice(this.typeName.length + 1);
  }
  /**
   * Check whether a record is an instance of this record type.
   *
   * @example
   *
   * ```ts
   * const result = recordType.isInstance(someRecord)
   * ```
   *
   * @param record - The record to check.
   * @returns Whether the record is an instance of this record type.
   */
  isInstance(record) {
    return (record == null ? void 0 : record.typeName) === this.typeName;
  }
  /**
   * Check whether an id is an id of this type.
   *
   * @example
   *
   * ```ts
   * const result = recordType.isIn('someId')
   * ```
   *
   * @param id - The id to check.
   * @returns Whether the id is an id of this type.
   */
  isId(id) {
    if (!id)
      return false;
    for (let i = 0; i < this.typeName.length; i++) {
      if (id[i] !== this.typeName[i])
        return false;
    }
    return id[this.typeName.length] === ":";
  }
  /**
   * Create a new RecordType that has the same type name as this RecordType and includes the given
   * default properties.
   *
   * @example
   *
   * ```ts
   * const authorType = createRecordType('author', () => ({ living: true }))
   * const deadAuthorType = authorType.withDefaultProperties({ living: false })
   * ```
   *
   * @param createDefaultProperties - A function that returns the default properties of the new RecordType.
   * @returns The new RecordType.
   */
  withDefaultProperties(createDefaultProperties) {
    return new _RecordType(this.typeName, {
      createDefaultProperties,
      validator: this.validator,
      scope: this.scope,
      ephemeralKeys: this.ephemeralKeys
    });
  }
  /**
   * Check that the passed in record passes the validations for this type. Returns its input
   * correctly typed if it does, but throws an error otherwise.
   */
  validate(record, recordBefore) {
    if (recordBefore && this.validator.validateUsingKnownGoodVersion) {
      return this.validator.validateUsingKnownGoodVersion(recordBefore, record);
    }
    return this.validator.validate(record);
  }
};
function createRecordType(typeName, config) {
  return new RecordType(typeName, {
    createDefaultProperties: () => ({}),
    validator: config.validator,
    scope: config.scope,
    ephemeralKeys: config.ephemeralKeys
  });
}
function assertIdType(id, type) {
  if (!id || !type.isId(id)) {
    throw new Error(`string ${JSON.stringify(id)} is not a valid ${type.typeName} id`);
  }
}

// node_modules/@tldraw/store/dist-esm/lib/RecordsDiff.mjs
function createEmptyRecordsDiff() {
  return { added: {}, updated: {}, removed: {} };
}
function reverseRecordsDiff(diff) {
  const result = { added: diff.removed, removed: diff.added, updated: {} };
  for (const [from2, to] of Object.values(diff.updated)) {
    result.updated[from2.id] = [to, from2];
  }
  return result;
}
function isRecordsDiffEmpty(diff) {
  return Object.keys(diff.added).length === 0 && Object.keys(diff.updated).length === 0 && Object.keys(diff.removed).length === 0;
}
function squashRecordDiffs(diffs) {
  const result = { added: {}, removed: {}, updated: {} };
  squashRecordDiffsMutable(result, diffs);
  return result;
}
function squashRecordDiffsMutable(target, diffs) {
  for (const diff of diffs) {
    for (const [id, value] of objectMapEntries(diff.added)) {
      if (target.removed[id]) {
        const original = target.removed[id];
        delete target.removed[id];
        if (original !== value) {
          target.updated[id] = [original, value];
        }
      } else {
        target.added[id] = value;
      }
    }
    for (const [id, [_from, to]] of objectMapEntries(diff.updated)) {
      if (target.added[id]) {
        target.added[id] = to;
        delete target.updated[id];
        delete target.removed[id];
        continue;
      }
      if (target.updated[id]) {
        target.updated[id] = [target.updated[id][0], to];
        delete target.removed[id];
        continue;
      }
      target.updated[id] = diff.updated[id];
      delete target.removed[id];
    }
    for (const [id, value] of objectMapEntries(diff.removed)) {
      if (target.added[id]) {
        delete target.added[id];
      } else if (target.updated[id]) {
        target.removed[id] = target.updated[id][0];
        delete target.updated[id];
      } else {
        target.removed[id] = value;
      }
    }
  }
}

// node_modules/@tldraw/store/dist-esm/lib/Store.mjs
var import_lodash4 = __toESM(require_lodash3(), 1);

// node_modules/@tldraw/store/dist-esm/lib/StoreQueries.mjs
var import_lodash3 = __toESM(require_lodash3(), 1);

// node_modules/@tldraw/store/dist-esm/lib/setUtils.mjs
function intersectSets(sets) {
  if (sets.length === 0)
    return /* @__PURE__ */ new Set();
  const first2 = sets[0];
  const rest = sets.slice(1);
  const result = /* @__PURE__ */ new Set();
  for (const val of first2) {
    if (rest.every((set) => set.has(val))) {
      result.add(val);
    }
  }
  return result;
}
function diffSets(prev, next) {
  const result = {};
  for (const val of next) {
    if (!prev.has(val)) {
      result.added ?? (result.added = /* @__PURE__ */ new Set());
      result.added.add(val);
    }
  }
  for (const val of prev) {
    if (!next.has(val)) {
      result.removed ?? (result.removed = /* @__PURE__ */ new Set());
      result.removed.add(val);
    }
  }
  return result.added || result.removed ? result : void 0;
}

// node_modules/@tldraw/store/dist-esm/lib/executeQuery.mjs
function objectMatchesQuery(query, object2) {
  for (const [key, _matcher] of Object.entries(query)) {
    const matcher = _matcher;
    const value = object2[key];
    if ("eq" in matcher && value !== matcher.eq)
      return false;
    if ("neq" in matcher && value === matcher.neq)
      return false;
    if ("gt" in matcher && (typeof value !== "number" || value <= matcher.gt))
      return false;
  }
  return true;
}
function executeQuery(store, typeName, query) {
  const matchIds = Object.fromEntries(Object.keys(query).map((key) => [key, /* @__PURE__ */ new Set()]));
  for (const [k, matcher] of Object.entries(query)) {
    if ("eq" in matcher) {
      const index3 = store.index(typeName, k);
      const ids = index3.get().get(matcher.eq);
      if (ids) {
        for (const id of ids) {
          matchIds[k].add(id);
        }
      }
    } else if ("neq" in matcher) {
      const index3 = store.index(typeName, k);
      for (const [value, ids] of index3.get()) {
        if (value !== matcher.neq) {
          for (const id of ids) {
            matchIds[k].add(id);
          }
        }
      }
    } else if ("gt" in matcher) {
      const index3 = store.index(typeName, k);
      for (const [value, ids] of index3.get()) {
        if (value > matcher.gt) {
          for (const id of ids) {
            matchIds[k].add(id);
          }
        }
      }
    }
  }
  return intersectSets(Object.values(matchIds));
}

// node_modules/@tldraw/store/dist-esm/lib/StoreQueries.mjs
var StoreQueries = class {
  constructor(recordMap, history2) {
    /**
     * A cache of derivations (indexes).
     *
     * @internal
     */
    __publicField(this, "indexCache", /* @__PURE__ */ new Map());
    /**
     * A cache of derivations (filtered histories).
     *
     * @internal
     */
    __publicField(this, "historyCache", /* @__PURE__ */ new Map());
    this.recordMap = recordMap;
    this.history = history2;
  }
  /**
   * Create a derivation that contains the history for a given type
   *
   * @param typeName - The name of the type to filter by.
   * @returns A derivation that returns the ids of all records of the given type.
   * @public
   */
  filterHistory(typeName) {
    if (this.historyCache.has(typeName)) {
      return this.historyCache.get(typeName);
    }
    const filtered = computed(
      "filterHistory:" + typeName,
      (lastValue, lastComputedEpoch) => {
        if (isUninitialized(lastValue)) {
          return this.history.get();
        }
        const diff = this.history.getDiffSince(lastComputedEpoch);
        if (diff === RESET_VALUE)
          return this.history.get();
        const res = { added: {}, removed: {}, updated: {} };
        let numAdded = 0;
        let numRemoved = 0;
        let numUpdated = 0;
        for (const changes of diff) {
          for (const added of objectMapValues(changes.added)) {
            if (added.typeName === typeName) {
              if (res.removed[added.id]) {
                const original = res.removed[added.id];
                delete res.removed[added.id];
                numRemoved--;
                if (original !== added) {
                  res.updated[added.id] = [original, added];
                  numUpdated++;
                }
              } else {
                res.added[added.id] = added;
                numAdded++;
              }
            }
          }
          for (const [from2, to] of objectMapValues(changes.updated)) {
            if (to.typeName === typeName) {
              if (res.added[to.id]) {
                res.added[to.id] = to;
              } else if (res.updated[to.id]) {
                res.updated[to.id] = [res.updated[to.id][0], to];
              } else {
                res.updated[to.id] = [from2, to];
                numUpdated++;
              }
            }
          }
          for (const removed of objectMapValues(changes.removed)) {
            if (removed.typeName === typeName) {
              if (res.added[removed.id]) {
                delete res.added[removed.id];
                numAdded--;
              } else if (res.updated[removed.id]) {
                res.removed[removed.id] = res.updated[removed.id][0];
                delete res.updated[removed.id];
                numUpdated--;
                numRemoved++;
              } else {
                res.removed[removed.id] = removed;
                numRemoved++;
              }
            }
          }
        }
        if (numAdded || numRemoved || numUpdated) {
          return withDiff(this.history.get(), res);
        } else {
          return lastValue;
        }
      },
      { historyLength: 100 }
    );
    this.historyCache.set(typeName, filtered);
    return filtered;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type.
   * @param property - The name of the property.
   * @public
   */
  index(typeName, property) {
    const cacheKey = typeName + ":" + property;
    if (this.indexCache.has(cacheKey)) {
      return this.indexCache.get(cacheKey);
    }
    const index3 = this.__uncached_createIndex(typeName, property);
    this.indexCache.set(cacheKey, index3);
    return index3;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type?.
   * @param property - The name of the property?.
   * @internal
   */
  __uncached_createIndex(typeName, property) {
    const typeHistory = this.filterHistory(typeName);
    const fromScratch = () => {
      typeHistory.get();
      const res = /* @__PURE__ */ new Map();
      for (const record of this.recordMap.values()) {
        if (record.typeName === typeName) {
          const value = record[property];
          if (!res.has(value)) {
            res.set(value, /* @__PURE__ */ new Set());
          }
          res.get(value).add(record.id);
        }
      }
      return res;
    };
    return computed(
      "index:" + typeName + ":" + property,
      (prevValue, lastComputedEpoch) => {
        if (isUninitialized(prevValue))
          return fromScratch();
        const history2 = typeHistory.getDiffSince(lastComputedEpoch);
        if (history2 === RESET_VALUE) {
          return fromScratch();
        }
        const setConstructors = /* @__PURE__ */ new Map();
        const add = (value, id) => {
          let setConstructor = setConstructors.get(value);
          if (!setConstructor)
            setConstructor = new IncrementalSetConstructor(
              prevValue.get(value) ?? /* @__PURE__ */ new Set()
            );
          setConstructor.add(id);
          setConstructors.set(value, setConstructor);
        };
        const remove2 = (value, id) => {
          let set = setConstructors.get(value);
          if (!set)
            set = new IncrementalSetConstructor(prevValue.get(value) ?? /* @__PURE__ */ new Set());
          set.remove(id);
          setConstructors.set(value, set);
        };
        for (const changes of history2) {
          for (const record of objectMapValues(changes.added)) {
            if (record.typeName === typeName) {
              const value = record[property];
              add(value, record.id);
            }
          }
          for (const [from2, to] of objectMapValues(changes.updated)) {
            if (to.typeName === typeName) {
              const prev = from2[property];
              const next = to[property];
              if (prev !== next) {
                remove2(prev, to.id);
                add(next, to.id);
              }
            }
          }
          for (const record of objectMapValues(changes.removed)) {
            if (record.typeName === typeName) {
              const value = record[property];
              remove2(value, record.id);
            }
          }
        }
        let nextValue = void 0;
        let nextDiff = void 0;
        for (const [value, setConstructor] of setConstructors) {
          const result = setConstructor.get();
          if (!result)
            continue;
          if (!nextValue)
            nextValue = new Map(prevValue);
          if (!nextDiff)
            nextDiff = /* @__PURE__ */ new Map();
          if (result.value.size === 0) {
            nextValue.delete(value);
          } else {
            nextValue.set(value, result.value);
          }
          nextDiff.set(value, result.diff);
        }
        if (nextValue && nextDiff) {
          return withDiff(nextValue, nextDiff);
        }
        return prevValue;
      },
      { historyLength: 100 }
    );
  }
  /**
   * Create a derivation that will return a signle record matching the given query.
   *
   * It will return undefined if there is no matching record
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optional) The name of the query.
   */
  record(typeName, queryCreator = () => ({}), name = "record:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const ids = this.ids(typeName, queryCreator, name);
    return computed(name, () => {
      for (const id of ids.get()) {
        return this.recordMap.get(id);
      }
      return void 0;
    });
  }
  /**
   * Create a derivation that will return an array of records matching the given query
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  records(typeName, queryCreator = () => ({}), name = "records:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const ids = this.ids(typeName, queryCreator, "ids:" + name);
    return computed(
      name,
      () => {
        return Array.from(ids.get(), (id) => this.recordMap.get(id));
      },
      {
        isEqual: areArraysShallowEqual
      }
    );
  }
  /**
   * Create a derivation that will return the ids of all records of the given type.
   *
   * @param typeName - The name of the type.
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  ids(typeName, queryCreator = () => ({}), name = "ids:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const typeHistory = this.filterHistory(typeName);
    const fromScratch = () => {
      typeHistory.get();
      const query = queryCreator();
      if (Object.keys(query).length === 0) {
        const ids = /* @__PURE__ */ new Set();
        for (const record of this.recordMap.values()) {
          if (record.typeName === typeName)
            ids.add(record.id);
        }
        return ids;
      }
      return executeQuery(this, typeName, query);
    };
    const fromScratchWithDiff = (prevValue) => {
      const nextValue = fromScratch();
      const diff = diffSets(prevValue, nextValue);
      if (diff) {
        return withDiff(nextValue, diff);
      } else {
        return prevValue;
      }
    };
    const cachedQuery = computed("ids_query:" + name, queryCreator, {
      isEqual: import_lodash3.default
    });
    return computed(
      "query:" + name,
      (prevValue, lastComputedEpoch) => {
        const query = cachedQuery.get();
        if (isUninitialized(prevValue)) {
          return fromScratch();
        }
        if (lastComputedEpoch < cachedQuery.lastChangedEpoch) {
          return fromScratchWithDiff(prevValue);
        }
        const history2 = typeHistory.getDiffSince(lastComputedEpoch);
        if (history2 === RESET_VALUE) {
          return fromScratchWithDiff(prevValue);
        }
        const setConstructor = new IncrementalSetConstructor(
          prevValue
        );
        for (const changes of history2) {
          for (const added of objectMapValues(changes.added)) {
            if (added.typeName === typeName && objectMatchesQuery(query, added)) {
              setConstructor.add(added.id);
            }
          }
          for (const [_, updated] of objectMapValues(changes.updated)) {
            if (updated.typeName === typeName) {
              if (objectMatchesQuery(query, updated)) {
                setConstructor.add(updated.id);
              } else {
                setConstructor.remove(updated.id);
              }
            }
          }
          for (const removed of objectMapValues(changes.removed)) {
            if (removed.typeName === typeName) {
              setConstructor.remove(removed.id);
            }
          }
        }
        const result = setConstructor.get();
        if (!result) {
          return prevValue;
        }
        return withDiff(result.value, result.diff);
      },
      { historyLength: 50 }
    );
  }
  exec(typeName, query) {
    const ids = executeQuery(this, typeName, query);
    if (ids.size === 0) {
      return EMPTY_ARRAY;
    }
    return Array.from(ids, (id) => this.recordMap.get(id));
  }
};

// node_modules/@tldraw/store/dist-esm/lib/StoreSideEffects.mjs
var StoreSideEffects = class {
  constructor(store) {
    __publicField(this, "_beforeCreateHandlers", {});
    __publicField(this, "_afterCreateHandlers", {});
    __publicField(this, "_beforeChangeHandlers", {});
    __publicField(this, "_afterChangeHandlers", {});
    __publicField(this, "_beforeDeleteHandlers", {});
    __publicField(this, "_afterDeleteHandlers", {});
    __publicField(this, "_operationCompleteHandlers", []);
    __publicField(this, "_isEnabled", true);
    this.store = store;
  }
  /** @internal */
  isEnabled() {
    return this._isEnabled;
  }
  /** @internal */
  setIsEnabled(enabled) {
    this._isEnabled = enabled;
  }
  /** @internal */
  handleBeforeCreate(record, source) {
    if (!this._isEnabled)
      return record;
    const handlers2 = this._beforeCreateHandlers[record.typeName];
    if (handlers2) {
      let r = record;
      for (const handler of handlers2) {
        r = handler(r, source);
      }
      return r;
    }
    return record;
  }
  /** @internal */
  handleAfterCreate(record, source) {
    if (!this._isEnabled)
      return;
    const handlers2 = this._afterCreateHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(record, source);
      }
    }
  }
  /** @internal */
  handleBeforeChange(prev, next, source) {
    if (!this._isEnabled)
      return next;
    const handlers2 = this._beforeChangeHandlers[next.typeName];
    if (handlers2) {
      let r = next;
      for (const handler of handlers2) {
        r = handler(prev, r, source);
      }
      return r;
    }
    return next;
  }
  /** @internal */
  handleAfterChange(prev, next, source) {
    if (!this._isEnabled)
      return;
    const handlers2 = this._afterChangeHandlers[next.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(prev, next, source);
      }
    }
  }
  /** @internal */
  handleBeforeDelete(record, source) {
    if (!this._isEnabled)
      return true;
    const handlers2 = this._beforeDeleteHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        if (handler(record, source) === false) {
          return false;
        }
      }
    }
    return true;
  }
  /** @internal */
  handleAfterDelete(record, source) {
    if (!this._isEnabled)
      return;
    const handlers2 = this._afterDeleteHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(record, source);
      }
    }
  }
  /** @internal */
  handleOperationComplete(source) {
    if (!this._isEnabled)
      return;
    for (const handler of this._operationCompleteHandlers) {
      handler(source);
    }
  }
  /**
   * Internal helper for registering a bunch of side effects at once and keeping them organized.
   * @internal
   */
  register(handlersByType) {
    const disposes = [];
    for (const [type, handlers2] of Object.entries(handlersByType)) {
      if (handlers2 == null ? void 0 : handlers2.beforeCreate) {
        disposes.push(this.registerBeforeCreateHandler(type, handlers2.beforeCreate));
      }
      if (handlers2 == null ? void 0 : handlers2.afterCreate) {
        disposes.push(this.registerAfterCreateHandler(type, handlers2.afterCreate));
      }
      if (handlers2 == null ? void 0 : handlers2.beforeChange) {
        disposes.push(this.registerBeforeChangeHandler(type, handlers2.beforeChange));
      }
      if (handlers2 == null ? void 0 : handlers2.afterChange) {
        disposes.push(this.registerAfterChangeHandler(type, handlers2.afterChange));
      }
      if (handlers2 == null ? void 0 : handlers2.beforeDelete) {
        disposes.push(this.registerBeforeDeleteHandler(type, handlers2.beforeDelete));
      }
      if (handlers2 == null ? void 0 : handlers2.afterDelete) {
        disposes.push(this.registerAfterDeleteHandler(type, handlers2.afterDelete));
      }
    }
    return () => {
      for (const dispose of disposes)
        dispose();
    };
  }
  /**
   * Register a handler to be called before a record of a certain type is created. Return a
   * modified record from the handler to change the record that will be created.
   *
   * Use this handle only to modify the creation of the record itself. If you want to trigger a
   * side-effect on a different record (for example, moving one shape when another is created),
   * use {@link StoreSideEffects.registerAfterCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {
   *     // only modify shapes created by the user
   *     if (source !== 'user') return shape
   *
   *     //by default, arrow shapes have no label. Let's make sure they always have a label.
   *     if (shape.type === 'arrow') {
   *         return {...shape, props: {...shape.props, text: 'an arrow'}}
   *     }
   *
   *     // other shapes get returned unmodified
   *     return shape
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeCreateHandler(typeName, handler) {
    const handlers2 = this._beforeCreateHandlers[typeName];
    if (!handlers2)
      this._beforeCreateHandlers[typeName] = [];
    this._beforeCreateHandlers[typeName].push(handler);
    return () => remove(this._beforeCreateHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is created. This is useful for side-effects
   * that would update _other_ records. If you want to modify the record being created use
   * {@link StoreSideEffects.registerBeforeCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterCreateHandler('page', (page, source) => {
   *     // Automatically create a shape when a page is created
   *     editor.createShape<TLTextShape>({
   *         id: createShapeId(),
   *         type: 'text',
   *         props: { richText: toRichText(page.name) },
   *     })
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterCreateHandler(typeName, handler) {
    const handlers2 = this._afterCreateHandlers[typeName];
    if (!handlers2)
      this._afterCreateHandlers[typeName] = [];
    this._afterCreateHandlers[typeName].push(handler);
    return () => remove(this._afterCreateHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called before a record is changed. The handler is given the old and
   * new record - you can return a modified record to apply a different update, or the old record
   * to block the update entirely.
   *
   * Use this handler only for intercepting updates to the record itself. If you want to update
   * other records in response to a change, use
   * {@link StoreSideEffects.registerAfterChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {
   *     if (next.isLocked && !prev.isLocked) {
   *         // prevent shapes from ever being locked:
   *         return prev
   *     }
   *     // other types of change are allowed
   *     return next
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeChangeHandler(typeName, handler) {
    const handlers2 = this._beforeChangeHandlers[typeName];
    if (!handlers2)
      this._beforeChangeHandlers[typeName] = [];
    this._beforeChangeHandlers[typeName].push(handler);
    return () => remove(this._beforeChangeHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is changed. This is useful for side-effects
   * that would update _other_ records - if you want to modify the record being changed, use
   * {@link StoreSideEffects.registerBeforeChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {
   *     if (next.props.color === 'red') {
   *         // there can only be one red shape at a time:
   *         const otherRedShapes = editor.getCurrentPageShapes().filter(s => s.props.color === 'red' && s.id !== next.id)
   *         editor.updateShapes(otherRedShapes.map(s => ({...s, props: {...s.props, color: 'blue'}})))
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterChangeHandler(typeName, handler) {
    const handlers2 = this._afterChangeHandlers[typeName];
    if (!handlers2)
      this._afterChangeHandlers[typeName] = [];
    this._afterChangeHandlers[typeName].push(handler);
    return () => remove(this._afterChangeHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called before a record is deleted. The handler can return `false` to
   * prevent the deletion.
   *
   * Use this handler only for intercepting deletions of the record itself. If you want to do
   * something to other records in response to a deletion, use
   * {@link StoreSideEffects.registerAfterDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {
   *     if (shape.props.color === 'red') {
   *         // prevent red shapes from being deleted
   * 	       return false
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeDeleteHandler(typeName, handler) {
    const handlers2 = this._beforeDeleteHandlers[typeName];
    if (!handlers2)
      this._beforeDeleteHandlers[typeName] = [];
    this._beforeDeleteHandlers[typeName].push(handler);
    return () => remove(this._beforeDeleteHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is deleted. This is useful for side-effects
   * that would update _other_ records - if you want to block the deletion of the record itself,
   * use {@link StoreSideEffects.registerBeforeDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {
   *     // if the last shape in a frame is deleted, delete the frame too:
   *     const parentFrame = editor.getShape(shape.parentId)
   *     if (!parentFrame || parentFrame.type !== 'frame') return
   *
   *     const siblings = editor.getSortedChildIdsForParent(parentFrame)
   *     if (siblings.length === 0) {
   *         editor.deleteShape(parentFrame.id)
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterDeleteHandler(typeName, handler) {
    const handlers2 = this._afterDeleteHandlers[typeName];
    if (!handlers2)
      this._afterDeleteHandlers[typeName] = [];
    this._afterDeleteHandlers[typeName].push(handler);
    return () => remove(this._afterDeleteHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called when a store completes an atomic operation.
   *
   * @example
   * ```ts
   * let count = 0
   *
   * editor.sideEffects.registerOperationCompleteHandler(() => count++)
   *
   * editor.selectAll()
   * expect(count).toBe(1)
   *
   * editor.store.atomic(() => {
   *	editor.selectNone()
   * 	editor.selectAll()
   * })
   *
   * expect(count).toBe(2)
   * ```
   *
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   *
   * @public
   */
  registerOperationCompleteHandler(handler) {
    this._operationCompleteHandlers.push(handler);
    return () => remove(this._operationCompleteHandlers, handler);
  }
};
function remove(array2, item) {
  const index3 = array2.indexOf(item);
  if (index3 >= 0) {
    array2.splice(index3, 1);
  }
}

// node_modules/@tldraw/store/dist-esm/lib/devFreeze.mjs
function devFreeze(object2) {
  if (false) {
    return object2;
  }
  const proto = Object.getPrototypeOf(object2);
  if (proto && !(Array.isArray(object2) || proto === Object.prototype || proto === null || proto === STRUCTURED_CLONE_OBJECT_PROTOTYPE)) {
    console.error("cannot include non-js data in a record", object2);
    throw new Error("cannot include non-js data in a record");
  }
  const propNames = Object.getOwnPropertyNames(object2);
  for (const name of propNames) {
    const value = object2[name];
    if (value && typeof value === "object") {
      devFreeze(value);
    }
  }
  return Object.freeze(object2);
}

// node_modules/@tldraw/store/dist-esm/lib/Store.mjs
var Store = class {
  constructor(config) {
    /**
     * The random id of the store.
     */
    __publicField(this, "id");
    /**
     * An AtomMap containing the stores records.
     *
     * @internal
     * @readonly
     */
    __publicField(this, "records");
    /**
     * An atom containing the store's history.
     *
     * @public
     * @readonly
     */
    __publicField(this, "history", atom("history", 0, {
      historyLength: 1e3
    }));
    /**
     * A StoreQueries instance for this store.
     *
     * @public
     * @readonly
     */
    __publicField(this, "query");
    /**
     * A set containing listeners that have been added to this store.
     *
     * @internal
     */
    __publicField(this, "listeners", /* @__PURE__ */ new Set());
    /**
     * An array of history entries that have not yet been flushed.
     *
     * @internal
     */
    __publicField(this, "historyAccumulator", new HistoryAccumulator());
    /**
     * A reactor that responds to changes to the history by squashing the accumulated history and
     * notifying listeners of the changes.
     *
     * @internal
     */
    __publicField(this, "historyReactor");
    __publicField(this, "schema");
    __publicField(this, "props");
    __publicField(this, "scopedTypes");
    __publicField(this, "sideEffects", new StoreSideEffects(this));
    __publicField(this, "isMergingRemoteChanges", false);
    __publicField(this, "_integrityChecker");
    __publicField(this, "_isPossiblyCorrupted", false);
    __publicField(this, "pendingAfterEvents", null);
    __publicField(this, "_isInAtomicOp", false);
    const { initialData, schema, id } = config;
    this.id = id ?? uniqueId();
    this.schema = schema;
    this.props = config.props;
    if (initialData) {
      this.records = new AtomMap(
        "store",
        objectMapEntries(initialData).map(([id2, record]) => [
          id2,
          devFreeze(this.schema.validateRecord(this, record, "initialize", null))
        ])
      );
    } else {
      this.records = new AtomMap("store");
    }
    this.query = new StoreQueries(this.records, this.history);
    this.historyReactor = reactor(
      "Store.historyReactor",
      () => {
        this.history.get();
        this._flushHistory();
      },
      { scheduleEffect: (cb) => this.cancelHistoryReactor = throttleToNextFrame(cb) }
    );
    this.scopedTypes = {
      document: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "document").map((t2) => t2.typeName)
      ),
      session: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "session").map((t2) => t2.typeName)
      ),
      presence: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "presence").map((t2) => t2.typeName)
      )
    };
  }
  /**
   * Function to dispose of any in-flight timeouts.
   *
   * @internal
   */
  cancelHistoryReactor() {
  }
  _flushHistory() {
    if (this.historyAccumulator.hasChanges()) {
      const entries = this.historyAccumulator.flush();
      for (const { changes, source } of entries) {
        let instanceChanges = null;
        let documentChanges = null;
        let presenceChanges = null;
        for (const { onHistory, filters } of this.listeners) {
          if (filters.source !== "all" && filters.source !== source) {
            continue;
          }
          if (filters.scope !== "all") {
            if (filters.scope === "document") {
              documentChanges ?? (documentChanges = this.filterChangesByScope(changes, "document"));
              if (!documentChanges)
                continue;
              onHistory({ changes: documentChanges, source });
            } else if (filters.scope === "session") {
              instanceChanges ?? (instanceChanges = this.filterChangesByScope(changes, "session"));
              if (!instanceChanges)
                continue;
              onHistory({ changes: instanceChanges, source });
            } else {
              presenceChanges ?? (presenceChanges = this.filterChangesByScope(changes, "presence"));
              if (!presenceChanges)
                continue;
              onHistory({ changes: presenceChanges, source });
            }
          } else {
            onHistory({ changes, source });
          }
        }
      }
    }
  }
  dispose() {
    this.cancelHistoryReactor();
  }
  /**
   * Filters out non-document changes from a diff. Returns null if there are no changes left.
   * @param change - the records diff
   * @param scope - the records scope
   * @returns
   */
  filterChangesByScope(change, scope) {
    const result = {
      added: filterEntries(change.added, (_, r) => this.scopedTypes[scope].has(r.typeName)),
      updated: filterEntries(change.updated, (_, r) => this.scopedTypes[scope].has(r[1].typeName)),
      removed: filterEntries(change.removed, (_, r) => this.scopedTypes[scope].has(r.typeName))
    };
    if (Object.keys(result.added).length === 0 && Object.keys(result.updated).length === 0 && Object.keys(result.removed).length === 0) {
      return null;
    }
    return result;
  }
  /**
   * Update the history with a diff of changes.
   *
   * @param changes - The changes to add to the history.
   */
  updateHistory(changes) {
    this.historyAccumulator.add({
      changes,
      source: this.isMergingRemoteChanges ? "remote" : "user"
    });
    if (this.listeners.size === 0) {
      this.historyAccumulator.clear();
    }
    this.history.set(this.history.get() + 1, changes);
  }
  validate(phase) {
    this.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null));
  }
  /**
   * Add some records to the store. It's an error if they already exist.
   *
   * @param records - The records to add.
   * @param phaseOverride - The phase override.
   * @public
   */
  put(records, phaseOverride) {
    this.atomic(() => {
      const updates = {};
      const additions = {};
      let record;
      let didChange = false;
      const source = this.isMergingRemoteChanges ? "remote" : "user";
      for (let i = 0, n = records.length; i < n; i++) {
        record = records[i];
        const initialValue = this.records.__unsafe__getWithoutCapture(record.id);
        if (initialValue) {
          record = this.sideEffects.handleBeforeChange(initialValue, record, source);
          const validated = this.schema.validateRecord(
            this,
            record,
            phaseOverride ?? "updateRecord",
            initialValue
          );
          if (validated === initialValue)
            continue;
          record = devFreeze(record);
          this.records.set(record.id, record);
          didChange = true;
          updates[record.id] = [initialValue, record];
          this.addDiffForAfterEvent(initialValue, record);
        } else {
          record = this.sideEffects.handleBeforeCreate(record, source);
          didChange = true;
          record = this.schema.validateRecord(
            this,
            record,
            phaseOverride ?? "createRecord",
            null
          );
          record = devFreeze(record);
          additions[record.id] = record;
          this.addDiffForAfterEvent(null, record);
          this.records.set(record.id, record);
        }
      }
      if (!didChange)
        return;
      this.updateHistory({
        added: additions,
        updated: updates,
        removed: {}
      });
    });
  }
  /**
   * Remove some records from the store via their ids.
   *
   * @param ids - The ids of the records to remove.
   * @public
   */
  remove(ids) {
    this.atomic(() => {
      const toDelete = new Set(ids);
      const source = this.isMergingRemoteChanges ? "remote" : "user";
      if (this.sideEffects.isEnabled()) {
        for (const id of ids) {
          const record = this.records.__unsafe__getWithoutCapture(id);
          if (!record)
            continue;
          if (this.sideEffects.handleBeforeDelete(record, source) === false) {
            toDelete.delete(id);
          }
        }
      }
      const actuallyDeleted = this.records.deleteMany(toDelete);
      if (actuallyDeleted.length === 0)
        return;
      const removed = {};
      for (const [id, record] of actuallyDeleted) {
        removed[id] = record;
        this.addDiffForAfterEvent(record, null);
      }
      this.updateHistory({ added: {}, updated: {}, removed });
    });
  }
  /**
   * Get the value of a store record by its id.
   *
   * @param id - The id of the record to get.
   * @public
   */
  get(id) {
    return this.records.get(id);
  }
  /**
   * Get the value of a store record by its id without updating its epoch.
   *
   * @param id - The id of the record to get.
   * @public
   */
  unsafeGetWithoutCapture(id) {
    return this.records.__unsafe__getWithoutCapture(id);
  }
  /**
   * Creates a JSON payload from the record store.
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'.
   * @returns The record store snapshot as a JSON payload.
   */
  serialize(scope = "document") {
    const result = {};
    for (const [id, record] of this.records) {
      if (scope === "all" || this.scopedTypes[scope].has(record.typeName)) {
        result[id] = record;
      }
    }
    return result;
  }
  /**
   * Get a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'.
   *
   * @public
   */
  getStoreSnapshot(scope = "document") {
    return {
      store: this.serialize(scope),
      schema: this.schema.serialize()
    };
  }
  /**
   * @deprecated use `getSnapshot` from the 'tldraw' package instead.
   */
  getSnapshot(scope = "document") {
    console.warn(
      "[tldraw] `Store.getSnapshot` is deprecated and will be removed in a future release. Use `getSnapshot` from the `tldraw` package instead."
    );
    return this.getStoreSnapshot(scope);
  }
  /**
   * Migrate a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getSnapshot()
   * store.migrateSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */
  migrateSnapshot(snapshot) {
    const migrationResult = this.schema.migrateStoreSnapshot(snapshot);
    if (migrationResult.type === "error") {
      throw new Error(`Failed to migrate snapshot: ${migrationResult.reason}`);
    }
    return {
      store: migrationResult.value,
      schema: this.schema.serialize()
    };
  }
  /**
   * Load a serialized snapshot.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */
  loadStoreSnapshot(snapshot) {
    const migrationResult = this.schema.migrateStoreSnapshot(snapshot);
    if (migrationResult.type === "error") {
      throw new Error(`Failed to migrate snapshot: ${migrationResult.reason}`);
    }
    const prevSideEffectsEnabled = this.sideEffects.isEnabled();
    try {
      this.sideEffects.setIsEnabled(false);
      this.atomic(() => {
        this.clear();
        this.put(Object.values(migrationResult.value));
        this.ensureStoreIsUsable();
      });
    } finally {
      this.sideEffects.setIsEnabled(prevSideEffectsEnabled);
    }
  }
  /**
   * @public
   * @deprecated use `loadSnapshot` from the 'tldraw' package instead.
   */
  loadSnapshot(snapshot) {
    console.warn(
      "[tldraw] `Store.loadSnapshot` is deprecated and will be removed in a future release. Use `loadSnapshot` from the 'tldraw' package instead."
    );
    this.loadStoreSnapshot(snapshot);
  }
  /**
   * Get an array of all values in the store.
   *
   * @returns An array of all values in the store.
   * @public
   */
  allRecords() {
    return Array.from(this.records.values());
  }
  /**
   * Removes all records from the store.
   *
   * @public
   */
  clear() {
    this.remove(Array.from(this.records.keys()));
  }
  /**
   * Update a record. To update multiple records at once, use the `update` method of the
   * `TypedStore` class.
   *
   * @param id - The id of the record to update.
   * @param updater - A function that updates the record.
   */
  update(id, updater) {
    const existing = this.unsafeGetWithoutCapture(id);
    if (!existing) {
      console.error(`Record ${id} not found. This is probably an error`);
      return;
    }
    this.put([updater(existing)]);
  }
  /**
   * Get whether the record store has a id.
   *
   * @param id - The id of the record to check.
   * @public
   */
  has(id) {
    return this.records.has(id);
  }
  /**
   * Add a new listener to the store.
   *
   * @param onHistory - The listener to call when the store updates.
   * @param filters - Filters to apply to the listener.
   * @returns A function to remove the listener.
   */
  listen(onHistory, filters) {
    this._flushHistory();
    const listener = {
      onHistory,
      filters: {
        source: (filters == null ? void 0 : filters.source) ?? "all",
        scope: (filters == null ? void 0 : filters.scope) ?? "all"
      }
    };
    if (!this.historyReactor.scheduler.isActivelyListening) {
      this.historyReactor.start();
      this.historyReactor.scheduler.execute();
    }
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
      if (this.listeners.size === 0) {
        this.historyReactor.stop();
      }
    };
  }
  /**
   * Merge changes from a remote source
   *
   * @param fn - A function that merges the external changes.
   * @public
   */
  mergeRemoteChanges(fn2) {
    if (this.isMergingRemoteChanges) {
      return fn2();
    }
    if (this._isInAtomicOp) {
      throw new Error("Cannot merge remote changes while in atomic operation");
    }
    try {
      this.atomic(fn2, true, true);
    } finally {
      this.ensureStoreIsUsable();
    }
  }
  /**
   * Run `fn` and return a {@link RecordsDiff} of the changes that occurred as a result.
   */
  extractingChanges(fn2) {
    const changes = [];
    const dispose = this.historyAccumulator.addInterceptor((entry2) => changes.push(entry2.changes));
    try {
      transact(fn2);
      return squashRecordDiffs(changes);
    } finally {
      dispose();
    }
  }
  applyDiff(diff, {
    runCallbacks = true,
    ignoreEphemeralKeys = false
  } = {}) {
    this.atomic(() => {
      const toPut = objectMapValues(diff.added);
      for (const [_from, to] of objectMapValues(diff.updated)) {
        const type = this.schema.getType(to.typeName);
        if (ignoreEphemeralKeys && type.ephemeralKeySet.size) {
          const existing = this.get(to.id);
          if (!existing) {
            toPut.push(to);
            continue;
          }
          let changed = null;
          for (const [key, value] of Object.entries(to)) {
            if (type.ephemeralKeySet.has(key) || Object.is(value, getOwnProperty(existing, key))) {
              continue;
            }
            if (!changed)
              changed = { ...existing };
            changed[key] = value;
          }
          if (changed)
            toPut.push(changed);
        } else {
          toPut.push(to);
        }
      }
      const toRemove = objectMapKeys(diff.removed);
      if (toPut.length) {
        this.put(toPut);
      }
      if (toRemove.length) {
        this.remove(toRemove);
      }
    }, runCallbacks);
  }
  /**
   * Create a cache based on values in the store. Pass in a function that takes and ID and a
   * signal for the underlying record. Return a signal (usually a computed) for the cached value.
   * For simple derivations, use {@link Store.createComputedCache}. This function is useful if you
   * need more precise control over intermediate values.
   */
  createCache(create) {
    const cache = new WeakCache();
    return {
      get: (id) => {
        const atom2 = this.records.getAtom(id);
        if (!atom2)
          return void 0;
        return cache.get(atom2, () => create(id, atom2)).get();
      }
    };
  }
  /**
   * Create a computed cache.
   *
   * @param name - The name of the derivation cache.
   * @param derive - A function used to derive the value of the cache.
   * @param opts - Options for the computed cache.
   * @public
   */
  createComputedCache(name, derive, opts) {
    return this.createCache((id, record) => {
      const recordSignal = (opts == null ? void 0 : opts.areRecordsEqual) ? computed(`${name}:${id}:isEqual`, () => record.get(), { isEqual: opts.areRecordsEqual }) : record;
      return computed(
        name + ":" + id,
        () => {
          return derive(recordSignal.get());
        },
        {
          isEqual: opts == null ? void 0 : opts.areResultsEqual
        }
      );
    });
  }
  /** @internal */
  ensureStoreIsUsable() {
    this.atomic(() => {
      var _a5;
      this._integrityChecker ?? (this._integrityChecker = this.schema.createIntegrityChecker(this));
      (_a5 = this._integrityChecker) == null ? void 0 : _a5.call(this);
    });
  }
  /** @internal */
  markAsPossiblyCorrupted() {
    this._isPossiblyCorrupted = true;
  }
  /** @internal */
  isPossiblyCorrupted() {
    return this._isPossiblyCorrupted;
  }
  addDiffForAfterEvent(before, after) {
    assert(this.pendingAfterEvents, "must be in event operation");
    if (before === after)
      return;
    if (before && after)
      assert(before.id === after.id);
    if (!before && !after)
      return;
    const id = (before || after).id;
    const existing = this.pendingAfterEvents.get(id);
    if (existing) {
      existing.after = after;
    } else {
      this.pendingAfterEvents.set(id, { before, after });
    }
  }
  flushAtomicCallbacks(isMergingRemoteChanges) {
    let updateDepth = 0;
    let source = isMergingRemoteChanges ? "remote" : "user";
    while (this.pendingAfterEvents) {
      const events = this.pendingAfterEvents;
      this.pendingAfterEvents = null;
      if (!this.sideEffects.isEnabled())
        continue;
      updateDepth++;
      if (updateDepth > 100) {
        throw new Error("Maximum store update depth exceeded, bailing out");
      }
      for (const { before, after } of events.values()) {
        if (before && after && before !== after && !(0, import_lodash4.default)(before, after)) {
          this.sideEffects.handleAfterChange(before, after, source);
        } else if (before && !after) {
          this.sideEffects.handleAfterDelete(before, source);
        } else if (!before && after) {
          this.sideEffects.handleAfterCreate(after, source);
        }
      }
      if (!this.pendingAfterEvents) {
        this.sideEffects.handleOperationComplete(source);
      } else {
        source = "user";
      }
    }
  }
  /** @internal */
  atomic(fn2, runCallbacks = true, isMergingRemoteChanges = false) {
    return transact(() => {
      if (this._isInAtomicOp) {
        if (!this.pendingAfterEvents)
          this.pendingAfterEvents = /* @__PURE__ */ new Map();
        const prevSideEffectsEnabled2 = this.sideEffects.isEnabled();
        assert(!isMergingRemoteChanges, "cannot call mergeRemoteChanges while in atomic operation");
        try {
          if (prevSideEffectsEnabled2 && !runCallbacks) {
            this.sideEffects.setIsEnabled(false);
          }
          return fn2();
        } finally {
          this.sideEffects.setIsEnabled(prevSideEffectsEnabled2);
        }
      }
      this.pendingAfterEvents = /* @__PURE__ */ new Map();
      const prevSideEffectsEnabled = this.sideEffects.isEnabled();
      this.sideEffects.setIsEnabled(runCallbacks ?? prevSideEffectsEnabled);
      this._isInAtomicOp = true;
      if (isMergingRemoteChanges) {
        this.isMergingRemoteChanges = true;
      }
      try {
        const result = fn2();
        this.isMergingRemoteChanges = false;
        this.flushAtomicCallbacks(isMergingRemoteChanges);
        return result;
      } finally {
        this.pendingAfterEvents = null;
        this.sideEffects.setIsEnabled(prevSideEffectsEnabled);
        this._isInAtomicOp = false;
        this.isMergingRemoteChanges = false;
      }
    });
  }
  /** @internal */
  addHistoryInterceptor(fn2) {
    return this.historyAccumulator.addInterceptor(
      (entry2) => fn2(entry2, this.isMergingRemoteChanges ? "remote" : "user")
    );
  }
};
function squashHistoryEntries(entries) {
  if (entries.length === 0)
    return [];
  const chunked = [];
  let chunk = [entries[0]];
  let entry2;
  for (let i = 1, n = entries.length; i < n; i++) {
    entry2 = entries[i];
    if (chunk[0].source !== entry2.source) {
      chunked.push(chunk);
      chunk = [];
    }
    chunk.push(entry2);
  }
  chunked.push(chunk);
  return devFreeze(
    chunked.map((chunk2) => ({
      source: chunk2[0].source,
      changes: squashRecordDiffs(chunk2.map((e) => e.changes))
    }))
  );
}
var HistoryAccumulator = class {
  constructor() {
    __publicField(this, "_history", []);
    __publicField(this, "_interceptors", /* @__PURE__ */ new Set());
  }
  addInterceptor(fn2) {
    this._interceptors.add(fn2);
    return () => {
      this._interceptors.delete(fn2);
    };
  }
  add(entry2) {
    this._history.push(entry2);
    for (const interceptor of this._interceptors) {
      interceptor(entry2);
    }
  }
  flush() {
    const history2 = squashHistoryEntries(this._history);
    this._history = [];
    return history2;
  }
  clear() {
    this._history = [];
  }
  hasChanges() {
    return this._history.length > 0;
  }
};
function createComputedCache(name, derive, opts) {
  const cache = new WeakCache();
  return {
    get(context, id) {
      const computedCache = cache.get(context, () => {
        const store = context instanceof Store ? context : context.store;
        return store.createComputedCache(name, (record) => derive(context, record), opts);
      });
      return computedCache.get(id);
    }
  };
}

// node_modules/@tldraw/store/dist-esm/lib/migrate.mjs
var didWarn = false;
function defineMigrations(opts) {
  const { currentVersion, firstVersion, migrators = {}, subTypeKey, subTypeMigrations } = opts;
  if (!didWarn) {
    console.warn(
      `The 'defineMigrations' function is deprecated and will be removed in a future release. Use the new migrations API instead. See the migration guide for more info: https://tldraw.dev/docs/persistence#Updating-legacy-shape-migrations-defineMigrations`
    );
    didWarn = true;
  }
  if (typeof currentVersion === "number" && typeof firstVersion === "number") {
    if (currentVersion === firstVersion) {
      throw Error(`Current version is equal to initial version.`);
    } else if (currentVersion < firstVersion) {
      throw Error(`Current version is lower than initial version.`);
    }
  }
  return {
    firstVersion: firstVersion ?? 0,
    // defaults
    currentVersion: currentVersion ?? 0,
    // defaults
    migrators,
    subTypeKey,
    subTypeMigrations
  };
}
function squashDependsOn(sequence) {
  const result = [];
  for (let i = sequence.length - 1; i >= 0; i--) {
    const elem = sequence[i];
    if (!("id" in elem)) {
      const dependsOn = elem.dependsOn;
      const prev = result[0];
      if (prev) {
        result[0] = {
          ...prev,
          dependsOn: dependsOn.concat(prev.dependsOn ?? [])
        };
      }
    } else {
      result.unshift(elem);
    }
  }
  return result;
}
function createMigrationSequence({
  sequence,
  sequenceId,
  retroactive = true
}) {
  const migrations = {
    sequenceId,
    retroactive,
    sequence: squashDependsOn(sequence)
  };
  validateMigrations(migrations);
  return migrations;
}
function createMigrationIds(sequenceId, versions) {
  return Object.fromEntries(
    objectMapEntries(versions).map(([key, version2]) => [key, `${sequenceId}/${version2}`])
  );
}
function createRecordMigrationSequence(opts) {
  const sequenceId = opts.sequenceId;
  return createMigrationSequence({
    sequenceId,
    retroactive: opts.retroactive ?? true,
    sequence: opts.sequence.map(
      (m) => "id" in m ? {
        ...m,
        scope: "record",
        filter: (r) => {
          var _a5, _b;
          return r.typeName === opts.recordType && (((_a5 = m.filter) == null ? void 0 : _a5.call(m, r)) ?? true) && (((_b = opts.filter) == null ? void 0 : _b.call(opts, r)) ?? true);
        }
      } : m
    )
  });
}
function sortMigrations(migrations) {
  const byId = new Map(migrations.map((m) => [m.id, m]));
  const isProcessing = /* @__PURE__ */ new Set();
  const result = [];
  function process2(m) {
    assert(!isProcessing.has(m.id), `Circular dependency in migrations: ${m.id}`);
    isProcessing.add(m.id);
    const { version: version2, sequenceId } = parseMigrationId(m.id);
    const parent = byId.get(`${sequenceId}/${version2 - 1}`);
    if (parent) {
      process2(parent);
    }
    if (m.dependsOn) {
      for (const dep of m.dependsOn) {
        const depMigration = byId.get(dep);
        if (depMigration) {
          process2(depMigration);
        }
      }
    }
    byId.delete(m.id);
    result.push(m);
  }
  for (const m of byId.values()) {
    process2(m);
  }
  return result;
}
function parseMigrationId(id) {
  const [sequenceId, version2] = id.split("/");
  return { sequenceId, version: parseInt(version2) };
}
function validateMigrationId(id, expectedSequenceId) {
  if (expectedSequenceId) {
    assert(
      id.startsWith(expectedSequenceId + "/"),
      `Every migration in sequence '${expectedSequenceId}' must have an id starting with '${expectedSequenceId}/'. Got invalid id: '${id}'`
    );
  }
  assert(id.match(/^(.*?)\/(0|[1-9]\d*)$/), `Invalid migration id: '${id}'`);
}
function validateMigrations(migrations) {
  assert(
    !migrations.sequenceId.includes("/"),
    `sequenceId cannot contain a '/', got ${migrations.sequenceId}`
  );
  assert(migrations.sequenceId.length, "sequenceId must be a non-empty string");
  if (migrations.sequence.length === 0) {
    return;
  }
  validateMigrationId(migrations.sequence[0].id, migrations.sequenceId);
  let n = parseMigrationId(migrations.sequence[0].id).version;
  assert(
    n === 1,
    `Expected the first migrationId to be '${migrations.sequenceId}/1' but got '${migrations.sequence[0].id}'`
  );
  for (let i = 1; i < migrations.sequence.length; i++) {
    const id = migrations.sequence[i].id;
    validateMigrationId(id, migrations.sequenceId);
    const m = parseMigrationId(id).version;
    assert(
      m === n + 1,
      `Migration id numbers must increase in increments of 1, expected ${migrations.sequenceId}/${n + 1} but got '${migrations.sequence[i].id}'`
    );
    n = m;
  }
}
var MigrationFailureReason = ((MigrationFailureReason2) => {
  MigrationFailureReason2["IncompatibleSubtype"] = "incompatible-subtype";
  MigrationFailureReason2["UnknownType"] = "unknown-type";
  MigrationFailureReason2["TargetVersionTooNew"] = "target-version-too-new";
  MigrationFailureReason2["TargetVersionTooOld"] = "target-version-too-old";
  MigrationFailureReason2["MigrationError"] = "migration-error";
  MigrationFailureReason2["UnrecognizedSubtype"] = "unrecognized-subtype";
  return MigrationFailureReason2;
})(MigrationFailureReason || {});

// node_modules/@tldraw/store/dist-esm/lib/StoreSchema.mjs
function upgradeSchema(schema) {
  if (schema.schemaVersion > 2 || schema.schemaVersion < 1)
    return Result.err("Bad schema version");
  if (schema.schemaVersion === 2)
    return Result.ok(schema);
  const result = {
    schemaVersion: 2,
    sequences: {
      "com.tldraw.store": schema.storeVersion
    }
  };
  for (const [typeName, recordVersion] of Object.entries(schema.recordVersions)) {
    result.sequences[`com.tldraw.${typeName}`] = recordVersion.version;
    if ("subTypeKey" in recordVersion) {
      for (const [subType, version2] of Object.entries(recordVersion.subTypeVersions)) {
        result.sequences[`com.tldraw.${typeName}.${subType}`] = version2;
      }
    }
  }
  return Result.ok(result);
}
var StoreSchema = class _StoreSchema {
  constructor(types, options2) {
    __publicField(this, "migrations", {});
    __publicField(this, "sortedMigrations");
    var _a5;
    this.types = types;
    this.options = options2;
    for (const m of options2.migrations ?? []) {
      assert(!this.migrations[m.sequenceId], `Duplicate migration sequenceId ${m.sequenceId}`);
      validateMigrations(m);
      this.migrations[m.sequenceId] = m;
    }
    const allMigrations = Object.values(this.migrations).flatMap((m) => m.sequence);
    this.sortedMigrations = sortMigrations(allMigrations);
    for (const migration of this.sortedMigrations) {
      if (!((_a5 = migration.dependsOn) == null ? void 0 : _a5.length))
        continue;
      for (const dep of migration.dependsOn) {
        const depMigration = allMigrations.find((m) => m.id === dep);
        assert(depMigration, `Migration '${migration.id}' depends on missing migration '${dep}'`);
      }
    }
  }
  static create(types, options2) {
    return new _StoreSchema(types, options2 ?? {});
  }
  validateRecord(store, record, phase, recordBefore) {
    try {
      const recordType = getOwnProperty(this.types, record.typeName);
      if (!recordType) {
        throw new Error(`Missing definition for record type ${record.typeName}`);
      }
      return recordType.validate(record, recordBefore ?? void 0);
    } catch (error) {
      if (this.options.onValidationFailure) {
        return this.options.onValidationFailure({
          store,
          record,
          phase,
          recordBefore,
          error
        });
      } else {
        throw error;
      }
    }
  }
  // TODO: use a weakmap to store the result of this function
  getMigrationsSince(persistedSchema) {
    const upgradeResult = upgradeSchema(persistedSchema);
    if (!upgradeResult.ok) {
      return upgradeResult;
    }
    const schema = upgradeResult.value;
    const sequenceIdsToInclude = new Set(
      // start with any shared sequences
      Object.keys(schema.sequences).filter((sequenceId) => this.migrations[sequenceId])
    );
    for (const sequenceId in this.migrations) {
      if (schema.sequences[sequenceId] === void 0 && this.migrations[sequenceId].retroactive) {
        sequenceIdsToInclude.add(sequenceId);
      }
    }
    if (sequenceIdsToInclude.size === 0) {
      return Result.ok([]);
    }
    const allMigrationsToInclude = /* @__PURE__ */ new Set();
    for (const sequenceId of sequenceIdsToInclude) {
      const theirVersion = schema.sequences[sequenceId];
      if (typeof theirVersion !== "number" && this.migrations[sequenceId].retroactive || theirVersion === 0) {
        for (const migration of this.migrations[sequenceId].sequence) {
          allMigrationsToInclude.add(migration.id);
        }
        continue;
      }
      const theirVersionId = `${sequenceId}/${theirVersion}`;
      const idx = this.migrations[sequenceId].sequence.findIndex((m) => m.id === theirVersionId);
      if (idx === -1) {
        return Result.err("Incompatible schema?");
      }
      for (const migration of this.migrations[sequenceId].sequence.slice(idx + 1)) {
        allMigrationsToInclude.add(migration.id);
      }
    }
    return Result.ok(this.sortedMigrations.filter(({ id }) => allMigrationsToInclude.has(id)));
  }
  migratePersistedRecord(record, persistedSchema, direction = "up") {
    const migrations = this.getMigrationsSince(persistedSchema);
    if (!migrations.ok) {
      console.error("Error migrating record", migrations.error);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    let migrationsToApply = migrations.value;
    if (migrationsToApply.length === 0) {
      return { type: "success", value: record };
    }
    if (migrationsToApply.some((m) => m.scope === "store")) {
      return {
        type: "error",
        reason: direction === "down" ? MigrationFailureReason.TargetVersionTooOld : MigrationFailureReason.TargetVersionTooNew
      };
    }
    if (direction === "down") {
      if (!migrationsToApply.every((m) => m.down)) {
        return {
          type: "error",
          reason: MigrationFailureReason.TargetVersionTooOld
        };
      }
      migrationsToApply = migrationsToApply.slice().reverse();
    }
    record = structuredClone(record);
    try {
      for (const migration of migrationsToApply) {
        if (migration.scope === "store")
          throw new Error(
            /* won't happen, just for TS */
          );
        const shouldApply = migration.filter ? migration.filter(record) : true;
        if (!shouldApply)
          continue;
        const result = migration[direction](record);
        if (result) {
          record = structuredClone(result);
        }
      }
    } catch (e) {
      console.error("Error migrating record", e);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    return { type: "success", value: record };
  }
  migrateStoreSnapshot(snapshot) {
    let { store } = snapshot;
    const migrations = this.getMigrationsSince(snapshot.schema);
    if (!migrations.ok) {
      console.error("Error migrating store", migrations.error);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    const migrationsToApply = migrations.value;
    if (migrationsToApply.length === 0) {
      return { type: "success", value: store };
    }
    store = structuredClone(store);
    try {
      for (const migration of migrationsToApply) {
        if (migration.scope === "record") {
          for (const [id, record] of Object.entries(store)) {
            const shouldApply = migration.filter ? migration.filter(record) : true;
            if (!shouldApply)
              continue;
            const result = migration.up(record);
            if (result) {
              store[id] = structuredClone(result);
            }
          }
        } else if (migration.scope === "store") {
          const result = migration.up(store);
          if (result) {
            store = structuredClone(result);
          }
        } else {
          exhaustiveSwitchError(migration);
        }
      }
    } catch (e) {
      console.error("Error migrating store", e);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    return { type: "success", value: store };
  }
  /** @internal */
  createIntegrityChecker(store) {
    var _a5, _b;
    return ((_b = (_a5 = this.options).createIntegrityChecker) == null ? void 0 : _b.call(_a5, store)) ?? void 0;
  }
  serialize() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId, sequence }) => [
          sequenceId,
          sequence.length ? parseMigrationId(sequence.at(-1).id).version : 0
        ])
      )
    };
  }
  /**
   * @deprecated This is only here for legacy reasons, don't use it unless you have david's blessing!
   */
  serializeEarliestVersion() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId }) => [sequenceId, 0])
      )
    };
  }
  /** @internal */
  getType(typeName) {
    const type = getOwnProperty(this.types, typeName);
    assert(type, "record type does not exists");
    return type;
  }
};

// node_modules/@tldraw/store/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "@tldraw/store",
  "3.13.1",
  "esm"
);

// node_modules/@tldraw/validate/dist-esm/lib/validation.mjs
var validation_exports = {};
__export(validation_exports, {
  ArrayOfValidator: () => ArrayOfValidator,
  DictValidator: () => DictValidator,
  ObjectValidator: () => ObjectValidator,
  UnionValidator: () => UnionValidator,
  ValidationError: () => ValidationError,
  Validator: () => Validator,
  any: () => any,
  array: () => array,
  arrayOf: () => arrayOf,
  bigint: () => bigint,
  boolean: () => boolean,
  dict: () => dict,
  httpUrl: () => httpUrl,
  indexKey: () => indexKey,
  integer: () => integer,
  jsonDict: () => jsonDict,
  jsonValue: () => jsonValue,
  linkUrl: () => linkUrl,
  literal: () => literal,
  literalEnum: () => literalEnum,
  model: () => model,
  nonZeroInteger: () => nonZeroInteger,
  nonZeroNumber: () => nonZeroNumber,
  nullable: () => nullable,
  number: () => number,
  numberUnion: () => numberUnion,
  object: () => object,
  optional: () => optional,
  or: () => or,
  positiveInteger: () => positiveInteger,
  positiveNumber: () => positiveNumber,
  setEnum: () => setEnum,
  srcUrl: () => srcUrl,
  string: () => string,
  union: () => union,
  unknown: () => unknown,
  unknownObject: () => unknownObject
});
function formatPath(path) {
  if (!path.length) {
    return null;
  }
  let formattedPath = "";
  for (const item of path) {
    if (typeof item === "number") {
      formattedPath += `.${item}`;
    } else if (item.startsWith("(")) {
      if (formattedPath.endsWith(")")) {
        formattedPath = `${formattedPath.slice(0, -1)}, ${item.slice(1)}`;
      } else {
        formattedPath += item;
      }
    } else {
      formattedPath += `.${item}`;
    }
  }
  formattedPath = formattedPath.replace(/id = [^,]+, /, "").replace(/id = [^)]+/, "");
  if (formattedPath.startsWith(".")) {
    return formattedPath.slice(1);
  }
  return formattedPath;
}
var ValidationError = class extends Error {
  constructor(rawMessage, path = []) {
    const formattedPath = formatPath(path);
    const indentedMessage = rawMessage.split("\n").map((line, i) => i === 0 ? line : `  ${line}`).join("\n");
    super(path ? `At ${formattedPath}: ${indentedMessage}` : indentedMessage);
    __publicField(this, "name", "ValidationError");
    this.rawMessage = rawMessage;
    this.path = path;
  }
};
function prefixError(path, fn2) {
  try {
    return fn2();
  } catch (err) {
    if (err instanceof ValidationError) {
      throw new ValidationError(err.rawMessage, [path, ...err.path]);
    }
    throw new ValidationError(err.toString(), [path]);
  }
}
function typeToString(value) {
  if (value === null)
    return "null";
  if (Array.isArray(value))
    return "an array";
  const type = typeof value;
  switch (type) {
    case "bigint":
    case "boolean":
    case "function":
    case "number":
    case "string":
    case "symbol":
      return `a ${type}`;
    case "object":
      return `an ${type}`;
    case "undefined":
      return "undefined";
    default:
      exhaustiveSwitchError(type);
  }
}
var Validator = class _Validator {
  constructor(validationFn, validateUsingKnownGoodVersionFn) {
    this.validationFn = validationFn;
    this.validateUsingKnownGoodVersionFn = validateUsingKnownGoodVersionFn;
  }
  /**
   * Asserts that the passed value is of the correct type and returns it. The returned value is
   * guaranteed to be referentially equal to the passed value.
   */
  validate(value) {
    const validated = this.validationFn(value);
    if (!Object.is(value, validated)) {
      throw new ValidationError("Validator functions must return the same value they were passed");
    }
    return validated;
  }
  validateUsingKnownGoodVersion(knownGoodValue, newValue) {
    if (Object.is(knownGoodValue, newValue)) {
      return knownGoodValue;
    }
    if (this.validateUsingKnownGoodVersionFn) {
      return this.validateUsingKnownGoodVersionFn(knownGoodValue, newValue);
    }
    return this.validate(newValue);
  }
  /** Checks that the passed value is of the correct type. */
  isValid(value) {
    try {
      this.validate(value);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Returns a new validator that also accepts null or undefined. The resulting value will always be
   * null.
   */
  nullable() {
    return nullable(this);
  }
  /**
   * Returns a new validator that also accepts null or undefined. The resulting value will always be
   * null.
   */
  optional() {
    return optional(this);
  }
  /**
   * Refine this validation to a new type. The passed-in validation function should throw an error
   * if the value can't be converted to the new type, or return the new type otherwise.
   */
  refine(otherValidationFn) {
    return new _Validator(
      (value) => {
        return otherValidationFn(this.validate(value));
      },
      (knownGoodValue, newValue) => {
        const validated = this.validateUsingKnownGoodVersion(knownGoodValue, newValue);
        if (Object.is(knownGoodValue, validated)) {
          return knownGoodValue;
        }
        return otherValidationFn(validated);
      }
    );
  }
  check(nameOrCheckFn, checkFn) {
    if (typeof nameOrCheckFn === "string") {
      return this.refine((value) => {
        prefixError(`(check ${nameOrCheckFn})`, () => checkFn(value));
        return value;
      });
    } else {
      return this.refine((value) => {
        nameOrCheckFn(value);
        return value;
      });
    }
  }
};
var ArrayOfValidator = class extends Validator {
  constructor(itemValidator) {
    super(
      (value) => {
        const arr = array.validate(value);
        for (let i = 0; i < arr.length; i++) {
          prefixError(i, () => itemValidator.validate(arr[i]));
        }
        return arr;
      },
      (knownGoodValue, newValue) => {
        if (!itemValidator.validateUsingKnownGoodVersion)
          return this.validate(newValue);
        const arr = array.validate(newValue);
        let isDifferent = knownGoodValue.length !== arr.length;
        for (let i = 0; i < arr.length; i++) {
          const item = arr[i];
          if (i >= knownGoodValue.length) {
            isDifferent = true;
            prefixError(i, () => itemValidator.validate(item));
            continue;
          }
          if (Object.is(knownGoodValue[i], item)) {
            continue;
          }
          const checkedItem = prefixError(
            i,
            () => itemValidator.validateUsingKnownGoodVersion(knownGoodValue[i], item)
          );
          if (!Object.is(checkedItem, knownGoodValue[i])) {
            isDifferent = true;
          }
        }
        return isDifferent ? newValue : knownGoodValue;
      }
    );
    this.itemValidator = itemValidator;
  }
  nonEmpty() {
    return this.check((value) => {
      if (value.length === 0) {
        throw new ValidationError("Expected a non-empty array");
      }
    });
  }
  lengthGreaterThan1() {
    return this.check((value) => {
      if (value.length <= 1) {
        throw new ValidationError("Expected an array with length greater than 1");
      }
    });
  }
};
var ObjectValidator = class _ObjectValidator extends Validator {
  constructor(config, shouldAllowUnknownProperties = false) {
    super(
      (object2) => {
        if (typeof object2 !== "object" || object2 === null) {
          throw new ValidationError(`Expected object, got ${typeToString(object2)}`);
        }
        for (const [key, validator] of Object.entries(config)) {
          prefixError(key, () => {
            ;
            validator.validate(getOwnProperty(object2, key));
          });
        }
        if (!shouldAllowUnknownProperties) {
          for (const key of Object.keys(object2)) {
            if (!hasOwnProperty(config, key)) {
              throw new ValidationError(`Unexpected property`, [key]);
            }
          }
        }
        return object2;
      },
      (knownGoodValue, newValue) => {
        if (typeof newValue !== "object" || newValue === null) {
          throw new ValidationError(`Expected object, got ${typeToString(newValue)}`);
        }
        let isDifferent = false;
        for (const [key, validator] of Object.entries(config)) {
          const prev = getOwnProperty(knownGoodValue, key);
          const next = getOwnProperty(newValue, key);
          if (Object.is(prev, next)) {
            continue;
          }
          const checked = prefixError(key, () => {
            const validatable = validator;
            if (validatable.validateUsingKnownGoodVersion) {
              return validatable.validateUsingKnownGoodVersion(prev, next);
            } else {
              return validatable.validate(next);
            }
          });
          if (!Object.is(checked, prev)) {
            isDifferent = true;
          }
        }
        if (!shouldAllowUnknownProperties) {
          for (const key of Object.keys(newValue)) {
            if (!hasOwnProperty(config, key)) {
              throw new ValidationError(`Unexpected property`, [key]);
            }
          }
        }
        for (const key of Object.keys(knownGoodValue)) {
          if (!hasOwnProperty(newValue, key)) {
            isDifferent = true;
            break;
          }
        }
        return isDifferent ? newValue : knownGoodValue;
      }
    );
    this.config = config;
    this.shouldAllowUnknownProperties = shouldAllowUnknownProperties;
  }
  allowUnknownProperties() {
    return new _ObjectValidator(this.config, true);
  }
  /**
   * Extend an object validator by adding additional properties.
   *
   * @example
   *
   * ```ts
   * const animalValidator = T.object({
   * 	name: T.string,
   * })
   * const catValidator = animalValidator.extend({
   * 	meowVolume: T.number,
   * })
   * ```
   */
  extend(extension) {
    return new _ObjectValidator({ ...this.config, ...extension });
  }
};
var UnionValidator = class _UnionValidator extends Validator {
  constructor(key, config, unknownValueValidation, useNumberKeys) {
    super(
      (input) => {
        this.expectObject(input);
        const { matchingSchema, variant } = this.getMatchingSchemaAndVariant(input);
        if (matchingSchema === void 0) {
          return this.unknownValueValidation(input, variant);
        }
        return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(input));
      },
      (prevValue, newValue) => {
        this.expectObject(newValue);
        this.expectObject(prevValue);
        const { matchingSchema, variant } = this.getMatchingSchemaAndVariant(newValue);
        if (matchingSchema === void 0) {
          return this.unknownValueValidation(newValue, variant);
        }
        if (getOwnProperty(prevValue, key) !== getOwnProperty(newValue, key)) {
          return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(newValue));
        }
        return prefixError(`(${key} = ${variant})`, () => {
          if (matchingSchema.validateUsingKnownGoodVersion) {
            return matchingSchema.validateUsingKnownGoodVersion(prevValue, newValue);
          } else {
            return matchingSchema.validate(newValue);
          }
        });
      }
    );
    this.key = key;
    this.config = config;
    this.unknownValueValidation = unknownValueValidation;
    this.useNumberKeys = useNumberKeys;
  }
  expectObject(value) {
    if (typeof value !== "object" || value === null) {
      throw new ValidationError(`Expected an object, got ${typeToString(value)}`, []);
    }
  }
  getMatchingSchemaAndVariant(object2) {
    const variant = getOwnProperty(object2, this.key);
    if (!this.useNumberKeys && typeof variant !== "string") {
      throw new ValidationError(
        `Expected a string for key "${this.key}", got ${typeToString(variant)}`
      );
    } else if (this.useNumberKeys && !Number.isFinite(Number(variant))) {
      throw new ValidationError(`Expected a number for key "${this.key}", got "${variant}"`);
    }
    const matchingSchema = hasOwnProperty(this.config, variant) ? this.config[variant] : void 0;
    return { matchingSchema, variant };
  }
  validateUnknownVariants(unknownValueValidation) {
    return new _UnionValidator(this.key, this.config, unknownValueValidation, this.useNumberKeys);
  }
};
var DictValidator = class extends Validator {
  constructor(keyValidator, valueValidator) {
    super(
      (object2) => {
        if (typeof object2 !== "object" || object2 === null) {
          throw new ValidationError(`Expected object, got ${typeToString(object2)}`);
        }
        for (const [key, value] of Object.entries(object2)) {
          prefixError(key, () => {
            keyValidator.validate(key);
            valueValidator.validate(value);
          });
        }
        return object2;
      },
      (knownGoodValue, newValue) => {
        if (typeof newValue !== "object" || newValue === null) {
          throw new ValidationError(`Expected object, got ${typeToString(newValue)}`);
        }
        let isDifferent = false;
        for (const [key, value] of Object.entries(newValue)) {
          if (!hasOwnProperty(knownGoodValue, key)) {
            isDifferent = true;
            prefixError(key, () => {
              keyValidator.validate(key);
              valueValidator.validate(value);
            });
            continue;
          }
          const prev = getOwnProperty(knownGoodValue, key);
          const next = value;
          if (Object.is(prev, next)) {
            continue;
          }
          const checked = prefixError(key, () => {
            if (valueValidator.validateUsingKnownGoodVersion) {
              return valueValidator.validateUsingKnownGoodVersion(prev, next);
            } else {
              return valueValidator.validate(next);
            }
          });
          if (!Object.is(checked, prev)) {
            isDifferent = true;
          }
        }
        for (const key of Object.keys(knownGoodValue)) {
          if (!hasOwnProperty(newValue, key)) {
            isDifferent = true;
            break;
          }
        }
        return isDifferent ? newValue : knownGoodValue;
      }
    );
    this.keyValidator = keyValidator;
    this.valueValidator = valueValidator;
  }
};
function typeofValidator(type) {
  return new Validator((value) => {
    if (typeof value !== type) {
      throw new ValidationError(`Expected ${type}, got ${typeToString(value)}`);
    }
    return value;
  });
}
var unknown = new Validator((value) => value);
var any = new Validator((value) => value);
var string = typeofValidator("string");
var number = typeofValidator("number").check((number2) => {
  if (Number.isNaN(number2)) {
    throw new ValidationError("Expected a number, got NaN");
  }
  if (!Number.isFinite(number2)) {
    throw new ValidationError(`Expected a finite number, got ${number2}`);
  }
});
var positiveNumber = number.check((value) => {
  if (value < 0)
    throw new ValidationError(`Expected a positive number, got ${value}`);
});
var nonZeroNumber = number.check((value) => {
  if (value <= 0)
    throw new ValidationError(`Expected a non-zero positive number, got ${value}`);
});
var integer = number.check((value) => {
  if (!Number.isInteger(value))
    throw new ValidationError(`Expected an integer, got ${value}`);
});
var positiveInteger = integer.check((value) => {
  if (value < 0)
    throw new ValidationError(`Expected a positive integer, got ${value}`);
});
var nonZeroInteger = integer.check((value) => {
  if (value <= 0)
    throw new ValidationError(`Expected a non-zero positive integer, got ${value}`);
});
var boolean = typeofValidator("boolean");
var bigint = typeofValidator("bigint");
function literal(expectedValue) {
  return new Validator((actualValue) => {
    if (actualValue !== expectedValue) {
      throw new ValidationError(`Expected ${expectedValue}, got ${JSON.stringify(actualValue)}`);
    }
    return expectedValue;
  });
}
var array = new Validator((value) => {
  if (!Array.isArray(value)) {
    throw new ValidationError(`Expected an array, got ${typeToString(value)}`);
  }
  return value;
});
function arrayOf(itemValidator) {
  return new ArrayOfValidator(itemValidator);
}
var unknownObject = new Validator((value) => {
  if (typeof value !== "object" || value === null) {
    throw new ValidationError(`Expected object, got ${typeToString(value)}`);
  }
  return value;
});
function object(config) {
  return new ObjectValidator(config);
}
function isPlainObject(value) {
  return typeof value === "object" && value !== null && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null || Object.getPrototypeOf(value) === STRUCTURED_CLONE_OBJECT_PROTOTYPE);
}
function isValidJson(value) {
  if (value === null || typeof value === "number" || typeof value === "string" || typeof value === "boolean") {
    return true;
  }
  if (Array.isArray(value)) {
    return value.every(isValidJson);
  }
  if (isPlainObject(value)) {
    return Object.values(value).every(isValidJson);
  }
  return false;
}
var jsonValue = new Validator(
  (value) => {
    if (isValidJson(value)) {
      return value;
    }
    throw new ValidationError(`Expected json serializable value, got ${typeof value}`);
  },
  (knownGoodValue, newValue) => {
    if (Array.isArray(knownGoodValue) && Array.isArray(newValue)) {
      let isDifferent = knownGoodValue.length !== newValue.length;
      for (let i = 0; i < newValue.length; i++) {
        if (i >= knownGoodValue.length) {
          isDifferent = true;
          jsonValue.validate(newValue[i]);
          continue;
        }
        const prev = knownGoodValue[i];
        const next = newValue[i];
        if (Object.is(prev, next)) {
          continue;
        }
        const checked = jsonValue.validateUsingKnownGoodVersion(prev, next);
        if (!Object.is(checked, prev)) {
          isDifferent = true;
        }
      }
      return isDifferent ? newValue : knownGoodValue;
    } else if (isPlainObject(knownGoodValue) && isPlainObject(newValue)) {
      let isDifferent = false;
      for (const key of Object.keys(newValue)) {
        if (!hasOwnProperty(knownGoodValue, key)) {
          isDifferent = true;
          jsonValue.validate(newValue[key]);
          continue;
        }
        const prev = knownGoodValue[key];
        const next = newValue[key];
        if (Object.is(prev, next)) {
          continue;
        }
        const checked = jsonValue.validateUsingKnownGoodVersion(prev, next);
        if (!Object.is(checked, prev)) {
          isDifferent = true;
        }
      }
      for (const key of Object.keys(knownGoodValue)) {
        if (!hasOwnProperty(newValue, key)) {
          isDifferent = true;
          break;
        }
      }
      return isDifferent ? newValue : knownGoodValue;
    } else {
      return jsonValue.validate(newValue);
    }
  }
);
function jsonDict() {
  return dict(string, jsonValue);
}
function dict(keyValidator, valueValidator) {
  return new DictValidator(keyValidator, valueValidator);
}
function union(key, config) {
  return new UnionValidator(
    key,
    config,
    (_unknownValue, unknownVariant) => {
      throw new ValidationError(
        `Expected one of ${Object.keys(config).map((key2) => JSON.stringify(key2)).join(" or ")}, got ${JSON.stringify(unknownVariant)}`,
        [key]
      );
    },
    false
  );
}
function numberUnion(key, config) {
  return new UnionValidator(
    key,
    config,
    (unknownValue, unknownVariant) => {
      throw new ValidationError(
        `Expected one of ${Object.keys(config).map((key2) => JSON.stringify(key2)).join(" or ")}, got ${JSON.stringify(unknownVariant)}`,
        [key]
      );
    },
    true
  );
}
function model(name, validator) {
  return new Validator(
    (value) => {
      return prefixError(name, () => validator.validate(value));
    },
    (prevValue, newValue) => {
      return prefixError(name, () => {
        if (validator.validateUsingKnownGoodVersion) {
          return validator.validateUsingKnownGoodVersion(prevValue, newValue);
        } else {
          return validator.validate(newValue);
        }
      });
    }
  );
}
function setEnum(values) {
  return new Validator((value) => {
    if (!values.has(value)) {
      const valuesString = Array.from(values, (value2) => JSON.stringify(value2)).join(" or ");
      throw new ValidationError(`Expected ${valuesString}, got ${value}`);
    }
    return value;
  });
}
function optional(validator) {
  return new Validator(
    (value) => {
      if (value === void 0)
        return void 0;
      return validator.validate(value);
    },
    (knownGoodValue, newValue) => {
      if (knownGoodValue === void 0 && newValue === void 0)
        return void 0;
      if (newValue === void 0)
        return void 0;
      if (validator.validateUsingKnownGoodVersion && knownGoodValue !== void 0) {
        return validator.validateUsingKnownGoodVersion(knownGoodValue, newValue);
      }
      return validator.validate(newValue);
    }
  );
}
function nullable(validator) {
  return new Validator(
    (value) => {
      if (value === null)
        return null;
      return validator.validate(value);
    },
    (knownGoodValue, newValue) => {
      if (newValue === null)
        return null;
      if (validator.validateUsingKnownGoodVersion && knownGoodValue !== null) {
        return validator.validateUsingKnownGoodVersion(knownGoodValue, newValue);
      }
      return validator.validate(newValue);
    }
  );
}
function literalEnum(...values) {
  return setEnum(new Set(values));
}
function parseUrl(str) {
  try {
    return new URL(str);
  } catch {
    if (str.startsWith("/") || str.startsWith("./")) {
      try {
        return new URL(str, "http://example.com");
      } catch {
        throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`);
      }
    }
    throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`);
  }
}
var validLinkProtocols = /* @__PURE__ */ new Set(["http:", "https:", "mailto:"]);
var linkUrl = string.check((value) => {
  if (value === "")
    return;
  const url = parseUrl(value);
  if (!validLinkProtocols.has(url.protocol.toLowerCase())) {
    throw new ValidationError(
      `Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
    );
  }
});
var validSrcProtocols = /* @__PURE__ */ new Set(["http:", "https:", "data:", "asset:"]);
var srcUrl = string.check((value) => {
  if (value === "")
    return;
  const url = parseUrl(value);
  if (!validSrcProtocols.has(url.protocol.toLowerCase())) {
    throw new ValidationError(
      `Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
    );
  }
});
var httpUrl = string.check((value) => {
  if (value === "")
    return;
  const url = parseUrl(value);
  if (!url.protocol.toLowerCase().match(/^https?:$/)) {
    throw new ValidationError(
      `Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
    );
  }
});
var indexKey = string.refine((key) => {
  try {
    validateIndexKey(key);
    return key;
  } catch {
    throw new ValidationError(`Expected an index key, got ${JSON.stringify(key)}`);
  }
});
function or(v1, v2) {
  return new Validator((value) => {
    try {
      return v1.validate(value);
    } catch {
      return v2.validate(value);
    }
  });
}

// node_modules/@tldraw/validate/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "@tldraw/validate",
  "3.13.1",
  "esm"
);

// node_modules/@tldraw/tlschema/dist-esm/misc/id-validator.mjs
function idValidator(prefix) {
  return validation_exports.string.refine((id) => {
    if (!id.startsWith(`${prefix}:`)) {
      throw new Error(`${prefix} ID must start with "${prefix}:"`);
    }
    return id;
  });
}

// node_modules/@tldraw/tlschema/dist-esm/assets/TLBaseAsset.mjs
var assetIdValidator = idValidator("asset");
function createAssetValidator(type, props) {
  return validation_exports.object({
    id: assetIdValidator,
    typeName: validation_exports.literal("asset"),
    type: validation_exports.literal(type),
    props,
    meta: validation_exports.jsonValue
  });
}

// node_modules/@tldraw/tlschema/dist-esm/misc/geometry-types.mjs
var vecModelValidator = validation_exports.object({
  x: validation_exports.number,
  y: validation_exports.number,
  z: validation_exports.number.optional()
});
var boxModelValidator = validation_exports.object({
  x: validation_exports.number,
  y: validation_exports.number,
  w: validation_exports.number,
  h: validation_exports.number
});

// node_modules/@tldraw/tlschema/dist-esm/misc/TLOpacity.mjs
var opacityValidator = validation_exports.number.check((n) => {
  if (n < 0 || n > 1) {
    throw new validation_exports.ValidationError("Opacity must be between 0 and 1");
  }
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLBaseShape.mjs
var parentIdValidator = validation_exports.string.refine((id) => {
  if (!id.startsWith("page:") && !id.startsWith("shape:")) {
    throw new Error('Parent ID must start with "page:" or "shape:"');
  }
  return id;
});
var shapeIdValidator = idValidator("shape");
function createShapeValidator(type, props, meta) {
  return validation_exports.object({
    id: shapeIdValidator,
    typeName: validation_exports.literal("shape"),
    x: validation_exports.number,
    y: validation_exports.number,
    rotation: validation_exports.number,
    index: validation_exports.indexKey,
    parentId: parentIdValidator,
    type: validation_exports.literal(type),
    isLocked: validation_exports.boolean,
    opacity: opacityValidator,
    props: props ? validation_exports.object(props) : validation_exports.jsonValue,
    meta: meta ? validation_exports.object(meta) : validation_exports.jsonValue
  });
}

// node_modules/@tldraw/tlschema/dist-esm/bindings/TLBaseBinding.mjs
var bindingIdValidator = idValidator("binding");
function createBindingValidator(type, props, meta) {
  return validation_exports.object({
    id: bindingIdValidator,
    typeName: validation_exports.literal("binding"),
    type: validation_exports.literal(type),
    fromId: shapeIdValidator,
    toId: shapeIdValidator,
    props: props ? validation_exports.object(props) : validation_exports.jsonValue,
    meta: meta ? validation_exports.object(meta) : validation_exports.jsonValue
  });
}

// node_modules/@tldraw/tlschema/dist-esm/records/TLBinding.mjs
var rootBindingVersions = createMigrationIds("com.tldraw.binding", {});
var rootBindingMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.binding",
  recordType: "binding",
  sequence: []
});
function isBinding(record) {
  if (!record)
    return false;
  return record.typeName === "binding";
}
function isBindingId(id) {
  if (!id)
    return false;
  return id.startsWith("binding:");
}
function createBindingId(id) {
  return `binding:${id ?? uniqueId()}`;
}
function createBindingPropsMigrationSequence(migrations) {
  return migrations;
}
function createBindingPropsMigrationIds(bindingType, ids) {
  return mapObjectMapValues(ids, (_k, v) => `com.tldraw.binding.${bindingType}/${v}`);
}
function createBindingRecordType(bindings) {
  return createRecordType("binding", {
    scope: "document",
    validator: validation_exports.model(
      "binding",
      validation_exports.union(
        "type",
        mapObjectMapValues(
          bindings,
          (type, { props, meta }) => createBindingValidator(type, props, meta)
        )
      )
    )
  }).withDefaultProperties(() => ({
    meta: {}
  }));
}

// node_modules/@tldraw/tlschema/dist-esm/styles/StyleProp.mjs
var StyleProp = class _StyleProp {
  /** @internal */
  constructor(id, defaultValue, type) {
    this.id = id;
    this.defaultValue = defaultValue;
    this.type = type;
  }
  /**
   * Define a new {@link StyleProp}.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `type`: Optionally, describe what type of data you expect for this style prop.
   *
   * @example
   * ```ts
   * import {T} from '@tldraw/validate'
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MyLineWidthProp = StyleProp.define('myApp:lineWidth', {
   *   defaultValue: 1,
   *   type: T.number,
   * })
   * ```
   * @public
   */
  static define(uniqueId2, options2) {
    const { defaultValue, type = validation_exports.any } = options2;
    return new _StyleProp(uniqueId2, defaultValue, type);
  }
  /**
   * Define a new {@link StyleProp} as a list of possible values.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `values`: An array of possible values of this style prop.
   *
   * @example
   * ```ts
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MySizeProp = StyleProp.defineEnum('myApp:size', {
   *   defaultValue: 'medium',
   *   values: ['small', 'medium', 'large'],
   * })
   * ```
   */
  static defineEnum(uniqueId2, options2) {
    const { defaultValue, values } = options2;
    return new EnumStyleProp(uniqueId2, defaultValue, values);
  }
  setDefaultValue(value) {
    this.defaultValue = value;
  }
  validate(value) {
    return this.type.validate(value);
  }
  validateUsingKnownGoodVersion(prevValue, newValue) {
    if (this.type.validateUsingKnownGoodVersion) {
      return this.type.validateUsingKnownGoodVersion(prevValue, newValue);
    } else {
      return this.validate(newValue);
    }
  }
};
var EnumStyleProp = class extends StyleProp {
  /** @internal */
  constructor(id, defaultValue, values) {
    super(id, defaultValue, validation_exports.literalEnum(...values));
    this.values = values;
  }
};

// node_modules/@tldraw/tlschema/dist-esm/records/TLShape.mjs
var rootShapeVersions = createMigrationIds("com.tldraw.shape", {
  AddIsLocked: 1,
  HoistOpacity: 2,
  AddMeta: 3,
  AddWhite: 4
});
var rootShapeMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.shape",
  recordType: "shape",
  sequence: [
    {
      id: rootShapeVersions.AddIsLocked,
      up: (record) => {
        record.isLocked = false;
      },
      down: (record) => {
        delete record.isLocked;
      }
    },
    {
      id: rootShapeVersions.HoistOpacity,
      up: (record) => {
        record.opacity = Number(record.props.opacity ?? "1");
        delete record.props.opacity;
      },
      down: (record) => {
        const opacity = record.opacity;
        delete record.opacity;
        record.props.opacity = opacity < 0.175 ? "0.1" : opacity < 0.375 ? "0.25" : opacity < 0.625 ? "0.5" : opacity < 0.875 ? "0.75" : "1";
      }
    },
    {
      id: rootShapeVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: rootShapeVersions.AddWhite,
      up: (_record) => {
      },
      down: (record) => {
        if (record.props.color === "white") {
          record.props.color = "black";
        }
      }
    }
  ]
});
function isShape(record) {
  if (!record)
    return false;
  return record.typeName === "shape";
}
function isShapeId(id) {
  if (!id)
    return false;
  return id.startsWith("shape:");
}
function createShapeId(id) {
  return `shape:${id ?? uniqueId()}`;
}
function getShapePropKeysByStyle(props) {
  const propKeysByStyle = /* @__PURE__ */ new Map();
  for (const [key, prop] of Object.entries(props)) {
    if (prop instanceof StyleProp) {
      if (propKeysByStyle.has(prop)) {
        throw new Error(
          `Duplicate style prop ${prop.id}. Each style prop can only be used once within a shape.`
        );
      }
      propKeysByStyle.set(prop, key);
    }
  }
  return propKeysByStyle;
}
function createShapePropsMigrationSequence(migrations) {
  return migrations;
}
function createShapePropsMigrationIds(shapeType, ids) {
  return mapObjectMapValues(ids, (_k, v) => `com.tldraw.shape.${shapeType}/${v}`);
}
function createShapeRecordType(shapes) {
  return createRecordType("shape", {
    scope: "document",
    validator: validation_exports.model(
      "shape",
      validation_exports.union(
        "type",
        mapObjectMapValues(
          shapes,
          (type, { props, meta }) => createShapeValidator(type, props, meta)
        )
      )
    )
  }).withDefaultProperties(() => ({
    x: 0,
    y: 0,
    rotation: 0,
    isLocked: false,
    opacity: 1,
    meta: {}
  }));
}

// node_modules/@tldraw/tlschema/dist-esm/recordsWithProps.mjs
function processPropsMigrations(typeName, records) {
  const result = [];
  for (const [subType, { migrations }] of Object.entries(records)) {
    const sequenceId = `com.tldraw.${typeName}.${subType}`;
    if (!migrations) {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: []
        })
      );
    } else if ("sequenceId" in migrations) {
      assert(
        sequenceId === migrations.sequenceId,
        `sequenceId mismatch for ${subType} ${RecordType} migrations. Expected '${sequenceId}', got '${migrations.sequenceId}'`
      );
      result.push(migrations);
    } else if ("sequence" in migrations) {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: migrations.sequence.map(
            (m) => "id" in m ? createPropsMigration(typeName, subType, m) : m
          )
        })
      );
    } else {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: Object.keys(migrations.migrators).map((k) => Number(k)).sort((a, b) => a - b).map(
            (version2) => ({
              id: `${sequenceId}/${version2}`,
              scope: "record",
              filter: (r) => r.typeName === typeName && r.type === subType,
              up: (record) => {
                const result2 = migrations.migrators[version2].up(record);
                if (result2) {
                  return result2;
                }
              },
              down: (record) => {
                const result2 = migrations.migrators[version2].down(record);
                if (result2) {
                  return result2;
                }
              }
            })
          )
        })
      );
    }
  }
  return result;
}
function createPropsMigration(typeName, subType, m) {
  return {
    id: m.id,
    dependsOn: m.dependsOn,
    scope: "record",
    filter: (r) => r.typeName === typeName && r.type === subType,
    up: (record) => {
      const result = m.up(record.props);
      if (result) {
        record.props = result;
      }
    },
    down: typeof m.down === "function" ? (record) => {
      const result = m.down(record.props);
      if (result) {
        record.props = result;
      }
    } : void 0
  };
}

// node_modules/@tldraw/tlschema/dist-esm/styles/TLColorStyle.mjs
var defaultColorNames = [
  "black",
  "grey",
  "light-violet",
  "violet",
  "blue",
  "light-blue",
  "yellow",
  "orange",
  "green",
  "light-green",
  "light-red",
  "red",
  "white"
];
var DefaultColorThemePalette = {
  lightMode: {
    id: "light",
    text: "#000000",
    background: "#f9fafb",
    solid: "#fcfffe",
    black: {
      solid: "#1d1d1d",
      fill: "#1d1d1d",
      frame: {
        headingStroke: "#717171",
        headingFill: "#ffffff",
        stroke: "#717171",
        fill: "#ffffff",
        text: "#000000"
      },
      note: {
        fill: "#FCE19C",
        text: "#000000"
      },
      semi: "#e8e8e8",
      pattern: "#494949",
      highlight: {
        srgb: "#fddd00",
        p3: "color(display-p3 0.972 0.8205 0.05)"
      }
    },
    blue: {
      solid: "#4465e9",
      fill: "#4465e9",
      frame: {
        headingStroke: "#6681ec",
        headingFill: "#f9fafe",
        stroke: "#6681ec",
        fill: "#f9fafe",
        text: "#000000"
      },
      note: {
        fill: "#8AA3FF",
        text: "#000000"
      },
      semi: "#dce1f8",
      pattern: "#6681ee",
      highlight: {
        srgb: "#10acff",
        p3: "color(display-p3 0.308 0.6632 0.9996)"
      }
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      frame: {
        headingStroke: "#37a684",
        headingFill: "#f8fcfa",
        stroke: "#37a684",
        fill: "#f8fcfa",
        text: "#000000"
      },
      note: {
        fill: "#6FC896",
        text: "#000000"
      },
      semi: "#d3e9e3",
      pattern: "#39a785",
      highlight: {
        srgb: "#00ffc8",
        p3: "color(display-p3 0.2536 0.984 0.7981)"
      }
    },
    grey: {
      solid: "#9fa8b2",
      fill: "#9fa8b2",
      frame: {
        headingStroke: "#aaaaab",
        headingFill: "#fbfcfc",
        stroke: "#aaaaab",
        fill: "#fcfcfd",
        text: "#000000"
      },
      note: {
        fill: "#C0CAD3",
        text: "#000000"
      },
      semi: "#eceef0",
      pattern: "#bcc3c9",
      highlight: {
        srgb: "#cbe7f1",
        p3: "color(display-p3 0.8163 0.9023 0.9416)"
      }
    },
    "light-blue": {
      solid: "#4ba1f1",
      fill: "#4ba1f1",
      frame: {
        headingStroke: "#6cb2f3",
        headingFill: "#f8fbfe",
        stroke: "#6cb2f3",
        fill: "#fafcff",
        text: "#000000"
      },
      note: {
        fill: "#9BC4FD",
        text: "#000000"
      },
      semi: "#ddedfa",
      pattern: "#6fbbf8",
      highlight: {
        srgb: "#00f4ff",
        p3: "color(display-p3 0.1512 0.9414 0.9996)"
      }
    },
    "light-green": {
      solid: "#4cb05e",
      fill: "#4cb05e",
      frame: {
        headingStroke: "#6dbe7c",
        headingFill: "#f8fcf9",
        stroke: "#6dbe7c",
        fill: "#fafdfa",
        text: "#000000"
      },
      note: {
        fill: "#98D08A",
        text: "#000000"
      },
      semi: "#dbf0e0",
      pattern: "#65cb78",
      highlight: {
        srgb: "#65f641",
        p3: "color(display-p3 0.563 0.9495 0.3857)"
      }
    },
    "light-red": {
      solid: "#f87777",
      fill: "#f87777",
      frame: {
        headingStroke: "#f89090",
        headingFill: "#fffafa",
        stroke: "#f89090",
        fill: "#fffbfb",
        text: "#000000"
      },
      note: {
        fill: "#F7A5A1",
        text: "#000000"
      },
      semi: "#f4dadb",
      pattern: "#fe9e9e",
      highlight: {
        srgb: "#ff7fa3",
        p3: "color(display-p3 0.9988 0.5301 0.6397)"
      }
    },
    "light-violet": {
      solid: "#e085f4",
      fill: "#e085f4",
      frame: {
        headingStroke: "#e59bf5",
        headingFill: "#fefaff",
        stroke: "#e59bf5",
        fill: "#fefbff",
        text: "#000000"
      },
      note: {
        fill: "#DFB0F9",
        text: "#000000"
      },
      semi: "#f5eafa",
      pattern: "#e9acf8",
      highlight: {
        srgb: "#ff88ff",
        p3: "color(display-p3 0.9676 0.5652 0.9999)"
      }
    },
    orange: {
      solid: "#e16919",
      fill: "#e16919",
      frame: {
        headingStroke: "#e68544",
        headingFill: "#fef9f6",
        stroke: "#e68544",
        fill: "#fef9f6",
        text: "#000000"
      },
      note: {
        fill: "#FAA475",
        text: "#000000"
      },
      semi: "#f8e2d4",
      pattern: "#f78438",
      highlight: {
        srgb: "#ffa500",
        p3: "color(display-p3 0.9988 0.6905 0.266)"
      }
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      frame: {
        headingStroke: "#e55757",
        headingFill: "#fef7f7",
        stroke: "#e55757",
        fill: "#fef9f9",
        text: "#000000"
      },
      note: {
        fill: "#FC8282",
        text: "#000000"
      },
      semi: "#f4dadb",
      pattern: "#e55959",
      highlight: {
        srgb: "#ff636e",
        p3: "color(display-p3 0.9992 0.4376 0.45)"
      }
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      frame: {
        headingStroke: "#bc62d3",
        headingFill: "#fcf7fd",
        stroke: "#bc62d3",
        fill: "#fdf9fd",
        text: "#000000"
      },
      note: {
        fill: "#DB91FD",
        text: "#000000"
      },
      semi: "#ecdcf2",
      pattern: "#bd63d3",
      highlight: {
        srgb: "#c77cff",
        p3: "color(display-p3 0.7469 0.5089 0.9995)"
      }
    },
    yellow: {
      solid: "#f1ac4b",
      fill: "#f1ac4b",
      frame: {
        headingStroke: "#f3bb6c",
        headingFill: "#fefcf8",
        stroke: "#f3bb6c",
        fill: "#fffdfa",
        text: "#000000"
      },
      note: {
        fill: "#FED49A",
        text: "#000000"
      },
      semi: "#f9f0e6",
      pattern: "#fecb92",
      highlight: {
        srgb: "#fddd00",
        p3: "color(display-p3 0.972 0.8705 0.05)"
      }
    },
    white: {
      solid: "#FFFFFF",
      fill: "#FFFFFF",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      frame: {
        headingStroke: "#7d7d7d",
        headingFill: "#ffffff",
        stroke: "#7d7d7d",
        fill: "#ffffff",
        text: "#000000"
      },
      note: {
        fill: "#FFFFFF",
        text: "#000000"
      },
      highlight: {
        srgb: "#ffffff",
        p3: "color(display-p3 1 1 1)"
      }
    }
  },
  darkMode: {
    id: "dark",
    text: "hsl(210, 17%, 98%)",
    background: "hsl(240, 5%, 6.5%)",
    solid: "#010403",
    black: {
      solid: "#f2f2f2",
      fill: "#f2f2f2",
      frame: {
        headingStroke: "#5c5c5c",
        headingFill: "#252525",
        stroke: "#5c5c5c",
        fill: "#0c0c0c",
        text: "#f2f2f2"
      },
      note: {
        fill: "#2c2c2c",
        text: "#f2f2f2"
      },
      semi: "#2c3036",
      pattern: "#989898",
      highlight: {
        srgb: "#d2b700",
        p3: "color(display-p3 0.8078 0.6225 0.0312)"
      }
    },
    blue: {
      solid: "#4f72fc",
      // 3c60f0
      fill: "#4f72fc",
      frame: {
        headingStroke: "#384994",
        headingFill: "#1C2036",
        stroke: "#384994",
        fill: "#11141f",
        text: "#f2f2f2"
      },
      note: {
        fill: "#2A3F98",
        text: "#f2f2f2"
      },
      semi: "#262d40",
      pattern: "#3a4b9e",
      highlight: {
        srgb: "#0079d2",
        p3: "color(display-p3 0.0032 0.4655 0.7991)"
      }
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      frame: {
        headingStroke: "#10513C",
        headingFill: "#14241f",
        stroke: "#10513C",
        fill: "#0E1614",
        text: "#f2f2f2"
      },
      note: {
        fill: "#014429",
        text: "#f2f2f2"
      },
      semi: "#253231",
      pattern: "#366a53",
      highlight: {
        srgb: "#009774",
        p3: "color(display-p3 0.0085 0.582 0.4604)"
      }
    },
    grey: {
      solid: "#9398b0",
      fill: "#9398b0",
      frame: {
        headingStroke: "#42474D",
        headingFill: "#23262A",
        stroke: "#42474D",
        fill: "#151719",
        text: "#f2f2f2"
      },
      note: {
        fill: "#56595F",
        text: "#f2f2f2"
      },
      semi: "#33373c",
      pattern: "#7c8187",
      highlight: {
        srgb: "#9cb4cb",
        p3: "color(display-p3 0.6299 0.7012 0.7856)"
      }
    },
    "light-blue": {
      solid: "#4dabf7",
      fill: "#4dabf7",
      frame: {
        headingStroke: "#075797",
        headingFill: "#142839",
        stroke: "#075797",
        fill: "#0B1823",
        text: "#f2f2f2"
      },
      note: {
        fill: "#1F5495",
        text: "#f2f2f2"
      },
      semi: "#2a3642",
      pattern: "#4d7aa9",
      highlight: {
        srgb: "#00bdc8",
        p3: "color(display-p3 0.0023 0.7259 0.7735)"
      }
    },
    "light-green": {
      solid: "#40c057",
      fill: "#40c057",
      frame: {
        headingStroke: "#1C5427",
        headingFill: "#18251A",
        stroke: "#1C5427",
        fill: "#0F1911",
        text: "#f2f2f2"
      },
      note: {
        fill: "#21581D",
        text: "#f2f2f2"
      },
      semi: "#2a3830",
      pattern: "#4e874e",
      highlight: {
        srgb: "#00a000",
        p3: "color(display-p3 0.2711 0.6172 0.0195)"
      }
    },
    "light-red": {
      solid: "#ff8787",
      fill: "#ff8787",
      frame: {
        headingStroke: "#6f3232",
        // Darker and desaturated variant of solid
        headingFill: "#341818",
        // Deep, muted dark red
        stroke: "#6f3232",
        // Matches headingStroke
        fill: "#181212",
        // Darker, muted background shade
        text: "#f2f2f2"
        // Consistent bright text color
      },
      note: {
        fill: "#7a3333",
        // Medium-dark, muted variant of solid
        text: "#f2f2f2"
      },
      semi: "#3c2b2b",
      // Subdued, darker neutral-red tone
      pattern: "#a56767",
      // Existing pattern shade retained
      highlight: {
        srgb: "#db005b",
        p3: "color(display-p3 0.7849 0.0585 0.3589)"
      }
    },
    "light-violet": {
      solid: "#e599f7",
      fill: "#e599f7",
      frame: {
        headingStroke: "#6c367a",
        headingFill: "#2D2230",
        stroke: "#6c367a",
        fill: "#1C151E",
        text: "#f2f2f2"
      },
      note: {
        fill: "#762F8E",
        text: "#f2f2f2"
      },
      semi: "#383442",
      pattern: "#9770a9",
      highlight: {
        srgb: "#c400c7",
        p3: "color(display-p3 0.7024 0.0403 0.753)"
      }
    },
    orange: {
      solid: "#f76707",
      fill: "#f76707",
      frame: {
        headingStroke: "#773a0e",
        // Darker, muted version of solid
        headingFill: "#2f1d13",
        // Deep, warm, muted background
        stroke: "#773a0e",
        // Matches headingStroke
        fill: "#1c1512",
        // Darker, richer muted background
        text: "#f2f2f2"
        // Bright text for contrast
      },
      note: {
        fill: "#7c3905",
        // Muted dark variant for note fill
        text: "#f2f2f2"
      },
      semi: "#3b2e27",
      // Muted neutral-orange tone
      pattern: "#9f552d",
      // Retained existing shade
      highlight: {
        srgb: "#d07a00",
        p3: "color(display-p3 0.7699 0.4937 0.0085)"
      }
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      frame: {
        headingStroke: "#701e1e",
        // Darker, muted variation of solid
        headingFill: "#301616",
        // Deep, muted reddish backdrop
        stroke: "#701e1e",
        // Matches headingStroke
        fill: "#1b1313",
        // Rich, dark muted background
        text: "#f2f2f2"
        // Bright text for readability
      },
      note: {
        fill: "#7e201f",
        // Muted dark variant for note fill
        text: "#f2f2f2"
      },
      semi: "#382726",
      // Dark neutral-red tone
      pattern: "#8f3734",
      // Existing pattern color retained
      highlight: {
        srgb: "#de002c",
        p3: "color(display-p3 0.7978 0.0509 0.2035)"
      }
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      frame: {
        headingStroke: "#6d1583",
        // Darker, muted variation of solid
        headingFill: "#27152e",
        // Deep, rich muted violet backdrop
        stroke: "#6d1583",
        // Matches headingStroke
        fill: "#1b0f21",
        // Darker muted violet background
        text: "#f2f2f2"
        // Consistent bright text color
      },
      note: {
        fill: "#5f1c70",
        // Muted dark variant for note fill
        text: "#f2f2f2"
      },
      semi: "#342938",
      // Dark neutral-violet tone
      pattern: "#763a8b",
      // Retained existing pattern color
      highlight: {
        srgb: "#9e00ee",
        p3: "color(display-p3 0.5651 0.0079 0.8986)"
      }
    },
    yellow: {
      solid: "#ffc034",
      fill: "#ffc034",
      frame: {
        headingStroke: "#684e12",
        // Darker, muted variant of solid
        headingFill: "#2a2113",
        // Rich, muted dark-yellow background
        stroke: "#684e12",
        // Matches headingStroke
        fill: "#1e1911",
        // Darker muted shade for background fill
        text: "#f2f2f2"
        // Bright text color for readability
      },
      note: {
        fill: "#8a5e1c",
        // Muted, dark complementary variant
        text: "#f2f2f2"
      },
      semi: "#3b352b",
      // Dark muted neutral-yellow tone
      pattern: "#fecb92",
      // Existing shade retained
      highlight: {
        srgb: "#d2b700",
        p3: "color(display-p3 0.8078 0.7225 0.0312)"
      }
    },
    white: {
      solid: "#f3f3f3",
      fill: "#f3f3f3",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      frame: {
        headingStroke: "#ffffff",
        headingFill: "#ffffff",
        stroke: "#ffffff",
        fill: "#ffffff",
        text: "#000000"
      },
      note: {
        fill: "#eaeaea",
        text: "#1d1d1d"
      },
      highlight: {
        srgb: "#ffffff",
        p3: "color(display-p3 1 1 1)"
      }
    }
  }
};
function getDefaultColorTheme(opts) {
  return opts.isDarkMode ? DefaultColorThemePalette.darkMode : DefaultColorThemePalette.lightMode;
}
var DefaultColorStyle = StyleProp.defineEnum("tldraw:color", {
  defaultValue: "black",
  values: defaultColorNames
});
var DefaultLabelColorStyle = StyleProp.defineEnum("tldraw:labelColor", {
  defaultValue: "black",
  values: defaultColorNames
});

// node_modules/@tldraw/tlschema/dist-esm/styles/TLDashStyle.mjs
var DefaultDashStyle = StyleProp.defineEnum("tldraw:dash", {
  defaultValue: "draw",
  values: ["draw", "solid", "dashed", "dotted"]
});

// node_modules/@tldraw/tlschema/dist-esm/styles/TLFillStyle.mjs
var DefaultFillStyle = StyleProp.defineEnum("tldraw:fill", {
  defaultValue: "none",
  values: ["none", "semi", "solid", "pattern", "fill"]
});

// node_modules/@tldraw/tlschema/dist-esm/styles/TLFontStyle.mjs
var DefaultFontStyle = StyleProp.defineEnum("tldraw:font", {
  defaultValue: "draw",
  values: ["draw", "sans", "serif", "mono"]
});
var DefaultFontFamilies = {
  draw: "'tldraw_draw', sans-serif",
  sans: "'tldraw_sans', sans-serif",
  serif: "'tldraw_serif', serif",
  mono: "'tldraw_mono', monospace"
};

// node_modules/@tldraw/tlschema/dist-esm/styles/TLSizeStyle.mjs
var DefaultSizeStyle = StyleProp.defineEnum("tldraw:size", {
  defaultValue: "m",
  values: ["s", "m", "l", "xl"]
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLArrowShape.mjs
var arrowKinds = ["arc", "elbow"];
var ArrowShapeKindStyle = StyleProp.defineEnum("tldraw:arrowKind", {
  defaultValue: "arc",
  values: arrowKinds
});
var arrowheadTypes = [
  "arrow",
  "triangle",
  "square",
  "dot",
  "pipe",
  "diamond",
  "inverted",
  "bar",
  "none"
];
var ArrowShapeArrowheadStartStyle = StyleProp.defineEnum("tldraw:arrowheadStart", {
  defaultValue: "none",
  values: arrowheadTypes
});
var ArrowShapeArrowheadEndStyle = StyleProp.defineEnum("tldraw:arrowheadEnd", {
  defaultValue: "arrow",
  values: arrowheadTypes
});
var arrowShapeProps = {
  kind: ArrowShapeKindStyle,
  labelColor: DefaultLabelColorStyle,
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  arrowheadStart: ArrowShapeArrowheadStartStyle,
  arrowheadEnd: ArrowShapeArrowheadEndStyle,
  font: DefaultFontStyle,
  start: vecModelValidator,
  end: vecModelValidator,
  bend: validation_exports.number,
  text: validation_exports.string,
  labelPosition: validation_exports.number,
  scale: validation_exports.nonZeroNumber,
  elbowMidPoint: validation_exports.number
};
var arrowShapeVersions = createShapePropsMigrationIds("arrow", {
  AddLabelColor: 1,
  AddIsPrecise: 2,
  AddLabelPosition: 3,
  ExtractBindings: 4,
  AddScale: 5,
  AddElbow: 6
});
function propsMigration(migration) {
  return createPropsMigration("shape", "arrow", migration);
}
var arrowShapeMigrations = createMigrationSequence({
  sequenceId: "com.tldraw.shape.arrow",
  retroactive: false,
  sequence: [
    propsMigration({
      id: arrowShapeVersions.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: "retired"
    }),
    propsMigration({
      id: arrowShapeVersions.AddIsPrecise,
      up: ({ start: start2, end: end2 }) => {
        if (start2.type === "binding") {
          start2.isPrecise = !(start2.normalizedAnchor.x === 0.5 && start2.normalizedAnchor.y === 0.5);
        }
        if (end2.type === "binding") {
          end2.isPrecise = !(end2.normalizedAnchor.x === 0.5 && end2.normalizedAnchor.y === 0.5);
        }
      },
      down: ({ start: start2, end: end2 }) => {
        if (start2.type === "binding") {
          if (!start2.isPrecise) {
            start2.normalizedAnchor = { x: 0.5, y: 0.5 };
          }
          delete start2.isPrecise;
        }
        if (end2.type === "binding") {
          if (!end2.isPrecise) {
            end2.normalizedAnchor = { x: 0.5, y: 0.5 };
          }
          delete end2.isPrecise;
        }
      }
    }),
    propsMigration({
      id: arrowShapeVersions.AddLabelPosition,
      up: (props) => {
        props.labelPosition = 0.5;
      },
      down: (props) => {
        delete props.labelPosition;
      }
    }),
    {
      id: arrowShapeVersions.ExtractBindings,
      scope: "store",
      up: (oldStore) => {
        const arrows = Object.values(oldStore).filter(
          (r) => r.typeName === "shape" && r.type === "arrow"
        );
        for (const arrow6 of arrows) {
          const { start: start2, end: end2 } = arrow6.props;
          if (start2.type === "binding") {
            const id = createBindingId();
            const binding = {
              typeName: "binding",
              id,
              type: "arrow",
              fromId: arrow6.id,
              toId: start2.boundShapeId,
              meta: {},
              props: {
                terminal: "start",
                normalizedAnchor: start2.normalizedAnchor,
                isExact: start2.isExact,
                isPrecise: start2.isPrecise
              }
            };
            oldStore[id] = binding;
            arrow6.props.start = { x: 0, y: 0 };
          } else {
            delete arrow6.props.start.type;
          }
          if (end2.type === "binding") {
            const id = createBindingId();
            const binding = {
              typeName: "binding",
              id,
              type: "arrow",
              fromId: arrow6.id,
              toId: end2.boundShapeId,
              meta: {},
              props: {
                terminal: "end",
                normalizedAnchor: end2.normalizedAnchor,
                isExact: end2.isExact,
                isPrecise: end2.isPrecise
              }
            };
            oldStore[id] = binding;
            arrow6.props.end = { x: 0, y: 0 };
          } else {
            delete arrow6.props.end.type;
          }
        }
      }
    },
    propsMigration({
      id: arrowShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }),
    propsMigration({
      id: arrowShapeVersions.AddElbow,
      up: (props) => {
        props.kind = "arc";
        props.elbowMidPoint = 0.5;
      },
      down: (props) => {
        delete props.kind;
        delete props.elbowMidPoint;
      }
    })
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/bindings/TLArrowBinding.mjs
var ElbowArrowSnap = validation_exports.literalEnum("center", "edge-point", "edge", "none");
var arrowBindingProps = {
  terminal: validation_exports.literalEnum("start", "end"),
  normalizedAnchor: vecModelValidator,
  isExact: validation_exports.boolean,
  isPrecise: validation_exports.boolean,
  snap: ElbowArrowSnap
};
var arrowBindingVersions = createBindingPropsMigrationIds("arrow", {
  AddSnap: 1
});
var arrowBindingMigrations = createBindingPropsMigrationSequence({
  sequence: [
    { dependsOn: [arrowShapeVersions.ExtractBindings] },
    {
      id: arrowBindingVersions.AddSnap,
      up: (props) => {
        props.snap = "none";
      },
      down: (props) => {
        delete props.snap;
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/records/TLCamera.mjs
var cameraValidator = validation_exports.model(
  "camera",
  validation_exports.object({
    typeName: validation_exports.literal("camera"),
    id: idValidator("camera"),
    x: validation_exports.number,
    y: validation_exports.number,
    z: validation_exports.number,
    meta: validation_exports.jsonValue
  })
);
var cameraVersions = createMigrationIds("com.tldraw.camera", {
  AddMeta: 1
});
var cameraMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.camera",
  recordType: "camera",
  sequence: [
    {
      id: cameraVersions.AddMeta,
      up: (record) => {
        ;
        record.meta = {};
      }
    }
  ]
});
var CameraRecordType = createRecordType("camera", {
  validator: cameraValidator,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    z: 1,
    meta: {}
  })
);

// node_modules/@tldraw/tlschema/dist-esm/misc/TLCursor.mjs
var TL_CURSOR_TYPES = /* @__PURE__ */ new Set([
  "none",
  "default",
  "pointer",
  "cross",
  "grab",
  "rotate",
  "grabbing",
  "resize-edge",
  "resize-corner",
  "text",
  "move",
  "ew-resize",
  "ns-resize",
  "nesw-resize",
  "nwse-resize",
  "nesw-rotate",
  "nwse-rotate",
  "swne-rotate",
  "senw-rotate",
  "zoom-in",
  "zoom-out"
]);
var cursorTypeValidator = validation_exports.setEnum(TL_CURSOR_TYPES);
var cursorValidator = validation_exports.object({
  type: cursorTypeValidator,
  rotation: validation_exports.number
});

// node_modules/@tldraw/tlschema/dist-esm/misc/TLColor.mjs
var TL_CANVAS_UI_COLOR_TYPES = /* @__PURE__ */ new Set([
  "accent",
  "white",
  "black",
  "selection-stroke",
  "selection-fill",
  "laser",
  "muted-1"
]);
var canvasUiColorTypeValidator = validation_exports.setEnum(TL_CANVAS_UI_COLOR_TYPES);

// node_modules/@tldraw/tlschema/dist-esm/misc/TLScribble.mjs
var TL_SCRIBBLE_STATES = /* @__PURE__ */ new Set(["starting", "paused", "active", "stopping"]);
var scribbleValidator = validation_exports.object({
  id: validation_exports.string,
  points: validation_exports.arrayOf(vecModelValidator),
  size: validation_exports.positiveNumber,
  color: canvasUiColorTypeValidator,
  opacity: validation_exports.number,
  state: validation_exports.setEnum(TL_SCRIBBLE_STATES),
  delay: validation_exports.number,
  shrink: validation_exports.number,
  taper: validation_exports.boolean
});

// node_modules/@tldraw/tlschema/dist-esm/records/TLPage.mjs
var pageIdValidator = idValidator("page");
var pageValidator = validation_exports.model(
  "page",
  validation_exports.object({
    typeName: validation_exports.literal("page"),
    id: pageIdValidator,
    name: validation_exports.string,
    index: validation_exports.indexKey,
    meta: validation_exports.jsonValue
  })
);
var pageVersions = createMigrationIds("com.tldraw.page", {
  AddMeta: 1
});
var pageMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.page",
  recordType: "page",
  sequence: [
    {
      id: pageVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
var PageRecordType = createRecordType("page", {
  validator: pageValidator,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
}));
function isPageId(id) {
  return PageRecordType.isId(id);
}

// node_modules/@tldraw/tlschema/dist-esm/records/TLInstance.mjs
var shouldKeyBePreservedBetweenSessions = {
  // This object defines keys that should be preserved across calls to loadSnapshot()
  id: false,
  // meta
  typeName: false,
  // meta
  currentPageId: false,
  // does not preserve because who knows if the page still exists
  opacityForNextShape: false,
  // does not preserve because it's a temporary state
  stylesForNextShape: false,
  // does not preserve because it's a temporary state
  followingUserId: false,
  // does not preserve because it's a temporary state
  highlightedUserIds: false,
  // does not preserve because it's a temporary state
  brush: false,
  // does not preserve because it's a temporary state
  cursor: false,
  // does not preserve because it's a temporary state
  scribbles: false,
  // does not preserve because it's a temporary state
  isFocusMode: true,
  // preserves because it's a user preference
  isDebugMode: true,
  // preserves because it's a user preference
  isToolLocked: true,
  // preserves because it's a user preference
  exportBackground: true,
  // preserves because it's a user preference
  screenBounds: true,
  // preserves because it's capturing the user's screen state
  insets: true,
  // preserves because it's capturing the user's screen state
  zoomBrush: false,
  // does not preserve because it's a temporary state
  chatMessage: false,
  // does not preserve because it's a temporary state
  isChatting: false,
  // does not preserve because it's a temporary state
  isPenMode: false,
  // does not preserve because it's a temporary state
  isGridMode: true,
  // preserves because it's a user preference
  isFocused: true,
  // preserves because obviously
  devicePixelRatio: true,
  // preserves because it captures the user's screen state
  isCoarsePointer: true,
  // preserves because it captures the user's screen state
  isHoveringCanvas: false,
  // does not preserve because it's a temporary state
  openMenus: false,
  // does not preserve because it's a temporary state
  isChangingStyle: false,
  // does not preserve because it's a temporary state
  isReadonly: true,
  // preserves because it's a config option
  meta: false,
  // does not preserve because who knows what's in there, leave it up to sdk users to save and reinstate
  duplicateProps: false
  //
};
function pluckPreservingValues(val) {
  return val ? filterEntries(val, (key) => {
    return shouldKeyBePreservedBetweenSessions[key];
  }) : null;
}
var instanceIdValidator = idValidator("instance");
function createInstanceRecordType(stylesById) {
  const stylesForNextShapeValidators = {};
  for (const [id, style2] of stylesById) {
    stylesForNextShapeValidators[id] = validation_exports.optional(style2);
  }
  const instanceTypeValidator = validation_exports.model(
    "instance",
    validation_exports.object({
      typeName: validation_exports.literal("instance"),
      id: idValidator("instance"),
      currentPageId: pageIdValidator,
      followingUserId: validation_exports.string.nullable(),
      brush: boxModelValidator.nullable(),
      opacityForNextShape: opacityValidator,
      stylesForNextShape: validation_exports.object(stylesForNextShapeValidators),
      cursor: cursorValidator,
      scribbles: validation_exports.arrayOf(scribbleValidator),
      isFocusMode: validation_exports.boolean,
      isDebugMode: validation_exports.boolean,
      isToolLocked: validation_exports.boolean,
      exportBackground: validation_exports.boolean,
      screenBounds: boxModelValidator,
      insets: validation_exports.arrayOf(validation_exports.boolean),
      zoomBrush: boxModelValidator.nullable(),
      isPenMode: validation_exports.boolean,
      isGridMode: validation_exports.boolean,
      chatMessage: validation_exports.string,
      isChatting: validation_exports.boolean,
      highlightedUserIds: validation_exports.arrayOf(validation_exports.string),
      isFocused: validation_exports.boolean,
      devicePixelRatio: validation_exports.number,
      isCoarsePointer: validation_exports.boolean,
      isHoveringCanvas: validation_exports.boolean.nullable(),
      openMenus: validation_exports.arrayOf(validation_exports.string),
      isChangingStyle: validation_exports.boolean,
      isReadonly: validation_exports.boolean,
      meta: validation_exports.jsonValue,
      duplicateProps: validation_exports.object({
        shapeIds: validation_exports.arrayOf(idValidator("shape")),
        offset: validation_exports.object({
          x: validation_exports.number,
          y: validation_exports.number
        })
      }).nullable()
    })
  );
  return createRecordType("instance", {
    validator: instanceTypeValidator,
    scope: "session",
    ephemeralKeys: {
      currentPageId: false,
      meta: false,
      followingUserId: true,
      opacityForNextShape: true,
      stylesForNextShape: true,
      brush: true,
      cursor: true,
      scribbles: true,
      isFocusMode: true,
      isDebugMode: true,
      isToolLocked: true,
      exportBackground: true,
      screenBounds: true,
      insets: true,
      zoomBrush: true,
      isPenMode: true,
      isGridMode: true,
      chatMessage: true,
      isChatting: true,
      highlightedUserIds: true,
      isFocused: true,
      devicePixelRatio: true,
      isCoarsePointer: true,
      isHoveringCanvas: true,
      openMenus: true,
      isChangingStyle: true,
      isReadonly: true,
      duplicateProps: true
    }
  }).withDefaultProperties(
    () => ({
      followingUserId: null,
      opacityForNextShape: 1,
      stylesForNextShape: {},
      brush: null,
      scribbles: [],
      cursor: {
        type: "default",
        rotation: 0
      },
      isFocusMode: false,
      exportBackground: false,
      isDebugMode: false,
      isToolLocked: false,
      screenBounds: { x: 0, y: 0, w: 1080, h: 720 },
      insets: [false, false, false, false],
      zoomBrush: null,
      isGridMode: false,
      isPenMode: false,
      chatMessage: "",
      isChatting: false,
      highlightedUserIds: [],
      isFocused: false,
      devicePixelRatio: typeof window === "undefined" ? 1 : window.devicePixelRatio,
      isCoarsePointer: false,
      isHoveringCanvas: null,
      openMenus: [],
      isChangingStyle: false,
      isReadonly: false,
      meta: {},
      duplicateProps: null
    })
  );
}
var instanceVersions = createMigrationIds("com.tldraw.instance", {
  AddTransparentExportBgs: 1,
  RemoveDialog: 2,
  AddToolLockMode: 3,
  RemoveExtraPropsForNextShape: 4,
  AddLabelColor: 5,
  AddFollowingUserId: 6,
  RemoveAlignJustify: 7,
  AddZoom: 8,
  AddVerticalAlign: 9,
  AddScribbleDelay: 10,
  RemoveUserId: 11,
  AddIsPenModeAndIsGridMode: 12,
  HoistOpacity: 13,
  AddChat: 14,
  AddHighlightedUserIds: 15,
  ReplacePropsForNextShapeWithStylesForNextShape: 16,
  AddMeta: 17,
  RemoveCursorColor: 18,
  AddLonelyProperties: 19,
  ReadOnlyReadonly: 20,
  AddHoveringCanvas: 21,
  AddScribbles: 22,
  AddInset: 23,
  AddDuplicateProps: 24,
  RemoveCanMoveCamera: 25
});
var instanceMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance",
  recordType: "instance",
  sequence: [
    {
      id: instanceVersions.AddTransparentExportBgs,
      up: (instance) => {
        return { ...instance, exportBackground: true };
      }
    },
    {
      id: instanceVersions.RemoveDialog,
      up: ({ dialog: _, ...instance }) => {
        return instance;
      }
    },
    {
      id: instanceVersions.AddToolLockMode,
      up: (instance) => {
        return { ...instance, isToolLocked: false };
      }
    },
    {
      id: instanceVersions.RemoveExtraPropsForNextShape,
      up: ({ propsForNextShape, ...instance }) => {
        return {
          ...instance,
          propsForNextShape: Object.fromEntries(
            Object.entries(propsForNextShape).filter(
              ([key]) => [
                "color",
                "labelColor",
                "dash",
                "fill",
                "size",
                "font",
                "align",
                "verticalAlign",
                "icon",
                "geo",
                "arrowheadStart",
                "arrowheadEnd",
                "spline"
              ].includes(key)
            )
          )
        };
      }
    },
    {
      id: instanceVersions.AddLabelColor,
      up: ({ propsForNextShape, ...instance }) => {
        return {
          ...instance,
          propsForNextShape: {
            ...propsForNextShape,
            labelColor: "black"
          }
        };
      }
    },
    {
      id: instanceVersions.AddFollowingUserId,
      up: (instance) => {
        return { ...instance, followingUserId: null };
      }
    },
    {
      id: instanceVersions.RemoveAlignJustify,
      up: (instance) => {
        let newAlign = instance.propsForNextShape.align;
        if (newAlign === "justify") {
          newAlign = "start";
        }
        return {
          ...instance,
          propsForNextShape: {
            ...instance.propsForNextShape,
            align: newAlign
          }
        };
      }
    },
    {
      id: instanceVersions.AddZoom,
      up: (instance) => {
        return { ...instance, zoomBrush: null };
      }
    },
    {
      id: instanceVersions.AddVerticalAlign,
      up: (instance) => {
        return {
          ...instance,
          propsForNextShape: {
            ...instance.propsForNextShape,
            verticalAlign: "middle"
          }
        };
      }
    },
    {
      id: instanceVersions.AddScribbleDelay,
      up: (instance) => {
        if (instance.scribble !== null) {
          return { ...instance, scribble: { ...instance.scribble, delay: 0 } };
        }
        return { ...instance };
      }
    },
    {
      id: instanceVersions.RemoveUserId,
      up: ({ userId: _, ...instance }) => {
        return instance;
      }
    },
    {
      id: instanceVersions.AddIsPenModeAndIsGridMode,
      up: (instance) => {
        return { ...instance, isPenMode: false, isGridMode: false };
      }
    },
    {
      id: instanceVersions.HoistOpacity,
      up: ({ propsForNextShape: { opacity, ...propsForNextShape }, ...instance }) => {
        return { ...instance, opacityForNextShape: Number(opacity ?? "1"), propsForNextShape };
      }
    },
    {
      id: instanceVersions.AddChat,
      up: (instance) => {
        return { ...instance, chatMessage: "", isChatting: false };
      }
    },
    {
      id: instanceVersions.AddHighlightedUserIds,
      up: (instance) => {
        return { ...instance, highlightedUserIds: [] };
      }
    },
    {
      id: instanceVersions.ReplacePropsForNextShapeWithStylesForNextShape,
      up: ({ propsForNextShape: _, ...instance }) => {
        return { ...instance, stylesForNextShape: {} };
      }
    },
    {
      id: instanceVersions.AddMeta,
      up: (record) => {
        return {
          ...record,
          meta: {}
        };
      }
    },
    {
      id: instanceVersions.RemoveCursorColor,
      up: (record) => {
        const { color: _, ...cursor } = record.cursor;
        return {
          ...record,
          cursor
        };
      }
    },
    {
      id: instanceVersions.AddLonelyProperties,
      up: (record) => {
        return {
          ...record,
          canMoveCamera: true,
          isFocused: false,
          devicePixelRatio: 1,
          isCoarsePointer: false,
          openMenus: [],
          isChangingStyle: false,
          isReadOnly: false
        };
      }
    },
    {
      id: instanceVersions.ReadOnlyReadonly,
      up: ({ isReadOnly: _isReadOnly, ...record }) => {
        return {
          ...record,
          isReadonly: _isReadOnly
        };
      }
    },
    {
      id: instanceVersions.AddHoveringCanvas,
      up: (record) => {
        return {
          ...record,
          isHoveringCanvas: null
        };
      }
    },
    {
      id: instanceVersions.AddScribbles,
      up: ({ scribble: _, ...record }) => {
        return {
          ...record,
          scribbles: []
        };
      }
    },
    {
      id: instanceVersions.AddInset,
      up: (record) => {
        return {
          ...record,
          insets: [false, false, false, false]
        };
      },
      down: ({ insets: _, ...record }) => {
        return {
          ...record
        };
      }
    },
    {
      id: instanceVersions.AddDuplicateProps,
      up: (record) => {
        return {
          ...record,
          duplicateProps: null
        };
      },
      down: ({ duplicateProps: _, ...record }) => {
        return {
          ...record
        };
      }
    },
    {
      id: instanceVersions.RemoveCanMoveCamera,
      up: ({ canMoveCamera: _, ...record }) => {
        return {
          ...record
        };
      },
      down: (instance) => {
        return { ...instance, canMoveCamera: true };
      }
    }
  ]
});
var TLINSTANCE_ID = "instance:instance";

// node_modules/@tldraw/tlschema/dist-esm/records/TLPageState.mjs
var instancePageStateValidator = validation_exports.model(
  "instance_page_state",
  validation_exports.object({
    typeName: validation_exports.literal("instance_page_state"),
    id: idValidator("instance_page_state"),
    pageId: pageIdValidator,
    selectedShapeIds: validation_exports.arrayOf(shapeIdValidator),
    hintingShapeIds: validation_exports.arrayOf(shapeIdValidator),
    erasingShapeIds: validation_exports.arrayOf(shapeIdValidator),
    hoveredShapeId: shapeIdValidator.nullable(),
    editingShapeId: shapeIdValidator.nullable(),
    croppingShapeId: shapeIdValidator.nullable(),
    focusedGroupId: shapeIdValidator.nullable(),
    meta: validation_exports.jsonValue
  })
);
var instancePageStateVersions = createMigrationIds("com.tldraw.instance_page_state", {
  AddCroppingId: 1,
  RemoveInstanceIdAndCameraId: 2,
  AddMeta: 3,
  RenameProperties: 4,
  RenamePropertiesAgain: 5
});
var instancePageStateMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance_page_state",
  recordType: "instance_page_state",
  sequence: [
    {
      id: instancePageStateVersions.AddCroppingId,
      up(instance) {
        instance.croppingShapeId = null;
      }
    },
    {
      id: instancePageStateVersions.RemoveInstanceIdAndCameraId,
      up(instance) {
        delete instance.instanceId;
        delete instance.cameraId;
      }
    },
    {
      id: instancePageStateVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: instancePageStateVersions.RenameProperties,
      // this migration is cursed: it was written wrong and doesn't do anything.
      // rather than replace it, I've added another migration below that fixes it.
      up: (_record) => {
      },
      down: (_record) => {
      }
    },
    {
      id: instancePageStateVersions.RenamePropertiesAgain,
      up: (record) => {
        record.selectedShapeIds = record.selectedIds;
        delete record.selectedIds;
        record.hintingShapeIds = record.hintingIds;
        delete record.hintingIds;
        record.erasingShapeIds = record.erasingIds;
        delete record.erasingIds;
        record.hoveredShapeId = record.hoveredId;
        delete record.hoveredId;
        record.editingShapeId = record.editingId;
        delete record.editingId;
        record.croppingShapeId = record.croppingShapeId ?? record.croppingId ?? null;
        delete record.croppingId;
        record.focusedGroupId = record.focusLayerId;
        delete record.focusLayerId;
      },
      down: (record) => {
        record.selectedIds = record.selectedShapeIds;
        delete record.selectedShapeIds;
        record.hintingIds = record.hintingShapeIds;
        delete record.hintingShapeIds;
        record.erasingIds = record.erasingShapeIds;
        delete record.erasingShapeIds;
        record.hoveredId = record.hoveredShapeId;
        delete record.hoveredShapeId;
        record.editingId = record.editingShapeId;
        delete record.editingShapeId;
        record.croppingId = record.croppingShapeId;
        delete record.croppingShapeId;
        record.focusLayerId = record.focusedGroupId;
        delete record.focusedGroupId;
      }
    }
  ]
});
var InstancePageStateRecordType = createRecordType(
  "instance_page_state",
  {
    validator: instancePageStateValidator,
    scope: "session",
    ephemeralKeys: {
      pageId: false,
      selectedShapeIds: false,
      editingShapeId: false,
      croppingShapeId: false,
      meta: false,
      hintingShapeIds: true,
      erasingShapeIds: true,
      hoveredShapeId: true,
      focusedGroupId: true
    }
  }
).withDefaultProperties(
  () => ({
    editingShapeId: null,
    croppingShapeId: null,
    selectedShapeIds: [],
    hoveredShapeId: null,
    erasingShapeIds: [],
    hintingShapeIds: [],
    focusedGroupId: null,
    meta: {}
  })
);

// node_modules/@tldraw/tlschema/dist-esm/records/TLPointer.mjs
var pointerValidator = validation_exports.model(
  "pointer",
  validation_exports.object({
    typeName: validation_exports.literal("pointer"),
    id: idValidator("pointer"),
    x: validation_exports.number,
    y: validation_exports.number,
    lastActivityTimestamp: validation_exports.number,
    meta: validation_exports.jsonValue
  })
);
var pointerVersions = createMigrationIds("com.tldraw.pointer", {
  AddMeta: 1
});
var pointerMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.pointer",
  recordType: "pointer",
  sequence: [
    {
      id: pointerVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
var PointerRecordType = createRecordType("pointer", {
  validator: pointerValidator,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    lastActivityTimestamp: 0,
    meta: {}
  })
);
var TLPOINTER_ID = PointerRecordType.createId("pointer");

// node_modules/@tldraw/tlschema/dist-esm/records/TLPresence.mjs
var instancePresenceValidator = validation_exports.model(
  "instance_presence",
  validation_exports.object({
    typeName: validation_exports.literal("instance_presence"),
    id: idValidator("instance_presence"),
    userId: validation_exports.string,
    userName: validation_exports.string,
    lastActivityTimestamp: validation_exports.number.nullable(),
    followingUserId: validation_exports.string.nullable(),
    cursor: validation_exports.object({
      x: validation_exports.number,
      y: validation_exports.number,
      type: cursorTypeValidator,
      rotation: validation_exports.number
    }).nullable(),
    color: validation_exports.string,
    camera: validation_exports.object({
      x: validation_exports.number,
      y: validation_exports.number,
      z: validation_exports.number
    }).nullable(),
    screenBounds: boxModelValidator.nullable(),
    selectedShapeIds: validation_exports.arrayOf(idValidator("shape")),
    currentPageId: idValidator("page"),
    brush: boxModelValidator.nullable(),
    scribbles: validation_exports.arrayOf(scribbleValidator),
    chatMessage: validation_exports.string,
    meta: validation_exports.jsonValue
  })
);
var instancePresenceVersions = createMigrationIds("com.tldraw.instance_presence", {
  AddScribbleDelay: 1,
  RemoveInstanceId: 2,
  AddChatMessage: 3,
  AddMeta: 4,
  RenameSelectedShapeIds: 5,
  NullableCameraCursor: 6
});
var instancePresenceMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance_presence",
  recordType: "instance_presence",
  sequence: [
    {
      id: instancePresenceVersions.AddScribbleDelay,
      up: (instance) => {
        if (instance.scribble !== null) {
          instance.scribble.delay = 0;
        }
      }
    },
    {
      id: instancePresenceVersions.RemoveInstanceId,
      up: (instance) => {
        delete instance.instanceId;
      }
    },
    {
      id: instancePresenceVersions.AddChatMessage,
      up: (instance) => {
        instance.chatMessage = "";
      }
    },
    {
      id: instancePresenceVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: instancePresenceVersions.RenameSelectedShapeIds,
      up: (_record) => {
      }
    },
    {
      id: instancePresenceVersions.NullableCameraCursor,
      up: (_record) => {
      },
      down: (record) => {
        if (record.camera === null) {
          record.camera = { x: 0, y: 0, z: 1 };
        }
        if (record.lastActivityTimestamp === null) {
          record.lastActivityTimestamp = 0;
        }
        if (record.cursor === null) {
          record.cursor = { type: "default", x: 0, y: 0, rotation: 0 };
        }
        if (record.screenBounds === null) {
          record.screenBounds = { x: 0, y: 0, w: 1, h: 1 };
        }
      }
    }
  ]
});
var InstancePresenceRecordType = createRecordType(
  "instance_presence",
  {
    validator: instancePresenceValidator,
    scope: "presence"
  }
).withDefaultProperties(() => ({
  lastActivityTimestamp: null,
  followingUserId: null,
  color: "#FF0000",
  camera: null,
  cursor: null,
  screenBounds: null,
  selectedShapeIds: [],
  brush: null,
  scribbles: [],
  chatMessage: "",
  meta: {}
}));

// node_modules/@tldraw/tlschema/dist-esm/createPresenceStateDerivation.mjs
function createPresenceStateDerivation($user, instanceId) {
  return (store) => {
    return computed("instancePresence", () => {
      const user = $user.get();
      if (!user)
        return null;
      const state = getDefaultUserPresence(store, user);
      if (!state)
        return null;
      return InstancePresenceRecordType.create({
        ...state,
        id: instanceId ?? InstancePresenceRecordType.createId(store.id)
      });
    });
  };
}
function getDefaultUserPresence(store, user) {
  const instance = store.get(TLINSTANCE_ID);
  const pageState = store.get(InstancePageStateRecordType.createId(instance == null ? void 0 : instance.currentPageId));
  const camera = store.get(CameraRecordType.createId(instance == null ? void 0 : instance.currentPageId));
  const pointer = store.get(TLPOINTER_ID);
  if (!pageState || !instance || !camera || !pointer) {
    return null;
  }
  return {
    selectedShapeIds: pageState.selectedShapeIds,
    brush: instance.brush,
    scribbles: instance.scribbles,
    userId: user.id,
    userName: user.name ?? "",
    followingUserId: instance.followingUserId,
    camera: {
      x: camera.x,
      y: camera.y,
      z: camera.z
    },
    color: user.color ?? "#FF0000",
    currentPageId: instance.currentPageId,
    cursor: {
      x: pointer.x,
      y: pointer.y,
      rotation: instance.cursor.rotation,
      type: instance.cursor.type
    },
    lastActivityTimestamp: pointer.lastActivityTimestamp,
    screenBounds: instance.screenBounds,
    chatMessage: instance.chatMessage,
    meta: {}
  };
}

// node_modules/@tldraw/tlschema/dist-esm/records/TLDocument.mjs
var documentValidator = validation_exports.model(
  "document",
  validation_exports.object({
    typeName: validation_exports.literal("document"),
    id: validation_exports.literal("document:document"),
    gridSize: validation_exports.number,
    name: validation_exports.string,
    meta: validation_exports.jsonValue
  })
);
function isDocument(record) {
  if (!record)
    return false;
  return record.typeName === "document";
}
var documentVersions = createMigrationIds("com.tldraw.document", {
  AddName: 1,
  AddMeta: 2
});
var documentMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.document",
  recordType: "document",
  sequence: [
    {
      id: documentVersions.AddName,
      up: (document2) => {
        ;
        document2.name = "";
      },
      down: (document2) => {
        delete document2.name;
      }
    },
    {
      id: documentVersions.AddMeta,
      up: (record) => {
        ;
        record.meta = {};
      }
    }
  ]
});
var DocumentRecordType = createRecordType("document", {
  validator: documentValidator,
  scope: "document"
}).withDefaultProperties(
  () => ({
    gridSize: 10,
    name: "",
    meta: {}
  })
);
var TLDOCUMENT_ID = DocumentRecordType.createId("document");

// node_modules/@tldraw/tlschema/dist-esm/TLStore.mjs
function sortByIndex2(a, b) {
  if (a.index < b.index) {
    return -1;
  } else if (a.index > b.index) {
    return 1;
  }
  return 0;
}
function redactRecordForErrorReporting(record) {
  if (record.typeName === "asset") {
    if ("src" in record) {
      record.src = "<redacted>";
    }
    if ("src" in record.props) {
      record.props.src = "<redacted>";
    }
  }
}
function onValidationFailure({
  error,
  phase,
  record,
  recordBefore
}) {
  const isExistingValidationIssue = (
    // if we're initializing the store for the first time, we should
    // allow invalid records so people can load old buggy data:
    phase === "initialize"
  );
  annotateError(error, {
    tags: {
      origin: "store.validateRecord",
      storePhase: phase,
      isExistingValidationIssue
    },
    extras: {
      recordBefore: recordBefore ? redactRecordForErrorReporting(structuredClone(recordBefore)) : void 0,
      recordAfter: redactRecordForErrorReporting(structuredClone(record))
    }
  });
  throw error;
}
function getDefaultPages() {
  return [
    PageRecordType.create({
      id: "page:page",
      name: "Page 1",
      index: "a1",
      meta: {}
    })
  ];
}
function createIntegrityChecker(store) {
  const $pageIds = store.query.ids("page");
  const $pageStates = store.query.records("instance_page_state");
  const ensureStoreIsUsable = () => {
    if (!store.has(TLDOCUMENT_ID)) {
      store.put([DocumentRecordType.create({ id: TLDOCUMENT_ID, name: store.props.defaultName })]);
      return ensureStoreIsUsable();
    }
    if (!store.has(TLPOINTER_ID)) {
      store.put([PointerRecordType.create({ id: TLPOINTER_ID })]);
      return ensureStoreIsUsable();
    }
    const pageIds = $pageIds.get();
    if (pageIds.size === 0) {
      store.put(getDefaultPages());
      return ensureStoreIsUsable();
    }
    const getFirstPageId = () => [...pageIds].map((id) => store.get(id)).sort(sortByIndex2)[0].id;
    const instanceState = store.get(TLINSTANCE_ID);
    if (!instanceState) {
      store.put([
        store.schema.types.instance.create({
          id: TLINSTANCE_ID,
          currentPageId: getFirstPageId(),
          exportBackground: true
        })
      ]);
      return ensureStoreIsUsable();
    } else if (!pageIds.has(instanceState.currentPageId)) {
      store.put([{ ...instanceState, currentPageId: getFirstPageId() }]);
      return ensureStoreIsUsable();
    }
    const missingPageStateIds = /* @__PURE__ */ new Set();
    const missingCameraIds = /* @__PURE__ */ new Set();
    for (const id of pageIds) {
      const pageStateId = InstancePageStateRecordType.createId(id);
      const pageState = store.get(pageStateId);
      if (!pageState) {
        missingPageStateIds.add(pageStateId);
      }
      const cameraId = CameraRecordType.createId(id);
      if (!store.has(cameraId)) {
        missingCameraIds.add(cameraId);
      }
    }
    if (missingPageStateIds.size > 0) {
      store.put(
        [...missingPageStateIds].map(
          (id) => InstancePageStateRecordType.create({
            id,
            pageId: InstancePageStateRecordType.parseId(id)
          })
        )
      );
    }
    if (missingCameraIds.size > 0) {
      store.put([...missingCameraIds].map((id) => CameraRecordType.create({ id })));
    }
    const pageStates = $pageStates.get();
    for (const pageState of pageStates) {
      if (!pageIds.has(pageState.pageId)) {
        store.remove([pageState.id]);
        continue;
      }
      if (pageState.croppingShapeId && !store.has(pageState.croppingShapeId)) {
        store.put([{ ...pageState, croppingShapeId: null }]);
        return ensureStoreIsUsable();
      }
      if (pageState.focusedGroupId && !store.has(pageState.focusedGroupId)) {
        store.put([{ ...pageState, focusedGroupId: null }]);
        return ensureStoreIsUsable();
      }
      if (pageState.hoveredShapeId && !store.has(pageState.hoveredShapeId)) {
        store.put([{ ...pageState, hoveredShapeId: null }]);
        return ensureStoreIsUsable();
      }
      const filteredSelectedIds = pageState.selectedShapeIds.filter((id) => store.has(id));
      if (filteredSelectedIds.length !== pageState.selectedShapeIds.length) {
        store.put([{ ...pageState, selectedShapeIds: filteredSelectedIds }]);
        return ensureStoreIsUsable();
      }
      const filteredHintingIds = pageState.hintingShapeIds.filter((id) => store.has(id));
      if (filteredHintingIds.length !== pageState.hintingShapeIds.length) {
        store.put([{ ...pageState, hintingShapeIds: filteredHintingIds }]);
        return ensureStoreIsUsable();
      }
      const filteredErasingIds = pageState.erasingShapeIds.filter((id) => store.has(id));
      if (filteredErasingIds.length !== pageState.erasingShapeIds.length) {
        store.put([{ ...pageState, erasingShapeIds: filteredErasingIds }]);
        return ensureStoreIsUsable();
      }
    }
  };
  return ensureStoreIsUsable;
}

// node_modules/@tldraw/tlschema/dist-esm/assets/TLBookmarkAsset.mjs
var bookmarkAssetValidator = createAssetValidator(
  "bookmark",
  validation_exports.object({
    title: validation_exports.string,
    description: validation_exports.string,
    image: validation_exports.string,
    favicon: validation_exports.string,
    src: validation_exports.srcUrl.nullable()
  })
);
var Versions = createMigrationIds("com.tldraw.asset.bookmark", {
  MakeUrlsValid: 1,
  AddFavicon: 2
});
var bookmarkAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.bookmark",
  recordType: "asset",
  filter: (asset) => asset.type === "bookmark",
  sequence: [
    {
      id: Versions.MakeUrlsValid,
      up: (asset) => {
        if (!validation_exports.srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions.AddFavicon,
      up: (asset) => {
        if (!validation_exports.srcUrl.isValid(asset.props.favicon)) {
          asset.props.favicon = "";
        }
      },
      down: (asset) => {
        delete asset.props.favicon;
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/assets/TLImageAsset.mjs
var imageAssetValidator = createAssetValidator(
  "image",
  validation_exports.object({
    w: validation_exports.number,
    h: validation_exports.number,
    name: validation_exports.string,
    isAnimated: validation_exports.boolean,
    mimeType: validation_exports.string.nullable(),
    src: validation_exports.srcUrl.nullable(),
    fileSize: validation_exports.nonZeroNumber.optional()
  })
);
var Versions2 = createMigrationIds("com.tldraw.asset.image", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
});
var imageAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.image",
  recordType: "asset",
  filter: (asset) => asset.type === "image",
  sequence: [
    {
      id: Versions2.AddIsAnimated,
      up: (asset) => {
        asset.props.isAnimated = false;
      },
      down: (asset) => {
        delete asset.props.isAnimated;
      }
    },
    {
      id: Versions2.RenameWidthHeight,
      up: (asset) => {
        asset.props.w = asset.props.width;
        asset.props.h = asset.props.height;
        delete asset.props.width;
        delete asset.props.height;
      },
      down: (asset) => {
        asset.props.width = asset.props.w;
        asset.props.height = asset.props.h;
        delete asset.props.w;
        delete asset.props.h;
      }
    },
    {
      id: Versions2.MakeUrlsValid,
      up: (asset) => {
        if (!validation_exports.srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions2.AddFileSize,
      up: (asset) => {
        asset.props.fileSize = -1;
      },
      down: (asset) => {
        delete asset.props.fileSize;
      }
    },
    {
      id: Versions2.MakeFileSizeOptional,
      up: (asset) => {
        if (asset.props.fileSize === -1) {
          asset.props.fileSize = void 0;
        }
      },
      down: (asset) => {
        if (asset.props.fileSize === void 0) {
          asset.props.fileSize = -1;
        }
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/assets/TLVideoAsset.mjs
var videoAssetValidator = createAssetValidator(
  "video",
  validation_exports.object({
    w: validation_exports.number,
    h: validation_exports.number,
    name: validation_exports.string,
    isAnimated: validation_exports.boolean,
    mimeType: validation_exports.string.nullable(),
    src: validation_exports.srcUrl.nullable(),
    fileSize: validation_exports.number.optional()
  })
);
var Versions3 = createMigrationIds("com.tldraw.asset.video", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
});
var videoAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.video",
  recordType: "asset",
  filter: (asset) => asset.type === "video",
  sequence: [
    {
      id: Versions3.AddIsAnimated,
      up: (asset) => {
        asset.props.isAnimated = false;
      },
      down: (asset) => {
        delete asset.props.isAnimated;
      }
    },
    {
      id: Versions3.RenameWidthHeight,
      up: (asset) => {
        asset.props.w = asset.props.width;
        asset.props.h = asset.props.height;
        delete asset.props.width;
        delete asset.props.height;
      },
      down: (asset) => {
        asset.props.width = asset.props.w;
        asset.props.height = asset.props.h;
        delete asset.props.w;
        delete asset.props.h;
      }
    },
    {
      id: Versions3.MakeUrlsValid,
      up: (asset) => {
        if (!validation_exports.srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions3.AddFileSize,
      up: (asset) => {
        asset.props.fileSize = -1;
      },
      down: (asset) => {
        delete asset.props.fileSize;
      }
    },
    {
      id: Versions3.MakeFileSizeOptional,
      up: (asset) => {
        if (asset.props.fileSize === -1) {
          asset.props.fileSize = void 0;
        }
      },
      down: (asset) => {
        if (asset.props.fileSize === void 0) {
          asset.props.fileSize = -1;
        }
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/records/TLAsset.mjs
var assetValidator = validation_exports.model(
  "asset",
  validation_exports.union("type", {
    image: imageAssetValidator,
    video: videoAssetValidator,
    bookmark: bookmarkAssetValidator
  })
);
var assetVersions = createMigrationIds("com.tldraw.asset", {
  AddMeta: 1
});
var assetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset",
  recordType: "asset",
  sequence: [
    {
      id: assetVersions.AddMeta,
      up: (record) => {
        ;
        record.meta = {};
      }
    }
  ]
});
var AssetRecordType = createRecordType("asset", {
  validator: assetValidator,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
}));

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLBookmarkShape.mjs
var bookmarkShapeProps = {
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  assetId: assetIdValidator.nullable(),
  url: validation_exports.linkUrl
};
var Versions4 = createShapePropsMigrationIds("bookmark", {
  NullAssetId: 1,
  MakeUrlsValid: 2
});
var bookmarkShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions4.NullAssetId,
      up: (props) => {
        if (props.assetId === void 0) {
          props.assetId = null;
        }
      },
      down: "retired"
    },
    {
      id: Versions4.MakeUrlsValid,
      up: (props) => {
        if (!validation_exports.linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLDrawShape.mjs
var DrawShapeSegment = validation_exports.object({
  type: validation_exports.literalEnum("free", "straight"),
  points: validation_exports.arrayOf(vecModelValidator)
});
var drawShapeProps = {
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  segments: validation_exports.arrayOf(DrawShapeSegment),
  isComplete: validation_exports.boolean,
  isClosed: validation_exports.boolean,
  isPen: validation_exports.boolean,
  scale: validation_exports.nonZeroNumber
};
var Versions5 = createShapePropsMigrationIds("draw", {
  AddInPen: 1,
  AddScale: 2
});
var drawShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions5.AddInPen,
      up: (props) => {
        const { points } = props.segments[0];
        if (points.length === 0) {
          props.isPen = false;
          return;
        }
        let isPen = !(points[0].z === 0 || points[0].z === 0.5);
        if (points[1]) {
          isPen = isPen && !(points[1].z === 0 || points[1].z === 0.5);
        }
        props.isPen = isPen;
      },
      down: "retired"
    },
    {
      id: Versions5.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLEmbedShape.mjs
var TLDRAW_APP_RE = /(^\/r\/[^/]+\/?$)/;
var EMBED_DEFINITIONS = [
  {
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {
        return url;
      }
      return;
    }
  },
  {
    hostnames: ["figma.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/?$/)) {
        const outUrl = urlObj.searchParams.get("url");
        if (outUrl) {
          return outUrl;
        }
      }
      return;
    }
  },
  {
    hostnames: ["google.*"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj)
        return;
      const matches2 = urlObj.pathname.match(/^\/maps\/embed\/v1\/view\/?$/);
      if (matches2 && urlObj.searchParams.has("center") && urlObj.searchParams.get("zoom")) {
        const zoom = urlObj.searchParams.get("zoom");
        const [lat, lon] = urlObj.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${lat},${lon},${zoom}z`;
      }
      return;
    }
  },
  {
    hostnames: ["val.town"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/v/${matches2[1]}`;
      }
      return;
    }
  },
  {
    hostnames: ["codesandbox.io"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/s/${matches2[1]}`;
      }
      return;
    }
  },
  {
    hostnames: ["codepen.io"],
    fromEmbedUrl: (url) => {
      const CODEPEN_EMBED_REGEXP = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/;
      const matches2 = url.match(CODEPEN_EMBED_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/pen/${id}`;
      }
      return;
    }
  },
  {
    hostnames: ["scratch.mit.edu"],
    fromEmbedUrl: (url) => {
      const SCRATCH_EMBED_REGEXP = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/;
      const matches2 = url.match(SCRATCH_EMBED_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/${id}`;
      }
      return;
    }
  },
  {
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj)
        return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtube.com") {
        const matches2 = urlObj.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (matches2) {
          return `https://www.youtube.com/watch?v=${matches2[1]}`;
        }
      }
      return;
    }
  },
  {
    hostnames: ["calendar.google.*"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const srcQs = urlObj == null ? void 0 : urlObj.searchParams.get("src");
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/\/calendar\/embed/)) && srcQs) {
        urlObj.pathname = "/calendar/u/0";
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("cid", srcQs);
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["docs.google.*"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/^\/presentation/)) && (urlObj == null ? void 0 : urlObj.pathname.match(/\/embed\/?$/))) {
        urlObj.pathname = urlObj.pathname.replace(/\/embed$/, "/pub");
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["gist.github.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([^/]+)/)) {
        if (!url.split("/").pop())
          return;
        return url;
      }
      return;
    }
  },
  {
    hostnames: ["replit.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/) && urlObj.searchParams.has("embed")) {
        urlObj.searchParams.delete("embed");
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["felt.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/map\//)) {
        urlObj.pathname = urlObj.pathname.replace(/^\/embed/, "");
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["open.spotify.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/(artist|album)\//)) {
        return urlObj.origin + urlObj.pathname.replace(/^\/embed/, "");
      }
      return;
    }
  },
  {
    hostnames: ["vimeo.com", "player.vimeo.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "player.vimeo.com") {
        const matches2 = urlObj.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (matches2) {
          return "https://vimeo.com/" + matches2[1];
        }
      }
      return;
    }
  },
  {
    hostnames: ["excalidraw.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hash.match(/#room=/)) {
        return url;
      }
      return;
    }
  },
  {
    hostnames: ["observablehq.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "")}#cell-*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/embed\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "/d")}#cell-*`;
      }
      return;
    }
  },
  {
    hostnames: ["desmos.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "?embed" && urlObj.hash === "") {
        return url.replace("?embed", "");
      }
      return;
    }
  }
];
var embedShapeProps = {
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  url: validation_exports.string
};
var Versions6 = createShapePropsMigrationIds("embed", {
  GenOriginalUrlInEmbed: 1,
  RemoveDoesResize: 2,
  RemoveTmpOldUrl: 3,
  RemovePermissionOverrides: 4
});
var embedShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions6.GenOriginalUrlInEmbed,
      // add tmpOldUrl property
      up: (props) => {
        try {
          const url = props.url;
          const host = new URL(url).host.replace("www.", "");
          let originalUrl;
          for (const localEmbedDef of EMBED_DEFINITIONS) {
            if (localEmbedDef.hostnames.includes(host)) {
              try {
                originalUrl = localEmbedDef.fromEmbedUrl(url);
              } catch (err) {
                console.warn(err);
              }
            }
          }
          props.tmpOldUrl = props.url;
          props.url = originalUrl ?? "";
        } catch {
          props.url = "";
          props.tmpOldUrl = props.url;
        }
      },
      down: "retired"
    },
    {
      id: Versions6.RemoveDoesResize,
      up: (props) => {
        delete props.doesResize;
      },
      down: "retired"
    },
    {
      id: Versions6.RemoveTmpOldUrl,
      up: (props) => {
        delete props.tmpOldUrl;
      },
      down: "retired"
    },
    {
      id: Versions6.RemovePermissionOverrides,
      up: (props) => {
        delete props.overridePermissions;
      },
      down: "retired"
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLFrameShape.mjs
var frameShapeProps = {
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  name: validation_exports.string,
  // because shape colors are an option, we don't want them to be picked up by the editor as a
  // style prop by default, so instead of a proper style we just supply an equivalent validator.
  // Check `FrameShapeUtil.configure` for how we replace this with the original
  // `DefaultColorStyle` style when the option is turned on.
  color: validation_exports.literalEnum(...DefaultColorStyle.values)
};
var Versions7 = createShapePropsMigrationIds("frame", {
  AddColorProp: 1
});
var frameShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions7.AddColorProp,
      up: (props) => {
        props.color = "black";
      },
      down: (props) => {
        delete props.color;
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/misc/TLRichText.mjs
var richTextValidator = validation_exports.object({ type: validation_exports.string, content: validation_exports.arrayOf(validation_exports.unknown) });
function toRichText(text) {
  const lines = text.split("\n");
  const content = lines.map((text2) => {
    if (!text2) {
      return {
        type: "paragraph"
      };
    }
    return {
      type: "paragraph",
      content: [{ type: "text", text: text2 }]
    };
  });
  return {
    type: "doc",
    content
  };
}

// node_modules/@tldraw/tlschema/dist-esm/styles/TLHorizontalAlignStyle.mjs
var DefaultHorizontalAlignStyle = StyleProp.defineEnum("tldraw:horizontalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end", "start-legacy", "end-legacy", "middle-legacy"]
});

// node_modules/@tldraw/tlschema/dist-esm/styles/TLVerticalAlignStyle.mjs
var DefaultVerticalAlignStyle = StyleProp.defineEnum("tldraw:verticalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end"]
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLGeoShape.mjs
var GeoShapeGeoStyle = StyleProp.defineEnum("tldraw:geo", {
  defaultValue: "rectangle",
  values: [
    "cloud",
    "rectangle",
    "ellipse",
    "triangle",
    "diamond",
    "pentagon",
    "hexagon",
    "octagon",
    "star",
    "rhombus",
    "rhombus-2",
    "oval",
    "trapezoid",
    "arrow-right",
    "arrow-left",
    "arrow-up",
    "arrow-down",
    "x-box",
    "check-box",
    "heart"
  ]
});
var geoShapeProps = {
  geo: GeoShapeGeoStyle,
  labelColor: DefaultLabelColorStyle,
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  align: DefaultHorizontalAlignStyle,
  verticalAlign: DefaultVerticalAlignStyle,
  url: validation_exports.linkUrl,
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  growY: validation_exports.positiveNumber,
  richText: richTextValidator,
  scale: validation_exports.nonZeroNumber
};
var geoShapeVersions = createShapePropsMigrationIds("geo", {
  AddUrlProp: 1,
  AddLabelColor: 2,
  RemoveJustify: 3,
  AddCheckBox: 4,
  AddVerticalAlign: 5,
  MigrateLegacyAlign: 6,
  AddCloud: 7,
  MakeUrlsValid: 8,
  AddScale: 9,
  AddRichText: 10
});
var geoShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: geoShapeVersions.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddCheckBox,
      up: (_props) => {
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddVerticalAlign,
      up: (props) => {
        props.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.MigrateLegacyAlign,
      up: (props) => {
        let newAlign;
        switch (props.align) {
          case "start":
            newAlign = "start-legacy";
            break;
          case "end":
            newAlign = "end-legacy";
            break;
          default:
            newAlign = "middle-legacy";
            break;
        }
        props.align = newAlign;
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddCloud,
      up: (_props) => {
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.MakeUrlsValid,
      up: (props) => {
        if (!validation_exports.linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: geoShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    },
    {
      id: geoShapeVersions.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLGroupShape.mjs
var groupShapeProps = {};
var groupShapeMigrations = createShapePropsMigrationSequence({ sequence: [] });

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLHighlightShape.mjs
var highlightShapeProps = {
  color: DefaultColorStyle,
  size: DefaultSizeStyle,
  segments: validation_exports.arrayOf(DrawShapeSegment),
  isComplete: validation_exports.boolean,
  isPen: validation_exports.boolean,
  scale: validation_exports.nonZeroNumber
};
var Versions8 = createShapePropsMigrationIds("highlight", {
  AddScale: 1
});
var highlightShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions8.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLImageShape.mjs
var ImageShapeCrop = validation_exports.object({
  topLeft: vecModelValidator,
  bottomRight: vecModelValidator
});
var imageShapeProps = {
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  playing: validation_exports.boolean,
  url: validation_exports.linkUrl,
  assetId: assetIdValidator.nullable(),
  crop: ImageShapeCrop.nullable(),
  flipX: validation_exports.boolean,
  flipY: validation_exports.boolean,
  altText: validation_exports.string
};
var Versions9 = createShapePropsMigrationIds("image", {
  AddUrlProp: 1,
  AddCropProp: 2,
  MakeUrlsValid: 3,
  AddFlipProps: 4,
  AddAltText: 5
});
var imageShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions9.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions9.AddCropProp,
      up: (props) => {
        props.crop = null;
      },
      down: (props) => {
        delete props.crop;
      }
    },
    {
      id: Versions9.MakeUrlsValid,
      up: (props) => {
        if (!validation_exports.linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions9.AddFlipProps,
      up: (props) => {
        props.flipX = false;
        props.flipY = false;
      },
      down: (props) => {
        delete props.flipX;
        delete props.flipY;
      }
    },
    {
      id: Versions9.AddAltText,
      up: (props) => {
        props.altText = "";
      },
      down: (props) => {
        delete props.altText;
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLLineShape.mjs
var LineShapeSplineStyle = StyleProp.defineEnum("tldraw:spline", {
  defaultValue: "line",
  values: ["cubic", "line"]
});
var lineShapePointValidator = validation_exports.object({
  id: validation_exports.string,
  index: validation_exports.indexKey,
  x: validation_exports.number,
  y: validation_exports.number
});
var lineShapeProps = {
  color: DefaultColorStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  spline: LineShapeSplineStyle,
  points: validation_exports.dict(validation_exports.string, lineShapePointValidator),
  scale: validation_exports.nonZeroNumber
};
var lineShapeVersions = createShapePropsMigrationIds("line", {
  AddSnapHandles: 1,
  RemoveExtraHandleProps: 2,
  HandlesToPoints: 3,
  PointIndexIds: 4,
  AddScale: 5
});
var lineShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: lineShapeVersions.AddSnapHandles,
      up: (props) => {
        for (const handle of Object.values(props.handles)) {
          ;
          handle.canSnap = true;
        }
      },
      down: "retired"
    },
    {
      id: lineShapeVersions.RemoveExtraHandleProps,
      up: (props) => {
        props.handles = objectMapFromEntries(
          Object.values(props.handles).map((handle) => [
            handle.index,
            {
              x: handle.x,
              y: handle.y
            }
          ])
        );
      },
      down: (props) => {
        const handles = Object.entries(props.handles).map(([index3, handle]) => ({ index: index3, ...handle })).sort(sortByIndex);
        props.handles = Object.fromEntries(
          handles.map((handle, i) => {
            const id = i === 0 ? "start" : i === handles.length - 1 ? "end" : `handle:${handle.index}`;
            return [
              id,
              {
                id,
                type: "vertex",
                canBind: false,
                canSnap: true,
                index: handle.index,
                x: handle.x,
                y: handle.y
              }
            ];
          })
        );
      }
    },
    {
      id: lineShapeVersions.HandlesToPoints,
      up: (props) => {
        const sortedHandles = Object.entries(props.handles).map(([index3, { x, y }]) => ({ x, y, index: index3 })).sort(sortByIndex);
        props.points = sortedHandles.map(({ x, y }) => ({ x, y }));
        delete props.handles;
      },
      down: (props) => {
        const indices = getIndices(props.points.length);
        props.handles = Object.fromEntries(
          props.points.map((handle, i) => {
            const index3 = indices[i];
            return [
              index3,
              {
                x: handle.x,
                y: handle.y
              }
            ];
          })
        );
        delete props.points;
      }
    },
    {
      id: lineShapeVersions.PointIndexIds,
      up: (props) => {
        const indices = getIndices(props.points.length);
        props.points = Object.fromEntries(
          props.points.map((point, i) => {
            const id = indices[i];
            return [
              id,
              {
                id,
                index: id,
                x: point.x,
                y: point.y
              }
            ];
          })
        );
      },
      down: (props) => {
        const sortedHandles = Object.values(props.points).sort(sortByIndex);
        props.points = sortedHandles.map(({ x, y }) => ({ x, y }));
      }
    },
    {
      id: lineShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLNoteShape.mjs
var noteShapeProps = {
  color: DefaultColorStyle,
  labelColor: DefaultLabelColorStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  fontSizeAdjustment: validation_exports.positiveNumber,
  align: DefaultHorizontalAlignStyle,
  verticalAlign: DefaultVerticalAlignStyle,
  growY: validation_exports.positiveNumber,
  url: validation_exports.linkUrl,
  richText: richTextValidator,
  scale: validation_exports.nonZeroNumber
};
var Versions10 = createShapePropsMigrationIds("note", {
  AddUrlProp: 1,
  RemoveJustify: 2,
  MigrateLegacyAlign: 3,
  AddVerticalAlign: 4,
  MakeUrlsValid: 5,
  AddFontSizeAdjustment: 6,
  AddScale: 7,
  AddLabelColor: 8,
  AddRichText: 9
});
var noteShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions10.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions10.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: Versions10.MigrateLegacyAlign,
      up: (props) => {
        switch (props.align) {
          case "start":
            props.align = "start-legacy";
            return;
          case "end":
            props.align = "end-legacy";
            return;
          default:
            props.align = "middle-legacy";
            return;
        }
      },
      down: "retired"
    },
    {
      id: Versions10.AddVerticalAlign,
      up: (props) => {
        props.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: Versions10.MakeUrlsValid,
      up: (props) => {
        if (!validation_exports.linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions10.AddFontSizeAdjustment,
      up: (props) => {
        props.fontSizeAdjustment = 0;
      },
      down: (props) => {
        delete props.fontSizeAdjustment;
      }
    },
    {
      id: Versions10.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    },
    {
      id: Versions10.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: (props) => {
        delete props.labelColor;
      }
    },
    {
      id: Versions10.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/styles/TLTextAlignStyle.mjs
var DefaultTextAlignStyle = StyleProp.defineEnum("tldraw:textAlign", {
  defaultValue: "start",
  values: ["start", "middle", "end"]
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLTextShape.mjs
var textShapeProps = {
  color: DefaultColorStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  textAlign: DefaultTextAlignStyle,
  w: validation_exports.nonZeroNumber,
  richText: richTextValidator,
  scale: validation_exports.nonZeroNumber,
  autoSize: validation_exports.boolean
};
var Versions11 = createShapePropsMigrationIds("text", {
  RemoveJustify: 1,
  AddTextAlign: 2,
  AddRichText: 3
});
var textShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions11.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: Versions11.AddTextAlign,
      up: (props) => {
        props.textAlign = props.align;
        delete props.align;
      },
      down: (props) => {
        props.align = props.textAlign;
        delete props.textAlign;
      }
    },
    {
      id: Versions11.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/shapes/TLVideoShape.mjs
var videoShapeProps = {
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  time: validation_exports.number,
  playing: validation_exports.boolean,
  url: validation_exports.linkUrl,
  assetId: assetIdValidator.nullable(),
  altText: validation_exports.string
};
var Versions12 = createShapePropsMigrationIds("video", {
  AddUrlProp: 1,
  MakeUrlsValid: 2,
  AddAltText: 3
});
var videoShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions12.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions12.MakeUrlsValid,
      up: (props) => {
        if (!validation_exports.linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions12.AddAltText,
      up: (props) => {
        props.altText = "";
      },
      down: (props) => {
        delete props.altText;
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/store-migrations.mjs
var Versions13 = createMigrationIds("com.tldraw.store", {
  RemoveCodeAndIconShapeTypes: 1,
  AddInstancePresenceType: 2,
  RemoveTLUserAndPresenceAndAddPointer: 3,
  RemoveUserDocument: 4
});
var storeMigrations = createMigrationSequence({
  sequenceId: "com.tldraw.store",
  retroactive: false,
  sequence: [
    {
      id: Versions13.RemoveCodeAndIconShapeTypes,
      scope: "store",
      up: (store) => {
        for (const [id, record] of objectMapEntries(store)) {
          if (record.typeName === "shape" && (record.type === "icon" || record.type === "code")) {
            delete store[id];
          }
        }
      }
    },
    {
      id: Versions13.AddInstancePresenceType,
      scope: "store",
      up(_store) {
      }
    },
    {
      // remove user and presence records and add pointer records
      id: Versions13.RemoveTLUserAndPresenceAndAddPointer,
      scope: "store",
      up: (store) => {
        for (const [id, record] of objectMapEntries(store)) {
          if (record.typeName.match(/^(user|user_presence)$/)) {
            delete store[id];
          }
        }
      }
    },
    {
      // remove user document records
      id: Versions13.RemoveUserDocument,
      scope: "store",
      up: (store) => {
        for (const [id, record] of objectMapEntries(store)) {
          if (record.typeName.match("user_document")) {
            delete store[id];
          }
        }
      }
    }
  ]
});

// node_modules/@tldraw/tlschema/dist-esm/createTLSchema.mjs
var defaultShapeSchemas = {
  arrow: { migrations: arrowShapeMigrations, props: arrowShapeProps },
  bookmark: { migrations: bookmarkShapeMigrations, props: bookmarkShapeProps },
  draw: { migrations: drawShapeMigrations, props: drawShapeProps },
  embed: { migrations: embedShapeMigrations, props: embedShapeProps },
  frame: { migrations: frameShapeMigrations, props: frameShapeProps },
  geo: { migrations: geoShapeMigrations, props: geoShapeProps },
  group: { migrations: groupShapeMigrations, props: groupShapeProps },
  highlight: { migrations: highlightShapeMigrations, props: highlightShapeProps },
  image: { migrations: imageShapeMigrations, props: imageShapeProps },
  line: { migrations: lineShapeMigrations, props: lineShapeProps },
  note: { migrations: noteShapeMigrations, props: noteShapeProps },
  text: { migrations: textShapeMigrations, props: textShapeProps },
  video: { migrations: videoShapeMigrations, props: videoShapeProps }
};
var defaultBindingSchemas = {
  arrow: { migrations: arrowBindingMigrations, props: arrowBindingProps }
};
function createTLSchema({
  shapes = defaultShapeSchemas,
  bindings = defaultBindingSchemas,
  migrations
} = {}) {
  const stylesById = /* @__PURE__ */ new Map();
  for (const shape of objectMapValues(shapes)) {
    for (const style2 of getShapePropKeysByStyle(shape.props ?? {}).keys()) {
      if (stylesById.has(style2.id) && stylesById.get(style2.id) !== style2) {
        throw new Error(`Multiple StyleProp instances with the same id: ${style2.id}`);
      }
      stylesById.set(style2.id, style2);
    }
  }
  const ShapeRecordType = createShapeRecordType(shapes);
  const BindingRecordType = createBindingRecordType(bindings);
  const InstanceRecordType = createInstanceRecordType(stylesById);
  return StoreSchema.create(
    {
      asset: AssetRecordType,
      binding: BindingRecordType,
      camera: CameraRecordType,
      document: DocumentRecordType,
      instance: InstanceRecordType,
      instance_page_state: InstancePageStateRecordType,
      page: PageRecordType,
      instance_presence: InstancePresenceRecordType,
      pointer: PointerRecordType,
      shape: ShapeRecordType
    },
    {
      migrations: [
        storeMigrations,
        assetMigrations,
        cameraMigrations,
        documentMigrations,
        instanceMigrations,
        instancePageStateMigrations,
        pageMigrations,
        instancePresenceMigrations,
        pointerMigrations,
        rootShapeMigrations,
        bookmarkAssetMigrations,
        imageAssetMigrations,
        videoAssetMigrations,
        ...processPropsMigrations("shape", shapes),
        ...processPropsMigrations("binding", bindings),
        ...migrations ?? []
      ],
      onValidationFailure,
      createIntegrityChecker
    }
  );
}

// node_modules/@tldraw/tlschema/dist-esm/misc/TLHandle.mjs
var TL_HANDLE_TYPES = /* @__PURE__ */ new Set(["vertex", "virtual", "create", "clone"]);

// node_modules/@tldraw/tlschema/dist-esm/translations/languages.mjs
var LANGUAGES = [
  { locale: "id", label: "Bahasa Indonesia" },
  { locale: "ms", label: "Bahasa Melayu" },
  { locale: "ca", label: "Català" },
  { locale: "cs", label: "Čeština" },
  { locale: "da", label: "Danish" },
  { locale: "de", label: "Deutsch" },
  { locale: "en", label: "English" },
  { locale: "es", label: "Español" },
  { locale: "tl", label: "Filipino" },
  { locale: "fr", label: "Français" },
  { locale: "gl", label: "Galego" },
  { locale: "hr", label: "Hrvatski" },
  { locale: "it", label: "Italiano" },
  { locale: "hu", label: "Magyar" },
  { locale: "nl", label: "Nederlands" },
  { locale: "no", label: "Norwegian" },
  { locale: "pl", label: "Polski" },
  { locale: "pt-br", label: "Português - Brasil" },
  { locale: "pt-pt", label: "Português - Europeu" },
  { locale: "ro", label: "Română" },
  { locale: "sl", label: "Slovenščina" },
  { locale: "so", label: "Somali" },
  { locale: "fi", label: "Suomi" },
  { locale: "sv", label: "Svenska" },
  { locale: "vi", label: "Tiếng Việt" },
  { locale: "tr", label: "Türkçe" },
  { locale: "el", label: "Ελληνικά" },
  { locale: "ru", label: "Русский" },
  { locale: "uk", label: "Українська" },
  { locale: "he", label: "עברית" },
  { locale: "ur", label: "اردو" },
  { locale: "ar", label: "عربي" },
  { locale: "fa", label: "فارسی" },
  { locale: "ne", label: "नेपाली" },
  { locale: "mr", label: "मराठी" },
  { locale: "hi-in", label: "हिन्दी" },
  { locale: "bn", label: "বাংলা" },
  { locale: "pa", label: "ਪੰਜਾਬੀ" },
  { locale: "gu-in", label: "ગુજરાતી" },
  { locale: "ta", label: "தமிழ்" },
  { locale: "te", label: "తెలుగు" },
  { locale: "kn", label: "ಕನ್ನಡ" },
  { locale: "ml", label: "മലയാളം" },
  { locale: "th", label: "ภาษาไทย" },
  { locale: "km-kh", label: "ភាសាខ្មែរ" },
  { locale: "ko-kr", label: "한국어" },
  { locale: "ja", label: "日本語" },
  { locale: "zh-cn", label: "简体中文" },
  { locale: "zh-tw", label: "繁體中文 (台灣)" }
];

// node_modules/@tldraw/tlschema/dist-esm/translations/translations.mjs
function getDefaultTranslationLocale() {
  const locales = typeof window !== "undefined" ? window.navigator.languages ?? ["en"] : ["en"];
  return _getDefaultTranslationLocale(locales);
}
function _getDefaultTranslationLocale(locales) {
  for (const locale of locales) {
    const supportedLocale = getSupportedLocale(locale);
    if (supportedLocale) {
      return supportedLocale;
    }
  }
  return "en";
}
var DEFAULT_LOCALE_REGIONS = {
  zh: "zh-cn",
  pt: "pt-br",
  ko: "ko-kr",
  hi: "hi-in"
};
function getSupportedLocale(locale) {
  const exactMatch = LANGUAGES.find((t2) => t2.locale === locale.toLowerCase());
  if (exactMatch) {
    return exactMatch.locale;
  }
  const [language, region] = locale.split(/[-_]/).map((s) => s.toLowerCase());
  if (region) {
    const languageMatch = LANGUAGES.find((t2) => t2.locale === language);
    if (languageMatch) {
      return languageMatch.locale;
    }
  }
  if (language in DEFAULT_LOCALE_REGIONS) {
    return DEFAULT_LOCALE_REGIONS[language];
  }
  return null;
}

// node_modules/@tldraw/tlschema/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "@tldraw/tlschema",
  "3.13.1",
  "esm"
);

// node_modules/@tldraw/editor/dist-esm/lib/TldrawEditor.mjs
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react45 = __toESM(require_react(), 1);
var import_classnames11 = __toESM(require_classnames(), 1);

// node_modules/@tldraw/editor/dist-esm/version.mjs
var version = "3.13.1";
var publishDates = {
  major: "2024-09-13T14:36:29.063Z",
  minor: "2025-05-22T13:38:59.946Z",
  patch: "2025-05-23T15:32:18.274Z"
};

// node_modules/@tldraw/editor/dist-esm/lib/components/ErrorBoundary.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React2 = __toESM(require_react(), 1);
var initialState = { error: null };
var ErrorBoundary = class extends React2.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", initialState);
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  componentDidCatch(error) {
    var _a5, _b;
    (_b = (_a5 = this.props).onError) == null ? void 0 : _b.call(_a5, error);
  }
  render() {
    const { error } = this.state;
    if (error !== null) {
      const { fallback: Fallback } = this.props;
      return (0, import_jsx_runtime.jsx)(Fallback, { error });
    }
    return this.props.children;
  }
};
function OptionalErrorBoundary({
  children,
  fallback,
  ...props
}) {
  if (fallback === null) {
    return children;
  }
  return (0, import_jsx_runtime.jsx)(ErrorBoundary, { fallback, ...props, children });
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultErrorFallback.mjs
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_classnames9 = __toESM(require_classnames(), 1);
var import_react32 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useEditor.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useSafeId.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
function suffixSafeId(id, suffix) {
  return sanitizeId(`${id}_${suffix}`);
}
function useUniqueSafeId(suffix) {
  return sanitizeId(`${(0, import_react8.useId)()}${suffix ?? ""}`);
}
function useSharedSafeId(id) {
  const idScope = assertExists((0, import_react8.useContext)(IdContext));
  return sanitizeId(`${idScope}_${id}`);
}
function sanitizeId(id) {
  return id.replace(/:/g, "_");
}
var IdContext = (0, import_react8.createContext)(null);
function IdProvider({ children }) {
  const id = useUniqueSafeId();
  return (0, import_jsx_runtime2.jsx)(IdContext.Provider, { value: id, children });
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useEditor.mjs
var EditorContext = (0, import_react9.createContext)(null);
function useEditor() {
  const editor = import_react9.default.useContext(EditorContext);
  if (!editor) {
    throw new Error(
      "useEditor must be used inside of the <Tldraw /> or <TldrawEditor /> components"
    );
  }
  return editor;
}
function useMaybeEditor() {
  return import_react9.default.useContext(EditorContext);
}
function EditorProvider({
  editor,
  children
}) {
  return (0, import_jsx_runtime3.jsx)(EditorContext.Provider, { value: editor, children: (0, import_jsx_runtime3.jsx)(IdProvider, { children }) });
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useEditorComponents.mjs
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var import_react31 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultBackground.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function DefaultBackground() {
  return (0, import_jsx_runtime4.jsx)("div", { className: "tl-background" });
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultBrush.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useTransform.mjs
var import_react10 = __toESM(require_react(), 1);
function useTransform(ref, x, y, scale, rotate, additionalOffset) {
  (0, import_react10.useLayoutEffect)(() => {
    const elm = ref.current;
    if (!elm)
      return;
    if (x === void 0)
      return;
    let trans = `translate(${x}px, ${y}px)`;
    if (scale !== void 0) {
      trans += ` scale(${scale})`;
    }
    if (rotate !== void 0) {
      trans += ` rotate(${rotate}rad)`;
    }
    if (additionalOffset) {
      trans += ` translate(${additionalOffset.x}px, ${additionalOffset.y}px)`;
    }
    elm.style.transform = trans;
  });
}

// node_modules/@tldraw/editor/dist-esm/lib/primitives/easings.mjs
var EASINGS = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => t2 * (2 - t2),
  easeInOutQuad: (t2) => t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2,
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => --t2 * t2 * t2 + 1,
  easeInOutCubic: (t2) => t2 < 0.5 ? 4 * t2 * t2 * t2 : (t2 - 1) * (2 * t2 - 2) * (2 * t2 - 2) + 1,
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => 1 - --t2 * t2 * t2 * t2,
  easeInOutQuart: (t2) => t2 < 0.5 ? 8 * t2 * t2 * t2 * t2 : 1 - 8 * --t2 * t2 * t2 * t2,
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => 1 + --t2 * t2 * t2 * t2 * t2,
  easeInOutQuint: (t2) => t2 < 0.5 ? 16 * t2 * t2 * t2 * t2 * t2 : 1 + 16 * --t2 * t2 * t2 * t2 * t2,
  easeInSine: (t2) => 1 - Math.cos(t2 * Math.PI / 2),
  easeOutSine: (t2) => Math.sin(t2 * Math.PI / 2),
  easeInOutSine: (t2) => -(Math.cos(Math.PI * t2) - 1) / 2,
  easeInExpo: (t2) => t2 <= 0 ? 0 : Math.pow(2, 10 * t2 - 10),
  easeOutExpo: (t2) => t2 >= 1 ? 1 : 1 - Math.pow(2, -10 * t2),
  easeInOutExpo: (t2) => t2 <= 0 ? 0 : t2 >= 1 ? 1 : t2 < 0.5 ? Math.pow(2, 20 * t2 - 10) / 2 : (2 - Math.pow(2, -20 * t2 + 10)) / 2
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/Vec.mjs
var Vec = class _Vec {
  constructor(x = 0, y = 0, z = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  // eslint-disable-next-line no-restricted-syntax
  get pressure() {
    return this.z;
  }
  set(x = this.x, y = this.y, z = this.z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setTo({ x = 0, y = 0, z = 1 }) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  rot(r) {
    if (r === 0)
      return this;
    const { x, y } = this;
    const s = Math.sin(r);
    const c = Math.cos(r);
    this.x = x * c - y * s;
    this.y = x * s + y * c;
    return this;
  }
  rotWith(C, r) {
    if (r === 0)
      return this;
    const x = this.x - C.x;
    const y = this.y - C.y;
    const s = Math.sin(r);
    const c = Math.cos(r);
    this.x = C.x + (x * c - y * s);
    this.y = C.y + (x * s + y * c);
    return this;
  }
  clone() {
    const { x, y, z } = this;
    return new _Vec(x, y, z);
  }
  sub(V2) {
    this.x -= V2.x;
    this.y -= V2.y;
    return this;
  }
  subXY(x, y) {
    this.x -= x;
    this.y -= y;
    return this;
  }
  subScalar(n) {
    this.x -= n;
    this.y -= n;
    return this;
  }
  add(V2) {
    this.x += V2.x;
    this.y += V2.y;
    return this;
  }
  addXY(x, y) {
    this.x += x;
    this.y += y;
    return this;
  }
  addScalar(n) {
    this.x += n;
    this.y += n;
    return this;
  }
  clamp(min4, max3) {
    this.x = Math.max(this.x, min4);
    this.y = Math.max(this.y, min4);
    if (max3 !== void 0) {
      this.x = Math.min(this.x, max3);
      this.y = Math.min(this.y, max3);
    }
    return this;
  }
  div(t2) {
    this.x /= t2;
    this.y /= t2;
    return this;
  }
  divV(V2) {
    this.x /= V2.x;
    this.y /= V2.y;
    return this;
  }
  mul(t2) {
    this.x *= t2;
    this.y *= t2;
    return this;
  }
  mulV(V2) {
    this.x *= V2.x;
    this.y *= V2.y;
    return this;
  }
  abs() {
    this.x = Math.abs(this.x);
    this.y = Math.abs(this.y);
    return this;
  }
  nudge(B, distance) {
    const tan = _Vec.Tan(B, this);
    return this.add(tan.mul(distance));
  }
  neg() {
    this.x *= -1;
    this.y *= -1;
    return this;
  }
  cross(V2) {
    this.x = this.y * V2.z - this.z * V2.y;
    this.y = this.z * V2.x - this.x * V2.z;
    return this;
  }
  dpr(V2) {
    return _Vec.Dpr(this, V2);
  }
  cpr(V2) {
    return _Vec.Cpr(this, V2);
  }
  len2() {
    return _Vec.Len2(this);
  }
  len() {
    return _Vec.Len(this);
  }
  pry(V2) {
    return _Vec.Pry(this, V2);
  }
  per() {
    const { x, y } = this;
    this.x = y;
    this.y = -x;
    return this;
  }
  uni() {
    return _Vec.Uni(this);
  }
  tan(V2) {
    return _Vec.Tan(this, V2);
  }
  dist(V2) {
    return _Vec.Dist(this, V2);
  }
  distanceToLineSegment(A, B) {
    return _Vec.DistanceToLineSegment(A, B, this);
  }
  slope(B) {
    return _Vec.Slope(this, B);
  }
  snapToGrid(gridSize) {
    this.x = Math.round(this.x / gridSize) * gridSize;
    this.y = Math.round(this.y / gridSize) * gridSize;
    return this;
  }
  angle(B) {
    return _Vec.Angle(this, B);
  }
  toAngle() {
    return _Vec.ToAngle(this);
  }
  lrp(B, t2) {
    this.x = this.x + (B.x - this.x) * t2;
    this.y = this.y + (B.y - this.y) * t2;
    return this;
  }
  equals(B) {
    return _Vec.Equals(this, B);
  }
  equalsXY(x, y) {
    return _Vec.EqualsXY(this, x, y);
  }
  norm() {
    const l = this.len();
    this.x = l === 0 ? 0 : this.x / l;
    this.y = l === 0 ? 0 : this.y / l;
    return this;
  }
  toFixed() {
    return _Vec.ToFixed(this);
  }
  toString() {
    return _Vec.ToString(_Vec.ToFixed(this));
  }
  toJson() {
    return _Vec.ToJson(this);
  }
  toArray() {
    return _Vec.ToArray(this);
  }
  static Add(A, B) {
    return new _Vec(A.x + B.x, A.y + B.y);
  }
  static AddXY(A, x, y) {
    return new _Vec(A.x + x, A.y + y);
  }
  static Sub(A, B) {
    return new _Vec(A.x - B.x, A.y - B.y);
  }
  static SubXY(A, x, y) {
    return new _Vec(A.x - x, A.y - y);
  }
  static AddScalar(A, n) {
    return new _Vec(A.x + n, A.y + n);
  }
  static SubScalar(A, n) {
    return new _Vec(A.x - n, A.y - n);
  }
  static Div(A, t2) {
    return new _Vec(A.x / t2, A.y / t2);
  }
  static Mul(A, t2) {
    return new _Vec(A.x * t2, A.y * t2);
  }
  static DivV(A, B) {
    return new _Vec(A.x / B.x, A.y / B.y);
  }
  static MulV(A, B) {
    return new _Vec(A.x * B.x, A.y * B.y);
  }
  static Neg(A) {
    return new _Vec(-A.x, -A.y);
  }
  /**
   * Get the perpendicular vector to A.
   */
  static Per(A) {
    return new _Vec(A.y, -A.x);
  }
  static Abs(A) {
    return new _Vec(Math.abs(A.x), Math.abs(A.y));
  }
  // Get the distance between two points.
  static Dist(A, B) {
    return ((A.y - B.y) ** 2 + (A.x - B.x) ** 2) ** 0.5;
  }
  // Get the Manhattan distance between two points.
  static ManhattanDist(A, B) {
    return Math.abs(A.x - B.x) + Math.abs(A.y - B.y);
  }
  // Get whether a distance between two points is less than a number. This is faster to calulate than using `Vec.Dist(a, b) < n`.
  static DistMin(A, B, n) {
    return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y) < n ** 2;
  }
  // Get the squared distance between two points. This is faster to calculate (no square root) so useful for "minimum distance" checks where the actual measurement does not matter.
  static Dist2(A, B) {
    return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y);
  }
  /**
   * Dot product of two vectors which is used to calculate the angle between them.
   */
  static Dpr(A, B) {
    return A.x * B.x + A.y * B.y;
  }
  static Cross(A, V2) {
    return new _Vec(
      A.y * V2.z - A.z * V2.y,
      A.z * V2.x - A.x * V2.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  /**
   * Cross product of two vectors which is used to calculate the area of a parallelogram.
   */
  static Cpr(A, B) {
    return A.x * B.y - B.x * A.y;
  }
  static Len2(A) {
    return A.x * A.x + A.y * A.y;
  }
  static Len(A) {
    return (A.x * A.x + A.y * A.y) ** 0.5;
  }
  /**
   * Get the projection of A onto B.
   */
  static Pry(A, B) {
    return _Vec.Dpr(A, B) / _Vec.Len(B);
  }
  /**
   * Get the unit vector of A.
   */
  static Uni(A) {
    return _Vec.Div(A, _Vec.Len(A));
  }
  static Tan(A, B) {
    return _Vec.Uni(_Vec.Sub(A, B));
  }
  static Min(A, B) {
    return new _Vec(Math.min(A.x, B.x), Math.min(A.y, B.y));
  }
  static Max(A, B) {
    return new _Vec(Math.max(A.x, B.x), Math.max(A.y, B.y));
  }
  static From({ x, y, z = 1 }) {
    return new _Vec(x, y, z);
  }
  static FromArray(v) {
    return new _Vec(v[0], v[1]);
  }
  static Rot(A, r = 0) {
    const s = Math.sin(r);
    const c = Math.cos(r);
    return new _Vec(A.x * c - A.y * s, A.x * s + A.y * c);
  }
  static RotWith(A, C, r) {
    const x = A.x - C.x;
    const y = A.y - C.y;
    const s = Math.sin(r);
    const c = Math.cos(r);
    return new _Vec(C.x + (x * c - y * s), C.y + (x * s + y * c));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(A, u, P) {
    return _Vec.Mul(u, _Vec.Sub(P, A).pry(u)).add(A);
  }
  static NearestPointOnLineSegment(A, B, P, clamp5 = true) {
    if (_Vec.Equals(A, P))
      return _Vec.From(P);
    if (_Vec.Equals(B, P))
      return _Vec.From(P);
    const u = _Vec.Tan(B, A);
    const C = _Vec.Add(A, _Vec.Mul(u, _Vec.Sub(P, A).pry(u)));
    if (clamp5) {
      if (C.x < Math.min(A.x, B.x))
        return _Vec.Cast(A.x < B.x ? A : B);
      if (C.x > Math.max(A.x, B.x))
        return _Vec.Cast(A.x > B.x ? A : B);
      if (C.y < Math.min(A.y, B.y))
        return _Vec.Cast(A.y < B.y ? A : B);
      if (C.y > Math.max(A.y, B.y))
        return _Vec.Cast(A.y > B.y ? A : B);
    }
    return C;
  }
  static DistanceToLineThroughPoint(A, u, P) {
    return _Vec.Dist(P, _Vec.NearestPointOnLineThroughPoint(A, u, P));
  }
  static DistanceToLineSegment(A, B, P, clamp5 = true) {
    return _Vec.Dist(P, _Vec.NearestPointOnLineSegment(A, B, P, clamp5));
  }
  static Snap(A, step = 1) {
    return new _Vec(Math.round(A.x / step) * step, Math.round(A.y / step) * step);
  }
  static Cast(A) {
    if (A instanceof _Vec)
      return A;
    return _Vec.From(A);
  }
  static Slope(A, B) {
    if (A.x === B.y)
      return NaN;
    return (A.y - B.y) / (A.x - B.x);
  }
  static IsNaN(A) {
    return isNaN(A.x) || isNaN(A.y);
  }
  /**
   * Get the angle from position A to position B.
   */
  static Angle(A, B) {
    return Math.atan2(B.y - A.y, B.x - A.x);
  }
  /**
   * Get the angle between vector A and vector B. This will return the smallest angle between the
   * two vectors, between -π and π. The sign indicates direction of angle.
   */
  static AngleBetween(A, B) {
    const p = A.x * B.x + A.y * B.y;
    const n = Math.sqrt(
      (Math.pow(A.x, 2) + Math.pow(A.y, 2)) * (Math.pow(B.x, 2) + Math.pow(B.y, 2))
    );
    const sign = A.x * B.y - A.y * B.x < 0 ? -1 : 1;
    const angle = sign * Math.acos(p / n);
    return angle;
  }
  /**
   * Linearly interpolate between two points.
   * @param A - The first point.
   * @param B - The second point.
   * @param t - The interpolation value between 0 and 1.
   * @returns The interpolated point.
   */
  static Lrp(A, B, t2) {
    return _Vec.Sub(B, A).mul(t2).add(A);
  }
  static Med(A, B) {
    return new _Vec((A.x + B.x) / 2, (A.y + B.y) / 2);
  }
  static Equals(A, B) {
    return Math.abs(A.x - B.x) < 1e-4 && Math.abs(A.y - B.y) < 1e-4;
  }
  static EqualsXY(A, x, y) {
    return A.x === x && A.y === y;
  }
  static Clockwise(A, B, C) {
    return (C.x - A.x) * (B.y - A.y) - (B.x - A.x) * (C.y - A.y) < 0;
  }
  static Rescale(A, n) {
    const l = _Vec.Len(A);
    return new _Vec(n * A.x / l, n * A.y / l);
  }
  static ScaleWithOrigin(A, scale, origin) {
    return _Vec.Sub(A, origin).mul(scale).add(origin);
  }
  static ToFixed(A) {
    return new _Vec(toFixed(A.x), toFixed(A.y));
  }
  static ToInt(A) {
    return new _Vec(
      parseInt(A.x.toFixed(0)),
      parseInt(A.y.toFixed(0)),
      parseInt((A.z ?? 0).toFixed(0))
    );
  }
  static ToCss(A) {
    return `${A.x},${A.y}`;
  }
  static Nudge(A, B, distance) {
    return _Vec.Add(A, _Vec.Tan(B, A).mul(distance));
  }
  static ToString(A) {
    return `${A.x}, ${A.y}`;
  }
  static ToAngle(A) {
    let r = Math.atan2(A.y, A.x);
    if (r < 0)
      r += Math.PI * 2;
    return r;
  }
  static FromAngle(r, length = 1) {
    return new _Vec(Math.cos(r) * length, Math.sin(r) * length);
  }
  static ToArray(A) {
    return [A.x, A.y, A.z];
  }
  static ToJson(A) {
    const { x, y, z } = A;
    return { x, y, z };
  }
  static Average(arr) {
    const len = arr.length;
    const avg = new _Vec(0, 0);
    if (len === 0) {
      return avg;
    }
    for (let i = 0; i < len; i++) {
      avg.add(arr[i]);
    }
    return avg.div(len);
  }
  static Clamp(A, min4, max3) {
    if (max3 === void 0) {
      return new _Vec(Math.min(Math.max(A.x, min4)), Math.min(Math.max(A.y, min4)));
    }
    return new _Vec(Math.min(Math.max(A.x, min4), max3), Math.min(Math.max(A.y, min4), max3));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(A, B, steps = 6) {
    const results = [];
    for (let i = 0; i < steps; i++) {
      const t2 = EASINGS.easeInQuad(i / (steps - 1));
      const point = _Vec.Lrp(A, B, t2);
      point.z = Math.min(1, 0.5 + Math.abs(0.5 - ease(t2)) * 0.65);
      results.push(point);
    }
    return results;
  }
  static SnapToGrid(A, gridSize = 8) {
    return new _Vec(Math.round(A.x / gridSize) * gridSize, Math.round(A.y / gridSize) * gridSize);
  }
};
var ease = (t2) => t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2;

// node_modules/@tldraw/editor/dist-esm/lib/primitives/utils.mjs
function precise(A) {
  return `${toDomPrecision(A.x)},${toDomPrecision(A.y)} `;
}
function average(A, B) {
  return `${toDomPrecision((A.x + B.x) / 2)},${toDomPrecision((A.y + B.y) / 2)} `;
}
var PI = Math.PI;
var HALF_PI = PI / 2;
var PI2 = PI * 2;
var SIN = Math.sin;
function clamp(n, min4, max3) {
  return Math.max(min4, typeof max3 !== "undefined" ? Math.min(n, max3) : n);
}
function toPrecision(n, precision = 1e10) {
  if (!n)
    return 0;
  return Math.round(n * precision) / precision;
}
function approximately(a, b, precision = 1e-6) {
  return Math.abs(a - b) <= precision;
}
function perimeterOfEllipse(rx, ry) {
  const h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
  return PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));
}
function canonicalizeRotation(a) {
  a = a % PI2;
  if (a < 0) {
    a = a + PI2;
  } else if (a === 0) {
    a = 0;
  }
  return a;
}
function clockwiseAngleDist(a0, a1) {
  a0 = canonicalizeRotation(a0);
  a1 = canonicalizeRotation(a1);
  if (a0 > a1) {
    a1 += PI2;
  }
  return a1 - a0;
}
function counterClockwiseAngleDist(a0, a1) {
  return PI2 - clockwiseAngleDist(a0, a1);
}
function shortAngleDist(a0, a1) {
  const da = (a1 - a0) % PI2;
  return 2 * da % PI2 - da;
}
function clampRadians(r) {
  return (PI2 + r) % PI2;
}
function snapAngle(r, segments) {
  const seg = PI2 / segments;
  let ang = Math.floor((clampRadians(r) + seg / 2) / seg) * seg % PI2;
  if (ang < PI)
    ang += PI2;
  if (ang > PI)
    ang -= PI2;
  return ang;
}
function areAnglesCompatible(a, b) {
  return a === b || approximately(a % (Math.PI / 2) - b % (Math.PI / 2), 0);
}
function degreesToRadians(d) {
  return d * PI / 180;
}
function radiansToDegrees(r) {
  return r * 180 / PI;
}
function getPointOnCircle(center, r, a) {
  return new Vec(center.x, center.y).add(Vec.FromAngle(a, r));
}
function getPolygonVertices(width, height, sides2) {
  const cx = width / 2;
  const cy = height / 2;
  const pointsOnPerimeter = [];
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < sides2; i++) {
    const step = PI2 / sides2;
    const t2 = -HALF_PI + i * step;
    const x = cx + cx * Math.cos(t2);
    const y = cy + cy * Math.sin(t2);
    if (x < minX)
      minX = x;
    if (y < minY)
      minY = y;
    if (x > maxX)
      maxX = x;
    if (y > maxY)
      maxY = y;
    pointsOnPerimeter.push(new Vec(x, y));
  }
  const w = maxX - minX;
  const h = maxY - minY;
  const dx = width - w;
  const dy = height - h;
  if (dx !== 0 || dy !== 0) {
    for (let i = 0; i < pointsOnPerimeter.length; i++) {
      const pt = pointsOnPerimeter[i];
      pt.x = (pt.x - minX) / w * width;
      pt.y = (pt.y - minY) / h * height;
    }
  }
  return pointsOnPerimeter;
}
function rangesOverlap(a0, a1, b0, b1) {
  return a0 < b1 && b0 < a1;
}
function rangeIntersection(a0, a1, b0, b1) {
  const min4 = Math.max(a0, b0);
  const max3 = Math.min(a1, b1);
  if (min4 <= max3) {
    return [min4, max3];
  }
  return null;
}
function cross(x, y, z) {
  return (y.x - x.x) * (z.y - x.y) - (z.x - x.x) * (y.y - x.y);
}
function pointInPolygon(A, points) {
  let windingNumber = 0;
  let a;
  let b;
  for (let i = 0; i < points.length; i++) {
    a = points[i];
    if (a.x === A.x && a.y === A.y)
      return true;
    b = points[(i + 1) % points.length];
    if (Vec.Dist(A, a) + Vec.Dist(A, b) === Vec.Dist(a, b))
      return true;
    if (a.y <= A.y) {
      if (b.y > A.y && cross(a, b, A) > 0) {
        windingNumber += 1;
      }
    } else if (b.y <= A.y && cross(a, b, A) < 0) {
      windingNumber -= 1;
    }
  }
  return windingNumber !== 0;
}
function toDomPrecision(v) {
  return Math.round(v * 1e4) / 1e4;
}
function toFixed(v) {
  return Math.round(v * 100) / 100;
}
var isSafeFloat = (n) => {
  return Math.abs(n) < Number.MAX_SAFE_INTEGER;
};
function angleDistance(fromAngle, toAngle, direction) {
  const dist = direction < 0 ? clockwiseAngleDist(fromAngle, toAngle) : counterClockwiseAngleDist(fromAngle, toAngle);
  return dist;
}
function getPointInArcT(mAB, A, B, P) {
  let mAP;
  if (Math.abs(mAB) > PI) {
    mAP = shortAngleDist(A, P);
    const mPB = shortAngleDist(P, B);
    if (Math.abs(mAP) < Math.abs(mPB)) {
      return mAP / mAB;
    } else {
      return (mAB - mPB) / mAB;
    }
  } else {
    mAP = shortAngleDist(A, P);
    const t2 = mAP / mAB;
    if (Math.sign(mAP) !== Math.sign(mAB)) {
      return Math.abs(t2) > 0.5 ? 1 : 0;
    }
    return t2;
  }
}
function getArcMeasure(A, B, sweepFlag, largeArcFlag) {
  const m = 2 * ((B - A) % PI2) % PI2 - (B - A) % PI2;
  if (!largeArcFlag)
    return m;
  return (PI2 - Math.abs(m)) * (sweepFlag ? 1 : -1);
}
function centerOfCircleFromThreePoints(a, b, c) {
  const u = -2 * (a.x * (b.y - c.y) - a.y * (b.x - c.x) + b.x * c.y - c.x * b.y);
  const x = ((a.x * a.x + a.y * a.y) * (c.y - b.y) + (b.x * b.x + b.y * b.y) * (a.y - c.y) + (c.x * c.x + c.y * c.y) * (b.y - a.y)) / u;
  const y = ((a.x * a.x + a.y * a.y) * (b.x - c.x) + (b.x * b.x + b.y * b.y) * (c.x - a.x) + (c.x * c.x + c.y * c.y) * (a.x - b.x)) / u;
  if (!Number.isFinite(x) || !Number.isFinite(y)) {
    return null;
  }
  return new Vec(x, y);
}
function getPointsOnArc(startPoint, endPoint, center, radius, numPoints) {
  if (center === null) {
    return [Vec.From(startPoint), Vec.From(endPoint)];
  }
  const results = [];
  const startAngle = Vec.Angle(center, startPoint);
  const endAngle = Vec.Angle(center, endPoint);
  const l = clockwiseAngleDist(startAngle, endAngle);
  for (let i = 0; i < numPoints; i++) {
    const t2 = i / (numPoints - 1);
    const angle = startAngle + l * t2;
    const point = getPointOnCircle(center, radius, angle);
    results.push(point);
  }
  return results;
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultBrush.mjs
var DefaultBrush = ({ brush, color, opacity, className }) => {
  const rSvg = (0, import_react11.useRef)(null);
  useTransform(rSvg, brush.x, brush.y);
  const w = toDomPrecision(Math.max(1, brush.w));
  const h = toDomPrecision(Math.max(1, brush.h));
  return (0, import_jsx_runtime5.jsx)("svg", { className: "tl-overlays__item", ref: rSvg, children: color ? (0, import_jsx_runtime5.jsxs)("g", { className: "tl-brush", opacity, children: [
    (0, import_jsx_runtime5.jsx)("rect", { width: w, height: h, fill: color, opacity: 0.75 }),
    (0, import_jsx_runtime5.jsx)("rect", { width: w, height: h, fill: "none", stroke: color, opacity: 0.1 })
  ] }) : (0, import_jsx_runtime5.jsx)("rect", { className: `tl-brush tl-brush__default ${className}`, width: w, height: h }) });
};

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultCanvas.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_classnames = __toESM(require_classnames(), 1);
var import_react24 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/globals/environment.mjs
var tlenv = {
  isSafari: false,
  isIos: false,
  isChromeForIos: false,
  isFirefox: false,
  isAndroid: false,
  isWebview: false,
  isDarwin: false,
  hasCanvasSupport: false
};
if (typeof window !== "undefined" && "navigator" in window) {
  tlenv.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  tlenv.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i);
  tlenv.isChromeForIos = /crios.*safari/i.test(navigator.userAgent);
  tlenv.isFirefox = /firefox/i.test(navigator.userAgent);
  tlenv.isAndroid = /android/i.test(navigator.userAgent);
  tlenv.isDarwin = window.navigator.userAgent.toLowerCase().indexOf("mac") > -1;
  tlenv.hasCanvasSupport = typeof window !== "undefined" && "Promise" in window && "HTMLCanvasElement" in window;
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useCanvasEvents.mjs
var import_react12 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/constants.mjs
var DEFAULT_CAMERA_OPTIONS = {
  isLocked: false,
  wheelBehavior: "pan",
  panSpeed: 1,
  zoomSpeed: 1,
  zoomSteps: [0.05, 0.1, 0.25, 0.5, 1, 2, 4, 8]
};
var DEFAULT_ANIMATION_OPTIONS = {
  duration: 0,
  easing: EASINGS.easeInOutCubic
};
var INTERNAL_POINTER_IDS = {
  CAMERA_MOVE: -10
};
var SIDES = ["top", "right", "bottom", "left"];
var LEFT_MOUSE_BUTTON = 0;
var RIGHT_MOUSE_BUTTON = 2;
var MIDDLE_MOUSE_BUTTON = 1;
var STYLUS_ERASER_BUTTON = 5;
var ZOOM_TO_FIT_PADDING = 128;

// node_modules/@tldraw/editor/dist-esm/lib/utils/debug-flags.mjs
var featureFlags = {};
var pointerCaptureTrackingObject = createDebugValue(
  "pointerCaptureTrackingObject",
  // ideally we wouldn't store this mutable value in an atom but it's not
  // a big deal for debug values
  {
    defaults: { all: /* @__PURE__ */ new Map() },
    shouldStoreForSession: false
  }
);
var debugFlags = {
  // --- DEBUG VALUES ---
  logPreventDefaults: createDebugValue("logPreventDefaults", {
    defaults: { all: false }
  }),
  logPointerCaptures: createDebugValue("logPointerCaptures", {
    defaults: { all: false }
  }),
  logElementRemoves: createDebugValue("logElementRemoves", {
    defaults: { all: false }
  }),
  debugSvg: createDebugValue("debugSvg", {
    defaults: { all: false }
  }),
  showFps: createDebugValue("showFps", {
    defaults: { all: false }
  }),
  measurePerformance: createDebugValue("measurePerformance", { defaults: { all: false } }),
  throwToBlob: createDebugValue("throwToBlob", {
    defaults: { all: false }
  }),
  reconnectOnPing: createDebugValue("reconnectOnPing", {
    defaults: { all: false }
  }),
  debugCursors: createDebugValue("debugCursors", {
    defaults: { all: false }
  }),
  forceSrgb: createDebugValue("forceSrgbColors", { defaults: { all: false } }),
  debugGeometry: createDebugValue("debugGeometry", { defaults: { all: false } }),
  hideShapes: createDebugValue("hideShapes", { defaults: { all: false } }),
  editOnType: createDebugValue("editOnType", { defaults: { all: false } }),
  a11y: createDebugValue("a11y", { defaults: { all: false } }),
  debugElbowArrows: createDebugValue("debugElbowArrows", { defaults: { all: false } })
};
if (typeof Element !== "undefined") {
  const nativeElementRemoveChild = Element.prototype.removeChild;
  react("element removal logging", () => {
    if (debugFlags.logElementRemoves.get()) {
      Element.prototype.removeChild = function(child) {
        console.warn("[tldraw] removing child:", child);
        return nativeElementRemoveChild.call(this, child);
      };
    } else {
      Element.prototype.removeChild = nativeElementRemoveChild;
    }
  });
}
function createDebugValue(name, {
  defaults: defaults2,
  shouldStoreForSession = true
}) {
  return createDebugValueBase({
    name,
    defaults: defaults2,
    shouldStoreForSession
  });
}
function createDebugValueBase(def) {
  const defaultValue = getDefaultValue(def);
  const storedValue = def.shouldStoreForSession ? getStoredInitialValue(def.name) : null;
  const valueAtom = atom(`debug:${def.name}`, storedValue ?? defaultValue);
  if (typeof window !== "undefined") {
    if (def.shouldStoreForSession) {
      react(`debug:${def.name}`, () => {
        const currentValue = valueAtom.get();
        if (currentValue === defaultValue) {
          deleteFromSessionStorage(`tldraw_debug:${def.name}`);
        } else {
          setInSessionStorage(`tldraw_debug:${def.name}`, JSON.stringify(currentValue));
        }
      });
    }
    Object.defineProperty(window, `tldraw${def.name.replace(/^[a-z]/, (l) => l.toUpperCase())}`, {
      get() {
        return valueAtom.get();
      },
      set(newValue) {
        valueAtom.set(newValue);
      },
      configurable: true
    });
  }
  return Object.assign(valueAtom, def, {
    reset: () => valueAtom.set(defaultValue)
  });
}
function getStoredInitialValue(name) {
  try {
    return JSON.parse(getFromSessionStorage(`tldraw_debug:${name}`) ?? "null");
  } catch {
    return null;
  }
}
function readEnv(fn2) {
  try {
    return fn2();
  } catch {
    return null;
  }
}
function getDefaultValue(def) {
  const env2 = readEnv(() => process.env.TLDRAW_ENV) ?? readEnv(() => process.env.VERCEL_PUBLIC_TLDRAW_ENV) ?? readEnv(() => process.env.NEXT_PUBLIC_TLDRAW_ENV) ?? // default to production because if we don't have one of these, this is probably a library use
  "production";
  switch (env2) {
    case "production":
      return def.defaults.production ?? def.defaults.all;
    case "preview":
    case "staging":
      return def.defaults.staging ?? def.defaults.all;
    default:
      return def.defaults.development ?? def.defaults.all;
  }
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/dom.mjs
function loopToHtmlElement(elm) {
  if (elm instanceof HTMLElement)
    return elm;
  if (elm.parentElement)
    return loopToHtmlElement(elm.parentElement);
  else
    throw Error("Could not find a parent element of an HTML type!");
}
function preventDefault(event) {
  event.preventDefault();
  if (debugFlags.logPreventDefaults.get()) {
    console.warn("preventDefault called on event:", event);
  }
}
function setPointerCapture(element, event) {
  element.setPointerCapture(event.pointerId);
  if (debugFlags.logPointerCaptures.get()) {
    const trackingObj = pointerCaptureTrackingObject.get();
    trackingObj.set(element, (trackingObj.get(element) ?? 0) + 1);
    console.warn("setPointerCapture called on element:", element, event);
  }
}
function releasePointerCapture(element, event) {
  if (!element.hasPointerCapture(event.pointerId)) {
    return;
  }
  element.releasePointerCapture(event.pointerId);
  if (debugFlags.logPointerCaptures.get()) {
    const trackingObj = pointerCaptureTrackingObject.get();
    if (trackingObj.get(element) === 1) {
      trackingObj.delete(element);
    } else if (trackingObj.has(element)) {
      trackingObj.set(element, trackingObj.get(element) - 1);
    } else {
      console.warn("Release without capture");
    }
    console.warn("releasePointerCapture called on element:", element, event);
  }
}
var stopEventPropagation = (e) => e.stopPropagation();
var setStyleProperty = (elm, property, value) => {
  if (!elm)
    return;
  elm.style.setProperty(property, value);
};
function activeElementShouldCaptureKeys(allowButtons = false) {
  const { activeElement } = document;
  const elements = allowButtons ? ["input", "textarea"] : ["input", "select", "button", "textarea"];
  return !!(activeElement && (activeElement.isContentEditable || elements.indexOf(activeElement.tagName.toLowerCase()) > -1 || activeElement.classList.contains("tlui-slider__thumb")));
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/keyboard.mjs
var isAccelKey = (e) => {
  return tlenv.isDarwin ? e.metaKey : e.ctrlKey || e.metaKey;
};

// node_modules/@tldraw/editor/dist-esm/lib/utils/getPointerInfo.mjs
function getPointerInfo(e) {
  ;
  e.isKilled = true;
  return {
    point: {
      x: e.clientX,
      y: e.clientY,
      z: e.pressure
    },
    shiftKey: e.shiftKey,
    altKey: e.altKey,
    ctrlKey: e.metaKey || e.ctrlKey,
    metaKey: e.metaKey,
    accelKey: isAccelKey(e),
    pointerId: e.pointerId,
    button: e.button,
    isPen: e.pointerType === "pen"
  };
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useCanvasEvents.mjs
function useCanvasEvents() {
  const editor = useEditor();
  const currentTool = useValue("current tool", () => editor.getCurrentTool(), [editor]);
  const events = (0, import_react12.useMemo)(
    function canvasEvents() {
      let lastX, lastY;
      function onPointerDown(e) {
        if (e.isKilled)
          return;
        if (e.button === RIGHT_MOUSE_BUTTON) {
          editor.dispatch({
            type: "pointer",
            target: "canvas",
            name: "right_click",
            ...getPointerInfo(e)
          });
          return;
        }
        if (e.button !== 0 && e.button !== 1 && e.button !== 5)
          return;
        setPointerCapture(e.currentTarget, e);
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_down",
          ...getPointerInfo(e)
        });
      }
      function onPointerMove(e) {
        if (e.isKilled)
          return;
        if (e.clientX === lastX && e.clientY === lastY)
          return;
        lastX = e.clientX;
        lastY = e.clientY;
        const events2 = currentTool.useCoalescedEvents && e.nativeEvent.getCoalescedEvents ? e.nativeEvent.getCoalescedEvents() : [e];
        for (const singleEvent of events2) {
          editor.dispatch({
            type: "pointer",
            target: "canvas",
            name: "pointer_move",
            ...getPointerInfo(singleEvent)
          });
        }
      }
      function onPointerUp(e) {
        if (e.isKilled)
          return;
        if (e.button !== 0 && e.button !== 1 && e.button !== 2 && e.button !== 5)
          return;
        lastX = e.clientX;
        lastY = e.clientY;
        releasePointerCapture(e.currentTarget, e);
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_up",
          ...getPointerInfo(e)
        });
      }
      function onPointerEnter(e) {
        if (e.isKilled)
          return;
        if (editor.getInstanceState().isPenMode && e.pointerType !== "pen")
          return;
        const canHover = e.pointerType === "mouse" || e.pointerType === "pen";
        editor.updateInstanceState({ isHoveringCanvas: canHover ? true : null });
      }
      function onPointerLeave(e) {
        if (e.isKilled)
          return;
        if (editor.getInstanceState().isPenMode && e.pointerType !== "pen")
          return;
        const canHover = e.pointerType === "mouse" || e.pointerType === "pen";
        editor.updateInstanceState({ isHoveringCanvas: canHover ? false : null });
      }
      function onTouchStart(e) {
        ;
        e.isKilled = true;
        preventDefault(e);
      }
      function onTouchEnd(e) {
        ;
        e.isKilled = true;
        if (!(e.target instanceof HTMLElement))
          return;
        if (e.target.tagName !== "A" && e.target.tagName !== "TEXTAREA" && !e.target.isContentEditable && // When in EditingShape state, we are actually clicking on a 'DIV'
        // not A/TEXTAREA/contenteditable element yet. So, to preserve cursor position
        // for edit mode on mobile we need to not preventDefault.
        // TODO: Find out if we still need this preventDefault in general though.
        !(editor.getEditingShape() && e.target.className.includes("tl-text-content"))) {
          preventDefault(e);
        }
      }
      function onDragOver(e) {
        preventDefault(e);
      }
      async function onDrop(e) {
        var _a5, _b;
        preventDefault(e);
        stopEventPropagation(e);
        if ((_b = (_a5 = e.dataTransfer) == null ? void 0 : _a5.files) == null ? void 0 : _b.length) {
          const files = Array.from(e.dataTransfer.files);
          await editor.putExternalContent({
            type: "files",
            files,
            point: editor.screenToPage({ x: e.clientX, y: e.clientY }),
            ignoreParent: false
          });
          return;
        }
        const url = e.dataTransfer.getData("url");
        if (url) {
          await editor.putExternalContent({
            type: "url",
            url,
            point: editor.screenToPage({ x: e.clientX, y: e.clientY })
          });
          return;
        }
      }
      function onClick(e) {
        stopEventPropagation(e);
      }
      return {
        onPointerDown,
        onPointerMove,
        onPointerUp,
        onPointerEnter,
        onPointerLeave,
        onDragOver,
        onDrop,
        onTouchStart,
        onTouchEnd,
        onClick
      };
    },
    [editor, currentTool]
  );
  return events;
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useCoarsePointer.mjs
var import_react13 = __toESM(require_react(), 1);
function useCoarsePointer() {
  const editor = useEditor();
  (0, import_react13.useEffect)(() => {
    let isCoarse = editor.getInstanceState().isCoarsePointer;
    const handlePointerDown = (e) => {
      const isCoarseEvent = e.pointerType !== "mouse";
      if (isCoarse === isCoarseEvent)
        return;
      isCoarse = isCoarseEvent;
      editor.updateInstanceState({ isCoarsePointer: isCoarseEvent });
    };
    window.addEventListener("pointerdown", handlePointerDown, { capture: true });
    const mql = window.matchMedia && window.matchMedia("(any-pointer: coarse)");
    const isForcedFinePointer = tlenv.isFirefox && !tlenv.isAndroid && !tlenv.isIos;
    const handleMediaQueryChange = () => {
      const next = isForcedFinePointer ? false : mql.matches;
      if (isCoarse !== next)
        return;
      isCoarse = next;
      editor.updateInstanceState({ isCoarsePointer: next });
    };
    if (mql) {
      mql.addEventListener("change", handleMediaQueryChange);
      handleMediaQueryChange();
    }
    return () => {
      window.removeEventListener("pointerdown", handlePointerDown, { capture: true });
      if (mql) {
        mql.removeEventListener("change", handleMediaQueryChange);
      }
    };
  }, [editor]);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useContainer.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
var ContainerContext = (0, import_react14.createContext)(null);
function ContainerProvider({ container, children }) {
  return (0, import_jsx_runtime6.jsx)(ContainerContext.Provider, { value: container, children });
}
function useContainer() {
  return assertExists((0, import_react14.useContext)(ContainerContext), "useContainer used outside of <Tldraw />");
}
function useContainerIfExists() {
  return (0, import_react14.useContext)(ContainerContext);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useDocumentEvents.mjs
var import_react15 = __toESM(require_react(), 1);
function useDocumentEvents() {
  const editor = useEditor();
  const container = useContainer();
  const isEditing = useValue("isEditing", () => editor.getEditingShapeId(), [editor]);
  const isAppFocused = useValue("isFocused", () => editor.getIsFocused(), [editor]);
  (0, import_react15.useEffect)(() => {
    if (!container)
      return;
    function onDrop(e) {
      if (e.isSpecialRedispatchedEvent)
        return;
      preventDefault(e);
      stopEventPropagation(e);
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs)
        return;
      const newEvent = new DragEvent(e.type, e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    container.addEventListener("dragover", onDrop);
    container.addEventListener("drop", onDrop);
    return () => {
      container.removeEventListener("dragover", onDrop);
      container.removeEventListener("drop", onDrop);
    };
  }, [container]);
  (0, import_react15.useEffect)(() => {
    if (typeof window === "undefined" || !("matchMedia" in window))
      return;
    let remove2 = null;
    const updatePixelRatio = () => {
      if (remove2 != null) {
        remove2();
      }
      const mqString = `(resolution: ${window.devicePixelRatio}dppx)`;
      const media = matchMedia(mqString);
      const safariCb = (ev) => {
        if (ev.type === "change") {
          updatePixelRatio();
        }
      };
      if (media.addEventListener) {
        media.addEventListener("change", updatePixelRatio);
      } else if (media.addListener) {
        media.addListener(safariCb);
      }
      remove2 = () => {
        if (media.removeEventListener) {
          media.removeEventListener("change", updatePixelRatio);
        } else if (media.removeListener) {
          media.removeListener(safariCb);
        }
      };
      editor.updateInstanceState({ devicePixelRatio: window.devicePixelRatio });
    };
    updatePixelRatio();
    return () => {
      remove2 == null ? void 0 : remove2();
    };
  }, [editor]);
  (0, import_react15.useEffect)(() => {
    if (!isAppFocused)
      return;
    const handleKeyDown2 = (e) => {
      if (e.altKey && // todo: When should we allow the alt key to be used? Perhaps states should declare which keys matter to them?
      (editor.isIn("zoom") || !editor.getPath().endsWith(".idle")) && !areShortcutsDisabled(editor)) {
        preventDefault(e);
      }
      if (e.isKilled)
        return;
      e.isKilled = true;
      const hasSelectedShapes = !!editor.getSelectedShapeIds().length;
      switch (e.key) {
        case "=":
        case "-":
        case "0": {
          if (e.metaKey || e.ctrlKey) {
            preventDefault(e);
            return;
          }
          break;
        }
        case "Tab": {
          if (areShortcutsDisabled(editor)) {
            return;
          }
          if (hasSelectedShapes && !isEditing) {
            preventDefault(e);
          }
          break;
        }
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "ArrowDown": {
          if (areShortcutsDisabled(editor)) {
            return;
          }
          if (hasSelectedShapes && (e.metaKey || e.ctrlKey)) {
            preventDefault(e);
          }
          break;
        }
        case ",": {
          return;
        }
        case "Escape": {
          if (editor.getEditingShape() || editor.getSelectedShapeIds().length > 0) {
            preventDefault(e);
          }
          if (editor.menus.getOpenMenus().length > 0)
            return;
          if (editor.inputs.keys.has("Escape")) {
          } else {
            editor.inputs.keys.add("Escape");
            editor.cancel();
            container.focus();
          }
          return;
        }
        default: {
          if (areShortcutsDisabled(editor)) {
            return;
          }
        }
      }
      const info = {
        type: "keyboard",
        name: e.repeat ? "key_repeat" : "key_down",
        key: e.key,
        code: e.code,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      };
      editor.dispatch(info);
    };
    const handleKeyUp = (e) => {
      if (e.isKilled)
        return;
      e.isKilled = true;
      if (areShortcutsDisabled(editor)) {
        return;
      }
      if (e.key === ",") {
        return;
      }
      const info = {
        type: "keyboard",
        name: "key_up",
        key: e.key,
        code: e.code,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      };
      editor.dispatch(info);
    };
    function handleTouchStart(e) {
      var _a5, _b;
      if (container.contains(e.target)) {
        const touchXPosition = e.touches[0].pageX;
        const touchXRadius = e.touches[0].radiusX || 0;
        if (touchXPosition - touchXRadius < 10 || touchXPosition + touchXRadius > editor.getViewportScreenBounds().width - 10) {
          if (((_a5 = e.target) == null ? void 0 : _a5.tagName) === "BUTTON") {
            ;
            (_b = e.target) == null ? void 0 : _b.click();
          }
          preventDefault(e);
        }
      }
    }
    const handleWheel = (e) => {
      if (container.contains(e.target) && (e.ctrlKey || e.metaKey)) {
        preventDefault(e);
      }
    };
    container.addEventListener("touchstart", handleTouchStart, { passive: false });
    container.addEventListener("wheel", handleWheel, { passive: false });
    document.addEventListener("gesturestart", preventDefault);
    document.addEventListener("gesturechange", preventDefault);
    document.addEventListener("gestureend", preventDefault);
    container.addEventListener("keydown", handleKeyDown2);
    container.addEventListener("keyup", handleKeyUp);
    return () => {
      container.removeEventListener("touchstart", handleTouchStart);
      container.removeEventListener("wheel", handleWheel);
      document.removeEventListener("gesturestart", preventDefault);
      document.removeEventListener("gesturechange", preventDefault);
      document.removeEventListener("gestureend", preventDefault);
      container.removeEventListener("keydown", handleKeyDown2);
      container.removeEventListener("keyup", handleKeyUp);
    };
  }, [editor, container, isAppFocused, isEditing]);
}
function areShortcutsDisabled(editor) {
  return editor.menus.hasOpenMenus() || activeElementShouldCaptureKeys();
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useFixSafariDoubleTapZoomPencilEvents.mjs
var import_react16 = __toESM(require_react(), 1);
var IGNORED_TAGS = ["textarea", "input"];
function useFixSafariDoubleTapZoomPencilEvents(ref) {
  const editor = useEditor();
  (0, import_react16.useEffect)(() => {
    const elm = ref.current;
    if (!elm)
      return;
    const handleEvent = (e) => {
      var _a5;
      if (e instanceof PointerEvent && e.pointerType === "pen") {
        ;
        e.isKilled = true;
        const { target } = e;
        if (IGNORED_TAGS.includes((_a5 = target.tagName) == null ? void 0 : _a5.toLocaleLowerCase()) || target.isContentEditable || editor.isIn("select.editing_shape")) {
          return;
        }
        preventDefault(e);
      }
    };
    elm.addEventListener("touchstart", handleEvent);
    elm.addEventListener("touchend", handleEvent);
    return () => {
      elm.removeEventListener("touchstart", handleEvent);
      elm.removeEventListener("touchend", handleEvent);
    };
  }, [editor, ref]);
}

// node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js
function clamp2(v, min4, max3) {
  return Math.max(min4, Math.min(v, max3));
}
var V = {
  toVector(v, fallback) {
    if (v === void 0)
      v = fallback;
    return Array.isArray(v) ? v : [v, v];
  },
  add(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
  },
  sub(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
  },
  addTo(v1, v2) {
    v1[0] += v2[0];
    v1[1] += v2[1];
  },
  subTo(v1, v2) {
    v1[0] -= v2[0];
    v1[1] -= v2[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity)
    return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min4, max3, constant = 0.15) {
  if (constant === 0)
    return clamp2(position, min4, max3);
  if (position < min4)
    return -rubberband(min4 - position, max3 - min4, constant) + min4;
  if (position > max3)
    return +rubberband(position - max3, max3 - min4, constant) + max3;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}

// node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t2), true).forEach(function(r2) {
      _defineProperty(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
var EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string2) {
  if (!string2)
    return "";
  return string2[0].toUpperCase() + string2.slice(1);
}
var actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive2 = !!~eventKey.indexOf("passive");
  if (passive2)
    eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture)
    eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive: passive2
  };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event))
    return "touch";
  if ("pointerType" in event)
    return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e) => {
    var _event$currentTarget, _event$currentTarget$;
    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));
  });
}
function distanceAngle(P1, P2) {
  try {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return {
      angle,
      distance,
      origin
    };
  } catch (_unused) {
  }
  return null;
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event)
    payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey: altKey2,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey: altKey2,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call(v, ...args) {
  if (typeof v === "function") {
    return v(...args);
  } else {
    return v;
  }
}
function noop2() {
}
function chain(...fns) {
  if (fns.length === 0)
    return noop2;
  if (fns.length === 1)
    return fns[0];
  return function() {
    let result;
    for (const fn2 of fns) {
      result = fn2.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init)
        this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = state.timeDelta = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
      state.startTime = state.timeStamp = event.timeStamp;
    }
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable)
        state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent)
      this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional)
      return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked)
      this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config)
            state._bounds = call(config.bounds, state);
          if (this.setup)
            this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt > 0) {
        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        state.timeDelta = dt;
      }
    }
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config = this.config;
    if (!state._active)
      this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents)
      return;
    const memo35 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo35 !== void 0)
      state.memo = memo35;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};
function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
var CoordinatesEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config = this.config;
    if (!state.axis && event) {
      const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
  }
  restrictToAxis(v) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v[1] = 0;
          break;
        case "y":
          v[0] = 0;
          break;
      }
    }
  }
};
var identity = (v) => v;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config) {
    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function")
      return value;
    if (value != null)
      return V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    if (true) {
      const originalTransform = transform || identity;
      return (v) => {
        const r = originalTransform(v);
        if (!isFinite(r[0]) || !isFinite(r[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);
        }
        return r;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (true) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
      return NaN;
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}
var DEFAULT_AXIS_THRESHOLD = 0;
var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection)
      return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left: left2 = -Infinity,
      right: right2 = Infinity,
      top: top2 = -Infinity,
      bottom: bottom2 = Infinity
    } = value;
    return [[left2, right2], [top2, bottom2]];
  }
});
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: supportsTouchEvents(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var DEFAULT_KEYBOARD_DISPLACEMENT = 10;
var DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device(_v, _k, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch)
      return "touch";
    if (this.pointerLock)
      return "mouse";
    if (SUPPORT.pointer && !mouse)
      return "pointer";
    if (SUPPORT.touch)
      return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false)
      return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1,
      keys: keys2 = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys2;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value)
      return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  },
  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
    return value;
  }
});
if (true) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
      return NaN;
    }
  });
}
function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 100;
var PinchEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset: offset5,
      lastOffset
    } = this.state;
    this.state.movement = [offset5[0] / lastOffset[0], offset5[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0)
        state.axis = "angle";
      else if (axisMovementDifference > 0)
        state.axis = "scale";
    }
  }
  restrictToAxis(v) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale")
        v[1] = 0;
      else if (this.state.axis === "angle")
        v[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id)))
        return;
    }
    if (ctrlTouchIds.size < 2)
      return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    if (!payload)
      return;
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1)
      return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id)))
        return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2)
      return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload)
      return;
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active)
      return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    if (!payload)
      return;
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active)
      return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload)
      return;
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270)
      delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active)
      return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active)
      return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    if (state._active)
      return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable)
      event.preventDefault();
    if (!this.state._active)
      return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && (Array.isArray(modifierKey) ? !modifierKey.find((k) => event[k]) : !event[modifierKey]))
      return;
    if (!this.state._active)
      this.wheelStart(event);
    else
      this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (!event.defaultPrevented) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
      bindFunction("lostPointerCapture", "", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
};
var pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device(_v, _k, {
    shared,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)
      return "gesture";
    if (SUPPORT.touch && touch)
      return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer)
        return "pointer";
      if (SUPPORT.touch)
        return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };
    const _angleBounds = (state) => {
      const A = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function")
      return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0)
      return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});
var moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var WheelEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active)
      this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};
var wheelConfigResolver = coordinatesConfigResolver;
var hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var EngineMap = /* @__PURE__ */ new Map();
var ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
var import_react17 = __toESM(require_react());

// node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive: passive2 = true,
    capture = false
  } = {}) {
    return {
      passive: passive2,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        if (true) {
          const r = resolver.call(result, config[key], key, config);
          if (!Number.isNaN(r))
            result[key] = r;
        } else {
          result[key] = resolver.call(result, config[key], key, config);
        }
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver)
          result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig, {
    target,
    eventOptions,
    window: window3,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  _config.shared = resolveWith({
    target,
    eventOptions,
    window: window3,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (true) {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}
var EventStore = class {
  constructor(ctrl, gestureKey) {
    _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options2) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options2);
    element.addEventListener(type, handler, eventOptions);
    const remove2 = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove2);
    };
    listeners.add(remove2);
    return remove2;
  }
  clean() {
    this._listeners.forEach((remove2) => remove2());
    this._listeners.clear();
  }
};
var TimeoutStore = class {
  constructor() {
    _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout)
      window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
};
var Controller = class {
  constructor(handlers2) {
    _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers2);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel")
        this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown")
        this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers2, nativeHandlers) {
    this.handlers = handlers2;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse(config, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target)
      this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target)
        return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
          event,
          args
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target)
      return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive: passive2
      } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], {
        capture,
        passive: passive2
      });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag)
    setupGesture(ctrl, "drag");
  if (internalHandlers.wheel)
    setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll)
    setupGesture(ctrl, "scroll");
  if (internalHandlers.move)
    setupGesture(ctrl, "move");
  if (internalHandlers.pinch)
    setupGesture(ctrl, "pinch");
  if (internalHandlers.hover)
    setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options2 = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options2.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive2 = (_options$passive = options2.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive2)
    handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers2) {
  const native = {};
  const handlers2 = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers2) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers2[key] = _handlers2[key];
    } else {
      native[key] = _handlers2[key];
    }
  }
  return [handlers2, native, actions];
}
function registerGesture(actions, handlers2, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey))
    return;
  if (!EngineMap.has(key)) {
    if (true) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey2 = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn2 = (state) => {
    let memo35 = void 0;
    if (state.first && startKey2 in handlers2)
      handlers2[startKey2](state);
    if (handlerKey in handlers2)
      memo35 = handlers2[handlerKey](state);
    if (state.last && endKey in handlers2)
      handlers2[endKey](state);
    return memo35;
  };
  internalHandlers[key] = fn2;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers2, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers2, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
function useRecognizers(handlers2, config = {}, gestureKey, nativeHandlers) {
  const ctrl = import_react17.default.useMemo(() => new Controller(handlers2), []);
  ctrl.applyHandlers(handlers2, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  import_react17.default.useEffect(ctrl.effect.bind(ctrl));
  import_react17.default.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers2, _config) {
    const {
      handlers: handlers2,
      nativeHandlers,
      config
    } = parseMergedHandlers(_handlers2, _config || {});
    return useRecognizers(handlers2, config, void 0, nativeHandlers);
  };
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useGestureEvents.mjs
var React5 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/utils/normalizeWheel.mjs
var MAX_ZOOM_STEP = 10;
var IS_DARWIN = /Mac|iPod|iPhone|iPad/.test(
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  typeof window === "undefined" ? "node" : window.navigator.platform
);
function normalizeWheel(event) {
  let { deltaY, deltaX } = event;
  let deltaZ = 0;
  if (event.ctrlKey || event.altKey || event.metaKey) {
    deltaZ = (Math.abs(deltaY) > MAX_ZOOM_STEP ? MAX_ZOOM_STEP * Math.sign(deltaY) : deltaY) / 100;
  } else {
    if (event.shiftKey && !IS_DARWIN) {
      deltaX = deltaY;
      deltaY = 0;
    }
  }
  return { x: -deltaX, y: -deltaY, z: -deltaZ };
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useGestureEvents.mjs
var useGesture = createUseGesture([wheelAction, pinchAction]);
var lastWheelTime = void 0;
var isWheelEndEvent = (time2) => {
  if (lastWheelTime === void 0) {
    lastWheelTime = time2;
    return false;
  }
  if (time2 - lastWheelTime > 120 && time2 - lastWheelTime < 160) {
    lastWheelTime = time2;
    return true;
  }
  lastWheelTime = time2;
  return false;
};
function useGestureEvents(ref) {
  const editor = useEditor();
  const events = React5.useMemo(() => {
    let pinchState = "not sure";
    const onWheel = ({ event }) => {
      if (!editor.getInstanceState().isFocused) {
        return;
      }
      pinchState = "not sure";
      if (isWheelEndEvent(Date.now())) {
        return;
      }
      const editingShapeId = editor.getEditingShapeId();
      if (editingShapeId) {
        const shape = editor.getShape(editingShapeId);
        if (shape) {
          const util = editor.getShapeUtil(shape);
          if (util.canScroll(shape)) {
            const bounds = editor.getShapePageBounds(editingShapeId);
            if (bounds == null ? void 0 : bounds.containsPoint(editor.inputs.currentPagePoint)) {
              return;
            }
          }
        }
      }
      preventDefault(event);
      stopEventPropagation(event);
      const delta = normalizeWheel(event);
      if (delta.x === 0 && delta.y === 0)
        return;
      const info = {
        type: "wheel",
        name: "wheel",
        delta,
        point: new Vec(event.clientX, event.clientY),
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        ctrlKey: event.metaKey || event.ctrlKey,
        metaKey: event.metaKey,
        accelKey: isAccelKey(event)
      };
      editor.dispatch(info);
    };
    let initDistanceBetweenFingers = 1;
    let initZoom = 1;
    let currDistanceBetweenFingers = 0;
    const initPointBetweenFingers = new Vec();
    const prevPointBetweenFingers = new Vec();
    const onPinchStart = (gesture) => {
      const elm = ref.current;
      pinchState = "not sure";
      const { event, origin, da } = gesture;
      if (event instanceof WheelEvent)
        return;
      if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
        return;
      prevPointBetweenFingers.x = origin[0];
      prevPointBetweenFingers.y = origin[1];
      initPointBetweenFingers.x = origin[0];
      initPointBetweenFingers.y = origin[1];
      initDistanceBetweenFingers = da[0];
      initZoom = editor.getZoomLevel();
      editor.dispatch({
        type: "pinch",
        name: "pinch_start",
        point: { x: origin[0], y: origin[1], z: editor.getZoomLevel() },
        delta: { x: 0, y: 0 },
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        ctrlKey: event.metaKey || event.ctrlKey,
        metaKey: event.metaKey,
        accelKey: isAccelKey(event)
      });
    };
    const updatePinchState = (isSafariTrackpadPinch) => {
      if (isSafariTrackpadPinch) {
        pinchState = "zooming";
      }
      if (pinchState === "zooming") {
        return;
      }
      const touchDistance = Math.abs(currDistanceBetweenFingers - initDistanceBetweenFingers);
      const originDistance = Vec.Dist(initPointBetweenFingers, prevPointBetweenFingers);
      switch (pinchState) {
        case "not sure": {
          if (touchDistance > 24) {
            pinchState = "zooming";
          } else if (originDistance > 16) {
            pinchState = "panning";
          }
          break;
        }
        case "panning": {
          if (touchDistance > 64) {
            pinchState = "zooming";
          }
          break;
        }
      }
    };
    const onPinch = (gesture) => {
      const elm = ref.current;
      const { event, origin, offset: offset5, da } = gesture;
      if (event instanceof WheelEvent)
        return;
      if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
        return;
      const isSafariTrackpadPinch = gesture.type === "gesturechange" || gesture.type === "gestureend";
      currDistanceBetweenFingers = da[0];
      const dx = origin[0] - prevPointBetweenFingers.x;
      const dy = origin[1] - prevPointBetweenFingers.y;
      prevPointBetweenFingers.x = origin[0];
      prevPointBetweenFingers.y = origin[1];
      updatePinchState(isSafariTrackpadPinch);
      switch (pinchState) {
        case "zooming": {
          const currZoom = offset5[0] ** editor.getCameraOptions().zoomSpeed;
          editor.dispatch({
            type: "pinch",
            name: "pinch",
            point: { x: origin[0], y: origin[1], z: currZoom },
            delta: { x: dx, y: dy },
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            ctrlKey: event.metaKey || event.ctrlKey,
            metaKey: event.metaKey,
            accelKey: isAccelKey(event)
          });
          break;
        }
        case "panning": {
          editor.dispatch({
            type: "pinch",
            name: "pinch",
            point: { x: origin[0], y: origin[1], z: initZoom },
            delta: { x: dx, y: dy },
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            ctrlKey: event.metaKey || event.ctrlKey,
            metaKey: event.metaKey,
            accelKey: isAccelKey(event)
          });
          break;
        }
      }
    };
    const onPinchEnd = (gesture) => {
      const elm = ref.current;
      const { event, origin, offset: offset5 } = gesture;
      if (event instanceof WheelEvent)
        return;
      if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
        return;
      const scale = offset5[0] ** editor.getCameraOptions().zoomSpeed;
      pinchState = "not sure";
      editor.timers.requestAnimationFrame(() => {
        editor.dispatch({
          type: "pinch",
          name: "pinch_end",
          point: { x: origin[0], y: origin[1], z: scale },
          delta: { x: origin[0], y: origin[1] },
          shiftKey: event.shiftKey,
          altKey: event.altKey,
          ctrlKey: event.metaKey || event.ctrlKey,
          metaKey: event.metaKey,
          accelKey: isAccelKey(event)
        });
      });
    };
    return {
      onWheel,
      onPinchStart,
      onPinchEnd,
      onPinch
    };
  }, [editor, ref]);
  useGesture(events, {
    target: ref,
    eventOptions: { passive: false },
    pinch: {
      from: () => {
        const { zoomSpeed } = editor.getCameraOptions();
        const level = editor.getZoomLevel() ** (1 / zoomSpeed);
        return [level, 0];
      },
      // Return the camera z to use when pinch starts
      scaleBounds: () => {
        const baseZoom = editor.getBaseZoom();
        const { zoomSteps, zoomSpeed } = editor.getCameraOptions();
        const zoomMin = zoomSteps[0] * baseZoom;
        const zoomMax = zoomSteps[zoomSteps.length - 1] * baseZoom;
        return {
          max: zoomMax ** (1 / zoomSpeed),
          min: zoomMin ** (1 / zoomSpeed)
        };
      }
    }
  });
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useHandleEvents.mjs
var React6 = __toESM(require_react(), 1);
function getHandle(editor, id, handleId) {
  const shape = editor.getShape(id);
  const handles = editor.getShapeHandles(shape);
  return { shape, handle: handles.find((h) => h.id === handleId) };
}
function useHandleEvents(id, handleId) {
  const editor = useEditor();
  return React6.useMemo(() => {
    const onPointerDown = (e) => {
      if (e.isKilled)
        return;
      const target = loopToHtmlElement(e.currentTarget);
      setPointerCapture(target, e);
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle)
        return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_down",
        ...getPointerInfo(e)
      });
    };
    let lastX, lastY;
    const onPointerMove = (e) => {
      if (e.isKilled)
        return;
      if (e.clientX === lastX && e.clientY === lastY)
        return;
      lastX = e.clientX;
      lastY = e.clientY;
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle)
        return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_move",
        ...getPointerInfo(e)
      });
    };
    const onPointerUp = (e) => {
      if (e.isKilled)
        return;
      const target = loopToHtmlElement(e.currentTarget);
      releasePointerCapture(target, e);
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle)
        return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_up",
        ...getPointerInfo(e)
      });
    };
    return {
      onPointerDown,
      onPointerMove,
      onPointerUp
    };
  }, [editor, id, handleId]);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useScreenBounds.mjs
var import_react19 = __toESM(require_react(), 1);
function useScreenBounds(ref) {
  const editor = useEditor();
  (0, import_react19.useLayoutEffect)(() => {
    const updateBounds = (0, import_lodash.default)(
      () => {
        if (!ref.current)
          return;
        editor.updateViewportScreenBounds(ref.current);
      },
      200,
      {
        trailing: true
      }
    );
    const interval = editor.timers.setInterval(updateBounds, 1e3);
    window.addEventListener("resize", updateBounds);
    const resizeObserver = new ResizeObserver((entries) => {
      if (!entries[0].contentRect)
        return;
      updateBounds();
    });
    const container = ref.current;
    let scrollingParent = null;
    if (container) {
      resizeObserver.observe(container);
      scrollingParent = getNearestScrollableContainer(container);
      scrollingParent.addEventListener("scroll", updateBounds);
    }
    return () => {
      clearInterval(interval);
      window.removeEventListener("resize", updateBounds);
      resizeObserver.disconnect();
      scrollingParent == null ? void 0 : scrollingParent.removeEventListener("scroll", updateBounds);
      updateBounds.cancel();
    };
  }, [editor, ref]);
}
var getNearestScrollableContainer = (element) => {
  let parent = element.parentElement;
  while (parent) {
    if (parent === document.body) {
      return document;
    }
    const { overflowY } = window.getComputedStyle(parent);
    const hasScrollableContent = parent.scrollHeight > parent.clientHeight;
    if (hasScrollableContent && (overflowY === "auto" || overflowY === "scroll" || overflowY === "overlay")) {
      return parent;
    }
    parent = parent.parentElement;
  }
  return document;
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/Box.mjs
var Box = class _Box {
  constructor(x = 0, y = 0, w = 0, h = 0) {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "w", 0);
    __publicField(this, "h", 0);
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get point() {
    return new Vec(this.x, this.y);
  }
  // eslint-disable-next-line no-restricted-syntax
  set point(val) {
    this.x = val.x;
    this.y = val.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minX() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minX(n) {
    this.x = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get left() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midX() {
    return this.x + this.w / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxX() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get right() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minY() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minY(n) {
    this.y = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get top() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midY() {
    return this.y + this.h / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxY() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get bottom() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get width() {
    return this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  set width(n) {
    this.w = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get height() {
    return this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  set height(n) {
    this.h = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get aspectRatio() {
    return this.width / this.height;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return new Vec(this.midX, this.midY);
  }
  // eslint-disable-next-line no-restricted-syntax
  set center(v) {
    this.minX = v.x - this.width / 2;
    this.minY = v.y - this.height / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get corners() {
    return [
      new Vec(this.minX, this.minY),
      new Vec(this.maxX, this.minY),
      new Vec(this.maxX, this.maxY),
      new Vec(this.minX, this.maxY)
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get cornersAndCenter() {
    return [
      new Vec(this.minX, this.minY),
      new Vec(this.maxX, this.minY),
      new Vec(this.maxX, this.maxY),
      new Vec(this.minX, this.maxY),
      this.center
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get sides() {
    const { corners } = this;
    return [
      [corners[0], corners[1]],
      [corners[1], corners[2]],
      [corners[2], corners[3]],
      [corners[3], corners[0]]
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return new Vec(this.w, this.h);
  }
  toFixed() {
    this.x = toPrecision(this.x);
    this.y = toPrecision(this.y);
    this.w = toPrecision(this.w);
    this.h = toPrecision(this.h);
    return this;
  }
  setTo(B) {
    this.x = B.x;
    this.y = B.y;
    this.w = B.w;
    this.h = B.h;
    return this;
  }
  set(x = 0, y = 0, w = 0, h = 0) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    return this;
  }
  expand(A) {
    const minX = Math.min(this.minX, A.minX);
    const minY = Math.min(this.minY, A.minY);
    const maxX = Math.max(this.maxX, A.maxX);
    const maxY = Math.max(this.maxY, A.maxY);
    this.x = minX;
    this.y = minY;
    this.w = maxX - minX;
    this.h = maxY - minY;
    return this;
  }
  expandBy(n) {
    this.x -= n;
    this.y -= n;
    this.w += n * 2;
    this.h += n * 2;
    return this;
  }
  scale(n) {
    this.x /= n;
    this.y /= n;
    this.w /= n;
    this.h /= n;
    return this;
  }
  clone() {
    const { x, y, w, h } = this;
    return new _Box(x, y, w, h);
  }
  translate(delta) {
    this.x += delta.x;
    this.y += delta.y;
    return this;
  }
  snapToGrid(size4) {
    const minX = Math.round(this.minX / size4) * size4;
    const minY = Math.round(this.minY / size4) * size4;
    const maxX = Math.round(this.maxX / size4) * size4;
    const maxY = Math.round(this.maxY / size4) * size4;
    this.minX = minX;
    this.minY = minY;
    this.width = Math.max(1, maxX - minX);
    this.height = Math.max(1, maxY - minY);
  }
  collides(B) {
    return _Box.Collides(this, B);
  }
  contains(B) {
    return _Box.Contains(this, B);
  }
  includes(B) {
    return _Box.Includes(this, B);
  }
  containsPoint(V2, margin = 0) {
    return _Box.ContainsPoint(this, V2, margin);
  }
  getHandlePoint(handle) {
    switch (handle) {
      case "top_left":
        return new Vec(this.minX, this.minY);
      case "top_right":
        return new Vec(this.maxX, this.minY);
      case "bottom_left":
        return new Vec(this.minX, this.maxY);
      case "bottom_right":
        return new Vec(this.maxX, this.maxY);
      case "top":
        return new Vec(this.midX, this.minY);
      case "right":
        return new Vec(this.maxX, this.midY);
      case "bottom":
        return new Vec(this.midX, this.maxY);
      case "left":
        return new Vec(this.minX, this.midY);
    }
  }
  toJson() {
    return { x: this.minX, y: this.minY, w: this.w, h: this.h };
  }
  resize(handle, dx, dy) {
    const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = this;
    let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = this;
    switch (handle) {
      case "left":
      case "top_left":
      case "bottom_left": {
        b0x += dx;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        b1x += dx;
        break;
      }
    }
    switch (handle) {
      case "top":
      case "top_left":
      case "top_right": {
        b0y += dy;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        b1y += dy;
        break;
      }
    }
    const scaleX = (b1x - b0x) / (a1x - a0x);
    const scaleY = (b1y - b0y) / (a1y - a0y);
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    if (flipX) {
      const t2 = b1x;
      b1x = b0x;
      b0x = t2;
    }
    if (flipY) {
      const t2 = b1y;
      b1y = b0y;
      b0y = t2;
    }
    this.minX = b0x;
    this.minY = b0y;
    this.width = Math.abs(b1x - b0x);
    this.height = Math.abs(b1y - b0y);
  }
  union(box) {
    const minX = Math.min(this.minX, box.x);
    const minY = Math.min(this.minY, box.y);
    const maxX = Math.max(this.maxX, box.w + box.x);
    const maxY = Math.max(this.maxY, box.h + box.y);
    this.x = minX;
    this.y = minY;
    this.width = maxX - minX;
    this.height = maxY - minY;
    return this;
  }
  static From(box) {
    return new _Box(box.x, box.y, box.w, box.h);
  }
  static FromCenter(center, size4) {
    return new _Box(center.x - size4.x / 2, center.y - size4.y / 2, size4.x, size4.y);
  }
  static FromPoints(points) {
    if (points.length === 0)
      return new _Box();
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let point;
    for (let i = 0, n = points.length; i < n; i++) {
      point = points[i];
      minX = Math.min(point.x, minX);
      minY = Math.min(point.y, minY);
      maxX = Math.max(point.x, maxX);
      maxY = Math.max(point.y, maxY);
    }
    return new _Box(minX, minY, maxX - minX, maxY - minY);
  }
  static Expand(A, B) {
    const minX = Math.min(B.minX, A.minX);
    const minY = Math.min(B.minY, A.minY);
    const maxX = Math.max(B.maxX, A.maxX);
    const maxY = Math.max(B.maxY, A.maxY);
    return new _Box(minX, minY, maxX - minX, maxY - minY);
  }
  static ExpandBy(A, n) {
    return new _Box(A.minX - n, A.minY - n, A.width + n * 2, A.height + n * 2);
  }
  static Collides(A, B) {
    return !(A.maxX < B.minX || A.minX > B.maxX || A.maxY < B.minY || A.minY > B.maxY);
  }
  static Contains(A, B) {
    return A.minX < B.minX && A.minY < B.minY && A.maxY > B.maxY && A.maxX > B.maxX;
  }
  static Includes(A, B) {
    return _Box.Collides(A, B) || _Box.Contains(A, B);
  }
  static ContainsPoint(A, B, margin = 0) {
    return !(B.x < A.minX - margin || B.y < A.minY - margin || B.x > A.maxX + margin || B.y > A.maxY + margin);
  }
  static Common(boxes) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < boxes.length; i++) {
      const B = boxes[i];
      minX = Math.min(minX, B.minX);
      minY = Math.min(minY, B.minY);
      maxX = Math.max(maxX, B.maxX);
      maxY = Math.max(maxY, B.maxY);
    }
    return new _Box(minX, minY, maxX - minX, maxY - minY);
  }
  static Sides(A, inset = 0) {
    const { corners } = A;
    if (inset) {
    }
    return [
      [corners[0], corners[1]],
      [corners[1], corners[2]],
      [corners[2], corners[3]],
      [corners[3], corners[0]]
    ];
  }
  static Resize(box, handle, dx, dy, isAspectRatioLocked = false) {
    const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = box;
    let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = box;
    switch (handle) {
      case "left":
      case "top_left":
      case "bottom_left": {
        b0x += dx;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        b1x += dx;
        break;
      }
    }
    switch (handle) {
      case "top":
      case "top_left":
      case "top_right": {
        b0y += dy;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        b1y += dy;
        break;
      }
    }
    const scaleX = (b1x - b0x) / (a1x - a0x);
    const scaleY = (b1y - b0y) / (a1y - a0y);
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    if (isAspectRatioLocked) {
      const aspectRatio = (a1x - a0x) / (a1y - a0y);
      const bw = Math.abs(b1x - b0x);
      const bh = Math.abs(b1y - b0y);
      const tw = bw * (scaleY < 0 ? 1 : -1) * (1 / aspectRatio);
      const th = bh * (scaleX < 0 ? 1 : -1) * aspectRatio;
      const isTall = aspectRatio < bw / bh;
      switch (handle) {
        case "top_left": {
          if (isTall)
            b0y = b1y + tw;
          else
            b0x = b1x + th;
          break;
        }
        case "top_right": {
          if (isTall)
            b0y = b1y + tw;
          else
            b1x = b0x - th;
          break;
        }
        case "bottom_right": {
          if (isTall)
            b1y = b0y - tw;
          else
            b1x = b0x - th;
          break;
        }
        case "bottom_left": {
          if (isTall)
            b1y = b0y - tw;
          else
            b0x = b1x + th;
          break;
        }
        case "bottom":
        case "top": {
          const m = (b0x + b1x) / 2;
          const w = bh * aspectRatio;
          b0x = m - w / 2;
          b1x = m + w / 2;
          break;
        }
        case "left":
        case "right": {
          const m = (b0y + b1y) / 2;
          const h = bw / aspectRatio;
          b0y = m - h / 2;
          b1y = m + h / 2;
          break;
        }
      }
    }
    if (flipX) {
      const t2 = b1x;
      b1x = b0x;
      b0x = t2;
    }
    if (flipY) {
      const t2 = b1y;
      b1y = b0y;
      b0y = t2;
    }
    const final = new _Box(b0x, b0y, Math.abs(b1x - b0x), Math.abs(b1y - b0y));
    return {
      box: final,
      scaleX: +(final.width / box.width * (scaleX > 0 ? 1 : -1)).toFixed(5),
      scaleY: +(final.height / box.height * (scaleY > 0 ? 1 : -1)).toFixed(5)
    };
  }
  equals(other) {
    return _Box.Equals(this, other);
  }
  static Equals(a, b) {
    return b.x === a.x && b.y === a.y && b.w === a.w && b.h === a.h;
  }
  zeroFix() {
    this.w = Math.max(1, this.w);
    this.h = Math.max(1, this.h);
    return this;
  }
  static ZeroFix(other) {
    return new _Box(other.x, other.y, Math.max(1, other.w), Math.max(1, other.h));
  }
};
function flipSelectionHandleY(handle) {
  switch (handle) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "top_left":
      return "bottom_left";
    case "top_right":
      return "bottom_right";
    case "bottom_left":
      return "top_left";
    case "bottom_right":
      return "top_right";
    default:
      return handle;
  }
}
function flipSelectionHandleX(handle) {
  switch (handle) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top_left":
      return "top_right";
    case "top_right":
      return "top_left";
    case "bottom_left":
      return "bottom_right";
    case "bottom_right":
      return "bottom_left";
    default:
      return handle;
  }
}
var ORDERED_SELECTION_HANDLES = [
  "top",
  "top_right",
  "right",
  "bottom_right",
  "bottom",
  "bottom_left",
  "left",
  "top_left"
];
function rotateSelectionHandle(handle, rotation) {
  rotation = rotation % PI2;
  const numSteps = Math.round(rotation / (PI / 4));
  const currentIndex = ORDERED_SELECTION_HANDLES.indexOf(handle);
  return ORDERED_SELECTION_HANDLES[(currentIndex + numSteps) % ORDERED_SELECTION_HANDLES.length];
}
function isSelectionCorner(selection) {
  return selection === "top_left" || selection === "top_right" || selection === "bottom_right" || selection === "bottom_left";
}
var ROTATE_CORNER_TO_SELECTION_CORNER = {
  top_left_rotate: "top_left",
  top_right_rotate: "top_right",
  bottom_right_rotate: "bottom_right",
  bottom_left_rotate: "bottom_left",
  mobile_rotate: "top_left"
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/Mat.mjs
var Mat = class _Mat {
  constructor(a, b, c, d, e, f) {
    __publicField(this, "a", 1);
    __publicField(this, "b", 0);
    __publicField(this, "c", 0);
    __publicField(this, "d", 1);
    __publicField(this, "e", 0);
    __publicField(this, "f", 0);
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
  }
  equals(m) {
    return this === m || this.a === m.a && this.b === m.b && this.c === m.c && this.d === m.d && this.e === m.e && this.f === m.f;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.e = 0;
    this.f = 0;
    return this;
  }
  multiply(m) {
    const m2 = m;
    const { a, b, c, d, e, f } = this;
    this.a = a * m2.a + c * m2.b;
    this.c = a * m2.c + c * m2.d;
    this.e = a * m2.e + c * m2.f + e;
    this.b = b * m2.a + d * m2.b;
    this.d = b * m2.c + d * m2.d;
    this.f = b * m2.e + d * m2.f + f;
    return this;
  }
  rotate(r, cx, cy) {
    if (r === 0)
      return this;
    if (cx === void 0)
      return this.multiply(_Mat.Rotate(r));
    return this.translate(cx, cy).multiply(_Mat.Rotate(r)).translate(-cx, -cy);
  }
  translate(x, y) {
    return this.multiply(_Mat.Translate(x, y));
  }
  scale(x, y) {
    return this.multiply(_Mat.Scale(x, y));
  }
  invert() {
    const { a, b, c, d, e, f } = this;
    const denom = a * d - b * c;
    this.a = d / denom;
    this.b = b / -denom;
    this.c = c / -denom;
    this.d = a / denom;
    this.e = (d * e - c * f) / -denom;
    this.f = (b * e - a * f) / denom;
    return this;
  }
  applyToPoint(point) {
    return _Mat.applyToPoint(this, point);
  }
  applyToPoints(points) {
    return _Mat.applyToPoints(this, points);
  }
  rotation() {
    return _Mat.Rotation(this);
  }
  point() {
    return _Mat.Point(this);
  }
  decomposed() {
    return _Mat.Decompose(this);
  }
  toCssString() {
    return _Mat.toCssString(this);
  }
  setTo(model2) {
    Object.assign(this, model2);
    return this;
  }
  decompose() {
    return _Mat.Decompose(this);
  }
  clone() {
    return new _Mat(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  /* --------------------- Static --------------------- */
  static Identity() {
    return new _Mat(1, 0, 0, 1, 0, 0);
  }
  static Translate(x, y) {
    return new _Mat(1, 0, 0, 1, x, y);
  }
  static Rotate(r, cx, cy) {
    if (r === 0)
      return _Mat.Identity();
    const cosAngle = Math.cos(r);
    const sinAngle = Math.sin(r);
    const rotationMatrix = new _Mat(cosAngle, sinAngle, -sinAngle, cosAngle, 0, 0);
    if (cx === void 0)
      return rotationMatrix;
    return _Mat.Compose(_Mat.Translate(cx, cy), rotationMatrix, _Mat.Translate(-cx, -cy));
  }
  static Scale(x, y, cx, cy) {
    const scaleMatrix = new _Mat(x, 0, 0, y, 0, 0);
    if (cx === void 0)
      return scaleMatrix;
    return _Mat.Translate(cx, cy).multiply(scaleMatrix).translate(-cx, -cy);
  }
  static Multiply(m1, m2) {
    return {
      a: m1.a * m2.a + m1.c * m2.b,
      c: m1.a * m2.c + m1.c * m2.d,
      e: m1.a * m2.e + m1.c * m2.f + m1.e,
      b: m1.b * m2.a + m1.d * m2.b,
      d: m1.b * m2.c + m1.d * m2.d,
      f: m1.b * m2.e + m1.d * m2.f + m1.f
    };
  }
  static Inverse(m) {
    const denom = m.a * m.d - m.b * m.c;
    return {
      a: m.d / denom,
      b: m.b / -denom,
      c: m.c / -denom,
      d: m.a / denom,
      e: (m.d * m.e - m.c * m.f) / -denom,
      f: (m.b * m.e - m.a * m.f) / denom
    };
  }
  static Absolute(m) {
    const denom = m.a * m.d - m.b * m.c;
    return {
      a: m.d / denom,
      b: m.b / -denom,
      c: m.c / -denom,
      d: m.a / denom,
      e: (m.d * m.e - m.c * m.f) / denom,
      f: (m.b * m.e - m.a * m.f) / -denom
    };
  }
  static Compose(...matrices) {
    const matrix = _Mat.Identity();
    for (let i = 0, n = matrices.length; i < n; i++) {
      matrix.multiply(matrices[i]);
    }
    return matrix;
  }
  static Point(m) {
    return new Vec(m.e, m.f);
  }
  static Rotation(m) {
    let rotation;
    if (m.a !== 0 || m.c !== 0) {
      const hypotAc = (m.a * m.a + m.c * m.c) ** 0.5;
      rotation = Math.acos(m.a / hypotAc) * (m.c > 0 ? -1 : 1);
    } else if (m.b !== 0 || m.d !== 0) {
      const hypotBd = (m.b * m.b + m.d * m.d) ** 0.5;
      rotation = HALF_PI + Math.acos(m.b / hypotBd) * (m.d > 0 ? -1 : 1);
    } else {
      rotation = 0;
    }
    return clampRadians(rotation);
  }
  static Decompose(m) {
    let scaleX, scaleY, rotation;
    if (m.a !== 0 || m.c !== 0) {
      const hypotAc = (m.a * m.a + m.c * m.c) ** 0.5;
      scaleX = hypotAc;
      scaleY = (m.a * m.d - m.b * m.c) / hypotAc;
      rotation = Math.acos(m.a / hypotAc) * (m.c > 0 ? -1 : 1);
    } else if (m.b !== 0 || m.d !== 0) {
      const hypotBd = (m.b * m.b + m.d * m.d) ** 0.5;
      scaleX = (m.a * m.d - m.b * m.c) / hypotBd;
      scaleY = hypotBd;
      rotation = HALF_PI + Math.acos(m.b / hypotBd) * (m.d > 0 ? -1 : 1);
    } else {
      scaleX = 0;
      scaleY = 0;
      rotation = 0;
    }
    return {
      x: m.e,
      y: m.f,
      scaleX,
      scaleY,
      rotation: clampRadians(rotation)
    };
  }
  static Smooth(m, precision = 1e10) {
    m.a = Math.round(m.a * precision) / precision;
    m.b = Math.round(m.b * precision) / precision;
    m.c = Math.round(m.c * precision) / precision;
    m.d = Math.round(m.d * precision) / precision;
    m.e = Math.round(m.e * precision) / precision;
    m.f = Math.round(m.f * precision) / precision;
    return m;
  }
  static toCssString(m) {
    return `matrix(${toDomPrecision(m.a)}, ${toDomPrecision(m.b)}, ${toDomPrecision(
      m.c
    )}, ${toDomPrecision(m.d)}, ${toDomPrecision(m.e)}, ${toDomPrecision(m.f)})`;
  }
  static applyToPoint(m, point) {
    return new Vec(
      m.a * point.x + m.c * point.y + m.e,
      m.b * point.x + m.d * point.y + m.f,
      point.z
    );
  }
  static applyToXY(m, x, y) {
    return [m.a * x + m.c * y + m.e, m.b * x + m.d * y + m.f];
  }
  static applyToPoints(m, points) {
    return points.map(
      (point) => new Vec(m.a * point.x + m.c * point.y + m.e, m.b * point.x + m.d * point.y + m.f, point.z)
    );
  }
  static applyToBounds(m, box) {
    return new Box(m.e + box.minX, m.f + box.minY, box.width, box.height);
  }
  static From(m) {
    return new _Mat(m.a, m.b, m.c, m.d, m.e, m.f);
  }
  static Cast(m) {
    return m instanceof _Mat ? m : _Mat.From(m);
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/utils/nearestMultiple.mjs
function gcd(a, b) {
  return b === 0 ? a : gcd(b, a % b);
}
function nearestMultiple(float) {
  const decimal = float.toString().split(".")[1];
  if (!decimal)
    return 1;
  const denominator = Math.pow(10, decimal.length);
  const numerator = parseInt(decimal, 10);
  return denominator / gcd(numerator, denominator);
}

// node_modules/@tldraw/editor/dist-esm/lib/components/GeometryDebuggingView.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/primitives/intersect.mjs
function intersectLineSegmentLineSegment(a1, a2, b1, b2) {
  const ABx = a1.x - b1.x;
  const ABy = a1.y - b1.y;
  const BVx = b2.x - b1.x;
  const BVy = b2.y - b1.y;
  const AVx = a2.x - a1.x;
  const AVy = a2.y - a1.y;
  const ua_t = BVx * ABy - BVy * ABx;
  const ub_t = AVx * ABy - AVy * ABx;
  const u_b = BVy * AVx - BVx * AVy;
  if (ua_t === 0 || ub_t === 0)
    return null;
  if (u_b === 0)
    return null;
  if (u_b !== 0) {
    const ua = ua_t / u_b;
    const ub = ub_t / u_b;
    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      return Vec.AddXY(a1, ua * AVx, ua * AVy);
    }
  }
  return null;
}
function intersectLineSegmentCircle(a1, a2, c, r) {
  const a = (a2.x - a1.x) * (a2.x - a1.x) + (a2.y - a1.y) * (a2.y - a1.y);
  const b = 2 * ((a2.x - a1.x) * (a1.x - c.x) + (a2.y - a1.y) * (a1.y - c.y));
  const cc = c.x * c.x + c.y * c.y + a1.x * a1.x + a1.y * a1.y - 2 * (c.x * a1.x + c.y * a1.y) - r * r;
  const deter = b * b - 4 * a * cc;
  if (deter < 0)
    return null;
  if (deter === 0)
    return null;
  const e = Math.sqrt(deter);
  const u1 = (-b + e) / (2 * a);
  const u2 = (-b - e) / (2 * a);
  if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {
    return null;
  }
  const result = [];
  if (0 <= u1 && u1 <= 1)
    result.push(Vec.Lrp(a1, a2, u1));
  if (0 <= u2 && u2 <= 1)
    result.push(Vec.Lrp(a1, a2, u2));
  if (result.length === 0)
    return null;
  return result;
}
function intersectLineSegmentPolyline(a1, a2, points) {
  const result = [];
  let segmentIntersection;
  for (let i = 0, n = points.length - 1; i < n; i++) {
    segmentIntersection = intersectLineSegmentLineSegment(a1, a2, points[i], points[i + 1]);
    if (segmentIntersection)
      result.push(segmentIntersection);
  }
  if (result.length === 0)
    return null;
  return result;
}
function intersectLineSegmentPolygon(a1, a2, points) {
  const result = [];
  let segmentIntersection;
  for (let i = 1, n = points.length; i < n + 1; i++) {
    segmentIntersection = intersectLineSegmentLineSegment(
      a1,
      a2,
      points[i - 1],
      points[i % points.length]
    );
    if (segmentIntersection)
      result.push(segmentIntersection);
  }
  if (result.length === 0)
    return null;
  return result;
}
function intersectCircleCircle(c1, r1, c2, r2) {
  let dx = c2.x - c1.x;
  let dy = c2.y - c1.y;
  const d = Math.sqrt(dx * dx + dy * dy), x = (d * d - r2 * r2 + r1 * r1) / (2 * d), y = Math.sqrt(r1 * r1 - x * x);
  dx /= d;
  dy /= d;
  return [
    new Vec(c1.x + dx * x - dy * y, c1.y + dy * x + dx * y),
    new Vec(c1.x + dx * x + dy * y, c1.y + dy * x - dx * y)
  ];
}
function intersectCirclePolygon(c, r, points) {
  const result = [];
  let a, b, int;
  for (let i = 0, n = points.length; i < n; i++) {
    a = points[i];
    b = points[(i + 1) % points.length];
    int = intersectLineSegmentCircle(a, b, c, r);
    if (int)
      result.push(...int);
  }
  if (result.length === 0)
    return null;
  return result;
}
function intersectCirclePolyline(c, r, points) {
  const result = [];
  let a, b, int;
  for (let i = 1, n = points.length; i < n; i++) {
    a = points[i - 1];
    b = points[i];
    int = intersectLineSegmentCircle(a, b, c, r);
    if (int)
      result.push(...int);
  }
  if (result.length === 0)
    return null;
  return result;
}
function intersectPolygonBounds(points, bounds) {
  const result = [];
  let segmentIntersection;
  for (const side of bounds.sides) {
    segmentIntersection = intersectLineSegmentPolygon(side[0], side[1], points);
    if (segmentIntersection)
      result.push(...segmentIntersection);
  }
  if (result.length === 0)
    return null;
  return result;
}
function ccw(A, B, C) {
  return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
}
function linesIntersect(A, B, C, D) {
  return ccw(A, C, D) !== ccw(B, C, D) && ccw(A, B, C) !== ccw(A, B, D);
}
function intersectPolygonPolygon(polygonA, polygonB) {
  const result = /* @__PURE__ */ new Map();
  let a, b, c, d;
  for (let i = 0, n = polygonA.length; i < n; i++) {
    a = polygonA[i];
    if (pointInPolygon(a, polygonB)) {
      const id = getPointId(a);
      if (!result.has(id)) {
        result.set(id, a);
      }
    }
  }
  for (let i = 0, n = polygonB.length; i < n; i++) {
    a = polygonB[i];
    if (pointInPolygon(a, polygonA)) {
      const id = getPointId(a);
      if (!result.has(id)) {
        result.set(id, a);
      }
    }
  }
  for (let i = 0, n = polygonA.length; i < n; i++) {
    a = polygonA[i];
    b = polygonA[(i + 1) % polygonA.length];
    for (let j = 0, m = polygonB.length; j < m; j++) {
      c = polygonB[j];
      d = polygonB[(j + 1) % polygonB.length];
      const intersection = intersectLineSegmentLineSegment(a, b, c, d);
      if (intersection !== null) {
        const id = getPointId(intersection);
        if (!result.has(id)) {
          result.set(id, intersection);
        }
      }
    }
  }
  if (result.size === 0)
    return null;
  return orderClockwise([...result.values()]);
}
function intersectPolys(polyA, polyB, isAClosed, isBClosed) {
  const result = /* @__PURE__ */ new Map();
  for (let i = 0, n = isAClosed ? polyA.length : polyA.length - 1; i < n; i++) {
    const currentA = polyA[i];
    const nextA = polyA[(i + 1) % polyA.length];
    for (let j = 0, m = isBClosed ? polyB.length : polyB.length - 1; j < m; j++) {
      const currentB = polyB[j];
      const nextB = polyB[(j + 1) % polyB.length];
      const intersection = intersectLineSegmentLineSegment(currentA, nextA, currentB, nextB);
      if (intersection !== null) {
        const id = getPointId(intersection);
        if (!result.has(id)) {
          result.set(id, intersection);
        }
      }
    }
  }
  return [...result.values()];
}
function getPointId(point) {
  return `${point.x},${point.y}`;
}
function orderClockwise(points) {
  const C = Vec.Average(points);
  return points.sort((A, B) => Vec.Angle(C, A) - Vec.Angle(C, B));
}
function polygonsIntersect(a, b) {
  let a0, a1, b0, b1;
  for (let i = 0, n = a.length; i < n; i++) {
    a0 = a[i];
    a1 = a[(i + 1) % n];
    for (let j = 0, m = b.length; j < m; j++) {
      b0 = b[j];
      b1 = b[(j + 1) % m];
      if (linesIntersect(a0, a1, b0, b1))
        return true;
    }
  }
  return false;
}
function polygonIntersectsPolyline(polygon, polyline) {
  let a, b, c, d;
  for (let i = 0, n = polygon.length; i < n; i++) {
    a = polygon[i];
    b = polygon[(i + 1) % n];
    for (let j = 1, m = polyline.length; j < m; j++) {
      c = polyline[j - 1];
      d = polyline[j];
      if (linesIntersect(a, b, c, d))
        return true;
    }
  }
  return false;
}

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Geometry2d.mjs
var Geometry2dFilters = {
  EXCLUDE_NON_STANDARD: {
    includeLabels: false,
    includeInternal: false
  },
  INCLUDE_ALL: { includeLabels: true, includeInternal: true },
  EXCLUDE_LABELS: { includeLabels: false, includeInternal: true },
  EXCLUDE_INTERNAL: { includeLabels: true, includeInternal: false }
};
var Geometry2d = class {
  constructor(opts) {
    __publicField(this, "isFilled", false);
    __publicField(this, "isClosed", true);
    __publicField(this, "isLabel", false);
    __publicField(this, "isInternal", false);
    __publicField(this, "debugColor");
    __publicField(this, "ignore");
    __publicField(this, "_vertices");
    __publicField(this, "_bounds");
    __publicField(this, "_area");
    __publicField(this, "_length");
    this.isFilled = opts.isFilled;
    this.isClosed = opts.isClosed;
    this.isLabel = opts.isLabel ?? false;
    this.isInternal = opts.isInternal ?? false;
    this.debugColor = opts.debugColor;
    this.ignore = opts.ignore;
  }
  isExcludedByFilter(filters) {
    if (!filters)
      return false;
    if (this.isLabel && !filters.includeLabels)
      return true;
    if (this.isInternal && !filters.includeInternal)
      return true;
    return false;
  }
  hitTestPoint(point, margin = 0, hitInside = false, _filters) {
    if (this.isClosed && (this.isFilled || hitInside) && pointInPolygon(point, this.vertices)) {
      return true;
    }
    return Vec.Dist2(point, this.nearestPoint(point)) <= margin * margin;
  }
  distanceToPoint(point, hitInside = false, filters) {
    return Vec.Dist(point, this.nearestPoint(point, filters)) * (this.isClosed && (this.isFilled || hitInside) && pointInPolygon(point, this.vertices) ? -1 : 1);
  }
  distanceToLineSegment(A, B, filters) {
    if (Vec.Equals(A, B))
      return this.distanceToPoint(A, false, filters);
    const { vertices } = this;
    let nearest;
    let dist = Infinity;
    let d, p, q;
    for (let i = 0; i < vertices.length; i++) {
      p = vertices[i];
      q = Vec.NearestPointOnLineSegment(A, B, p, true);
      d = Vec.Dist2(p, q);
      if (d < dist) {
        dist = d;
        nearest = q;
      }
    }
    if (!nearest)
      throw Error("nearest point not found");
    return this.isClosed && this.isFilled && pointInPolygon(nearest, this.vertices) ? -dist : dist;
  }
  hitTestLineSegment(A, B, distance = 0, filters) {
    return this.distanceToLineSegment(A, B, filters) <= distance;
  }
  intersectLineSegment(A, B, _filters) {
    const intersections = this.isClosed ? intersectLineSegmentPolygon(A, B, this.vertices) : intersectLineSegmentPolyline(A, B, this.vertices);
    return intersections ?? [];
  }
  intersectCircle(center, radius, _filters) {
    const intersections = this.isClosed ? intersectCirclePolygon(center, radius, this.vertices) : intersectCirclePolyline(center, radius, this.vertices);
    return intersections ?? [];
  }
  intersectPolygon(polygon, _filters) {
    return intersectPolys(polygon, this.vertices, true, this.isClosed);
  }
  intersectPolyline(polyline, _filters) {
    return intersectPolys(polyline, this.vertices, false, this.isClosed);
  }
  /**
   * Find a point along the edge of the geometry that is a fraction `t` along the entire way round.
   */
  interpolateAlongEdge(t2, _filters) {
    const { vertices } = this;
    if (t2 <= 0)
      return vertices[0];
    const distanceToTravel = t2 * this.length;
    let distanceTraveled = 0;
    for (let i = 0; i < (this.isClosed ? vertices.length : vertices.length - 1); i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % vertices.length];
      const dist = Vec.Dist(curr, next);
      const newDistanceTraveled = distanceTraveled + dist;
      if (newDistanceTraveled >= distanceToTravel) {
        const p = Vec.Lrp(
          curr,
          next,
          invLerp(distanceTraveled, newDistanceTraveled, distanceToTravel)
        );
        return p;
      }
      distanceTraveled = newDistanceTraveled;
    }
    return this.isClosed ? vertices[0] : vertices[vertices.length - 1];
  }
  /**
   * Take `point`, find the closest point to it on the edge of the geometry, and return how far
   * along the edge it is as a fraction of the total length.
   */
  uninterpolateAlongEdge(point, _filters) {
    const { vertices, length } = this;
    let closestSegment = null;
    let closestDistance = Infinity;
    let distanceTraveled = 0;
    for (let i = 0; i < (this.isClosed ? vertices.length : vertices.length - 1); i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % vertices.length];
      const nearestPoint = Vec.NearestPointOnLineSegment(curr, next, point, true);
      const distance = Vec.Dist(nearestPoint, point);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestSegment = {
          start: curr,
          end: next,
          nearestPoint,
          distanceToStart: distanceTraveled
        };
      }
      distanceTraveled += Vec.Dist(curr, next);
    }
    assert(closestSegment);
    const distanceAlongRoute = closestSegment.distanceToStart + Vec.Dist(closestSegment.start, closestSegment.nearestPoint);
    return distanceAlongRoute / length;
  }
  /** @deprecated Iterate the vertices instead. */
  nearestPointOnLineSegment(A, B) {
    const { vertices } = this;
    let nearest;
    let dist = Infinity;
    let d, p, q;
    for (let i = 0; i < vertices.length; i++) {
      p = vertices[i];
      q = Vec.NearestPointOnLineSegment(A, B, p, true);
      d = Vec.Dist2(p, q);
      if (d < dist) {
        dist = d;
        nearest = q;
      }
    }
    if (!nearest)
      throw Error("nearest point not found");
    return nearest;
  }
  isPointInBounds(point, margin = 0) {
    const { bounds } = this;
    return !(point.x < bounds.minX - margin || point.y < bounds.minY - margin || point.x > bounds.maxX + margin || point.y > bounds.maxY + margin);
  }
  transform(transform, opts) {
    return new TransformedGeometry2d(this, transform, opts);
  }
  // eslint-disable-next-line no-restricted-syntax
  get vertices() {
    if (!this._vertices) {
      this._vertices = this.getVertices(Geometry2dFilters.EXCLUDE_LABELS);
    }
    return this._vertices;
  }
  getBounds() {
    return Box.FromPoints(this.vertices);
  }
  // eslint-disable-next-line no-restricted-syntax
  get bounds() {
    if (!this._bounds) {
      this._bounds = this.getBounds();
    }
    return this._bounds;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return this.bounds.center;
  }
  // eslint-disable-next-line no-restricted-syntax
  get area() {
    if (!this._area) {
      this._area = this.getArea();
    }
    return this._area;
  }
  getArea() {
    if (!this.isClosed) {
      return 0;
    }
    const { vertices } = this;
    let area = 0;
    for (let i = 0, n = vertices.length; i < n; i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % n];
      area += curr.x * next.y - next.x * curr.y;
    }
    return area / 2;
  }
  toSimpleSvgPath() {
    let path = "";
    const { vertices } = this;
    const n = vertices.length;
    if (n === 0)
      return path;
    path += `M${vertices[0].x},${vertices[0].y}`;
    for (let i = 1; i < n; i++) {
      path += `L${vertices[i].x},${vertices[i].y}`;
    }
    if (this.isClosed) {
      path += "Z";
    }
    return path;
  }
  // eslint-disable-next-line no-restricted-syntax
  get length() {
    if (this._length)
      return this._length;
    this._length = this.getLength(Geometry2dFilters.EXCLUDE_LABELS);
    return this._length;
  }
  getLength(_filters) {
    const vertices = this.getVertices(_filters ?? Geometry2dFilters.EXCLUDE_LABELS);
    if (vertices.length === 0)
      return 0;
    let prev = vertices[0];
    let length = 0;
    for (let i = 1; i < vertices.length; i++) {
      const next = vertices[i];
      length += Vec.Dist(prev, next);
      prev = next;
    }
    if (this.isClosed) {
      length += Vec.Dist(vertices[vertices.length - 1], vertices[0]);
    }
    return length;
  }
};
var TransformedGeometry2d = class _TransformedGeometry2d extends Geometry2d {
  constructor(geometry, matrix, opts) {
    super(geometry);
    __publicField(this, "inverse");
    __publicField(this, "decomposed");
    this.geometry = geometry;
    this.matrix = matrix;
    this.inverse = Mat.Inverse(matrix);
    this.decomposed = Mat.Decompose(matrix);
    if (opts) {
      if (opts.isLabel != null)
        this.isLabel = opts.isLabel;
      if (opts.isInternal != null)
        this.isInternal = opts.isInternal;
      if (opts.debugColor != null)
        this.debugColor = opts.debugColor;
      if (opts.ignore != null)
        this.ignore = opts.ignore;
    }
    assert(
      approximately(this.decomposed.scaleX, this.decomposed.scaleY),
      "non-uniform scaling is not yet supported"
    );
  }
  getVertices(filters) {
    return this.geometry.getVertices(filters).map((v) => Mat.applyToPoint(this.matrix, v));
  }
  nearestPoint(point, filters) {
    return Mat.applyToPoint(
      this.matrix,
      this.geometry.nearestPoint(Mat.applyToPoint(this.inverse, point), filters)
    );
  }
  hitTestPoint(point, margin = 0, hitInside, filters) {
    return this.geometry.hitTestPoint(
      Mat.applyToPoint(this.inverse, point),
      margin / this.decomposed.scaleX,
      hitInside,
      filters
    );
  }
  distanceToPoint(point, hitInside = false, filters) {
    return this.geometry.distanceToPoint(Mat.applyToPoint(this.inverse, point), hitInside, filters) * this.decomposed.scaleX;
  }
  distanceToLineSegment(A, B, filters) {
    return this.geometry.distanceToLineSegment(
      Mat.applyToPoint(this.inverse, A),
      Mat.applyToPoint(this.inverse, B),
      filters
    ) * this.decomposed.scaleX;
  }
  hitTestLineSegment(A, B, distance = 0, filters) {
    return this.geometry.hitTestLineSegment(
      Mat.applyToPoint(this.inverse, A),
      Mat.applyToPoint(this.inverse, B),
      distance / this.decomposed.scaleX,
      filters
    );
  }
  intersectLineSegment(A, B, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectLineSegment(
        Mat.applyToPoint(this.inverse, A),
        Mat.applyToPoint(this.inverse, B),
        filters
      )
    );
  }
  intersectCircle(center, radius, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectCircle(
        Mat.applyToPoint(this.inverse, center),
        radius / this.decomposed.scaleX,
        filters
      )
    );
  }
  intersectPolygon(polygon, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectPolygon(Mat.applyToPoints(this.inverse, polygon), filters)
    );
  }
  intersectPolyline(polyline, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectPolyline(Mat.applyToPoints(this.inverse, polyline), filters)
    );
  }
  transform(transform, opts) {
    return new _TransformedGeometry2d(this.geometry, Mat.Multiply(transform, this.matrix), {
      isLabel: (opts == null ? void 0 : opts.isLabel) ?? this.isLabel,
      isInternal: (opts == null ? void 0 : opts.isInternal) ?? this.isInternal,
      debugColor: (opts == null ? void 0 : opts.debugColor) ?? this.debugColor,
      ignore: (opts == null ? void 0 : opts.ignore) ?? this.ignore
    });
  }
  getSvgPathData() {
    throw new Error("Cannot get SVG path data for transformed geometry.");
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Group2d.mjs
var Group2d = class _Group2d extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: true, isFilled: false });
    __publicField(this, "children", []);
    __publicField(this, "ignoredChildren", []);
    for (const child of config.children) {
      if (child.ignore) {
        this.ignoredChildren.push(child);
      } else {
        this.children.push(child);
      }
    }
    if (this.children.length === 0)
      throw Error("Group2d must have at least one child");
  }
  getVertices(filters) {
    if (this.isExcludedByFilter(filters))
      return [];
    return this.children.filter((c) => !c.isExcludedByFilter(filters)).flatMap((c) => c.getVertices(filters));
  }
  nearestPoint(point, filters) {
    let dist = Infinity;
    let nearest;
    const { children } = this;
    if (children.length === 0) {
      throw Error("no children");
    }
    let p;
    let d;
    for (const child of children) {
      if (child.isExcludedByFilter(filters))
        continue;
      p = child.nearestPoint(point, filters);
      d = Vec.Dist2(p, point);
      if (d < dist) {
        dist = d;
        nearest = p;
      }
    }
    if (!nearest)
      throw Error("nearest point not found");
    return nearest;
  }
  distanceToPoint(point, hitInside = false, filters) {
    let smallestDistance = Infinity;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters))
        continue;
      const distance = child.distanceToPoint(point, hitInside, filters);
      if (distance < smallestDistance) {
        smallestDistance = distance;
      }
    }
    return smallestDistance;
  }
  hitTestPoint(point, margin, hitInside, filters = Geometry2dFilters.EXCLUDE_LABELS) {
    return !!this.children.filter((c) => !c.isExcludedByFilter(filters)).find((c) => c.hitTestPoint(point, margin, hitInside));
  }
  hitTestLineSegment(A, B, zoom, filters = Geometry2dFilters.EXCLUDE_LABELS) {
    return !!this.children.filter((c) => !c.isExcludedByFilter(filters)).find((c) => c.hitTestLineSegment(A, B, zoom));
  }
  intersectLineSegment(A, B, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters))
        return EMPTY_ARRAY;
      return child.intersectLineSegment(A, B, filters);
    });
  }
  intersectCircle(center, radius, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters))
        return EMPTY_ARRAY;
      return child.intersectCircle(center, radius, filters);
    });
  }
  intersectPolygon(polygon, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters))
        return EMPTY_ARRAY;
      return child.intersectPolygon(polygon, filters);
    });
  }
  intersectPolyline(polyline, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters))
        return EMPTY_ARRAY;
      return child.intersectPolyline(polyline, filters);
    });
  }
  interpolateAlongEdge(t2, filters) {
    const totalLength = this.getLength(filters);
    const distanceToTravel = t2 * totalLength;
    let distanceTraveled = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters))
        continue;
      const childLength = child.length;
      const newDistanceTraveled = distanceTraveled + childLength;
      if (newDistanceTraveled >= distanceToTravel) {
        return child.interpolateAlongEdge(
          invLerp(distanceTraveled, newDistanceTraveled, distanceToTravel),
          filters
        );
      }
      distanceTraveled = newDistanceTraveled;
    }
    return this.children[this.children.length - 1].interpolateAlongEdge(1, filters);
  }
  uninterpolateAlongEdge(point, filters) {
    const totalLength = this.getLength(filters);
    let closestChild = null;
    let closestDistance = Infinity;
    let distanceTraveled = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters))
        continue;
      const childLength = child.getLength(filters);
      const newDistanceTraveled = distanceTraveled + childLength;
      const distance = child.distanceToPoint(point, false, filters);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestChild = {
          startLength: distanceTraveled,
          endLength: newDistanceTraveled,
          child
        };
      }
      distanceTraveled = newDistanceTraveled;
    }
    assert(closestChild);
    const normalizedDistanceInChild = closestChild.child.uninterpolateAlongEdge(point, filters);
    const childTLength = lerp(
      closestChild.startLength,
      closestChild.endLength,
      normalizedDistanceInChild
    );
    return childTLength / totalLength;
  }
  transform(transform) {
    return new _Group2d({
      children: this.children.map((c) => c.transform(transform)),
      isLabel: this.isLabel,
      debugColor: this.debugColor,
      ignore: this.ignore
    });
  }
  getArea() {
    return this.children[0].area;
  }
  toSimpleSvgPath() {
    let path = "";
    for (const child of this.children) {
      path += child.toSimpleSvgPath();
    }
    const corners = Box.FromPoints(this.vertices).corners;
    for (let i = 0, n = corners.length; i < n; i++) {
      const corner = corners[i];
      const prevCorner = corners[(i - 1 + n) % n];
      const prevDist = corner.dist(prevCorner);
      const nextCorner = corners[(i + 1) % n];
      const nextDist = corner.dist(nextCorner);
      const A = corner.clone().lrp(prevCorner, 4 / prevDist);
      const B = corner;
      const C = corner.clone().lrp(nextCorner, 4 / nextDist);
      path += `M${A.x},${A.y} L${B.x},${B.y} L${C.x},${C.y} `;
    }
    return path;
  }
  getLength(filters) {
    let length = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters))
        continue;
      length += child.length;
    }
    return length;
  }
  getSvgPathData() {
    return this.children.map((c, i) => c.isLabel ? "" : c.getSvgPathData(i === 0)).join(" ");
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/components/GeometryDebuggingView.mjs
function useTick(isEnabled = true) {
  const [_, setTick] = (0, import_react20.useState)(0);
  const editor = useEditor();
  (0, import_react20.useEffect)(() => {
    if (!isEnabled)
      return;
    const update = () => setTick((tick2) => tick2 + 1);
    editor.on("tick", update);
    return () => {
      editor.off("tick", update);
    };
  }, [editor, isEnabled]);
}
var GeometryDebuggingView = track(function GeometryDebuggingView2({
  showStroke = true,
  showVertices = true,
  showClosestPointOnOutline = true
}) {
  const editor = useEditor();
  useTick(showClosestPointOnOutline);
  const zoomLevel = editor.getZoomLevel();
  const renderingShapes = editor.getRenderingShapes();
  const {
    inputs: { currentPagePoint }
  } = editor;
  return (0, import_jsx_runtime7.jsx)(
    "svg",
    {
      style: {
        position: "absolute",
        pointerEvents: "none",
        zIndex: 999999999,
        top: 0,
        left: 0,
        overflow: "visible"
      },
      children: renderingShapes.map((result) => {
        const shape = editor.getShape(result.id);
        if (shape.type === "group")
          return null;
        const geometry = editor.getShapeGeometry(shape);
        const pageTransform = editor.getShapePageTransform(shape);
        const pointInShapeSpace = editor.getPointInShapeSpace(shape, currentPagePoint);
        const nearestPointOnShape = geometry.nearestPoint(pointInShapeSpace);
        const distanceToPoint = geometry.distanceToPoint(pointInShapeSpace, true);
        const dist = Math.abs(distanceToPoint) * zoomLevel;
        const hitInside = distanceToPoint < 0;
        const { vertices } = geometry;
        return (0, import_jsx_runtime7.jsxs)(
          "g",
          {
            transform: pageTransform.toCssString(),
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              showStroke && (0, import_jsx_runtime7.jsx)(
                "g",
                {
                  stroke: geometry.debugColor ?? "red",
                  opacity: "1",
                  strokeWidth: 2 / zoomLevel,
                  fill: "none",
                  children: (0, import_jsx_runtime7.jsx)(GeometryStroke, { geometry })
                }
              ),
              showVertices && vertices.map((v, i) => (0, import_jsx_runtime7.jsx)(
                "circle",
                {
                  cx: v.x,
                  cy: v.y,
                  r: 2 / zoomLevel,
                  fill: `hsl(${modulate(i, [0, vertices.length - 1], [120, 200])}, 100%, 50%)`,
                  stroke: "black",
                  strokeWidth: 1 / zoomLevel
                },
                `v${i}`
              )),
              showClosestPointOnOutline && dist < 150 && (0, import_jsx_runtime7.jsx)(
                "line",
                {
                  x1: nearestPointOnShape.x,
                  y1: nearestPointOnShape.y,
                  x2: pointInShapeSpace.x,
                  y2: pointInShapeSpace.y,
                  opacity: 1 - dist / 150,
                  stroke: hitInside ? "goldenrod" : "dodgerblue",
                  strokeWidth: 2 / zoomLevel
                }
              )
            ]
          },
          result.id + "_outline"
        );
      })
    }
  );
});
function GeometryStroke({ geometry }) {
  if (geometry instanceof Group2d) {
    return (0, import_jsx_runtime7.jsx)("g", { stroke: geometry.debugColor, children: [...geometry.children, ...geometry.ignoredChildren].map((child, i) => (0, import_jsx_runtime7.jsx)(GeometryStroke, { geometry: child }, i)) });
  }
  return (0, import_jsx_runtime7.jsx)("path", { d: geometry.toSimpleSvgPath(), stroke: geometry.debugColor });
}

// node_modules/@tldraw/editor/dist-esm/lib/components/LiveCollaborators.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react21 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/utils/uniq.mjs
function uniq(array2) {
  return (0, import_lodash2.default)(array2);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/usePeerIds.mjs
function usePeerIds() {
  const editor = useEditor();
  const $userIds = useComputed(
    "userIds",
    () => uniq(editor.getCollaborators().map((p) => p.userId)).sort(),
    { isEqual: (a, b) => {
      var _a5;
      return a.join(",") === ((_a5 = b.join) == null ? void 0 : _a5.call(b, ","));
    } },
    [editor]
  );
  return useValue($userIds);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/usePresence.mjs
function usePresence(userId) {
  const editor = useEditor();
  const latestPresence = useValue(
    `latestPresence:${userId}`,
    () => {
      return editor.getCollaborators().find((c) => c.userId === userId);
    },
    [editor, userId]
  );
  return latestPresence ?? null;
}

// node_modules/@tldraw/editor/dist-esm/lib/components/LiveCollaborators.mjs
var LiveCollaborators = track(function Collaborators() {
  const peerIds = usePeerIds();
  return peerIds.map((id) => (0, import_jsx_runtime8.jsx)(CollaboratorGuard, { collaboratorId: id }, id));
});
var CollaboratorGuard = track(function CollaboratorGuard2({
  collaboratorId
}) {
  const editor = useEditor();
  const presence = usePresence(collaboratorId);
  const collaboratorState = useCollaboratorState(editor, presence);
  if (!(presence && presence.currentPageId === editor.getCurrentPageId())) {
    return null;
  }
  switch (collaboratorState) {
    case "inactive": {
      const { followingUserId, highlightedUserIds } = editor.getInstanceState();
      if (!(followingUserId === presence.userId || highlightedUserIds.includes(presence.userId))) {
        return null;
      }
      break;
    }
    case "idle": {
      const { highlightedUserIds } = editor.getInstanceState();
      if (presence.followingUserId === editor.user.getId() && !(presence.chatMessage || highlightedUserIds.includes(presence.userId))) {
        return null;
      }
      break;
    }
    case "active": {
      break;
    }
  }
  return (0, import_jsx_runtime8.jsx)(Collaborator, { latestPresence: presence });
});
var Collaborator = track(function Collaborator2({
  latestPresence
}) {
  const editor = useEditor();
  const {
    CollaboratorBrush,
    CollaboratorScribble,
    CollaboratorCursor,
    CollaboratorHint,
    CollaboratorShapeIndicator
  } = useEditorComponents();
  const zoomLevel = editor.getZoomLevel();
  const viewportPageBounds = editor.getViewportPageBounds();
  const { userId, chatMessage, brush, scribbles, selectedShapeIds, userName, cursor, color } = latestPresence;
  if (!cursor)
    return null;
  const isCursorInViewport = !(cursor.x < viewportPageBounds.minX - 12 / zoomLevel || cursor.y < viewportPageBounds.minY - 16 / zoomLevel || cursor.x > viewportPageBounds.maxX - 12 / zoomLevel || cursor.y > viewportPageBounds.maxY - 16 / zoomLevel);
  return (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
    brush && CollaboratorBrush ? (0, import_jsx_runtime8.jsx)(
      CollaboratorBrush,
      {
        className: "tl-collaborator__brush",
        userId,
        brush,
        color,
        opacity: 0.1
      },
      userId + "_brush"
    ) : null,
    isCursorInViewport && CollaboratorCursor ? (0, import_jsx_runtime8.jsx)(
      CollaboratorCursor,
      {
        className: "tl-collaborator__cursor",
        userId,
        point: cursor,
        color,
        zoom: zoomLevel,
        name: userName !== "New User" ? userName : null,
        chatMessage: chatMessage ?? ""
      },
      userId + "_cursor"
    ) : CollaboratorHint ? (0, import_jsx_runtime8.jsx)(
      CollaboratorHint,
      {
        className: "tl-collaborator__cursor-hint",
        userId,
        point: cursor,
        color,
        zoom: zoomLevel,
        viewport: viewportPageBounds
      },
      userId + "_cursor_hint"
    ) : null,
    CollaboratorScribble && scribbles.length ? (0, import_jsx_runtime8.jsx)(import_jsx_runtime8.Fragment, { children: scribbles.map((scribble) => (0, import_jsx_runtime8.jsx)(
      CollaboratorScribble,
      {
        className: "tl-collaborator__scribble",
        userId,
        scribble,
        color,
        zoom: zoomLevel,
        opacity: scribble.color === "laser" ? 0.5 : 0.1
      },
      userId + "_scribble_" + scribble.id
    )) }) : null,
    CollaboratorShapeIndicator && selectedShapeIds.filter((id) => !editor.isShapeHidden(id)).map((shapeId) => (0, import_jsx_runtime8.jsx)(
      CollaboratorShapeIndicator,
      {
        className: "tl-collaborator__shape-indicator",
        userId,
        shapeId,
        color,
        opacity: 0.5
      },
      userId + "_" + shapeId
    ))
  ] });
});
function getStateFromElapsedTime(editor, elapsed) {
  return elapsed > editor.options.collaboratorInactiveTimeoutMs ? "inactive" : elapsed > editor.options.collaboratorIdleTimeoutMs ? "idle" : "active";
}
function useCollaboratorState(editor, latestPresence) {
  const rLastActivityTimestamp = (0, import_react21.useRef)((latestPresence == null ? void 0 : latestPresence.lastActivityTimestamp) ?? -1);
  const [state, setState] = (0, import_react21.useState)(
    () => getStateFromElapsedTime(editor, Date.now() - rLastActivityTimestamp.current)
  );
  (0, import_react21.useEffect)(() => {
    const interval = editor.timers.setInterval(() => {
      setState(getStateFromElapsedTime(editor, Date.now() - rLastActivityTimestamp.current));
    }, editor.options.collaboratorCheckIntervalMs);
    return () => clearInterval(interval);
  }, [editor]);
  if (latestPresence) {
    rLastActivityTimestamp.current = latestPresence.lastActivityTimestamp ?? Infinity;
  }
  return state;
}

// node_modules/@tldraw/editor/dist-esm/lib/components/MenuClickCapture.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);
function MenuClickCapture() {
  const editor = useEditor();
  const isMenuOpen = useValue("is menu open", () => editor.menus.hasAnyOpenMenus(), [editor]);
  const [isPointing, setIsPointing] = (0, import_react22.useState)(false);
  const showElement = isMenuOpen || isPointing;
  const canvasEvents = useCanvasEvents();
  const rPointerState = (0, import_react22.useRef)({
    isDown: false,
    isDragging: false,
    start: new Vec()
  });
  const handlePointerDown = (0, import_react22.useCallback)(
    (e) => {
      if (e.button === 0) {
        setIsPointing(true);
        rPointerState.current = {
          isDown: true,
          isDragging: false,
          start: new Vec(e.clientX, e.clientY)
        };
      }
      editor.menus.clearOpenMenus();
    },
    [editor]
  );
  const handlePointerMove = (0, import_react22.useCallback)(
    (e) => {
      var _a5, _b, _c;
      if (!rPointerState.current.isDown)
        return;
      if (rPointerState.current.isDragging) {
        (_a5 = canvasEvents.onPointerMove) == null ? void 0 : _a5.call(canvasEvents, e);
        return;
      }
      if (
        // We're pointing, but are we dragging?
        Vec.Dist2(rPointerState.current.start, new Vec(e.clientX, e.clientY)) > editor.options.dragDistanceSquared
      ) {
        rPointerState.current = {
          ...rPointerState.current,
          isDown: true,
          isDragging: true
        };
        const { x, y } = rPointerState.current.start;
        (_b = canvasEvents.onPointerDown) == null ? void 0 : _b.call(canvasEvents, {
          ...e,
          clientX: x,
          clientY: y,
          button: 0
        });
        (_c = canvasEvents.onPointerMove) == null ? void 0 : _c.call(canvasEvents, e);
      }
    },
    [canvasEvents, editor]
  );
  const handlePointerUp = (0, import_react22.useCallback)(
    (e) => {
      var _a5;
      (_a5 = canvasEvents.onPointerUp) == null ? void 0 : _a5.call(canvasEvents, e);
      setIsPointing(false);
      rPointerState.current = {
        isDown: false,
        isDragging: false,
        start: new Vec(e.clientX, e.clientY)
      };
    },
    [canvasEvents]
  );
  return showElement && (0, import_jsx_runtime9.jsx)(
    "div",
    {
      className: "tlui-menu-click-capture",
      "data-testid": "menu-click-capture.content",
      ...canvasEvents,
      onPointerDown: handlePointerDown,
      onPointerMove: handlePointerMove,
      onPointerUp: handlePointerUp
    }
  );
}

// node_modules/@tldraw/editor/dist-esm/lib/components/Shape.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/utils/areShapesContentEqual.mjs
var areShapesContentEqual = (a, b) => a.props === b.props && a.meta === b.meta;

// node_modules/@tldraw/editor/dist-esm/lib/components/Shape.mjs
var Shape = (0, import_react23.memo)(function Shape2({
  id,
  shape,
  util,
  index: index3,
  backgroundIndex,
  opacity,
  dprMultiple
}) {
  const editor = useEditor();
  const { ShapeErrorFallback } = useEditorComponents();
  const containerRef = (0, import_react23.useRef)(null);
  const bgContainerRef = (0, import_react23.useRef)(null);
  (0, import_react23.useEffect)(() => {
    return react("load fonts", () => {
      const fonts = editor.fonts.getShapeFontFaces(id);
      editor.fonts.requestFonts(fonts);
    });
  }, [editor, id]);
  const memoizedStuffRef = (0, import_react23.useRef)({
    transform: "",
    clipPath: "none",
    width: 0,
    height: 0,
    x: 0,
    y: 0,
    isCulled: false
  });
  useQuickReactor(
    "set shape stuff",
    () => {
      const shape2 = editor.getShape(id);
      if (!shape2)
        return;
      const prev = memoizedStuffRef.current;
      const clipPath = editor.getShapeClipPath(id) ?? "none";
      if (clipPath !== prev.clipPath) {
        setStyleProperty(containerRef.current, "clip-path", clipPath);
        setStyleProperty(bgContainerRef.current, "clip-path", clipPath);
        prev.clipPath = clipPath;
      }
      const pageTransform = editor.getShapePageTransform(id);
      const transform = Mat.toCssString(pageTransform);
      const bounds = editor.getShapeGeometry(shape2).bounds;
      if (transform !== prev.transform) {
        setStyleProperty(containerRef.current, "transform", transform);
        setStyleProperty(bgContainerRef.current, "transform", transform);
        prev.transform = transform;
      }
      const widthRemainder = bounds.w % dprMultiple;
      const heightRemainder = bounds.h % dprMultiple;
      const width = widthRemainder === 0 ? bounds.w : bounds.w + (dprMultiple - widthRemainder);
      const height = heightRemainder === 0 ? bounds.h : bounds.h + (dprMultiple - heightRemainder);
      if (width !== prev.width || height !== prev.height) {
        setStyleProperty(containerRef.current, "width", Math.max(width, dprMultiple) + "px");
        setStyleProperty(containerRef.current, "height", Math.max(height, dprMultiple) + "px");
        setStyleProperty(bgContainerRef.current, "width", Math.max(width, dprMultiple) + "px");
        setStyleProperty(bgContainerRef.current, "height", Math.max(height, dprMultiple) + "px");
        prev.width = width;
        prev.height = height;
      }
    },
    [editor]
  );
  (0, import_react23.useLayoutEffect)(() => {
    const container = containerRef.current;
    const bgContainer = bgContainerRef.current;
    setStyleProperty(container, "opacity", opacity);
    setStyleProperty(bgContainer, "opacity", opacity);
    setStyleProperty(container, "z-index", index3);
    setStyleProperty(bgContainer, "z-index", backgroundIndex);
  }, [opacity, index3, backgroundIndex]);
  useQuickReactor(
    "set display",
    () => {
      const shape2 = editor.getShape(id);
      if (!shape2)
        return;
      const culledShapes = editor.getCulledShapes();
      const isCulled = culledShapes.has(id);
      if (isCulled !== memoizedStuffRef.current.isCulled) {
        setStyleProperty(containerRef.current, "display", isCulled ? "none" : "block");
        setStyleProperty(bgContainerRef.current, "display", isCulled ? "none" : "block");
        memoizedStuffRef.current.isCulled = isCulled;
      }
    },
    [editor]
  );
  const annotateError2 = (0, import_react23.useCallback)(
    (error) => editor.annotateError(error, { origin: "shape", willCrashApp: false }),
    [editor]
  );
  if (!shape)
    return null;
  const isFilledShape = "fill" in shape.props && shape.props.fill !== "none";
  return (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
    util.backgroundComponent && (0, import_jsx_runtime10.jsx)(
      "div",
      {
        ref: bgContainerRef,
        className: "tl-shape tl-shape-background",
        "data-shape-type": shape.type,
        "data-shape-id": shape.id,
        draggable: false,
        children: (0, import_jsx_runtime10.jsx)(OptionalErrorBoundary, { fallback: ShapeErrorFallback, onError: annotateError2, children: (0, import_jsx_runtime10.jsx)(InnerShapeBackground, { shape, util }) })
      }
    ),
    (0, import_jsx_runtime10.jsx)(
      "div",
      {
        ref: containerRef,
        className: "tl-shape",
        "data-shape-type": shape.type,
        "data-shape-is-filled": isFilledShape,
        "data-shape-id": shape.id,
        draggable: false,
        children: (0, import_jsx_runtime10.jsx)(OptionalErrorBoundary, { fallback: ShapeErrorFallback, onError: annotateError2, children: (0, import_jsx_runtime10.jsx)(InnerShape, { shape, util }) })
      }
    )
  ] });
});
var InnerShape = (0, import_react23.memo)(
  function InnerShape2({ shape, util }) {
    return useStateTracking(
      "InnerShape:" + shape.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        util.component(util.editor.store.unsafeGetWithoutCapture(shape.id))
      ),
      [util, shape.id]
    );
  },
  (prev, next) => areShapesContentEqual(prev.shape, next.shape) && prev.util === next.util
);
var InnerShapeBackground = (0, import_react23.memo)(
  function InnerShapeBackground2({
    shape,
    util
  }) {
    return useStateTracking(
      "InnerShape:" + shape.type,
      () => {
        var _a5;
        return (
          // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
          // calling the render method with stale data.
          (_a5 = util.backgroundComponent) == null ? void 0 : _a5.call(util, util.editor.store.unsafeGetWithoutCapture(shape.id))
        );
      },
      [util, shape.id]
    );
  },
  (prev, next) => prev.shape.props === next.shape.props && prev.shape.meta === next.shape.meta && prev.util === next.util
);

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultCanvas.mjs
function DefaultCanvas({ className }) {
  const editor = useEditor();
  const { SelectionBackground, Background, SvgDefs, ShapeIndicators } = useEditorComponents();
  const rCanvas = (0, import_react24.useRef)(null);
  const rHtmlLayer = (0, import_react24.useRef)(null);
  const rHtmlLayer2 = (0, import_react24.useRef)(null);
  const container = useContainer();
  useScreenBounds(rCanvas);
  useDocumentEvents();
  useCoarsePointer();
  useGestureEvents(rCanvas);
  useFixSafariDoubleTapZoomPencilEvents(rCanvas);
  const rMemoizedStuff = (0, import_react24.useRef)({ lodDisableTextOutline: false, allowTextOutline: true });
  useQuickReactor(
    "position layers",
    function positionLayersWhenCameraMoves() {
      const { x, y, z } = editor.getCamera();
      if (rMemoizedStuff.current.allowTextOutline && tlenv.isSafari) {
        container.style.setProperty("--tl-text-outline", "none");
        rMemoizedStuff.current.allowTextOutline = false;
      }
      if (rMemoizedStuff.current.allowTextOutline && z < editor.options.textShadowLod !== rMemoizedStuff.current.lodDisableTextOutline) {
        const lodDisableTextOutline = z < editor.options.textShadowLod;
        container.style.setProperty(
          "--tl-text-outline",
          lodDisableTextOutline ? "none" : `var(--tl-text-outline-reference)`
        );
        rMemoizedStuff.current.lodDisableTextOutline = lodDisableTextOutline;
      }
      const offset5 = z >= 1 ? modulate(z, [1, 8], [0.125, 0.5], true) : modulate(z, [0.1, 1], [-2, 0.125], true);
      const transform = `scale(${toDomPrecision(z)}) translate(${toDomPrecision(
        x + offset5
      )}px,${toDomPrecision(y + offset5)}px)`;
      setStyleProperty(rHtmlLayer.current, "transform", transform);
      setStyleProperty(rHtmlLayer2.current, "transform", transform);
    },
    [editor, container]
  );
  const events = useCanvasEvents();
  const shapeSvgDefs = useValue(
    "shapeSvgDefs",
    () => {
      const shapeSvgDefsByKey = /* @__PURE__ */ new Map();
      for (const util of objectMapValues(editor.shapeUtils)) {
        if (!util)
          return;
        const defs = util.getCanvasSvgDefs();
        for (const { key, component: Component2 } of defs) {
          if (shapeSvgDefsByKey.has(key))
            continue;
          shapeSvgDefsByKey.set(key, (0, import_jsx_runtime11.jsx)(Component2, {}, key));
        }
      }
      return [...shapeSvgDefsByKey.values()];
    },
    [editor]
  );
  const hideShapes = useValue("debug_shapes", () => debugFlags.hideShapes.get(), [debugFlags]);
  const debugSvg = useValue("debug_svg", () => debugFlags.debugSvg.get(), [debugFlags]);
  const debugGeometry = useValue("debug_geometry", () => debugFlags.debugGeometry.get(), [
    debugFlags
  ]);
  const isEditingAnything = useValue(
    "isEditingAnything",
    () => editor.getEditingShapeId() !== null,
    [editor]
  );
  const isSelectingAnything = useValue(
    "isSelectingAnything",
    () => !!editor.getSelectedShapeIds().length,
    [editor]
  );
  return (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [
    (0, import_jsx_runtime11.jsxs)(
      "div",
      {
        ref: rCanvas,
        draggable: false,
        "data-iseditinganything": isEditingAnything,
        "data-isselectinganything": isSelectingAnything,
        className: (0, import_classnames.default)("tl-canvas", className),
        "data-testid": "canvas",
        ...events,
        children: [
          (0, import_jsx_runtime11.jsx)("svg", { className: "tl-svg-context", children: (0, import_jsx_runtime11.jsxs)("defs", { children: [
            shapeSvgDefs,
            (0, import_jsx_runtime11.jsx)(CursorDef, {}),
            (0, import_jsx_runtime11.jsx)(CollaboratorHintDef, {}),
            SvgDefs && (0, import_jsx_runtime11.jsx)(SvgDefs, {})
          ] }) }),
          Background && (0, import_jsx_runtime11.jsx)("div", { className: "tl-background__wrapper", children: (0, import_jsx_runtime11.jsx)(Background, {}) }),
          (0, import_jsx_runtime11.jsx)(GridWrapper, {}),
          (0, import_jsx_runtime11.jsxs)("div", { ref: rHtmlLayer, className: "tl-html-layer tl-shapes", draggable: false, children: [
            (0, import_jsx_runtime11.jsx)(OnTheCanvasWrapper, {}),
            SelectionBackground && (0, import_jsx_runtime11.jsx)(SelectionBackgroundWrapper, {}),
            hideShapes ? null : debugSvg ? (0, import_jsx_runtime11.jsx)(ShapesWithSVGs, {}) : (0, import_jsx_runtime11.jsx)(ShapesToDisplay, {})
          ] }),
          (0, import_jsx_runtime11.jsx)("div", { className: "tl-overlays", children: (0, import_jsx_runtime11.jsxs)("div", { ref: rHtmlLayer2, className: "tl-html-layer", children: [
            debugGeometry ? (0, import_jsx_runtime11.jsx)(GeometryDebuggingView, {}) : null,
            (0, import_jsx_runtime11.jsx)(BrushWrapper, {}),
            (0, import_jsx_runtime11.jsx)(ScribbleWrapper, {}),
            (0, import_jsx_runtime11.jsx)(ZoomBrushWrapper, {}),
            ShapeIndicators && (0, import_jsx_runtime11.jsx)(ShapeIndicators, {}),
            (0, import_jsx_runtime11.jsx)(HintedShapeIndicator, {}),
            (0, import_jsx_runtime11.jsx)(SnapIndicatorWrapper, {}),
            (0, import_jsx_runtime11.jsx)(SelectionForegroundWrapper, {}),
            (0, import_jsx_runtime11.jsx)(HandlesWrapper, {}),
            (0, import_jsx_runtime11.jsx)(OverlaysWrapper, {}),
            (0, import_jsx_runtime11.jsx)(LiveCollaborators, {})
          ] }) }),
          (0, import_jsx_runtime11.jsx)(MovingCameraHitTestBlocker, {})
        ]
      }
    ),
    (0, import_jsx_runtime11.jsx)(MenuClickCapture, {}),
    (0, import_jsx_runtime11.jsx)(InFrontOfTheCanvasWrapper, {})
  ] });
}
function InFrontOfTheCanvasWrapper() {
  const { InFrontOfTheCanvas } = useEditorComponents();
  if (!InFrontOfTheCanvas)
    return null;
  return (0, import_jsx_runtime11.jsx)(InFrontOfTheCanvas, {});
}
function GridWrapper() {
  const editor = useEditor();
  const gridSize = useValue("gridSize", () => editor.getDocumentSettings().gridSize, [editor]);
  const { x, y, z } = useValue("camera", () => editor.getCamera(), [editor]);
  const isGridMode = useValue("isGridMode", () => editor.getInstanceState().isGridMode, [editor]);
  const { Grid } = useEditorComponents();
  if (!(Grid && isGridMode))
    return null;
  return (0, import_jsx_runtime11.jsx)(Grid, { x, y, z, size: gridSize });
}
function ScribbleWrapper() {
  const editor = useEditor();
  const scribbles = useValue("scribbles", () => editor.getInstanceState().scribbles, [editor]);
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const { Scribble } = useEditorComponents();
  if (!(Scribble && scribbles.length))
    return null;
  return scribbles.map((scribble) => (0, import_jsx_runtime11.jsx)(Scribble, { className: "tl-user-scribble", scribble, zoom: zoomLevel }, scribble.id));
}
function BrushWrapper() {
  const editor = useEditor();
  const brush = useValue("brush", () => editor.getInstanceState().brush, [editor]);
  const { Brush } = useEditorComponents();
  if (!(Brush && brush))
    return null;
  return (0, import_jsx_runtime11.jsx)(Brush, { className: "tl-user-brush", brush });
}
function ZoomBrushWrapper() {
  const editor = useEditor();
  const zoomBrush = useValue("zoomBrush", () => editor.getInstanceState().zoomBrush, [editor]);
  const { ZoomBrush } = useEditorComponents();
  if (!(ZoomBrush && zoomBrush))
    return null;
  return (0, import_jsx_runtime11.jsx)(ZoomBrush, { className: "tl-user-brush tl-zoom-brush", brush: zoomBrush });
}
function SnapIndicatorWrapper() {
  const editor = useEditor();
  const lines = useValue("snapLines", () => editor.snaps.getIndicators(), [editor]);
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const { SnapIndicator } = useEditorComponents();
  if (!(SnapIndicator && lines.length > 0))
    return null;
  return lines.map((line) => (0, import_jsx_runtime11.jsx)(SnapIndicator, { className: "tl-user-snapline", line, zoom: zoomLevel }, line.id));
}
function HandlesWrapper() {
  const editor = useEditor();
  const shapeIdWithHandles = useValue(
    "handles shapeIdWithHandles",
    () => {
      const { isReadonly, isChangingStyle } = editor.getInstanceState();
      if (isReadonly || isChangingStyle)
        return false;
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape)
        return false;
      const handles = editor.getShapeHandles(onlySelectedShape);
      if (!handles)
        return false;
      return onlySelectedShape.id;
    },
    [editor]
  );
  if (!shapeIdWithHandles)
    return null;
  return (0, import_jsx_runtime11.jsx)(HandlesWrapperInner, { shapeId: shapeIdWithHandles });
}
function HandlesWrapperInner({ shapeId }) {
  const editor = useEditor();
  const { Handles } = useEditorComponents();
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const isCoarse = useValue("coarse pointer", () => editor.getInstanceState().isCoarsePointer, [
    editor
  ]);
  const transform = useValue("handles transform", () => editor.getShapePageTransform(shapeId), [
    editor,
    shapeId
  ]);
  const handles = useValue(
    "handles",
    () => {
      const handles2 = editor.getShapeHandles(shapeId);
      if (!handles2)
        return null;
      const minDistBetweenVirtualHandlesAndRegularHandles = (isCoarse ? editor.options.coarseHandleRadius : editor.options.handleRadius) / zoomLevel * 2;
      return handles2.filter(
        (handle) => (
          // if the handle isn't a virtual handle, we'll display it
          // but for virtual handles, we'll only display them if they're far enough away from vertex handles
          handle.type !== "virtual" || !handles2.some(
            (h) => (
              // skip the handle we're checking against
              // and check that their distance isn't below the minimum distance
              h !== handle && // only check against vertex handles
              h.type === "vertex" && Vec.Dist(handle, h) < minDistBetweenVirtualHandlesAndRegularHandles
            )
          )
        )
      ).sort((a) => a.type === "vertex" ? 1 : -1);
    },
    [editor, zoomLevel, isCoarse, shapeId]
  );
  const isHidden2 = useValue("isHidden", () => editor.isShapeHidden(shapeId), [editor, shapeId]);
  if (!Handles || !handles || !transform || isHidden2) {
    return null;
  }
  return (0, import_jsx_runtime11.jsx)(Handles, { children: (0, import_jsx_runtime11.jsx)("g", { transform: Mat.toCssString(transform), children: handles.map((handle) => {
    return (0, import_jsx_runtime11.jsx)(
      HandleWrapper,
      {
        shapeId,
        handle,
        zoom: zoomLevel,
        isCoarse
      },
      handle.id
    );
  }) }) });
}
function HandleWrapper({
  shapeId,
  handle,
  zoom,
  isCoarse
}) {
  const events = useHandleEvents(shapeId, handle.id);
  const { Handle } = useEditorComponents();
  if (!Handle)
    return null;
  return (0, import_jsx_runtime11.jsx)(
    "g",
    {
      role: "button",
      "aria-label": handle.label || "handle",
      transform: `translate(${handle.x}, ${handle.y})`,
      ...events,
      children: (0, import_jsx_runtime11.jsx)(Handle, { shapeId, handle, zoom, isCoarse })
    }
  );
}
function OverlaysWrapper() {
  const { Overlays } = useEditorComponents();
  if (!Overlays)
    return null;
  return (0, import_jsx_runtime11.jsx)("div", { className: "tl-custom-overlays tl-overlays__item", children: (0, import_jsx_runtime11.jsx)(Overlays, {}) });
}
function ShapesWithSVGs() {
  const editor = useEditor();
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  const dprMultiple = useValue(
    "dpr multiple",
    () => (
      // dprMultiple is the smallest number we can multiply dpr by to get an integer
      // it's usually 1, 2, or 4 (for e.g. dpr of 2, 2.5 and 2.25 respectively)
      nearestMultiple(Math.floor(editor.getInstanceState().devicePixelRatio * 100) / 100)
    ),
    [editor]
  );
  return renderingShapes.map((result) => (0, import_jsx_runtime11.jsxs)(import_react24.Fragment, { children: [
    (0, import_jsx_runtime11.jsx)(Shape, { ...result, dprMultiple }),
    (0, import_jsx_runtime11.jsx)(DebugSvgCopy, { id: result.id, mode: "iframe" })
  ] }, result.id + "_fragment"));
}
function ReflowIfNeeded() {
  const editor = useEditor();
  const culledShapesRef = (0, import_react24.useRef)(/* @__PURE__ */ new Set());
  useQuickReactor(
    "reflow for culled shapes",
    () => {
      const culledShapes = editor.getCulledShapes();
      if (culledShapesRef.current.size === culledShapes.size && [...culledShapes].every((id) => culledShapesRef.current.has(id)))
        return;
      culledShapesRef.current = culledShapes;
      const canvas = document.getElementsByClassName("tl-canvas");
      if (canvas.length === 0)
        return;
      const _height = canvas[0].offsetHeight;
    },
    [editor]
  );
  return null;
}
function ShapesToDisplay() {
  const editor = useEditor();
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  const dprMultiple = useValue(
    "dpr multiple",
    () => (
      // dprMultiple is the smallest number we can multiply dpr by to get an integer
      // it's usually 1, 2, or 4 (for e.g. dpr of 2, 2.5 and 2.25 respectively)
      nearestMultiple(Math.floor(editor.getInstanceState().devicePixelRatio * 100) / 100)
    ),
    [editor]
  );
  return (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [
    renderingShapes.map((result) => (0, import_jsx_runtime11.jsx)(Shape, { ...result, dprMultiple }, result.id + "_shape")),
    tlenv.isSafari && (0, import_jsx_runtime11.jsx)(ReflowIfNeeded, {})
  ] });
}
function HintedShapeIndicator() {
  const editor = useEditor();
  const { ShapeIndicator } = useEditorComponents();
  const ids = useValue("hinting shape ids", () => dedupe(editor.getHintingShapeIds()), [editor]);
  if (!ids.length)
    return null;
  if (!ShapeIndicator)
    return null;
  return ids.map((id) => (0, import_jsx_runtime11.jsx)(ShapeIndicator, { className: "tl-user-indicator__hint", shapeId: id }, id + "_hinting"));
}
function CursorDef() {
  return (0, import_jsx_runtime11.jsxs)("g", { id: useSharedSafeId("cursor"), children: [
    (0, import_jsx_runtime11.jsxs)("g", { fill: "rgba(0,0,0,.2)", transform: "translate(-11,-11)", children: [
      (0, import_jsx_runtime11.jsx)("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      (0, import_jsx_runtime11.jsx)("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    (0, import_jsx_runtime11.jsxs)("g", { fill: "white", transform: "translate(-12,-12)", children: [
      (0, import_jsx_runtime11.jsx)("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      (0, import_jsx_runtime11.jsx)("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    (0, import_jsx_runtime11.jsxs)("g", { fill: "currentColor", transform: "translate(-12,-12)", children: [
      (0, import_jsx_runtime11.jsx)("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
      (0, import_jsx_runtime11.jsx)("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
    ] })
  ] });
}
function CollaboratorHintDef() {
  const cursorHintId = useSharedSafeId("cursor_hint");
  return (0, import_jsx_runtime11.jsx)("path", { id: cursorHintId, fill: "currentColor", d: "M -2,-5 2,0 -2,5 Z" });
}
function DebugSvgCopy({ id, mode }) {
  const editor = useEditor();
  const [image, setImage] = (0, import_react24.useState)(null);
  const isInRoot = useValue(
    "is in root",
    () => {
      const shape = editor.getShape(id);
      return (shape == null ? void 0 : shape.parentId) === editor.getCurrentPageId();
    },
    [editor, id]
  );
  (0, import_react24.useEffect)(() => {
    if (!isInRoot)
      return;
    let latest = null;
    const unsubscribe = react("shape to svg", async () => {
      const renderId = Math.random();
      latest = renderId;
      const isSingleFrame = editor.isShapeOfType(id, "frame");
      const padding = isSingleFrame ? 0 : 10;
      let bounds = editor.getShapePageBounds(id);
      if (!bounds)
        return;
      bounds = bounds.clone().expandBy(padding);
      const result = await editor.getSvgString([id], { padding });
      if (latest !== renderId || !result)
        return;
      const svgDataUrl = `data:image/svg+xml;utf8,${encodeURIComponent(result.svg)}`;
      setImage({ src: svgDataUrl, bounds });
    });
    return () => {
      latest = null;
      unsubscribe();
    };
  }, [editor, id, isInRoot]);
  if (!isInRoot || !image)
    return null;
  if (mode === "iframe") {
    return (0, import_jsx_runtime11.jsx)(
      "iframe",
      {
        src: image.src,
        width: image.bounds.width,
        height: image.bounds.height,
        referrerPolicy: "no-referrer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          border: "none",
          transform: `translate(${image.bounds.x}px, ${image.bounds.maxY + 12}px)`,
          outline: "1px solid black",
          maxWidth: "none"
        }
      }
    );
  }
  return (0, import_jsx_runtime11.jsx)(
    "img",
    {
      src: image.src,
      width: image.bounds.width,
      height: image.bounds.height,
      referrerPolicy: "no-referrer",
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        transform: `translate(${image.bounds.x}px, ${image.bounds.maxY + 12}px)`,
        outline: "1px solid black",
        maxWidth: "none"
      }
    }
  );
}
function SelectionForegroundWrapper() {
  const editor = useEditor();
  const selectionRotation = useValue(
    "selection rotation",
    function getSelectionRotation() {
      return editor.getSelectionRotation();
    },
    [editor]
  );
  const selectionBounds = useValue(
    "selection bounds",
    () => editor.getSelectionRotatedPageBounds(),
    [editor]
  );
  const { SelectionForeground } = useEditorComponents();
  if (!selectionBounds || !SelectionForeground)
    return null;
  return (0, import_jsx_runtime11.jsx)(SelectionForeground, { bounds: selectionBounds, rotation: selectionRotation });
}
function SelectionBackgroundWrapper() {
  const editor = useEditor();
  const selectionRotation = useValue("selection rotation", () => editor.getSelectionRotation(), [
    editor
  ]);
  const selectionBounds = useValue(
    "selection bounds",
    () => editor.getSelectionRotatedPageBounds(),
    [editor]
  );
  const { SelectionBackground } = useEditorComponents();
  if (!selectionBounds || !SelectionBackground)
    return null;
  return (0, import_jsx_runtime11.jsx)(SelectionBackground, { bounds: selectionBounds, rotation: selectionRotation });
}
function OnTheCanvasWrapper() {
  const { OnTheCanvas } = useEditorComponents();
  if (!OnTheCanvas)
    return null;
  return (0, import_jsx_runtime11.jsx)(OnTheCanvas, {});
}
function MovingCameraHitTestBlocker() {
  const editor = useEditor();
  const cameraState = useValue("camera state", () => editor.getCameraState(), [editor]);
  return (0, import_jsx_runtime11.jsx)(
    "div",
    {
      className: (0, import_classnames.default)("tl-hit-test-blocker", {
        "tl-hit-test-blocker__hidden": cameraState === "idle"
      })
    }
  );
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultCollaboratorHint.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_classnames2 = __toESM(require_classnames(), 1);
var import_react25 = __toESM(require_react(), 1);
function DefaultCollaboratorHint({
  className,
  zoom,
  point,
  color,
  viewport: viewport2,
  opacity = 1
}) {
  const rSvg = (0, import_react25.useRef)(null);
  useTransform(
    rSvg,
    clamp(point.x, viewport2.minX + 5 / zoom, viewport2.maxX - 5 / zoom),
    clamp(point.y, viewport2.minY + 5 / zoom, viewport2.maxY - 5 / zoom),
    1 / zoom,
    Vec.Angle(viewport2.center, point)
  );
  const cursorHintId = useSharedSafeId("cursor_hint");
  return (0, import_jsx_runtime12.jsxs)("svg", { ref: rSvg, className: (0, import_classnames2.default)("tl-overlays__item", className), children: [
    (0, import_jsx_runtime12.jsx)(
      "use",
      {
        href: `#${cursorHintId}`,
        color,
        strokeWidth: 3,
        stroke: "var(--color-background)"
      }
    ),
    (0, import_jsx_runtime12.jsx)("use", { href: `#${cursorHintId}`, color, opacity })
  ] });
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultCursor.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_classnames3 = __toESM(require_classnames(), 1);
var import_react26 = __toESM(require_react(), 1);
var DefaultCursor = (0, import_react26.memo)(function DefaultCursor2({
  className,
  zoom,
  point,
  color,
  name,
  chatMessage
}) {
  const rCursor = (0, import_react26.useRef)(null);
  useTransform(rCursor, point == null ? void 0 : point.x, point == null ? void 0 : point.y, 1 / zoom);
  const cursorId = useSharedSafeId("cursor");
  if (!point)
    return null;
  return (0, import_jsx_runtime13.jsxs)("div", { ref: rCursor, className: (0, import_classnames3.default)("tl-overlays__item", className), children: [
    (0, import_jsx_runtime13.jsx)("svg", { className: "tl-cursor", children: (0, import_jsx_runtime13.jsx)("use", { href: `#${cursorId}`, color }) }),
    chatMessage ? (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, { children: [
      name && (0, import_jsx_runtime13.jsx)("div", { className: "tl-nametag-title", style: { color }, children: name }),
      (0, import_jsx_runtime13.jsx)("div", { className: "tl-nametag-chat", style: { backgroundColor: color }, children: chatMessage })
    ] }) : name && (0, import_jsx_runtime13.jsx)("div", { className: "tl-nametag", style: { backgroundColor: color }, children: name })
  ] });
});

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultGrid.mjs
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function DefaultGrid({ x, y, z, size: size4 }) {
  const id = useUniqueSafeId("grid");
  const editor = useEditor();
  const { gridSteps } = editor.options;
  return (0, import_jsx_runtime14.jsxs)("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: [
    (0, import_jsx_runtime14.jsx)("defs", { children: gridSteps.map(({ min: min4, mid, step }, i) => {
      const s = step * size4 * z;
      const xo = 0.5 + x * z;
      const yo = 0.5 + y * z;
      const gxo = xo > 0 ? xo % s : s + xo % s;
      const gyo = yo > 0 ? yo % s : s + yo % s;
      const opacity = z < mid ? modulate(z, [min4, mid], [0, 1]) : 1;
      return (0, import_jsx_runtime14.jsx)(
        "pattern",
        {
          id: suffixSafeId(id, `${step}`),
          width: s,
          height: s,
          patternUnits: "userSpaceOnUse",
          children: (0, import_jsx_runtime14.jsx)("circle", { className: "tl-grid-dot", cx: gxo, cy: gyo, r: 1, opacity })
        },
        i
      );
    }) }),
    gridSteps.map(({ step }, i) => (0, import_jsx_runtime14.jsx)("rect", { width: "100%", height: "100%", fill: `url(#${id}_${step})` }, i))
  ] });
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultHandle.mjs
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_classnames4 = __toESM(require_classnames(), 1);
function DefaultHandle({ handle, isCoarse, className, zoom }) {
  const editor = useEditor();
  const br = (isCoarse ? editor.options.coarseHandleRadius : editor.options.handleRadius) / zoom;
  if (handle.type === "clone") {
    const fr2 = 3 / zoom;
    const path = `M0,${-fr2} A${fr2},${fr2} 0 0,1 0,${fr2}`;
    const index3 = SIDES.indexOf(handle.id);
    return (0, import_jsx_runtime15.jsxs)("g", { className: (0, import_classnames4.default)(`tl-handle tl-handle__${handle.type}`, className), children: [
      (0, import_jsx_runtime15.jsx)("circle", { className: "tl-handle__bg", r: br }),
      (0, import_jsx_runtime15.jsx)("path", { className: "tl-handle__fg", d: path, transform: `rotate(${-90 + 90 * index3})` })
    ] });
  }
  const fr = (handle.type === "create" && isCoarse ? 3 : 4) / Math.max(zoom, 0.25);
  return (0, import_jsx_runtime15.jsxs)("g", { className: (0, import_classnames4.default)(`tl-handle tl-handle__${handle.type}`, className), children: [
    (0, import_jsx_runtime15.jsx)("circle", { className: "tl-handle__bg", r: br }),
    (0, import_jsx_runtime15.jsx)("circle", { className: "tl-handle__fg", r: fr })
  ] });
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultHandles.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var DefaultHandles = ({ children }) => {
  return (0, import_jsx_runtime16.jsx)("svg", { className: "tl-user-handles tl-overlays__item", children });
};

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultLoadingScreen.mjs
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var DefaultLoadingScreen = () => {
  const { Spinner: Spinner2 } = useEditorComponents();
  return (0, import_jsx_runtime17.jsx)(LoadingScreen, { children: Spinner2 ? (0, import_jsx_runtime17.jsx)(Spinner2, {}) : null });
};

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultScribble.mjs
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_classnames5 = __toESM(require_classnames(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/utils/getSvgPathFromPoints.mjs
function getSvgPathFromPoints(points, closed = true) {
  const len = points.length;
  if (len < 2) {
    return "";
  }
  let a = points[0];
  let b = points[1];
  if (len === 2) {
    return `M${precise(a)}L${precise(b)}`;
  }
  let result = "";
  for (let i = 2, max3 = len - 1; i < max3; i++) {
    a = points[i];
    b = points[i + 1];
    result += average(a, b);
  }
  if (closed) {
    return `M${average(points[0], points[1])}Q${precise(points[1])}${average(
      points[1],
      points[2]
    )}T${result}${average(points[len - 1], points[0])}${average(points[0], points[1])}Z`;
  } else {
    return `M${precise(points[0])}Q${precise(points[1])}${average(points[1], points[2])}${points.length > 3 ? "T" : ""}${result}L${precise(points[len - 1])}`;
  }
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultScribble.mjs
function DefaultScribble({ scribble, zoom, color, opacity, className }) {
  if (!scribble.points.length)
    return null;
  return (0, import_jsx_runtime18.jsx)("svg", { className: className ? (0, import_classnames5.default)("tl-overlays__item", className) : className, children: (0, import_jsx_runtime18.jsx)(
    "path",
    {
      className: "tl-scribble",
      d: getSvgPathFromPoints(scribble.points, false),
      stroke: color ?? `var(--color-${scribble.color})`,
      fill: "none",
      strokeWidth: 8 / zoom,
      opacity: opacity ?? scribble.opacity
    }
  ) });
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultSelectionForeground.mjs
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_classnames6 = __toESM(require_classnames(), 1);
var import_react27 = __toESM(require_react(), 1);
function DefaultSelectionForeground({ bounds, rotation }) {
  const editor = useEditor();
  const rSvg = (0, import_react27.useRef)(null);
  const onlyShape = useValue("only selected shape", () => editor.getOnlySelectedShape(), [editor]);
  const expandOutlineBy = onlyShape ? editor.getShapeUtil(onlyShape).expandSelectionOutlinePx(onlyShape) : 0;
  useTransform(rSvg, bounds == null ? void 0 : bounds.x, bounds == null ? void 0 : bounds.y, 1, rotation, {
    x: -expandOutlineBy,
    y: -expandOutlineBy
  });
  bounds = expandOutlineBy instanceof Box ? bounds.clone().expand(expandOutlineBy).zeroFix() : bounds.clone().expandBy(expandOutlineBy).zeroFix();
  return (0, import_jsx_runtime19.jsx)(
    "svg",
    {
      ref: rSvg,
      className: "tl-overlays__item tl-selection__fg",
      "data-testid": "selection-foreground",
      children: (0, import_jsx_runtime19.jsx)(
        "rect",
        {
          className: (0, import_classnames6.default)("tl-selection__fg__outline"),
          width: toDomPrecision(bounds.width),
          height: toDomPrecision(bounds.height)
        }
      )
    }
  );
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultShapeErrorFallback.mjs
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var DefaultShapeErrorFallback = () => {
  return (0, import_jsx_runtime20.jsx)("div", { className: "tl-shape-error-boundary" });
};

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultShapeIndicator.mjs
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_classnames7 = __toESM(require_classnames(), 1);
var import_react28 = __toESM(require_react(), 1);
var EvenInnererIndicator = (0, import_react28.memo)(
  ({ shape, util }) => {
    return useStateTracking(
      "Indicator: " + shape.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        util.indicator(util.editor.store.unsafeGetWithoutCapture(shape.id))
      )
    );
  },
  (prevProps, nextProps) => {
    return prevProps.shape.props === nextProps.shape.props && prevProps.shape.meta === nextProps.shape.meta;
  }
);
var InnerIndicator = (0, import_react28.memo)(({ editor, id }) => {
  const shape = useValue("shape for indicator", () => editor.store.get(id), [editor, id]);
  const { ShapeIndicatorErrorFallback } = useEditorComponents();
  if (!shape || shape.isLocked)
    return null;
  return (0, import_jsx_runtime21.jsx)(
    OptionalErrorBoundary,
    {
      fallback: ShapeIndicatorErrorFallback,
      onError: (error) => editor.annotateError(error, { origin: "react.shapeIndicator", willCrashApp: false }),
      children: (0, import_jsx_runtime21.jsx)(EvenInnererIndicator, { shape, util: editor.getShapeUtil(shape) }, shape.id)
    }
  );
});
var DefaultShapeIndicator = (0, import_react28.memo)(function DefaultShapeIndicator2({
  shapeId,
  className,
  color,
  hidden,
  opacity
}) {
  const editor = useEditor();
  const rIndicator = (0, import_react28.useRef)(null);
  useQuickReactor(
    "indicator transform",
    () => {
      if (hidden)
        return;
      const elm = rIndicator.current;
      if (!elm)
        return;
      const pageTransform = editor.getShapePageTransform(shapeId);
      if (!pageTransform)
        return;
      elm.style.setProperty("transform", pageTransform.toCssString());
    },
    [editor, shapeId, hidden]
  );
  (0, import_react28.useLayoutEffect)(() => {
    const elm = rIndicator.current;
    if (!elm)
      return;
    elm.style.setProperty("display", hidden ? "none" : "block");
  }, [hidden]);
  return (0, import_jsx_runtime21.jsx)("svg", { ref: rIndicator, className: (0, import_classnames7.default)("tl-overlays__item", className), children: (0, import_jsx_runtime21.jsx)("g", { className: "tl-shape-indicator", stroke: color ?? "var(--color-selected)", opacity, children: (0, import_jsx_runtime21.jsx)(InnerIndicator, { editor, id: shapeId }) }) });
});

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultShapeIndicatorErrorFallback.mjs
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var DefaultShapeIndicatorErrorFallback = () => {
  return (0, import_jsx_runtime22.jsx)("circle", { cx: 4, cy: 4, r: 8, strokeWidth: "1", stroke: "red" });
};

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultShapeIndicators.mjs
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react29 = __toESM(require_react(), 1);
var DefaultShapeIndicators = (0, import_react29.memo)(function DefaultShapeIndicators2({
  hideAll,
  showAll
}) {
  const editor = useEditor();
  if (hideAll && showAll)
    throw Error("You cannot set both hideAll and showAll props to true, cmon now");
  const rPreviousSelectedShapeIds = (0, import_react29.useRef)(/* @__PURE__ */ new Set());
  const idsToDisplay = useValue(
    "should display selected ids",
    () => {
      const prev = rPreviousSelectedShapeIds.current;
      const next = /* @__PURE__ */ new Set();
      const instanceState = editor.getInstanceState();
      const isChangingStyle = instanceState.isChangingStyle;
      const isIdleOrEditing = editor.isInAny("select.idle", "select.editing_shape");
      const isInSelectState = editor.isInAny(
        "select.brushing",
        "select.scribble_brushing",
        "select.pointing_shape",
        "select.pointing_selection",
        "select.pointing_handle"
      );
      if (isChangingStyle || !(isIdleOrEditing || isInSelectState)) {
        rPreviousSelectedShapeIds.current = next;
        return next;
      }
      for (const id of editor.getSelectedShapeIds()) {
        next.add(id);
      }
      if (isIdleOrEditing && instanceState.isHoveringCanvas && !instanceState.isCoarsePointer) {
        const hovered = editor.getHoveredShapeId();
        if (hovered)
          next.add(hovered);
      }
      if (prev.size !== next.size) {
        rPreviousSelectedShapeIds.current = next;
        return next;
      }
      for (const id of next) {
        if (!prev.has(id)) {
          rPreviousSelectedShapeIds.current = next;
          return next;
        }
      }
      return prev;
    },
    [editor]
  );
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  const { ShapeIndicator } = useEditorComponents();
  if (!ShapeIndicator)
    return null;
  return renderingShapes.map(({ id }) => (0, import_jsx_runtime23.jsx)(
    ShapeIndicator,
    {
      shapeId: id,
      hidden: !showAll && (hideAll || !idsToDisplay.has(id))
    },
    id + "_indicator"
  ));
});

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultSnapIndictor.mjs
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_classnames8 = __toESM(require_classnames(), 1);
var React7 = __toESM(require_react(), 1);
function PointsSnapIndicator({ points, zoom }) {
  const l = 2.5 / zoom;
  const minX = points.reduce((acc, p) => Math.min(acc, p.x), Infinity);
  const maxX = points.reduce((acc, p) => Math.max(acc, p.x), -Infinity);
  const minY = points.reduce((acc, p) => Math.min(acc, p.y), Infinity);
  const maxY = points.reduce((acc, p) => Math.max(acc, p.y), -Infinity);
  const useNWtoSEdireciton = points.some((p) => p.x === minX && p.y === minY);
  let firstX, firstY, secondX, secondY;
  if (useNWtoSEdireciton) {
    firstX = minX;
    firstY = minY;
    secondX = maxX;
    secondY = maxY;
  } else {
    firstX = minX;
    firstY = maxY;
    secondX = maxX;
    secondY = minY;
  }
  return (0, import_jsx_runtime24.jsxs)("g", { className: "tl-snap-indicator", stroke: "lime", children: [
    (0, import_jsx_runtime24.jsx)("line", { x1: firstX, y1: firstY, x2: secondX, y2: secondY }),
    points.map((p, i) => (0, import_jsx_runtime24.jsx)("g", { transform: `translate(${p.x},${p.y})`, children: (0, import_jsx_runtime24.jsx)(
      "path",
      {
        className: "tl-snap-point",
        d: `M ${-l},${-l} L ${l},${l} M ${-l},${l} L ${l},${-l}`
      }
    ) }, i))
  ] });
}
function GapsSnapIndicator({ gaps, direction, zoom }) {
  const l = 3.5 / zoom;
  let edgeIntersection = [-Infinity, Infinity];
  let nextEdgeIntersection = null;
  const horizontal = direction === "horizontal";
  for (const gap of gaps) {
    nextEdgeIntersection = rangeIntersection(
      edgeIntersection[0],
      edgeIntersection[1],
      horizontal ? gap.startEdge[0].y : gap.startEdge[0].x,
      horizontal ? gap.startEdge[1].y : gap.startEdge[1].x
    );
    if (nextEdgeIntersection) {
      edgeIntersection = nextEdgeIntersection;
    } else {
      continue;
    }
    nextEdgeIntersection = rangeIntersection(
      edgeIntersection[0],
      edgeIntersection[1],
      horizontal ? gap.endEdge[0].y : gap.endEdge[0].x,
      horizontal ? gap.endEdge[1].y : gap.endEdge[1].x
    );
    if (nextEdgeIntersection) {
      edgeIntersection = nextEdgeIntersection;
    } else {
      continue;
    }
  }
  if (edgeIntersection === null) {
    return null;
  }
  const midPoint2 = (edgeIntersection[0] + edgeIntersection[1]) / 2;
  return (0, import_jsx_runtime24.jsx)("g", { className: "tl-snap-indicator", stroke: "cyan", children: gaps.map(({ startEdge, endEdge }, i) => (0, import_jsx_runtime24.jsx)(React7.Fragment, { children: horizontal ? (
    // horizontal gap
    (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [
      (0, import_jsx_runtime24.jsx)(
        "line",
        {
          x1: startEdge[0].x,
          y1: midPoint2 - 2 * l,
          x2: startEdge[1].x,
          y2: midPoint2 + 2 * l
        }
      ),
      (0, import_jsx_runtime24.jsx)(
        "line",
        {
          x1: endEdge[0].x,
          y1: midPoint2 - 2 * l,
          x2: endEdge[1].x,
          y2: midPoint2 + 2 * l
        }
      ),
      (0, import_jsx_runtime24.jsx)("line", { x1: startEdge[0].x, y1: midPoint2, x2: endEdge[0].x, y2: midPoint2 }),
      (0, import_jsx_runtime24.jsx)(
        "line",
        {
          x1: (startEdge[0].x + endEdge[0].x) / 2,
          y1: midPoint2 - l,
          x2: (startEdge[0].x + endEdge[0].x) / 2,
          y2: midPoint2 + l
        }
      )
    ] })
  ) : (
    // vertical gap
    (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [
      (0, import_jsx_runtime24.jsx)(
        "line",
        {
          x1: midPoint2 - 2 * l,
          y1: startEdge[0].y,
          x2: midPoint2 + 2 * l,
          y2: startEdge[1].y
        }
      ),
      (0, import_jsx_runtime24.jsx)(
        "line",
        {
          x1: midPoint2 - 2 * l,
          y1: endEdge[0].y,
          x2: midPoint2 + 2 * l,
          y2: endEdge[1].y
        }
      ),
      (0, import_jsx_runtime24.jsx)("line", { x1: midPoint2, y1: startEdge[0].y, x2: midPoint2, y2: endEdge[0].y }),
      (0, import_jsx_runtime24.jsx)(
        "line",
        {
          x1: midPoint2 - l,
          y1: (startEdge[0].y + endEdge[0].y) / 2,
          x2: midPoint2 + l,
          y2: (startEdge[0].y + endEdge[0].y) / 2
        }
      )
    ] })
  ) }, i)) });
}
function DefaultSnapIndicator({ className, line, zoom }) {
  return (0, import_jsx_runtime24.jsx)("svg", { className: (0, import_classnames8.default)("tl-overlays__item", className), children: line.type === "points" ? (0, import_jsx_runtime24.jsx)(PointsSnapIndicator, { ...line, zoom }) : line.type === "gaps" ? (0, import_jsx_runtime24.jsx)(GapsSnapIndicator, { ...line, zoom }) : null });
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultSpinner.mjs
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
function DefaultSpinner() {
  return (0, import_jsx_runtime25.jsx)("svg", { width: 16, height: 16, viewBox: "0 0 16 16", "aria-hidden": "false", children: (0, import_jsx_runtime25.jsxs)("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
    (0, import_jsx_runtime25.jsx)("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
    (0, import_jsx_runtime25.jsx)("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor", children: (0, import_jsx_runtime25.jsx)(
      "animateTransform",
      {
        attributeName: "transform",
        type: "rotate",
        from: "0 8 8",
        to: "360 8 8",
        dur: "1s",
        repeatCount: "indefinite"
      }
    ) })
  ] }) });
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultSvgDefs.mjs
var DefaultSvgDefs = () => {
  return null;
};

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useIdentity.mjs
var import_react30 = __toESM(require_react(), 1);
function useIdentity(value, isEqual7) {
  const ref = (0, import_react30.useRef)(value);
  if (isEqual7(value, ref.current)) {
    return ref.current;
  }
  ref.current = value;
  return value;
}
var areNullableArraysShallowEqual = (a, b) => {
  a ?? (a = null);
  b ?? (b = null);
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return areArraysShallowEqual(a, b);
};
function useShallowArrayIdentity(arr) {
  return useIdentity(arr, areNullableArraysShallowEqual);
}
var areNullableObjectsShallowEqual = (a, b) => {
  a ?? (a = null);
  b ?? (b = null);
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return areObjectsShallowEqual(a, b);
};
function useShallowObjectIdentity(obj) {
  return useIdentity(obj, areNullableObjectsShallowEqual);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useEditorComponents.mjs
var EditorComponentsContext = (0, import_react31.createContext)(null);
function EditorComponentsProvider({
  overrides = {},
  children
}) {
  const _overrides = useShallowObjectIdentity(overrides);
  const value = (0, import_react31.useMemo)(
    () => ({
      Background: DefaultBackground,
      Brush: DefaultBrush,
      Canvas: DefaultCanvas,
      CollaboratorBrush: DefaultBrush,
      CollaboratorCursor: DefaultCursor,
      CollaboratorHint: DefaultCollaboratorHint,
      CollaboratorScribble: DefaultScribble,
      CollaboratorShapeIndicator: DefaultShapeIndicator,
      Cursor: DefaultCursor,
      Grid: DefaultGrid,
      Handle: DefaultHandle,
      Handles: DefaultHandles,
      InFrontOfTheCanvas: null,
      LoadingScreen: DefaultLoadingScreen,
      OnTheCanvas: null,
      Overlays: null,
      Scribble: DefaultScribble,
      SelectionBackground: null,
      SelectionForeground: DefaultSelectionForeground,
      ShapeIndicator: DefaultShapeIndicator,
      ShapeIndicators: DefaultShapeIndicators,
      SnapIndicator: DefaultSnapIndicator,
      Spinner: DefaultSpinner,
      SvgDefs: DefaultSvgDefs,
      ZoomBrush: DefaultBrush,
      ErrorFallback: DefaultErrorFallback,
      ShapeErrorFallback: DefaultShapeErrorFallback,
      ShapeIndicatorErrorFallback: DefaultShapeIndicatorErrorFallback,
      ..._overrides
    }),
    [_overrides]
  );
  return (0, import_jsx_runtime26.jsx)(EditorComponentsContext.Provider, { value, children });
}
function useEditorComponents() {
  const components = (0, import_react31.useContext)(EditorComponentsContext);
  if (!components) {
    throw new Error("useEditorComponents must be used inside of <EditorComponentsProvider />");
  }
  return components;
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/runtime.mjs
var runtime = {
  openWindow(url, target) {
    window.open(url, target, "noopener noreferrer");
  },
  refreshPage() {
    window.location.reload();
  },
  async hardReset() {
    var _a5;
    return await ((_a5 = window.__tldraw__hardReset) == null ? void 0 : _a5.call(window));
  }
};
function setRuntimeOverrides(input) {
  Object.assign(runtime, input);
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/hardResetEditor.mjs
function hardResetEditor() {
  runtime.hardReset();
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/refreshPage.mjs
function refreshPage() {
  runtime.refreshPage();
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultErrorFallback.mjs
var BASE_ERROR_URL = "https://github.com/tldraw/tldraw/issues/new";
var DefaultErrorFallback = ({ error, editor }) => {
  const containerRef = (0, import_react32.useRef)(null);
  const [shouldShowError, setShouldShowError] = (0, import_react32.useState)(true);
  const [didCopy, setDidCopy] = (0, import_react32.useState)(false);
  const [shouldShowResetConfirmation, setShouldShowResetConfirmation] = (0, import_react32.useState)(false);
  let Canvas = null;
  try {
    const components = useEditorComponents();
    Canvas = components.Canvas ?? null;
  } catch {
  }
  const errorMessage = error instanceof Error ? error.message : String(error);
  const errorStack = error instanceof Error ? error.stack : null;
  const isDarkModeFromApp = useValue(
    "isDarkMode",
    () => {
      try {
        if (editor) {
          return editor.user.getIsDarkMode();
        }
      } catch {
      }
      return null;
    },
    [editor]
  );
  const [isDarkMode, setIsDarkMode] = (0, import_react32.useState)(null);
  (0, import_react32.useLayoutEffect)(() => {
    var _a5;
    if (isDarkModeFromApp !== null) {
      setIsDarkMode(isDarkModeFromApp);
    }
    let parent = (_a5 = containerRef.current) == null ? void 0 : _a5.parentElement;
    let foundParentThemeClass = false;
    while (parent) {
      if (parent.classList.contains("tl-theme__dark") || parent.classList.contains("tl-theme__light")) {
        foundParentThemeClass = true;
        break;
      }
      parent = parent.parentElement;
    }
    if (foundParentThemeClass) {
      setIsDarkMode(null);
      return;
    }
    if (typeof window !== "undefined" && "matchMedia" in window) {
      setIsDarkMode(window.matchMedia("(prefers-color-scheme: dark)").matches);
    }
  }, [isDarkModeFromApp]);
  (0, import_react32.useEffect)(() => {
    if (didCopy) {
      const timeout = editor == null ? void 0 : editor.timers.setTimeout(() => {
        setDidCopy(false);
      }, 2e3);
      return () => clearTimeout(timeout);
    }
  }, [didCopy, editor]);
  const copyError = () => {
    const textarea = document.createElement("textarea");
    textarea.value = errorStack ?? errorMessage;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    textarea.remove();
    setDidCopy(true);
  };
  const refresh = () => {
    refreshPage();
  };
  const resetLocalState = async () => {
    hardResetEditor();
  };
  const url = new URL(BASE_ERROR_URL);
  url.searchParams.set("title", errorMessage);
  url.searchParams.set("labels", `bug`);
  url.searchParams.set(
    "body",
    `Hey, I ran into an error while using tldraw:

\`\`\`js
${errorStack ?? errorMessage}
\`\`\`

My browser: ${navigator.userAgent}`
  );
  return (0, import_jsx_runtime27.jsxs)(
    "div",
    {
      ref: containerRef,
      className: (0, import_classnames9.default)(
        "tl-container tl-error-boundary",
        // error-boundary is sometimes used outside of the theme
        // container, so we need to provide it with a theme for our
        // styles to work correctly
        isDarkMode === null ? "" : isDarkMode ? "tl-theme__dark" : "tl-theme__light"
      ),
      children: [
        (0, import_jsx_runtime27.jsx)("div", { className: "tl-error-boundary__overlay" }),
        editor && // opportunistically attempt to render the canvas to reassure
        // the user that their document is still there. there's a good
        // chance this won't work (ie the error that we're currently
        // notifying the user about originates in the canvas) so it's
        // not a big deal if it doesn't work - in that case we just have
        // a plain grey background.
        (0, import_jsx_runtime27.jsx)(ErrorBoundary, { onError: noop, fallback: () => null, children: (0, import_jsx_runtime27.jsx)(EditorProvider, { editor, children: (0, import_jsx_runtime27.jsx)("div", { className: "tl-overlay tl-error-boundary__canvas", children: Canvas ? (0, import_jsx_runtime27.jsx)(Canvas, {}) : null }) }) }),
        (0, import_jsx_runtime27.jsx)(
          "div",
          {
            className: (0, import_classnames9.default)("tl-modal", "tl-error-boundary__content", {
              "tl-error-boundary__content__expanded": shouldShowError && !shouldShowResetConfirmation
            }),
            children: shouldShowResetConfirmation ? (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [
              (0, import_jsx_runtime27.jsx)("h2", { children: "Are you sure?" }),
              (0, import_jsx_runtime27.jsx)("p", { children: "Resetting your data will delete your drawing and cannot be undone." }),
              (0, import_jsx_runtime27.jsxs)("div", { className: "tl-error-boundary__content__actions", children: [
                (0, import_jsx_runtime27.jsx)("button", { className: "tlui-button", onClick: () => setShouldShowResetConfirmation(false), children: "Cancel" }),
                (0, import_jsx_runtime27.jsx)("button", { className: "tlui-button tl-error-boundary__reset", onClick: resetLocalState, children: "Reset data" })
              ] })
            ] }) : (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [
              (0, import_jsx_runtime27.jsx)("h2", { children: "Something went wrong" }),
              (0, import_jsx_runtime27.jsx)("p", { children: "Please refresh your browser." }),
              (0, import_jsx_runtime27.jsx)("p", { children: "If the issue continues after refreshing, you may need to reset the tldraw data stored on your device." }),
              (0, import_jsx_runtime27.jsxs)("p", { children: [
                (0, import_jsx_runtime27.jsx)("strong", { children: "Note:" }),
                " Resetting will erase your current project and any unsaved work."
              ] }),
              (0, import_jsx_runtime27.jsxs)("p", { children: [
                "If you're developing with the SDK and need help, join us on",
                " ",
                (0, import_jsx_runtime27.jsx)("a", { href: "https://discord.tldraw.com/?utm_source=sdk&utm_medium=organic&utm_campaign=error-screen", children: "Discord" }),
                "."
              ] }),
              shouldShowError && (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [
                "Message:",
                (0, import_jsx_runtime27.jsx)("h4", { children: (0, import_jsx_runtime27.jsx)("code", { children: errorMessage }) }),
                "Stack trace:",
                (0, import_jsx_runtime27.jsxs)("div", { className: "tl-error-boundary__content__error", children: [
                  (0, import_jsx_runtime27.jsx)("pre", { children: (0, import_jsx_runtime27.jsx)("code", { children: errorStack ?? errorMessage }) }),
                  (0, import_jsx_runtime27.jsx)("button", { className: "tlui-button", onClick: copyError, children: didCopy ? "Copied!" : "Copy" })
                ] })
              ] }),
              (0, import_jsx_runtime27.jsxs)("div", { className: "tl-error-boundary__content__actions", children: [
                (0, import_jsx_runtime27.jsx)("button", { className: "tlui-button", onClick: () => setShouldShowError(!shouldShowError), children: shouldShowError ? "Hide details" : "Show details" }),
                (0, import_jsx_runtime27.jsxs)("div", { className: "tl-error-boundary__content__actions__group", children: [
                  (0, import_jsx_runtime27.jsx)(
                    "button",
                    {
                      className: "tlui-button tl-error-boundary__reset",
                      onClick: () => setShouldShowResetConfirmation(true),
                      children: "Reset data"
                    }
                  ),
                  (0, import_jsx_runtime27.jsx)("button", { className: "tlui-button tl-error-boundary__refresh", onClick: refresh, children: "Refresh Page" })
                ] })
              ] })
            ] })
          }
        )
      ]
    }
  );
};

// node_modules/@tldraw/editor/dist-esm/lib/config/createTLUser.mjs
var import_react33 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/config/TLUserPreferences.mjs
var USER_DATA_KEY = "TLDRAW_USER_DATA_v3";
var userTypeValidator = validation_exports.object({
  id: validation_exports.string,
  name: validation_exports.string.nullable().optional(),
  color: validation_exports.string.nullable().optional(),
  // N.B. These are duplicated in TLdrawAppUser.
  locale: validation_exports.string.nullable().optional(),
  animationSpeed: validation_exports.number.nullable().optional(),
  edgeScrollSpeed: validation_exports.number.nullable().optional(),
  colorScheme: validation_exports.literalEnum("light", "dark", "system").optional(),
  isSnapMode: validation_exports.boolean.nullable().optional(),
  isWrapMode: validation_exports.boolean.nullable().optional(),
  isDynamicSizeMode: validation_exports.boolean.nullable().optional(),
  isPasteAtCursorMode: validation_exports.boolean.nullable().optional()
});
var Versions14 = {
  AddAnimationSpeed: 1,
  AddIsSnapMode: 2,
  MakeFieldsNullable: 3,
  AddEdgeScrollSpeed: 4,
  AddExcalidrawSelectMode: 5,
  AddDynamicSizeMode: 6,
  AllowSystemColorScheme: 7,
  AddPasteAtCursor: 8
};
var CURRENT_VERSION = Math.max(...Object.values(Versions14));
function migrateSnapshot(data) {
  if (data.version < Versions14.AddAnimationSpeed) {
    data.user.animationSpeed = 1;
  }
  if (data.version < Versions14.AddIsSnapMode) {
    data.user.isSnapMode = false;
  }
  if (data.version < Versions14.MakeFieldsNullable) {
  }
  if (data.version < Versions14.AddEdgeScrollSpeed) {
    data.user.edgeScrollSpeed = 1;
  }
  if (data.version < Versions14.AddExcalidrawSelectMode) {
    data.user.isWrapMode = false;
  }
  if (data.version < Versions14.AllowSystemColorScheme) {
    if (data.user.isDarkMode === true) {
      data.user.colorScheme = "dark";
    } else if (data.user.isDarkMode === false) {
      data.user.colorScheme = "light";
    }
    delete data.user.isDarkMode;
  }
  if (data.version < Versions14.AddDynamicSizeMode) {
    data.user.isDynamicSizeMode = false;
  }
  if (data.version < Versions14.AddPasteAtCursor) {
    data.user.isPasteAtCursorMode = false;
  }
  data.version = CURRENT_VERSION;
}
var USER_COLORS = [
  "#FF802B",
  "#EC5E41",
  "#F2555A",
  "#F04F88",
  "#E34BA9",
  "#BD54C6",
  "#9D5BD2",
  "#7B66DC",
  "#02B1CC",
  "#11B3A3",
  "#39B178",
  "#55B467"
];
function getRandomColor() {
  return USER_COLORS[Math.floor(Math.random() * USER_COLORS.length)];
}
function userPrefersReducedMotion() {
  var _a5, _b;
  if (typeof window !== "undefined" && "matchMedia" in window) {
    return ((_b = (_a5 = window.matchMedia) == null ? void 0 : _a5.call(window, "(prefers-reduced-motion: reduce)")) == null ? void 0 : _b.matches) ?? false;
  }
  return false;
}
var defaultUserPreferences = Object.freeze({
  name: "",
  locale: getDefaultTranslationLocale(),
  color: getRandomColor(),
  // N.B. These are duplicated in TLdrawAppUser.
  edgeScrollSpeed: 1,
  animationSpeed: userPrefersReducedMotion() ? 0 : 1,
  isSnapMode: false,
  isWrapMode: false,
  isDynamicSizeMode: false,
  isPasteAtCursorMode: false,
  colorScheme: "light"
});
function getFreshUserPreferences() {
  return {
    id: uniqueId(),
    color: getRandomColor()
  };
}
function migrateUserPreferences(userData) {
  if (userData === null || typeof userData !== "object") {
    return getFreshUserPreferences();
  }
  if (!("version" in userData) || !("user" in userData) || typeof userData.version !== "number") {
    return getFreshUserPreferences();
  }
  const snapshot = structuredClone(userData);
  migrateSnapshot(snapshot);
  try {
    return userTypeValidator.validate(snapshot.user);
  } catch {
    return getFreshUserPreferences();
  }
}
function loadUserPreferences() {
  const userData = JSON.parse(getFromLocalStorage(USER_DATA_KEY) || "null") ?? null;
  return migrateUserPreferences(userData);
}
var globalUserPreferences = atom("globalUserData", null);
function storeUserPreferences() {
  setInLocalStorage(
    USER_DATA_KEY,
    JSON.stringify({
      version: CURRENT_VERSION,
      user: globalUserPreferences.get()
    })
  );
}
function setUserPreferences(user) {
  userTypeValidator.validate(user);
  globalUserPreferences.set(user);
  storeUserPreferences();
  broadcastUserPreferencesChange();
}
var isTest2 = typeof process !== "undefined" && false;
var channel = typeof BroadcastChannel !== "undefined" && !isTest2 ? new BroadcastChannel("tldraw-user-sync") : null;
channel == null ? void 0 : channel.addEventListener("message", (e) => {
  const data = e.data;
  if ((data == null ? void 0 : data.type) === broadcastEventKey && (data == null ? void 0 : data.origin) !== getBroadcastOrigin()) {
    globalUserPreferences.set(migrateUserPreferences(data.data));
  }
});
var _broadcastOrigin = null;
function getBroadcastOrigin() {
  if (_broadcastOrigin === null) {
    _broadcastOrigin = uniqueId();
  }
  return _broadcastOrigin;
}
var broadcastEventKey = "tldraw-user-preferences-change";
function broadcastUserPreferencesChange() {
  channel == null ? void 0 : channel.postMessage({
    type: broadcastEventKey,
    origin: getBroadcastOrigin(),
    data: {
      user: getUserPreferences(),
      version: CURRENT_VERSION
    }
  });
}
function getUserPreferences() {
  let prefs = globalUserPreferences.get();
  if (!prefs) {
    prefs = loadUserPreferences();
    setUserPreferences(prefs);
  }
  return prefs;
}

// node_modules/@tldraw/editor/dist-esm/lib/config/createTLUser.mjs
var defaultLocalStorageUserPrefs = computed(
  "defaultLocalStorageUserPrefs",
  () => getUserPreferences()
);
function createTLUser(opts = {}) {
  return {
    userPreferences: opts.userPreferences ?? defaultLocalStorageUserPrefs,
    setUserPreferences: opts.setUserPreferences ?? setUserPreferences
  };
}
function useTldrawUser(opts) {
  const prefs = useShallowObjectIdentity(opts.userPreferences ?? defaultLocalStorageUserPrefs);
  const userAtom = useAtom("userAtom", prefs);
  (0, import_react33.useEffect)(() => {
    userAtom.set(prefs);
  }, [prefs, userAtom]);
  return (0, import_react33.useMemo)(
    () => createTLUser({
      userPreferences: computed("userPreferences", () => {
        const userStuff = userAtom.get();
        return isSignal(userStuff) ? userStuff.get() : userStuff;
      }),
      setUserPreferences: opts.setUserPreferences
    }),
    [userAtom, opts.setUserPreferences]
  );
}

// node_modules/@tldraw/editor/dist-esm/lib/editor/Editor.mjs
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/config/TLSessionStateSnapshot.mjs
var import_lodash5 = __toESM(require_lodash3(), 1);
var tabIdKey = "TLDRAW_TAB_ID_v2";
var window2 = globalThis.window;
function iOS() {
  if (!window2)
    return false;
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    window2.navigator.platform
  ) || // iPad on iOS 13 detection
  tlenv.isDarwin && "ontouchend" in document;
}
var TAB_ID = window2 ? window2[tabIdKey] ?? getFromSessionStorage(tabIdKey) ?? `TLDRAW_INSTANCE_STATE_V1_` + uniqueId() : "<error>";
if (window2) {
  window2[tabIdKey] = TAB_ID;
  if (iOS()) {
    setInSessionStorage(tabIdKey, TAB_ID);
  } else {
    deleteFromSessionStorage(tabIdKey);
  }
}
window2 == null ? void 0 : window2.addEventListener("beforeunload", () => {
  setInSessionStorage(tabIdKey, TAB_ID);
});
var Versions15 = {
  Initial: 0
};
var CURRENT_SESSION_STATE_SNAPSHOT_VERSION = Math.max(...Object.values(Versions15));
function migrate(snapshot) {
  if (snapshot.version < Versions15.Initial) {
  }
  snapshot.version = CURRENT_SESSION_STATE_SNAPSHOT_VERSION;
}
var sessionStateSnapshotValidator = validation_exports.object({
  version: validation_exports.number,
  currentPageId: pageIdValidator.optional(),
  isFocusMode: validation_exports.boolean.optional(),
  exportBackground: validation_exports.boolean.optional(),
  isDebugMode: validation_exports.boolean.optional(),
  isToolLocked: validation_exports.boolean.optional(),
  isGridMode: validation_exports.boolean.optional(),
  pageStates: validation_exports.arrayOf(
    validation_exports.object({
      pageId: pageIdValidator,
      camera: validation_exports.object({
        x: validation_exports.number,
        y: validation_exports.number,
        z: validation_exports.number
      }).optional(),
      selectedShapeIds: validation_exports.arrayOf(shapeIdValidator).optional(),
      focusedGroupId: shapeIdValidator.nullable().optional()
    })
  ).optional()
});
function migrateAndValidateSessionStateSnapshot(state) {
  if (!state || typeof state !== "object") {
    console.warn("Invalid instance state");
    return null;
  }
  if (!("version" in state) || typeof state.version !== "number") {
    console.warn("No version in instance state");
    return null;
  }
  if (state.version !== CURRENT_SESSION_STATE_SNAPSHOT_VERSION) {
    state = structuredClone(state);
    migrate(state);
  }
  try {
    return sessionStateSnapshotValidator.validate(state);
  } catch (e) {
    console.warn(e);
    return null;
  }
}
function createSessionStateSnapshotSignal(store) {
  const $allPageIds = store.query.ids("page");
  return computed(
    "sessionStateSnapshot",
    () => {
      const instanceState = store.get(TLINSTANCE_ID);
      if (!instanceState)
        return null;
      const allPageIds = [...$allPageIds.get()];
      return {
        version: CURRENT_SESSION_STATE_SNAPSHOT_VERSION,
        currentPageId: instanceState.currentPageId,
        exportBackground: instanceState.exportBackground,
        isFocusMode: instanceState.isFocusMode,
        isDebugMode: instanceState.isDebugMode,
        isToolLocked: instanceState.isToolLocked,
        isGridMode: instanceState.isGridMode,
        pageStates: allPageIds.map((id) => {
          const ps = store.get(InstancePageStateRecordType.createId(id));
          const camera = store.get(CameraRecordType.createId(id));
          return {
            pageId: id,
            camera: {
              x: (camera == null ? void 0 : camera.x) ?? 0,
              y: (camera == null ? void 0 : camera.y) ?? 0,
              z: (camera == null ? void 0 : camera.z) ?? 1
            },
            selectedShapeIds: (ps == null ? void 0 : ps.selectedShapeIds) ?? [],
            focusedGroupId: (ps == null ? void 0 : ps.focusedGroupId) ?? null
          };
        })
      };
    },
    { isEqual: import_lodash5.default }
  );
}
function loadSessionStateSnapshotIntoStore(store, snapshot, opts) {
  const res = migrateAndValidateSessionStateSnapshot(snapshot);
  if (!res)
    return;
  const preserved = pluckPreservingValues(store.get(TLINSTANCE_ID));
  const primary = (opts == null ? void 0 : opts.forceOverwrite) ? res : preserved;
  const secondary = (opts == null ? void 0 : opts.forceOverwrite) ? preserved : res;
  const instanceState = store.schema.types.instance.create({
    id: TLINSTANCE_ID,
    ...preserved,
    // the integrity checker will ensure that the currentPageId is valid
    currentPageId: res.currentPageId,
    isDebugMode: (primary == null ? void 0 : primary.isDebugMode) ?? (secondary == null ? void 0 : secondary.isDebugMode),
    isFocusMode: (primary == null ? void 0 : primary.isFocusMode) ?? (secondary == null ? void 0 : secondary.isFocusMode),
    isToolLocked: (primary == null ? void 0 : primary.isToolLocked) ?? (secondary == null ? void 0 : secondary.isToolLocked),
    isGridMode: (primary == null ? void 0 : primary.isGridMode) ?? (secondary == null ? void 0 : secondary.isGridMode),
    exportBackground: (primary == null ? void 0 : primary.exportBackground) ?? (secondary == null ? void 0 : secondary.exportBackground)
  });
  store.atomic(() => {
    var _a5, _b, _c;
    for (const ps of res.pageStates ?? []) {
      if (!store.has(ps.pageId))
        continue;
      const cameraId = CameraRecordType.createId(ps.pageId);
      const instancePageState = InstancePageStateRecordType.createId(ps.pageId);
      const previousCamera = store.get(cameraId);
      const previousInstanceState = store.get(instancePageState);
      store.put([
        CameraRecordType.create({
          id: cameraId,
          x: ((_a5 = ps.camera) == null ? void 0 : _a5.x) ?? (previousCamera == null ? void 0 : previousCamera.x),
          y: ((_b = ps.camera) == null ? void 0 : _b.y) ?? (previousCamera == null ? void 0 : previousCamera.y),
          z: ((_c = ps.camera) == null ? void 0 : _c.z) ?? (previousCamera == null ? void 0 : previousCamera.z)
        }),
        InstancePageStateRecordType.create({
          id: instancePageState,
          pageId: ps.pageId,
          selectedShapeIds: ps.selectedShapeIds ?? (previousInstanceState == null ? void 0 : previousInstanceState.selectedShapeIds),
          focusedGroupId: ps.focusedGroupId ?? (previousInstanceState == null ? void 0 : previousInstanceState.focusedGroupId)
        })
      ]);
    }
    store.put([instanceState]);
    store.ensureStoreIsUsable();
  });
}
function extractSessionStateFromLegacySnapshot(store) {
  var _a5;
  const instanceRecords = [];
  for (const record of Object.values(store)) {
    if ((_a5 = record.typeName) == null ? void 0 : _a5.match(/^(instance.*|pointer|camera)$/)) {
      instanceRecords.push(record);
    }
  }
  const oldInstance = instanceRecords.filter(
    (r) => r.typeName === "instance" && r.id !== TLINSTANCE_ID
  )[0];
  if (!oldInstance)
    return null;
  const result = {
    version: CURRENT_SESSION_STATE_SNAPSHOT_VERSION,
    currentPageId: oldInstance.currentPageId,
    exportBackground: !!oldInstance.exportBackground,
    isFocusMode: !!oldInstance.isFocusMode,
    isDebugMode: !!oldInstance.isDebugMode,
    isToolLocked: !!oldInstance.isToolLocked,
    isGridMode: false,
    pageStates: instanceRecords.filter((r) => r.typeName === "instance_page_state" && r.instanceId === oldInstance.id).map((ps) => {
      const camera = store[ps.cameraId] ?? { x: 0, y: 0, z: 1 };
      return {
        pageId: ps.pageId,
        camera: {
          x: camera.x,
          y: camera.y,
          z: camera.z
        },
        selectedShapeIds: ps.selectedShapeIds,
        focusedGroupId: ps.focusedGroupId
      };
    })
  };
  try {
    sessionStateSnapshotValidator.validate(result);
    return result;
  } catch {
    return null;
  }
}

// node_modules/@tldraw/editor/dist-esm/lib/config/TLEditorSnapshot.mjs
function loadSnapshot(store, _snapshot, opts) {
  let snapshot = {};
  if ("store" in _snapshot) {
    const migrationResult = store.schema.migrateStoreSnapshot(_snapshot);
    if (migrationResult.type !== "success") {
      throw new Error("Failed to migrate store snapshot: " + migrationResult.reason);
    }
    snapshot.document = {
      schema: store.schema.serialize(),
      store: filterEntries(
        migrationResult.value,
        (_, { typeName }) => store.scopedTypes.document.has(typeName)
      )
    };
  } else {
    snapshot = _snapshot;
  }
  const preservingInstanceState = pluckPreservingValues(store.get(TLINSTANCE_ID));
  const preservingSessionState = sessionStateCache.get(store, createSessionStateSnapshotSignal).get();
  store.atomic(() => {
    if (snapshot.document) {
      store.loadStoreSnapshot(snapshot.document);
    }
    if (preservingInstanceState) {
      store.update(TLINSTANCE_ID, (r) => ({ ...r, ...preservingInstanceState }));
    }
    if (preservingSessionState) {
      loadSessionStateSnapshotIntoStore(store, preservingSessionState);
    }
    if (snapshot.session) {
      loadSessionStateSnapshotIntoStore(store, snapshot.session, {
        forceOverwrite: opts == null ? void 0 : opts.forceOverwriteSessionState
      });
    }
  });
}
var sessionStateCache = new WeakCache();
function getSnapshot(store) {
  const sessionState$ = sessionStateCache.get(store, createSessionStateSnapshotSignal);
  const session = sessionState$.get();
  if (!session) {
    throw new Error("Session state is not ready yet");
  }
  return {
    document: store.getStoreSnapshot(),
    session
  };
}

// node_modules/@tldraw/editor/dist-esm/lib/config/defaultBindings.mjs
function checkBindings(customBindings) {
  const bindings = [];
  const addedCustomBindingTypes = /* @__PURE__ */ new Set();
  for (const customBinding of customBindings) {
    if (addedCustomBindingTypes.has(customBinding.type)) {
      throw new Error(`Binding type "${customBinding.type}" is defined more than once`);
    }
    bindings.push(customBinding);
    addedCustomBindingTypes.add(customBinding.type);
  }
  return bindings;
}

// node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/group/GroupShapeUtil.mjs
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/components/SVGContainer.mjs
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_classnames10 = __toESM(require_classnames(), 1);
function SVGContainer({ children, className = "", ...rest }) {
  return (0, import_jsx_runtime28.jsx)("svg", { ...rest, className: (0, import_classnames10.default)("tl-svg-container", className), children });
}

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Edge2d.mjs
var Edge2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: false, isFilled: false });
    __publicField(this, "start");
    __publicField(this, "end");
    __publicField(this, "d");
    __publicField(this, "u");
    __publicField(this, "ul");
    const { start: start2, end: end2 } = config;
    this.start = start2;
    this.end = end2;
    this.d = start2.clone().sub(end2);
    this.u = this.d.clone().uni();
    this.ul = this.u.len();
  }
  getLength() {
    return this.d.len();
  }
  midPoint() {
    return this.start.lrp(this.end, 0.5);
  }
  getVertices() {
    return [this.start, this.end];
  }
  nearestPoint(point) {
    const { start: start2, end: end2, d, u, ul: l } = this;
    if (d.len() === 0)
      return start2;
    if (l === 0)
      return start2;
    const k = Vec.Sub(point, start2).dpr(u) / l;
    const cx = start2.x + u.x * k;
    if (cx < Math.min(start2.x, end2.x))
      return start2.x < end2.x ? start2 : end2;
    if (cx > Math.max(start2.x, end2.x))
      return start2.x > end2.x ? start2 : end2;
    const cy = start2.y + u.y * k;
    if (cy < Math.min(start2.y, end2.y))
      return start2.y < end2.y ? start2 : end2;
    if (cy > Math.max(start2.y, end2.y))
      return start2.y > end2.y ? start2 : end2;
    return new Vec(cx, cy);
  }
  hitTestLineSegment(A, B, distance = 0) {
    return linesIntersect(A, B, this.start, this.end) || this.distanceToLineSegment(A, B) <= distance;
  }
  getSvgPathData(first2 = true) {
    const { start: start2, end: end2 } = this;
    return `${first2 ? `M${start2.toFixed()}` : ``} L${end2.toFixed()}`;
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Polyline2d.mjs
var Polyline2d = class extends Geometry2d {
  constructor(config) {
    super({ isClosed: false, isFilled: false, ...config });
    __publicField(this, "points");
    __publicField(this, "_segments");
    const { points } = config;
    this.points = points;
  }
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { vertices } = this;
      for (let i = 0, n = vertices.length - 1; i < n; i++) {
        const start2 = vertices[i];
        const end2 = vertices[i + 1];
        this._segments.push(new Edge2d({ start: start2, end: end2 }));
      }
      if (this.isClosed) {
        this._segments.push(new Edge2d({ start: vertices[vertices.length - 1], end: vertices[0] }));
      }
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((acc, segment) => acc + segment.length, 0);
  }
  getVertices() {
    return this.points;
  }
  nearestPoint(A) {
    const { segments } = this;
    let nearest = this.points[0];
    let dist = Infinity;
    let p;
    let d;
    for (let i = 0; i < segments.length; i++) {
      p = segments[i].nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest)
      throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B, distance = 0) {
    const { segments } = this;
    for (let i = 0, n = segments.length; i < n; i++) {
      if (segments[i].hitTestLineSegment(A, B, distance)) {
        return true;
      }
    }
    return false;
  }
  getSvgPathData() {
    const { vertices } = this;
    if (vertices.length < 2)
      return "";
    return vertices.reduce((acc, vertex, i) => {
      if (i === 0)
        return `M ${vertex.x} ${vertex.y}`;
      return `${acc} L ${vertex.x} ${vertex.y}`;
    }, "");
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Polygon2d.mjs
var Polygon2d = class extends Polyline2d {
  constructor(config) {
    super({ ...config });
    this.isClosed = true;
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Rectangle2d.mjs
var Rectangle2d = class extends Polygon2d {
  constructor(config) {
    const { x = 0, y = 0, width, height } = config;
    super({
      ...config,
      points: [
        new Vec(x, y),
        new Vec(x + width, y),
        new Vec(x + width, y + height),
        new Vec(x, y + height)
      ]
    });
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "w");
    __publicField(this, "h");
    this.x = x;
    this.y = y;
    this.w = width;
    this.h = height;
  }
  getBounds() {
    return new Box(this.x, this.y, this.w, this.h);
  }
  getSvgPathData() {
    const { x, y, w, h } = this;
    return `M${x},${y} h${w} v${h} h-${w}z`;
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/ShapeUtil.mjs
var ShapeUtil = class {
  constructor(editor) {
    /**
     * Options for this shape util. If you're implementing a custom shape util, you can override
     * this to provide customization options for your shape. If using an existing shape util, you
     * can customizing this by calling {@link ShapeUtil.configure}.
     */
    __publicField(this, "options", {});
    this.editor = editor;
  }
  /** Configure this shape utils {@link ShapeUtil.options | `options`}. */
  static configure(options2) {
    return class extends this {
      constructor() {
        super(...arguments);
        // @ts-expect-error
        __publicField(this, "options", { ...this.options, ...options2 });
      }
    };
  }
  /**
   * Get the font faces that should be rendered in the document in order for this shape to render
   * correctly.
   *
   * @param shape - The shape.
   * @public
   */
  getFontFaces(shape) {
    return EMPTY_ARRAY;
  }
  /**
   * Whether the shape can be snapped to by another shape.
   *
   * @param shape - The shape.
   * @public
   */
  canSnap(_shape) {
    return true;
  }
  /**
   * Whether the shape can be tabbed to.
   *
   * @param shape - The shape.
   * @public
   */
  canTabTo(_shape) {
    return true;
  }
  /**
   * Whether the shape can be scrolled while editing.
   *
   * @public
   */
  canScroll(_shape) {
    return false;
  }
  /**
   * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.
   *
   * @public
   */
  canBind(_opts) {
    return true;
  }
  /**
   * Whether the shape can be double clicked to edit.
   *
   * @public
   */
  canEdit(_shape) {
    return false;
  }
  /**
   * Whether the shape can be resized.
   *
   * @public
   */
  canResize(_shape) {
    return true;
  }
  /**
   * Whether the shape can be edited in read-only mode.
   *
   * @public
   */
  canEditInReadonly(_shape) {
    return false;
  }
  /**
   * Whether the shape can be cropped.
   *
   * @public
   */
  canCrop(_shape) {
    return false;
  }
  /**
   * Whether the shape can participate in layout functions such as alignment or distribution.
   *
   * @param shape - The shape.
   * @param info - Additional context information: the type of action causing the layout and the
   * @public
   *
   * @public
   */
  canBeLaidOut(_shape, _info) {
    return true;
  }
  /**
   * Does this shape provide a background for its children? If this is true,
   * then any children with a `renderBackground` method will have their
   * backgrounds rendered _above_ this shape. Otherwise, the children's
   * backgrounds will be rendered above either the next ancestor that provides
   * a background, or the canvas background.
   *
   * @internal
   */
  providesBackgroundForChildren(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideResizeHandles(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its rotation handles when selected.
   *
   * @public
   */
  hideRotateHandle(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its selection bounds background when selected.
   *
   * @public
   */
  hideSelectionBoundsBg(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its selection bounds foreground when selected.
   *
   * @public
   */
  hideSelectionBoundsFg(_shape) {
    return false;
  }
  /**
   * Whether the shape's aspect ratio is locked.
   *
   * @public
   */
  isAspectRatioLocked(_shape) {
    return false;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape.
   * @param type - The shape type.
   * @public
   */
  canReceiveNewChildrenOfType(_shape, _type) {
    return false;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape type.
   * @param shapes - The shapes that are being dropped.
   * @public
   */
  canDropShapes(_shape, _shapes) {
    return false;
  }
  /** @internal */
  expandSelectionOutlinePx(shape) {
    return 0;
  }
  /**
   * Return elements to be added to the \<defs\> section of the canvases SVG context. This can be
   * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg
   * elements returned by `component`.
   *
   * Each def should have a unique `key`. If multiple defs from different shapes all have the same
   * key, only one will be used.
   */
  getCanvasSvgDefs() {
    return [];
  }
  /**
   * Get the geometry to use when snapping to this this shape in translate/resize operations. See
   * {@link BoundsSnapGeometry} for details.
   */
  getBoundsSnapGeometry(_shape) {
    return {};
  }
  /**
   * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}
   * for details.
   */
  getHandleSnapGeometry(_shape) {
    return {};
  }
  getText(_shape) {
    return void 0;
  }
  getAriaDescriptor(_shape) {
    return void 0;
  }
};
/**
 * Props allow you to define the shape's properties in a way that the editor can understand.
 * This has two main uses:
 *
 * 1. Validation. Shapes will be validated using these props to stop bad data from being saved.
 * 2. Styles. Each {@link @tldraw/tlschema#StyleProp} in the props can be set on many shapes at
 *    once, and will be remembered from one shape to the next.
 *
 * @example
 * ```tsx
 * import {T, TLBaseShape, TLDefaultColorStyle, DefaultColorStyle, ShapeUtil} from 'tldraw'
 *
 * type MyShape = TLBaseShape<'mine', {
 *      color: TLDefaultColorStyle,
 *      text: string,
 * }>
 *
 * class MyShapeUtil extends ShapeUtil<MyShape> {
 *     static props = {
 *         // we use tldraw's built-in color style:
 *         color: DefaultColorStyle,
 *         // validate that the text prop is a string:
 *         text: T.string,
 *     }
 * }
 * ```
 */
__publicField(ShapeUtil, "props");
/**
 * Migrations allow you to make changes to a shape's props over time. Read the
 * {@link https://www.tldraw.dev/docs/persistence#Shape-props-migrations | shape prop migrations}
 * guide for more information.
 */
__publicField(ShapeUtil, "migrations");
/**
 * The type of the shape util, which should match the shape's type.
 *
 * @public
 */
__publicField(ShapeUtil, "type");

// node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/group/DashedOutlineBox.mjs
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/shared/getPerfectDashProps.mjs
function getPerfectDashProps(totalLength, strokeWidth, opts = {}) {
  const {
    closed = false,
    snap = 1,
    start: start2 = "outset",
    end: end2 = "outset",
    lengthRatio = 2,
    style: style2 = "dashed",
    forceSolid = false
  } = opts;
  let dashLength = 0;
  let dashCount = 0;
  let ratio = 1;
  let gapLength = 0;
  let strokeDashoffset = 0;
  if (forceSolid) {
    return {
      strokeDasharray: "none",
      strokeDashoffset: "none"
    };
  }
  switch (style2) {
    case "dashed": {
      ratio = 1;
      dashLength = Math.min(strokeWidth * lengthRatio, totalLength / 4);
      break;
    }
    case "dotted": {
      ratio = 100;
      dashLength = strokeWidth / ratio;
      break;
    }
    default: {
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
    }
  }
  if (!closed) {
    if (start2 === "outset") {
      totalLength += dashLength / 2;
      strokeDashoffset += dashLength / 2;
    } else if (start2 === "skip") {
      totalLength -= dashLength;
      strokeDashoffset -= dashLength;
    }
    if (end2 === "outset") {
      totalLength += dashLength / 2;
    } else if (end2 === "skip") {
      totalLength -= dashLength;
    }
  }
  dashCount = Math.floor(totalLength / dashLength / (2 * ratio));
  dashCount -= dashCount % snap;
  if (dashCount < 3 && style2 === "dashed") {
    if (totalLength / strokeWidth < 4) {
      dashLength = totalLength;
      dashCount = 1;
      gapLength = 0;
    } else {
      dashLength = totalLength * (1 / 3);
      gapLength = totalLength * (1 / 3);
    }
  } else {
    dashLength = totalLength / dashCount / (2 * ratio);
    if (closed) {
      strokeDashoffset = dashLength / 2;
      gapLength = (totalLength - dashCount * dashLength) / dashCount;
    } else {
      gapLength = (totalLength - dashCount * dashLength) / Math.max(1, dashCount - 1);
    }
  }
  return {
    strokeDasharray: [dashLength, gapLength].join(" "),
    strokeDashoffset: strokeDashoffset.toString()
  };
}

// node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/group/DashedOutlineBox.mjs
function DashedOutlineBox({ bounds, className }) {
  const editor = useEditor();
  const zoomLevel = useValue("zoom level", () => editor.getZoomLevel(), [editor]);
  return (0, import_jsx_runtime29.jsx)("g", { className, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round", children: bounds.sides.map((side, i) => {
    const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
      side[0].dist(side[1]),
      1 / zoomLevel,
      {
        style: "dashed",
        lengthRatio: 4
      }
    );
    return (0, import_jsx_runtime29.jsx)(
      "line",
      {
        x1: side[0].x,
        y1: side[0].y,
        x2: side[1].x,
        y2: side[1].y,
        strokeDasharray,
        strokeDashoffset
      },
      i
    );
  }) });
}

// node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/group/GroupShapeUtil.mjs
var GroupShapeUtil = class extends ShapeUtil {
  hideSelectionBoundsFg() {
    return true;
  }
  canBind() {
    return false;
  }
  getDefaultProps() {
    return {};
  }
  getGeometry(shape) {
    const children = this.editor.getSortedChildIdsForParent(shape.id);
    if (children.length === 0) {
      return new Rectangle2d({ width: 1, height: 1, isFilled: false });
    }
    return new Group2d({
      children: children.map((childId) => {
        const shape2 = this.editor.getShape(childId);
        return this.editor.getShapeGeometry(childId).transform(this.editor.getShapeLocalTransform(shape2), { isLabel: false });
      })
    });
  }
  component(shape) {
    const isErasing = this.editor.getErasingShapeIds().includes(shape.id);
    const { hintingShapeIds } = this.editor.getCurrentPageState();
    const isHintingOtherGroup = hintingShapeIds.length > 0 && hintingShapeIds.some(
      (id) => id !== shape.id && this.editor.isShapeOfType(this.editor.getShape(id), "group")
    );
    const isFocused = this.editor.getCurrentPageState().focusedGroupId !== shape.id;
    if (!isErasing && // always show the outline while we're erasing the group
    // show the outline while the group is focused unless something outside of the group is being hinted
    // this happens dropping shapes from a group onto some outside group
    (isFocused || isHintingOtherGroup)) {
      return null;
    }
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    return (0, import_jsx_runtime30.jsx)(SVGContainer, { children: (0, import_jsx_runtime30.jsx)(DashedOutlineBox, { className: "tl-group", bounds }) });
  }
  indicator(shape) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    return (0, import_jsx_runtime30.jsx)(DashedOutlineBox, { className: "", bounds });
  }
  onChildrenChange(group) {
    const children = this.editor.getSortedChildIdsForParent(group.id);
    if (children.length === 0) {
      if (this.editor.getCurrentPageState().focusedGroupId === group.id) {
        this.editor.popFocusedGroupId();
      }
      this.editor.deleteShapes([group.id]);
      return;
    } else if (children.length === 1) {
      if (this.editor.getCurrentPageState().focusedGroupId === group.id) {
        this.editor.popFocusedGroupId();
      }
      this.editor.reparentShapes(children, group.parentId);
      this.editor.deleteShapes([group.id]);
      return;
    }
  }
};
__publicField(GroupShapeUtil, "type", "group");
__publicField(GroupShapeUtil, "props", groupShapeProps);
__publicField(GroupShapeUtil, "migrations", groupShapeMigrations);

// node_modules/@tldraw/editor/dist-esm/lib/config/defaultShapes.mjs
var coreShapes = [
  // created by grouping interactions, probably the corest core shape that we have
  GroupShapeUtil
];
var coreShapeTypes = new Set(coreShapes.map((s) => s.type));
function checkShapesAndAddCore(customShapes) {
  const shapes = [...coreShapes];
  const addedCustomShapeTypes = /* @__PURE__ */ new Set();
  for (const customShape of customShapes) {
    if (coreShapeTypes.has(customShape.type)) {
      throw new Error(
        `Shape type "${customShape.type}" is a core shapes type and cannot be overridden`
      );
    }
    if (addedCustomShapeTypes.has(customShape.type)) {
      throw new Error(`Shape type "${customShape.type}" is defined more than once`);
    }
    shapes.push(customShape);
    addedCustomShapeTypes.add(customShape.type);
  }
  return shapes;
}

// node_modules/@tldraw/editor/dist-esm/lib/exports/exportToSvg.mjs
var import_react_dom2 = __toESM(require_react_dom(), 1);
var import_client = __toESM(require_client(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/exports/fetchCache.mjs
function fetchCache(cb, init2) {
  const cache = /* @__PURE__ */ new Map();
  return async function fetchCached(url) {
    const existing = cache.get(url);
    if (existing)
      return existing;
    const promise = (async () => {
      try {
        const response = await fetch(url, init2);
        assert(response.ok);
        return await cb(response);
      } catch (err) {
        console.error(err);
        return null;
      }
    })();
    cache.set(url, promise);
    return promise;
  };
}
var resourceToDataUrl = fetchCache(async (response) => {
  return await FileHelpers.blobToDataUrl(await response.blob());
});

// node_modules/@tldraw/editor/dist-esm/lib/exports/parseCss.mjs
var importsRegex = /@import\s+(?:"([^"]+)"|'([^']+)'|url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\))([^;]+);/gi;
var fontFaceRegex = /@font-face\s*{([^}]+)}/gi;
var urlsRegex = /url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\)/gi;
var fontFamilyRegex = /(?:^|;)\s*font-family\s*:\s*(?:([^'"][^;\n]+)|"([^"]+)"|'([^']+)')\s*(?:;|$)/gi;
function parseCssImports(css) {
  return Array.from(css.matchAll(importsRegex), (m) => ({
    url: m[1] || m[2] || m[3] || m[4] || m[5],
    extras: m[6]
  }));
}
function parseCssFontFaces(css, baseUrl) {
  return Array.from(css.matchAll(fontFaceRegex), (m) => {
    const fontFace = m[1];
    const urls = Array.from(fontFace.matchAll(urlsRegex), (m2) => {
      var _a5;
      const original = m2[1] || m2[2] || m2[3];
      return {
        original,
        resolved: ((_a5 = safeParseUrl(original, baseUrl)) == null ? void 0 : _a5.href) ?? null
      };
    });
    const fontFamilies = new Set(
      Array.from(fontFace.matchAll(fontFamilyRegex), (m2) => (m2[1] || m2[2] || m2[3]).toLowerCase())
    );
    return { fontFace, urls, fontFamilies };
  });
}
function parseCssFontFamilyValue(value) {
  const valueRegex = /\s*(?:([^'"][^;\n\s,]+)|"([^"]+)"|'([^']+)')\s*/gi;
  const separatorRegex = /\s*,\s*/gi;
  const fontFamilies = /* @__PURE__ */ new Set();
  while (true) {
    const valueMatch = valueRegex.exec(value);
    if (!valueMatch) {
      break;
    }
    const fontFamily = valueMatch[1] || valueMatch[2] || valueMatch[3];
    fontFamilies.add(fontFamily.toLowerCase());
    separatorRegex.lastIndex = valueRegex.lastIndex;
    const separatorMatch = separatorRegex.exec(value);
    if (!separatorMatch) {
      break;
    }
    valueRegex.lastIndex = separatorRegex.lastIndex;
  }
  return fontFamilies;
}
function shouldIncludeCssProperty(property) {
  if (property.startsWith("-"))
    return false;
  if (property.startsWith("animation"))
    return false;
  if (property.startsWith("transition"))
    return false;
  if (property === "cursor")
    return false;
  if (property === "pointer-events")
    return false;
  if (property === "user-select")
    return false;
  if (property === "touch-action")
    return false;
  return true;
}
function parseCss(css, baseUrl) {
  return {
    imports: parseCssImports(css),
    fontFaces: parseCssFontFaces(css, baseUrl)
  };
}
function parseCssValueUrls(value) {
  return Array.from(value.matchAll(urlsRegex), (m) => ({
    original: m[0],
    url: m[1] || m[2] || m[3]
  }));
}

// node_modules/@tldraw/editor/dist-esm/lib/exports/FontEmbedder.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base2) => [, , , __create((base2 == null ? void 0 : base2[__knownSymbol("metadata")]) ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError("Function expected") : fn2;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn2 || null)) });
var __decoratorMetadata = (array2, target) => __defNormalProp(target, __knownSymbol("metadata"), array2[3]);
var __runInitializers = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet2(this, extra);
  }, set [name](x) {
    return __privateSet2(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet2 : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet2(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError("Object expected");
    else
      __expectFn(fn2 = it.get) && (desc.get = fn2), __expectFn(fn2 = it.set) && (desc.set = fn2), __expectFn(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata(array2, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField2 = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg2) => member.has(obj) || __typeError("Cannot " + msg2);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet2 = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet2 = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _onFontFamilyValue_dec;
var _init;
var SVG_EXPORT_CLASSNAME = "tldraw-svg-export";
_onFontFamilyValue_dec = [bind];
var FontEmbedder = class {
  constructor() {
    __runInitializers(_init, 5, this);
    __publicField2(this, "fontFacesPromise", null);
    __publicField2(this, "foundFontNames", /* @__PURE__ */ new Set());
    __publicField2(this, "fontFacesToEmbed", /* @__PURE__ */ new Set());
    __publicField2(this, "pendingPromises", []);
  }
  startFindingCurrentDocumentFontFaces() {
    assert(!this.fontFacesPromise, "FontEmbedder already started");
    this.fontFacesPromise = getCurrentDocumentFontFaces();
  }
  onFontFamilyValue(fontFamilyValue) {
    assert(this.fontFacesPromise, "FontEmbedder not started");
    const fonts = parseCssFontFamilyValue(fontFamilyValue);
    for (const font of fonts) {
      if (this.foundFontNames.has(font))
        return;
      this.foundFontNames.add(font);
      this.pendingPromises.push(
        this.fontFacesPromise.then((fontFaces) => {
          const relevantFontFaces = fontFaces.filter((fontFace) => fontFace.fontFamilies.has(font));
          for (const fontFace of relevantFontFaces) {
            if (this.fontFacesToEmbed.has(fontFace))
              continue;
            this.fontFacesToEmbed.add(fontFace);
            for (const url of fontFace.urls) {
              if (!url.resolved || url.embedded)
                continue;
              url.embedded = resourceToDataUrl(url.resolved);
            }
          }
        })
      );
    }
  }
  async createCss() {
    await Promise.all(this.pendingPromises);
    let css = "";
    for (const fontFace of this.fontFacesToEmbed) {
      let fontFaceString = `@font-face {${fontFace.fontFace}}`;
      for (const url of fontFace.urls) {
        if (!url.embedded)
          continue;
        const dataUrl = await url.embedded;
        if (!dataUrl)
          continue;
        fontFaceString = fontFaceString.replace(url.original, dataUrl);
      }
      css += fontFaceString;
    }
    return css;
  }
};
_init = __decoratorStart(null);
__decorateElement(_init, 1, "onFontFamilyValue", _onFontFamilyValue_dec, FontEmbedder);
__decoratorMetadata(_init, FontEmbedder);
async function getCurrentDocumentFontFaces() {
  var _a5;
  const fontFaces = [];
  const styleSheetsWithoutSvgExports = Array.from(document.styleSheets).filter(
    (styleSheet) => {
      var _a6;
      return !((_a6 = styleSheet.ownerNode) == null ? void 0 : _a6.closest(`.${SVG_EXPORT_CLASSNAME}`));
    }
  );
  for (const styleSheet of styleSheetsWithoutSvgExports) {
    let cssRules2;
    try {
      cssRules2 = styleSheet.cssRules;
    } catch {
    }
    if (cssRules2) {
      for (const rule of styleSheet.cssRules) {
        if (rule instanceof CSSFontFaceRule) {
          fontFaces.push(parseCssFontFaces(rule.cssText, styleSheet.href ?? document.baseURI));
        } else if (rule instanceof CSSImportRule) {
          const absoluteUrl = new URL(rule.href, ((_a5 = rule.parentStyleSheet) == null ? void 0 : _a5.href) ?? document.baseURI);
          fontFaces.push(fetchCssFontFaces(absoluteUrl.href));
        }
      }
    } else if (styleSheet.href) {
      fontFaces.push(fetchCssFontFaces(styleSheet.href));
    }
  }
  return compact(await Promise.all(fontFaces)).flat();
}
var fetchCssFontFaces = fetchCache(async (response) => {
  const parsed = parseCss(await response.text(), response.url);
  const importedFontFaces = await Promise.all(
    parsed.imports.map(({ url }) => fetchCssFontFaces(new URL(url, response.url).href))
  );
  return [...parsed.fontFaces, ...compact(importedFontFaces).flat()];
});

// node_modules/@tldraw/editor/dist-esm/lib/exports/cssRules.mjs
var isCoveredByCurrentColor = (value, property, { currentColor }) => {
  return value === "currentColor" || value === currentColor;
};
var isInherited = (value, property, { parentStyles }) => {
  return parentStyles[property] === value;
};
var isExcludedBorder = (borderDirection) => (value, property, { getStyle }) => {
  const borderWidth = getStyle(`border-${borderDirection}-width`);
  const borderStyle = getStyle(`border-${borderDirection}-style`);
  if (borderWidth === "0px")
    return true;
  if (borderStyle === "none")
    return true;
  return false;
};
var cssRules = {
  // currentColor properties:
  "border-block-end-color": isCoveredByCurrentColor,
  "border-block-start-color": isCoveredByCurrentColor,
  "border-bottom-color": isCoveredByCurrentColor,
  "border-inline-end-color": isCoveredByCurrentColor,
  "border-inline-start-color": isCoveredByCurrentColor,
  "border-left-color": isCoveredByCurrentColor,
  "border-right-color": isCoveredByCurrentColor,
  "border-top-color": isCoveredByCurrentColor,
  "caret-color": isCoveredByCurrentColor,
  "column-rule-color": isCoveredByCurrentColor,
  "outline-color": isCoveredByCurrentColor,
  "text-decoration": (value, property, { currentColor }) => {
    return value === "none solid currentColor" || value === "none solid " + currentColor;
  },
  "text-decoration-color": isCoveredByCurrentColor,
  "text-emphasis-color": isCoveredByCurrentColor,
  // inherited properties:
  "border-collapse": isInherited,
  "border-spacing": isInherited,
  "caption-side": isInherited,
  // N.B. We shouldn't inherit 'color' because there's some UA styling, e.g. `mark` elements
  // 'color': isInherited,
  cursor: isInherited,
  direction: isInherited,
  "empty-cells": isInherited,
  "font-family": isInherited,
  "font-size": isInherited,
  "font-style": isInherited,
  "font-variant": isInherited,
  "font-weight": isInherited,
  "font-size-adjust": isInherited,
  "font-stretch": isInherited,
  font: isInherited,
  "letter-spacing": isInherited,
  "line-height": isInherited,
  "list-style-image": isInherited,
  "list-style-position": isInherited,
  "list-style-type": isInherited,
  "list-style": isInherited,
  orphans: isInherited,
  "overflow-wrap": isInherited,
  quotes: isInherited,
  "stroke-linecap": isInherited,
  "stroke-linejoin": isInherited,
  "tab-size": isInherited,
  "text-align": isInherited,
  "text-align-last": isInherited,
  "text-indent": isInherited,
  "text-justify": isInherited,
  "text-shadow": isInherited,
  "text-transform": isInherited,
  visibility: isInherited,
  "white-space": isInherited,
  "white-space-collapse": isInherited,
  widows: isInherited,
  "word-break": isInherited,
  "word-spacing": isInherited,
  "word-wrap": isInherited,
  // special border cases - we have a weird case (tailwind seems to trigger this) where all
  // border-styles sometimes get set to 'solid', but the border-width is 0 so they don't render.
  // but in SVGs, **sometimes**, the border-width defaults (i think from a UA style-sheet? but
  // honestly can't tell) to 1.5px so the border displays. we work around this by only including
  // border styles at all if both the border-width and border-style are set to something that
  // would show a border.
  "border-top": isExcludedBorder("top"),
  "border-right": isExcludedBorder("right"),
  "border-bottom": isExcludedBorder("bottom"),
  "border-left": isExcludedBorder("left"),
  "border-block-end": isExcludedBorder("block-end"),
  "border-block-start": isExcludedBorder("block-start"),
  "border-inline-end": isExcludedBorder("inline-end"),
  "border-inline-start": isExcludedBorder("inline-start"),
  "border-top-style": isExcludedBorder("top"),
  "border-right-style": isExcludedBorder("right"),
  "border-bottom-style": isExcludedBorder("bottom"),
  "border-left-style": isExcludedBorder("left"),
  "border-block-end-style": isExcludedBorder("block-end"),
  "border-block-start-style": isExcludedBorder("block-start"),
  "border-inline-end-style": isExcludedBorder("inline-end"),
  "border-inline-start-style": isExcludedBorder("inline-start"),
  "border-top-width": isExcludedBorder("top"),
  "border-right-width": isExcludedBorder("right"),
  "border-bottom-width": isExcludedBorder("bottom"),
  "border-left-width": isExcludedBorder("left"),
  "border-block-end-width": isExcludedBorder("block-end"),
  "border-block-start-width": isExcludedBorder("block-start"),
  "border-inline-end-width": isExcludedBorder("inline-end")
};

// node_modules/@tldraw/editor/dist-esm/lib/exports/domUtils.mjs
function getRenderedChildNodes(node) {
  if (node.shadowRoot) {
    return node.shadowRoot.childNodes;
  }
  if (isShadowSlotElement(node)) {
    const assignedNodes = node.assignedNodes();
    if (assignedNodes == null ? void 0 : assignedNodes.length) {
      return assignedNodes;
    }
  }
  return node.childNodes;
}
function* getRenderedChildren(node) {
  for (const child of getRenderedChildNodes(node)) {
    if (isElement(child))
      yield child;
  }
}
function getWindow(node) {
  var _a5;
  return ((_a5 = node.ownerDocument) == null ? void 0 : _a5.defaultView) ?? globalThis;
}
function isElement(node) {
  return node instanceof getWindow(node).Element;
}
function isShadowRoot(node) {
  return node instanceof getWindow(node).ShadowRoot;
}
function isInShadowRoot(node) {
  return "getRootNode" in node && isShadowRoot(node.getRootNode());
}
function isShadowSlotElement(node) {
  return isInShadowRoot(node) && node instanceof getWindow(node).HTMLSlotElement;
}
function elementStyle(element) {
  return element.style;
}
function getComputedStyle2(element, pseudoElement) {
  return getWindow(element).getComputedStyle(element, pseudoElement);
}

// node_modules/@tldraw/editor/dist-esm/lib/exports/StyleEmbedder.mjs
var NO_STYLES = {};
var StyleEmbedder = class {
  constructor(root) {
    __publicField(this, "styles", /* @__PURE__ */ new Map());
    __publicField(this, "fonts", new FontEmbedder());
    this.root = root;
  }
  readRootElementStyles(rootElement) {
    this.readElementStyles(rootElement, {
      shouldRespectDefaults: false,
      shouldSkipInheritedParentStyles: false
    });
    const children = Array.from(getRenderedChildren(rootElement));
    while (children.length) {
      const child = children.pop();
      children.push(...getRenderedChildren(child));
      this.readElementStyles(child, {
        shouldRespectDefaults: true,
        shouldSkipInheritedParentStyles: true
      });
    }
  }
  readElementStyles(element, { shouldRespectDefaults = true, shouldSkipInheritedParentStyles = true }) {
    var _a5;
    const defaultStyles = shouldRespectDefaults ? getDefaultStylesForTagName(element.tagName.toLowerCase()) : NO_STYLES;
    const parentStyles = Object.assign({}, NO_STYLES);
    if (shouldSkipInheritedParentStyles) {
      let el = element.parentElement;
      while (el) {
        const currentStyles = (_a5 = this.styles.get(el)) == null ? void 0 : _a5.self;
        for (const style2 in currentStyles) {
          if (!parentStyles[style2]) {
            parentStyles[style2] = currentStyles[style2];
          }
        }
        el = el.parentElement;
      }
    }
    const info = {
      self: styleFromElement(element, { defaultStyles, parentStyles }),
      before: styleFromPseudoElement(element, "::before"),
      after: styleFromPseudoElement(element, "::after")
    };
    this.styles.set(element, info);
  }
  fetchResources() {
    const promises = [];
    for (const info of this.styles.values()) {
      for (const styles of objectMapValues(info)) {
        if (!styles)
          continue;
        for (const [property, value] of Object.entries(styles)) {
          if (!value)
            continue;
          if (property === "font-family") {
            this.fonts.onFontFamilyValue(value);
          }
          const urlMatches = parseCssValueUrls(value);
          if (urlMatches.length === 0)
            continue;
          promises.push(
            ...urlMatches.map(async ({ url, original }) => {
              const dataUrl = await resourceToDataUrl(url) ?? "data:";
              styles[property] = value.replace(original, `url("${dataUrl}")`);
            })
          );
        }
      }
    }
    return Promise.all(promises);
  }
  // custom elements are tricky. if we serialize the dom as-is, the custom elements wont have
  // their shadow-dom contents serialized. after we've read all the styles, we need to unwrap the
  // contents of each custom elements shadow dom directly into the parent element itself.
  unwrapCustomElements() {
    const visited = /* @__PURE__ */ new Set();
    const visit = (element, clonedParent) => {
      if (visited.has(element))
        return;
      visited.add(element);
      const shadowRoot = element.shadowRoot;
      if (shadowRoot) {
        const clonedCustomEl = document.createElement("div");
        this.styles.set(clonedCustomEl, this.styles.get(element));
        clonedCustomEl.setAttribute("data-tl-custom-element", element.tagName);
        (clonedParent ?? element.parentElement).appendChild(clonedCustomEl);
        for (const child of shadowRoot.childNodes) {
          if (child instanceof Element) {
            visit(child, clonedCustomEl);
          } else {
            clonedCustomEl.appendChild(child.cloneNode(true));
          }
        }
        element.remove();
      } else if (clonedParent) {
        if (element.tagName.toLowerCase() === "style") {
          return;
        }
        const clonedEl = element.cloneNode(false);
        this.styles.set(clonedEl, this.styles.get(element));
        clonedParent.appendChild(clonedEl);
        for (const child of getRenderedChildNodes(element)) {
          if (child instanceof Element) {
            visit(child, clonedEl);
          } else {
            clonedEl.appendChild(child.cloneNode(true));
          }
        }
      }
    };
    for (const element of this.styles.keys()) {
      visit(element, null);
    }
  }
  embedStyles() {
    let css = "";
    for (const [element, info] of this.styles) {
      if (info.after || info.before) {
        const className = `pseudo-${uniqueId()}`;
        element.classList.add(className);
        if (info.before) {
          css += `.${className}::before {${formatCss(info.before)}}
`;
        }
        if (info.after) {
          css += `.${className}::after {${formatCss(info.after)}}
`;
        }
      }
      const style2 = elementStyle(element);
      for (const [property, value] of Object.entries(info.self)) {
        if (!value)
          continue;
        style2.setProperty(property, value);
      }
      if (style2.fontKerning === "auto") {
        style2.fontKerning = "normal";
      }
    }
    return css;
  }
  async getFontFaceCss() {
    return await this.fonts.createCss();
  }
  dispose() {
    destroyDefaultStyleFrame();
  }
};
function styleFromElement(element, { defaultStyles, parentStyles }) {
  if (element.computedStyleMap) {
    return styleFromComputedStyleMap(element.computedStyleMap(), { defaultStyles, parentStyles });
  }
  return styleFromComputedStyle(getComputedStyle2(element), { defaultStyles, parentStyles });
}
function styleFromPseudoElement(element, pseudo) {
  const style2 = getComputedStyle2(element, pseudo);
  const content = style2.getPropertyValue("content");
  if (content === "" || content === "none") {
    return void 0;
  }
  return styleFromComputedStyle(style2, { defaultStyles: NO_STYLES, parentStyles: NO_STYLES });
}
function styleFromComputedStyleMap(style2, { defaultStyles, parentStyles }) {
  var _a5;
  const styles = {};
  const currentColor = ((_a5 = style2.get("color")) == null ? void 0 : _a5.toString()) || "";
  const ruleOptions = {
    currentColor,
    parentStyles,
    defaultStyles,
    getStyle: (property) => {
      var _a6;
      return ((_a6 = style2.get(property)) == null ? void 0 : _a6.toString()) ?? "";
    }
  };
  for (const property of style2.keys()) {
    if (!shouldIncludeCssProperty(property))
      continue;
    const value = style2.get(property).toString();
    if (defaultStyles[property] === value)
      continue;
    const rule = getOwnProperty(cssRules, property);
    if (rule && rule(value, property, ruleOptions))
      continue;
    styles[property] = value;
  }
  return styles;
}
function styleFromComputedStyle(style2, { defaultStyles, parentStyles }) {
  const styles = {};
  const currentColor = style2.color;
  const ruleOptions = {
    currentColor,
    parentStyles,
    defaultStyles,
    getStyle: (property) => style2.getPropertyValue(property)
  };
  for (const property in style2) {
    if (!shouldIncludeCssProperty(property))
      continue;
    const value = style2.getPropertyValue(property);
    if (defaultStyles[property] === value)
      continue;
    const rule = getOwnProperty(cssRules, property);
    if (rule && rule(value, property, ruleOptions))
      continue;
    styles[property] = value;
  }
  return styles;
}
function formatCss(style2) {
  let cssText = "";
  for (const [property, value] of Object.entries(style2)) {
    cssText += `${property}: ${value};`;
  }
  return cssText;
}
var defaultStyleFrame;
var defaultStylesByTagName = {};
function getDefaultStyleFrame() {
  if (!defaultStyleFrame) {
    const frame2 = document.createElement("iframe");
    frame2.style.display = "none";
    document.body.appendChild(frame2);
    const frameDocument = assertExists(frame2.contentDocument, "frame must have a document");
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
    svg.appendChild(foreignObject);
    frameDocument.body.appendChild(svg);
    defaultStyleFrame = { iframe: frame2, foreignObject, document: frameDocument };
  }
  return defaultStyleFrame;
}
function destroyDefaultStyleFrame() {
  if (defaultStyleFrame) {
    document.body.removeChild(defaultStyleFrame.iframe);
    defaultStyleFrame = void 0;
  }
}
var defaultStyleReadOptions = { defaultStyles: NO_STYLES, parentStyles: NO_STYLES };
function getDefaultStylesForTagName(tagName) {
  let existing = defaultStylesByTagName[tagName];
  if (!existing) {
    const { foreignObject, document: document2 } = getDefaultStyleFrame();
    const element = document2.createElement(tagName);
    foreignObject.appendChild(element);
    existing = element.computedStyleMap ? styleFromComputedStyleMap(element.computedStyleMap(), defaultStyleReadOptions) : styleFromComputedStyle(getComputedStyle2(element), defaultStyleReadOptions);
    foreignObject.removeChild(element);
    defaultStylesByTagName[tagName] = existing;
  }
  return existing;
}

// node_modules/@tldraw/editor/dist-esm/lib/exports/embedMedia.mjs
function copyAttrs(source, target) {
  const attrs = Array.from(source.attributes);
  attrs.forEach((attr) => {
    target.setAttribute(attr.name, attr.value);
  });
}
function replace(original, replacement) {
  original.replaceWith(replacement);
  return replacement;
}
async function createImage(dataUrl, cloneAttributesFrom) {
  const image = document.createElement("img");
  if (cloneAttributesFrom) {
    copyAttrs(cloneAttributesFrom, image);
  }
  image.setAttribute("src", dataUrl ?? "data:");
  image.setAttribute("decoding", "sync");
  image.setAttribute("loading", "eager");
  try {
    await image.decode();
  } catch {
  }
  return image;
}
async function getCanvasReplacement(canvas) {
  try {
    const dataURL = canvas.toDataURL();
    return await createImage(dataURL, canvas);
  } catch {
    return await createImage(null, canvas);
  }
}
async function getVideoReplacement(video) {
  try {
    const dataUrl = await MediaHelpers.getVideoFrameAsDataUrl(video);
    return createImage(dataUrl, video);
  } catch (err) {
    console.error("Could not get video frame", err);
  }
  if (video.poster) {
    const dataUrl = await resourceToDataUrl(video.poster);
    return createImage(dataUrl, video);
  }
  return createImage(null, video);
}
async function embedMedia(node) {
  if (node instanceof HTMLCanvasElement) {
    return replace(node, await getCanvasReplacement(node));
  } else if (node instanceof HTMLVideoElement) {
    return replace(node, await getVideoReplacement(node));
  } else if (node instanceof HTMLImageElement) {
    const src = node.currentSrc || node.src;
    const dataUrl = await resourceToDataUrl(src);
    node.setAttribute("src", dataUrl ?? "data:");
    node.setAttribute("decoding", "sync");
    node.setAttribute("loading", "eager");
    try {
      await node.decode();
    } catch {
    }
    return node;
  } else if (node instanceof HTMLInputElement) {
    node.setAttribute("value", node.value);
  } else if (node instanceof HTMLTextAreaElement) {
    node.textContent = node.value;
  }
  await Promise.all(
    Array.from(getRenderedChildren(node), (child) => embedMedia(child))
  );
}

// node_modules/@tldraw/editor/dist-esm/lib/exports/getSvgJsx.mjs
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/editor/types/SvgExportContext.mjs
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react35 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useEvent.mjs
var import_react34 = __toESM(require_react(), 1);
function useEvent(handler) {
  const handlerRef = (0, import_react34.useRef)();
  (0, import_react34.useLayoutEffect)(() => {
    handlerRef.current = handler;
  });
  (0, import_react34.useDebugValue)(handler);
  return (0, import_react34.useCallback)((...args) => {
    const fn2 = handlerRef.current;
    assert(fn2, "fn does not exist");
    return fn2(...args);
  }, []);
}
function useReactiveEvent(handler) {
  const handlerAtom = useAtom("useReactiveEvent", () => handler);
  (0, import_react34.useLayoutEffect)(() => {
    handlerAtom.set(handler);
  });
  (0, import_react34.useDebugValue)(handler);
  return (0, import_react34.useCallback)(
    (...args) => {
      const fn2 = handlerAtom.get();
      assert(fn2, "fn does not exist");
      return fn2(...args);
    },
    [handlerAtom]
  );
}

// node_modules/@tldraw/editor/dist-esm/lib/editor/types/SvgExportContext.mjs
var Context = (0, import_react35.createContext)(null);
function SvgExportContextProvider({
  context,
  editor,
  children
}) {
  const Provider2 = editor.options.exportProvider;
  return (0, import_jsx_runtime31.jsx)(EditorProvider, { editor, children: (0, import_jsx_runtime31.jsx)(ContainerProvider, { container: editor.getContainer(), children: (0, import_jsx_runtime31.jsx)(Context.Provider, { value: context, children: (0, import_jsx_runtime31.jsx)(Provider2, { children }) }) }) });
}
function useSvgExportContext() {
  return (0, import_react35.useContext)(Context);
}
function useDelaySvgExport() {
  const ctx = (0, import_react35.useContext)(Context);
  const [promise] = (0, import_react35.useState)(promiseWithResolve);
  (0, import_react35.useEffect)(() => {
    ctx == null ? void 0 : ctx.waitUntil(promise);
    return () => {
      promise.resolve();
    };
  }, [promise, ctx]);
  return useEvent(() => {
    promise.resolve();
  });
}

// node_modules/@tldraw/editor/dist-esm/lib/exports/ExportDelay.mjs
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __knownSymbol2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError2 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name2 = (target, value) => __defProp2(target, "name", { value, configurable: true });
var __decoratorStart2 = (base2) => [, , , __create2((base2 == null ? void 0 : base2[__knownSymbol2("metadata")]) ?? null)];
var __decoratorStrings2 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn2 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError2("Function expected") : fn2;
var __decoratorContext2 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings2[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError2("Already initialized") : fns.push(__expectFn2(fn2 || null)) });
var __decoratorMetadata2 = (array2, target) => __defNormalProp2(target, __knownSymbol2("metadata"), array2[3]);
var __runInitializers2 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement2 = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings2[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc2(k < 4 ? target : { get [name]() {
    return __privateGet3(this, extra);
  }, set [name](x) {
    return __privateSet3(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name2(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name2(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext2(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn2(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet3 : __privateMethod2)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet3(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn2(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError2("Object expected");
    else
      __expectFn2(fn2 = it.get) && (desc.get = fn2), __expectFn2(fn2 = it.set) && (desc.set = fn2), __expectFn2(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata2(array2, target), desc && __defProp2(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField3 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck2 = (obj, member, msg2) => member.has(obj) || __typeError2("Cannot " + msg2);
var __privateIn2 = (member, obj) => Object(obj) !== obj ? __typeError2('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet3 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet3 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var _waitUntil_dec;
var _init2;
_waitUntil_dec = [bind];
var ExportDelay = class {
  constructor(maxDelayTimeMs) {
    this.maxDelayTimeMs = maxDelayTimeMs;
    __runInitializers2(_init2, 5, this);
    __publicField3(this, "isResolved", false);
    __publicField3(this, "promisesToWaitFor", []);
  }
  waitUntil(promise) {
    if (this.isResolved) {
      throw new Error(
        "Cannot `waitUntil` - the export has already been resolved. Make sure to call `waitUntil` as soon as possible during an export - ie within the first react effect after rendering."
      );
    }
    this.promisesToWaitFor.push(
      promise.catch((err) => console.error("Error while waiting for export:", err))
    );
  }
  async resolvePromises() {
    let lastLength = null;
    while (this.promisesToWaitFor.length !== lastLength) {
      lastLength = this.promisesToWaitFor.length;
      await Promise.allSettled(this.promisesToWaitFor);
      await sleep(0);
    }
  }
  async resolve() {
    const timeoutPromise = sleep(this.maxDelayTimeMs).then(() => "timeout");
    const resolvePromise = this.resolvePromises().then(() => "resolved");
    const result = await Promise.race([timeoutPromise, resolvePromise]);
    if (result === "timeout") {
      console.warn("[tldraw] Export delay timed out after ${this.maxDelayTimeMs}ms");
    }
    this.isResolved = true;
  }
};
_init2 = __decoratorStart2(null);
__decorateElement2(_init2, 1, "waitUntil", _waitUntil_dec, ExportDelay);
__decoratorMetadata2(_init2, ExportDelay);

// node_modules/@tldraw/editor/dist-esm/lib/exports/getSvgJsx.mjs
function getSvgJsx(editor, ids, opts = {}) {
  var _a5, _b;
  if (!window.document)
    throw Error("No document");
  const {
    scale = 1,
    // should we include the background in the export? or is it transparent?
    background = editor.getInstanceState().exportBackground,
    padding = editor.options.defaultSvgPadding,
    preserveAspectRatio
  } = opts;
  const isDarkMode = opts.darkMode ?? editor.user.getIsDarkMode();
  const shapeIdsToInclude = editor.getShapeAndDescendantIds(ids);
  const renderingShapes = editor.getUnorderedRenderingShapes(false).filter(({ id }) => shapeIdsToInclude.has(id));
  let bbox = null;
  if (opts.bounds) {
    bbox = opts.bounds;
  } else {
    for (const { id } of renderingShapes) {
      const maskedPageBounds = editor.getShapeMaskedPageBounds(id);
      if (!maskedPageBounds)
        continue;
      if (bbox) {
        bbox.union(maskedPageBounds);
      } else {
        bbox = maskedPageBounds.clone();
      }
    }
  }
  if (!bbox)
    return;
  const singleFrameShapeId = ids.length === 1 && editor.isShapeOfType(editor.getShape(ids[0]), "frame") ? ids[0] : null;
  if (!singleFrameShapeId) {
    bbox.expandBy(padding);
  }
  const w = bbox.width * scale;
  const h = bbox.height * scale;
  try {
    (_b = (_a5 = document.body).focus) == null ? void 0 : _b.call(_a5);
  } catch {
  }
  const exportDelay = new ExportDelay(editor.options.maxExportDelayMs);
  const initialEffectPromise = promiseWithResolve();
  exportDelay.waitUntil(initialEffectPromise);
  const svg = (0, import_jsx_runtime32.jsx)(
    SvgExport,
    {
      editor,
      preserveAspectRatio,
      scale,
      pixelRatio: opts.pixelRatio ?? null,
      bbox,
      background,
      singleFrameShapeId,
      isDarkMode,
      renderingShapes,
      onMount: initialEffectPromise.resolve,
      waitUntil: exportDelay.waitUntil
    }
  );
  return { jsx: svg, width: w, height: h, exportDelay };
}
function SvgExport({
  editor,
  preserveAspectRatio,
  scale,
  pixelRatio,
  bbox,
  background,
  singleFrameShapeId,
  isDarkMode,
  renderingShapes,
  onMount: onMount2,
  waitUntil
}) {
  const masksId = useUniqueSafeId();
  const theme = getDefaultColorTheme({ isDarkMode });
  const stateAtom = useAtom("export state", { defsById: {}, shapeElements: null });
  const { defsById, shapeElements } = useValue(stateAtom);
  const addExportDef = useEvent((def) => {
    stateAtom.update((state) => {
      if (hasOwnProperty(state.defsById, def.key))
        return state;
      const promise = Promise.resolve(def.getElement());
      waitUntil(
        promise.then((result) => {
          stateAtom.update((state2) => ({
            ...state2,
            defsById: { ...state2.defsById, [def.key]: { pending: false, element: result } }
          }));
        })
      );
      return {
        ...state,
        defsById: { ...state.defsById, [def.key]: { pending: true, element: promise } }
      };
    });
  });
  const exportContext = (0, import_react36.useMemo)(
    () => ({
      isDarkMode,
      waitUntil,
      addExportDef,
      scale,
      pixelRatio,
      async resolveAssetUrl(assetId, width) {
        const asset = editor.getAsset(assetId);
        if (!asset || asset.type !== "image" && asset.type !== "video")
          return null;
        return await editor.resolveAssetUrl(assetId, {
          screenScale: scale * (width / asset.props.w),
          shouldResolveToOriginal: pixelRatio === null,
          dpr: pixelRatio ?? void 0
        });
      }
    }),
    [isDarkMode, waitUntil, addExportDef, scale, pixelRatio, editor]
  );
  const didRenderRef = (0, import_react36.useRef)(false);
  (0, import_react36.useLayoutEffect)(() => {
    if (didRenderRef.current) {
      throw new Error("SvgExport should only render once - do not use with react strict mode");
    }
    didRenderRef.current = true;
    (async () => {
      const shapeDefs = {};
      const unorderedShapeElementPromises = renderingShapes.map(
        async ({ id, opacity, index: index3, backgroundIndex }) => {
          var _a5, _b;
          if (id === singleFrameShapeId)
            return [];
          const shape = editor.getShape(id);
          if (editor.isShapeOfType(shape, "group"))
            return [];
          const elements = [];
          const util = editor.getShapeUtil(shape);
          if (util.toSvg || util.toBackgroundSvg) {
            const [toSvgResult, toBackgroundSvgResult] = await Promise.all([
              (_a5 = util.toSvg) == null ? void 0 : _a5.call(util, shape, exportContext),
              (_b = util.toBackgroundSvg) == null ? void 0 : _b.call(util, shape, exportContext)
            ]);
            const pageTransform = editor.getShapePageTransform(shape);
            let pageTransformString = pageTransform.toCssString();
            let scale2 = 1;
            if ("scale" in shape.props) {
              if (shape.props.scale !== 1) {
                scale2 = shape.props.scale;
                pageTransformString = `${pageTransformString} scale(${shape.props.scale}, ${shape.props.scale})`;
              }
            }
            const pageMask = editor.getShapeMask(shape.id);
            const shapeMask = pageMask ? Mat.From(Mat.Inverse(pageTransform)).applyToPoints(pageMask) : null;
            const shapeMaskId = suffixSafeId(masksId, shape.id);
            if (shapeMask) {
              shapeDefs[shapeMaskId] = {
                pending: false,
                element: (0, import_jsx_runtime32.jsx)("clipPath", { id: shapeMaskId, children: (0, import_jsx_runtime32.jsx)(
                  "path",
                  {
                    d: `M${shapeMask.map(({ x, y }) => `${x / scale2},${y / scale2}`).join("L")}Z`
                  }
                ) })
              };
            }
            if (toSvgResult) {
              elements.push({
                zIndex: index3,
                element: (0, import_jsx_runtime32.jsx)(
                  "g",
                  {
                    transform: pageTransformString,
                    opacity,
                    clipPath: pageMask ? `url(#${shapeMaskId})` : void 0,
                    children: toSvgResult
                  },
                  `fg_${shape.id}`
                )
              });
            }
            if (toBackgroundSvgResult) {
              elements.push({
                zIndex: backgroundIndex,
                element: (0, import_jsx_runtime32.jsx)(
                  "g",
                  {
                    transform: pageTransformString,
                    opacity,
                    clipPath: pageMask ? `url(#${shapeMaskId})` : void 0,
                    children: toBackgroundSvgResult
                  },
                  `bg_${shape.id}`
                )
              });
            }
          } else {
            elements.push({
              zIndex: index3,
              element: (0, import_jsx_runtime32.jsx)(
                ForeignObjectShape,
                {
                  shape,
                  util,
                  component: InnerShape,
                  className: "tl-shape",
                  bbox,
                  opacity
                },
                `fg_${shape.id}`
              )
            });
            if (util.backgroundComponent) {
              elements.push({
                zIndex: backgroundIndex,
                element: (0, import_jsx_runtime32.jsx)(
                  ForeignObjectShape,
                  {
                    shape,
                    util,
                    component: InnerShapeBackground,
                    className: "tl-shape tl-shape-background",
                    bbox,
                    opacity
                  },
                  `bg_${shape.id}`
                )
              });
            }
          }
          return elements;
        }
      );
      const unorderedShapeElements = (await Promise.all(unorderedShapeElementPromises)).flat();
      (0, import_react_dom.flushSync)(() => {
        stateAtom.update((state) => ({
          ...state,
          shapeElements: unorderedShapeElements.sort((a, b) => a.zIndex - b.zIndex).map(({ element }) => element),
          defsById: { ...state.defsById, ...shapeDefs }
        }));
      });
    })();
  }, [bbox, editor, exportContext, masksId, renderingShapes, singleFrameShapeId, stateAtom]);
  (0, import_react36.useEffect)(() => {
    const fontsInUse = /* @__PURE__ */ new Set();
    for (const { id } of renderingShapes) {
      for (const font of editor.fonts.getShapeFontFaces(id)) {
        fontsInUse.add(font);
      }
    }
    for (const font of fontsInUse) {
      addExportDef({
        key: uniqueId(),
        getElement: async () => {
          const declaration = await editor.fonts.toEmbeddedCssDeclaration(font);
          return (0, import_jsx_runtime32.jsx)("style", { nonce: editor.options.nonce, children: declaration });
        }
      });
    }
  }, [editor, renderingShapes, addExportDef]);
  (0, import_react36.useEffect)(() => {
    if (shapeElements === null)
      return;
    onMount2();
  }, [onMount2, shapeElements]);
  let backgroundColor = background ? theme.background : "transparent";
  if (singleFrameShapeId && background) {
    const frameShapeUtil = editor.getShapeUtil("frame");
    if (frameShapeUtil == null ? void 0 : frameShapeUtil.options.showColors) {
      const shape = editor.getShape(singleFrameShapeId);
      const color = theme[shape.props.color];
      backgroundColor = color.frame.fill;
    } else {
      backgroundColor = theme.solid;
    }
  }
  return (0, import_jsx_runtime32.jsx)(SvgExportContextProvider, { editor, context: exportContext, children: (0, import_jsx_runtime32.jsxs)(
    "svg",
    {
      preserveAspectRatio,
      direction: "ltr",
      width: bbox.width * scale,
      height: bbox.height * scale,
      viewBox: `${bbox.minX} ${bbox.minY} ${bbox.width} ${bbox.height}`,
      strokeLinecap: "round",
      strokeLinejoin: "round",
      style: { backgroundColor },
      "data-color-mode": isDarkMode ? "dark" : "light",
      className: `tl-container tl-theme__force-sRGB ${isDarkMode ? "tl-theme__dark" : "tl-theme__light"}`,
      children: [
        (0, import_jsx_runtime32.jsx)("defs", { children: Object.entries(defsById).map(
          ([key, def]) => def.pending ? null : (0, import_jsx_runtime32.jsx)(import_react36.Fragment, { children: def.element }, key)
        ) }),
        shapeElements
      ]
    }
  ) });
}
function ForeignObjectShape({
  shape,
  util,
  className,
  component: Component2,
  bbox,
  opacity
}) {
  const editor = useEditor();
  const transform = Mat.Translate(-bbox.minX, -bbox.minY).multiply(
    editor.getShapePageTransform(shape.id)
  );
  const bounds = editor.getShapeGeometry(shape.id).bounds;
  const width = Math.max(bounds.width, 1);
  const height = Math.max(bounds.height, 1);
  return (0, import_jsx_runtime32.jsx)(ErrorBoundary, { fallback: () => null, children: (0, import_jsx_runtime32.jsx)(
    "foreignObject",
    {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.w,
      height: bbox.h,
      className: "tl-shape-foreign-object tl-export-embed-styles",
      children: (0, import_jsx_runtime32.jsx)(
        "div",
        {
          className,
          "data-shape-type": shape.type,
          style: {
            clipPath: editor.getShapeClipPath(shape.id),
            transform: transform.toCssString(),
            width,
            height,
            opacity
          },
          children: (0, import_jsx_runtime32.jsx)(Component2, { shape, util })
        }
      )
    }
  ) });
}

// node_modules/@tldraw/editor/dist-esm/lib/exports/exportToSvg.mjs
var idCounter = 1;
async function exportToSvg(editor, shapeIds, opts = {}) {
  const result = getSvgJsx(editor, shapeIds, opts);
  if (!result)
    return void 0;
  const container = editor.getContainer();
  const renderTarget = document.createElement("div");
  renderTarget.className = SVG_EXPORT_CLASSNAME;
  renderTarget.inert = true;
  renderTarget.tabIndex = -1;
  Object.assign(renderTarget.style, {
    position: "absolute",
    top: "0px",
    left: "0px",
    width: result.width + "px",
    height: result.height + "px",
    pointerEvents: "none",
    opacity: 0
  });
  container.appendChild(renderTarget);
  const root = (0, import_client.createRoot)(renderTarget, { identifierPrefix: `export_${idCounter++}_` });
  try {
    await Promise.resolve();
    (0, import_react_dom2.flushSync)(() => {
      root.render(result.jsx);
    });
    await result.exportDelay.resolve();
    const svg = renderTarget.firstElementChild;
    assert(svg instanceof SVGSVGElement, "Expected an SVG element");
    await applyChangesToForeignObjects(svg);
    return { svg, width: result.width, height: result.height };
  } finally {
    setTimeout(() => {
      root.unmount();
      container.removeChild(renderTarget);
    }, 0);
  }
}
async function applyChangesToForeignObjects(svg) {
  const foreignObjectChildren = [
    ...svg.querySelectorAll("foreignObject.tl-export-embed-styles > *")
  ];
  if (!foreignObjectChildren.length)
    return;
  const styleEmbedder = new StyleEmbedder(svg);
  try {
    styleEmbedder.fonts.startFindingCurrentDocumentFontFaces();
    await Promise.all(foreignObjectChildren.map((el) => embedMedia(el)));
    for (const el of foreignObjectChildren) {
      styleEmbedder.readRootElementStyles(el);
    }
    await styleEmbedder.fetchResources();
    const fontCss = await styleEmbedder.getFontFaceCss();
    styleEmbedder.unwrapCustomElements();
    const pseudoCss = styleEmbedder.embedStyles();
    if (fontCss || pseudoCss) {
      const style2 = document.createElementNS("http://www.w3.org/2000/svg", "style");
      style2.textContent = `${fontCss}
${pseudoCss}`;
      svg.prepend(style2);
    }
  } finally {
    styleEmbedder.dispose();
  }
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/browserCanvasMaxSize.mjs
var maxCanvasSizes = null;
function getBrowserCanvasMaxSize() {
  if (!maxCanvasSizes) {
    maxCanvasSizes = {
      maxWidth: getCanvasSize("width"),
      // test very wide but 1 pixel tall canvases
      maxHeight: getCanvasSize("height"),
      // test very tall but 1 pixel wide canvases
      maxArea: getCanvasSize("area")
      // test square canvases
    };
  }
  return maxCanvasSizes;
}
var MAX_SAFE_CANVAS_DIMENSION = 8192;
var MAX_SAFE_CANVAS_AREA = 4096 * 4096;
var TEST_SIZES = {
  area: [
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4)
    // Edge 17 (Win)
    // Safari 7-12 (Mac)
    16384,
    // Chrome 68 (Android 7.1-9)
    14188,
    // Chrome 68 (Android 5)
    11402,
    // Firefox 63 (Mac, Win)
    11180,
    // Chrome 68 (Android 6)
    10836,
    // IE 9-11 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    // Safari (iOS 9 - 12)
    4096
  ],
  height: [
    // Safari 7-12 (Mac)
    // Safari (iOS 9-12)
    8388607,
    // Chrome 83 (Mac, Win)
    65535,
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4-9)
    // Firefox 63 (Mac, Win)
    32767,
    // Edge 17 (Win)
    // IE11 (Win)
    16384,
    // IE 9-10 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    4096
  ],
  width: [
    // Safari 7-12 (Mac)
    // Safari (iOS 9-12)
    4194303,
    // Chrome 83 (Mac, Win)
    65535,
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4-9)
    // Firefox 63 (Mac, Win)
    32767,
    // Edge 17 (Win)
    // IE11 (Win)
    16384,
    // IE 9-10 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    4096
  ]
};
function getCanvasSize(dimension) {
  const cropCvs = document.createElement("canvas");
  cropCvs.width = 1;
  cropCvs.height = 1;
  const cropCtx = cropCvs.getContext("2d");
  for (const size4 of TEST_SIZES[dimension]) {
    const w = dimension === "height" ? 1 : size4;
    const h = dimension === "width" ? 1 : size4;
    const testCvs = document.createElement("canvas");
    testCvs.width = w;
    testCvs.height = h;
    const testCtx = testCvs.getContext("2d");
    testCtx.fillRect(w - 1, h - 1, 1, 1);
    cropCtx.drawImage(testCvs, w - 1, h - 1, 1, 1, 0, 0, 1, 1);
    const isTestPassed = cropCtx.getImageData(0, 0, 1, 1).data[3] !== 0;
    testCvs.width = 0;
    testCvs.height = 0;
    if (isTestPassed) {
      cropCvs.width = 0;
      cropCvs.height = 0;
      if (dimension === "area") {
        return size4 * size4;
      } else {
        return size4;
      }
    }
  }
  cropCvs.width = 0;
  cropCvs.height = 0;
  throw Error("Failed to determine maximum canvas dimension");
}
function clampToBrowserMaxCanvasSize(width, height) {
  if (width <= MAX_SAFE_CANVAS_DIMENSION && height <= MAX_SAFE_CANVAS_DIMENSION && width * height <= MAX_SAFE_CANVAS_AREA) {
    return [width, height];
  }
  const { maxWidth, maxHeight, maxArea } = getBrowserCanvasMaxSize();
  const aspectRatio = width / height;
  if (width > maxWidth) {
    width = maxWidth;
    height = width / aspectRatio;
  }
  if (height > maxHeight) {
    height = maxHeight;
    width = height * aspectRatio;
  }
  if (width * height > maxArea) {
    const ratio = Math.sqrt(maxArea / (width * height));
    width *= ratio;
    height *= ratio;
  }
  return [width, height];
}

// node_modules/@tldraw/editor/dist-esm/lib/exports/getSvgAsImage.mjs
async function getSvgAsImage(svgString, options2) {
  const { type, width, height, quality = 1, pixelRatio = 2 } = options2;
  let [clampedWidth, clampedHeight] = clampToBrowserMaxCanvasSize(
    width * pixelRatio,
    height * pixelRatio
  );
  clampedWidth = Math.floor(clampedWidth);
  clampedHeight = Math.floor(clampedHeight);
  const effectiveScale = clampedWidth / width;
  const svgUrl = await FileHelpers.blobToDataUrl(new Blob([svgString], { type: "image/svg+xml" }));
  const canvas = await new Promise((resolve) => {
    const image = Image();
    image.crossOrigin = "anonymous";
    image.onload = async () => {
      if (tlenv.isSafari) {
        await sleep(250);
      }
      const canvas2 = document.createElement("canvas");
      const ctx = canvas2.getContext("2d");
      canvas2.width = clampedWidth;
      canvas2.height = clampedHeight;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(image, 0, 0, clampedWidth, clampedHeight);
      URL.revokeObjectURL(svgUrl);
      resolve(canvas2);
    };
    image.onerror = () => {
      resolve(null);
    };
    image.src = svgUrl;
  });
  if (!canvas)
    return null;
  const blob = await new Promise(
    (resolve) => canvas.toBlob(
      (blob2) => {
        if (!blob2 || debugFlags.throwToBlob.get()) {
          resolve(null);
        }
        resolve(blob2);
      },
      "image/" + type,
      quality
    )
  );
  if (!blob)
    return null;
  if (type === "png") {
    const view = new DataView(await blob.arrayBuffer());
    return PngHelpers.setPhysChunk(view, effectiveScale, {
      type: "image/" + type
    });
  } else {
    return blob;
  }
}

// node_modules/@tldraw/editor/dist-esm/lib/globals/menus.mjs
var tlmenus = {
  /**
   * A set of strings representing any open menus. When menus are open,
   * certain interactions will behave differently; for example, when a
   * draw tool is selected and a menu is open, a pointer-down will not
   * create a dot (because the user is probably trying to close the menu)
   * however a pointer-down event followed by a drag will begin drawing
   * a line (because the user is BOTH trying to close the menu AND start
   * drawing a line).
   *
   * @public
   */
  menus: atom("open menus", []),
  /**
   * Get the current open menus.
   *
   * @param contextId - An optional context to get menus for.
   *
   * @public
   */
  getOpenMenus(contextId) {
    if (contextId)
      return this.menus.get().filter((m) => m.endsWith("-" + contextId));
    return this.menus.get();
  },
  /**
   * Add an open menu.
   *
   * @example
   * ```ts
   * addOpenMenu('menu-id')
   * addOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to add.
   * @param contextId - An optional context to add the menu to.
   *
   * @public
   */
  addOpenMenu(id, contextId = "") {
    const idWithContext = contextId ? `${id}-${contextId}` : id;
    const menus = new Set(this.menus.get());
    if (!menus.has(idWithContext)) {
      menus.add(idWithContext);
      this.menus.set([...menus]);
    }
  },
  /**
   * Delete an open menu.
   *
   * @example
   * ```ts
   * deleteOpenMenu('menu-id')
   * deleteOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to delete.
   * @param contextId - An optional context to delete the menu from.
   *
   * @public
   */
  deleteOpenMenu(id, contextId = "") {
    const idWithContext = contextId ? `${id}-${contextId}` : id;
    const menus = new Set(this.menus.get());
    if (menus.has(idWithContext)) {
      menus.delete(idWithContext);
      this.menus.set([...menus]);
    }
  },
  /**
   * Clear all open menus.
   *
   * @example
   * ```ts
   * clearOpenMenus()
   * clearOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to clear menus for.
   *
   * @public
   */
  clearOpenMenus(contextId) {
    this.menus.set(contextId ? this.menus.get().filter((m) => !m.endsWith("-" + contextId)) : []);
  },
  _hiddenMenus: [],
  /**
   * Hide all open menus. Restore them with the `showOpenMenus` method.
   *
   * @example
   * ```ts
   * hideOpenMenus()
   * hideOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to hide menus for.
   *
   * @public
   */
  hideOpenMenus(contextId) {
    this._hiddenMenus = [...this.getOpenMenus(contextId)];
    if (this._hiddenMenus.length === 0)
      return;
    for (const menu of this._hiddenMenus) {
      this.deleteOpenMenu(menu, contextId);
    }
  },
  /**
   * Show all hidden menus.
   *
   * @example
   * ```ts
   * showOpenMenus()
   * showOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to show menus for.
   *
   * @public
   */
  showOpenMenus(contextId) {
    if (this._hiddenMenus.length === 0)
      return;
    for (const menu of this._hiddenMenus) {
      this.addOpenMenu(menu, contextId);
    }
    this._hiddenMenus = [];
  },
  /**
   * Get whether a menu is open for a given context.
   *
   * @example
   * ```ts
   * isMenuOpem(id, myEditorId)
   * ```
   *
   * @param id - The id of the menu to check.
   * @param contextId - An optional context to check menus for.
   *
   * @public
   */
  isMenuOpen(id, contextId) {
    return this.getOpenMenus(contextId).includes(id);
  },
  /**
   * Get whether any menus are open for a given context.
   *
   * @example
   * ```ts
   * hasOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - A context to check menus for.
   *
   * @public
   */
  hasOpenMenus(contextId) {
    return this.getOpenMenus(contextId).length > 0;
  },
  /**
   * Get whether any menus are open for any context.
   *
   * @example
   * ```ts
   * hasAnyOpenMenus()
   * ```
   *
   * @public
   */
  hasAnyOpenMenus() {
    return this.getOpenMenus().length > 0;
  },
  forContext(contextId) {
    return {
      getOpenMenus: () => this.getOpenMenus(contextId),
      addOpenMenu: (id) => this.addOpenMenu(id, contextId),
      deleteOpenMenu: (id) => this.deleteOpenMenu(id, contextId),
      clearOpenMenus: () => this.clearOpenMenus(contextId),
      // Gets whether any menus are open
      isMenuOpen: (id) => this.isMenuOpen(id, contextId),
      hasOpenMenus: () => this.hasOpenMenus(contextId),
      hasAnyOpenMenus: () => this.hasAnyOpenMenus()
    };
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/globals/time.mjs
var tltime = new Timers();

// node_modules/@tldraw/editor/dist-esm/lib/options.mjs
var import_react37 = __toESM(require_react(), 1);
var defaultTldrawOptions = {
  maxShapesPerPage: 4e3,
  maxFilesAtOnce: 100,
  maxPages: 40,
  animationMediumMs: 320,
  followChaseViewportSnap: 2,
  doubleClickDurationMs: 450,
  multiClickDurationMs: 200,
  coarseDragDistanceSquared: 36,
  // 6 squared
  dragDistanceSquared: 16,
  // 4 squared
  defaultSvgPadding: 32,
  cameraSlideFriction: 0.09,
  gridSteps: [
    { min: -1, mid: 0.15, step: 64 },
    { min: 0.05, mid: 0.375, step: 16 },
    { min: 0.15, mid: 1, step: 4 },
    { min: 0.7, mid: 2.5, step: 1 }
  ],
  collaboratorInactiveTimeoutMs: 6e4,
  collaboratorIdleTimeoutMs: 3e3,
  collaboratorCheckIntervalMs: 1200,
  cameraMovingTimeoutMs: 64,
  hitTestMargin: 8,
  edgeScrollDelay: 200,
  edgeScrollEaseDuration: 200,
  edgeScrollSpeed: 25,
  edgeScrollDistance: 8,
  coarsePointerWidth: 12,
  coarseHandleRadius: 20,
  handleRadius: 12,
  longPressDurationMs: 500,
  textShadowLod: 0.35,
  adjacentShapeMargin: 10,
  flattenImageBoundsExpand: 64,
  flattenImageBoundsPadding: 16,
  laserDelayMs: 1200,
  maxExportDelayMs: 5e3,
  temporaryAssetPreviewLifetimeMs: 18e4,
  actionShortcutsLocation: "swap",
  createTextOnCanvasDoubleClick: true,
  exportProvider: import_react37.Fragment,
  enableToolbarKeyboardShortcuts: true,
  maxFontsToLoadBeforeRender: Infinity,
  nonce: void 0
};

// node_modules/@tldraw/editor/dist-esm/lib/utils/SharedStylesMap.mjs
function sharedStyleEquals(a, b) {
  if (!b)
    return false;
  switch (a.type) {
    case "mixed":
      return b.type === "mixed";
    case "shared":
      return b.type === "shared" && a.value === b.value;
    default:
      throw exhaustiveSwitchError(a);
  }
}
var ReadonlySharedStyleMap = class {
  constructor(entries) {
    /** @internal */
    __publicField(this, "map");
    this.map = new Map(entries);
  }
  get(prop) {
    return this.map.get(prop);
  }
  getAsKnownValue(prop) {
    const value = this.get(prop);
    if (!value)
      return void 0;
    if (value.type === "mixed")
      return void 0;
    return value.value;
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.map.size;
  }
  equals(other) {
    if (this.size !== other.size)
      return false;
    const checkedKeys = /* @__PURE__ */ new Set();
    for (const [styleProp, value] of this) {
      if (!sharedStyleEquals(value, other.get(styleProp)))
        return false;
      checkedKeys.add(styleProp);
    }
    for (const [styleProp, value] of other) {
      if (checkedKeys.has(styleProp))
        continue;
      if (!sharedStyleEquals(value, this.get(styleProp)))
        return false;
    }
    return true;
  }
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
  [Symbol.iterator]() {
    return this.map[Symbol.iterator]();
  }
};
var SharedStyleMap = class extends ReadonlySharedStyleMap {
  set(prop, value) {
    this.map.set(prop, value);
  }
  applyValue(prop, value) {
    const existingValue = this.get(prop);
    if (!existingValue) {
      this.set(prop, { type: "shared", value });
      return;
    }
    switch (existingValue.type) {
      case "mixed":
        return;
      case "shared":
        if (existingValue.value !== value) {
          this.set(prop, { type: "mixed" });
        }
        return;
      default:
        exhaustiveSwitchError(existingValue, "type");
    }
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/utils/assets.mjs
function dataUrlToFile(url, filename, mimeType) {
  return fetch(url).then(function(res) {
    return res.arrayBuffer();
  }).then(function(buf) {
    return new File([buf], filename, { type: mimeType });
  });
}
var CDN_BASE_URL = "https://cdn.tldraw.com";
function getDefaultCdnBaseUrl() {
  return `${CDN_BASE_URL}/${version}`;
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/deepLinks.mjs
function createDeepLinkString(deepLink) {
  switch (deepLink.type) {
    case "shapes": {
      const ids = deepLink.shapeIds.map((id) => encodeId(id.slice("shape:".length)));
      return `s${ids.join(".")}`;
    }
    case "page": {
      return "p" + encodeId(PageRecordType.parseId(deepLink.pageId));
    }
    case "viewport": {
      const { bounds, pageId } = deepLink;
      let res = `v${Math.round(bounds.x)}.${Math.round(bounds.y)}.${Math.round(bounds.w)}.${Math.round(bounds.h)}`;
      if (pageId) {
        res += "." + encodeId(PageRecordType.parseId(pageId));
      }
      return res;
    }
    default:
      exhaustiveSwitchError(deepLink);
  }
}
function parseDeepLinkString(deepLinkString) {
  const type = deepLinkString[0];
  switch (type) {
    case "s": {
      const shapeIds = deepLinkString.slice(1).split(".").filter(Boolean).map((id) => createShapeId(decodeURIComponent(id)));
      return { type: "shapes", shapeIds };
    }
    case "p": {
      const pageId = PageRecordType.createId(decodeURIComponent(deepLinkString.slice(1)));
      return { type: "page", pageId };
    }
    case "v": {
      const [x, y, w, h, pageId] = deepLinkString.slice(1).split(".");
      return {
        type: "viewport",
        bounds: new Box(Number(x), Number(y), Number(w), Number(h)),
        pageId: pageId ? PageRecordType.createId(decodeURIComponent(pageId)) : void 0
      };
    }
    default:
      throw Error("Invalid deep link string");
  }
}
function encodeId(str) {
  return encodeURIComponent(str).replace(/\./g, "%2E");
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/getIncrementedName.mjs
function getIncrementedName(name, others) {
  var _a5;
  let result = name;
  const set = new Set(others);
  while (set.has(result)) {
    result = ((_a5 = /^.*(\d+)$/.exec(result)) == null ? void 0 : _a5[1]) ? result.replace(/(\d+)(?=\D?)$/, (m) => {
      return (+m + 1).toString();
    }) : `${result} 1`;
  }
  return result;
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/reorderShapes.mjs
function getReorderingShapesChanges(editor, operation, ids, opts) {
  if (ids.length === 0)
    return [];
  const parents = /* @__PURE__ */ new Map();
  for (const shape of compact(ids.map((id) => editor.getShape(id)))) {
    const { parentId } = shape;
    if (!parents.has(parentId)) {
      parents.set(parentId, {
        children: compact(
          editor.getSortedChildIdsForParent(parentId).map((id) => editor.getShape(id))
        ),
        moving: /* @__PURE__ */ new Set()
      });
    }
    parents.get(parentId).moving.add(shape);
  }
  const changes = [];
  switch (operation) {
    case "toBack": {
      parents.forEach(({ moving, children }) => reorderToBack(moving, children, changes));
      break;
    }
    case "toFront": {
      parents.forEach(({ moving, children }) => reorderToFront(moving, children, changes));
      break;
    }
    case "forward": {
      parents.forEach(
        ({ moving, children }) => reorderForward(editor, moving, children, changes, opts)
      );
      break;
    }
    case "backward": {
      parents.forEach(
        ({ moving, children }) => reorderBackward(editor, moving, children, changes, opts)
      );
      break;
    }
  }
  return changes;
}
function reorderToBack(moving, children, changes) {
  const len = children.length;
  if (moving.size === len)
    return;
  let below;
  let above;
  for (let i = 0; i < len; i++) {
    const shape = children[i];
    if (moving.has(shape)) {
      below = shape.index;
      moving.delete(shape);
    } else {
      above = shape.index;
      break;
    }
  }
  if (moving.size === 0) {
    return;
  } else {
    const indices = getIndicesBetween(below, above, moving.size);
    changes.push(
      ...Array.from(moving.values()).sort(sortByIndex).map((shape, i) => ({ ...shape, index: indices[i] }))
    );
  }
}
function reorderToFront(moving, children, changes) {
  const len = children.length;
  if (moving.size === len)
    return;
  let below;
  let above;
  for (let i = len - 1; i > -1; i--) {
    const shape = children[i];
    if (moving.has(shape)) {
      above = shape.index;
      moving.delete(shape);
    } else {
      below = shape.index;
      break;
    }
  }
  if (moving.size === 0) {
    return;
  } else {
    const indices = getIndicesBetween(below, above, moving.size);
    changes.push(
      ...Array.from(moving.values()).sort(sortByIndex).map((shape, i) => ({ ...shape, index: indices[i] }))
    );
  }
}
function getOverlapChecker(editor, moving) {
  const movingVertices = Array.from(moving).map((shape) => {
    const vertices = editor.getShapePageGeometry(shape).vertices;
    if (!vertices)
      return null;
    return { shape, vertices };
  }).filter(Boolean);
  const isOverlapping = (child) => {
    const vertices = editor.getShapePageGeometry(child).vertices;
    if (!vertices)
      return false;
    return movingVertices.some((other) => {
      return polygonsIntersect(other.vertices, vertices);
    });
  };
  return isOverlapping;
}
function reorderForward(editor, moving, children, changes, opts) {
  var _a5;
  const isOverlapping = getOverlapChecker(editor, moving);
  const len = children.length;
  if (moving.size === len)
    return;
  let state = { name: "skipping" };
  for (let i = 0; i < len; i++) {
    const isMoving = moving.has(children[i]);
    switch (state.name) {
      case "skipping": {
        if (!isMoving)
          continue;
        state = { name: "selecting", selectIndex: i };
        break;
      }
      case "selecting": {
        if (isMoving)
          continue;
        if (!(opts == null ? void 0 : opts.considerAllShapes) && !isOverlapping(children[i]))
          continue;
        const { selectIndex } = state;
        getIndicesBetween(children[i].index, (_a5 = children[i + 1]) == null ? void 0 : _a5.index, i - selectIndex).forEach(
          (index3, k) => {
            const child = children[selectIndex + k];
            if (!moving.has(child))
              return;
            changes.push({ ...child, index: index3 });
          }
        );
        state = { name: "skipping" };
        break;
      }
    }
  }
}
function reorderBackward(editor, moving, children, changes, opts) {
  var _a5;
  const isOverlapping = getOverlapChecker(editor, moving);
  const len = children.length;
  if (moving.size === len)
    return;
  let state = { name: "skipping" };
  for (let i = len - 1; i > -1; i--) {
    const isMoving = moving.has(children[i]);
    switch (state.name) {
      case "skipping": {
        if (!isMoving)
          continue;
        state = { name: "selecting", selectIndex: i };
        break;
      }
      case "selecting": {
        if (isMoving)
          continue;
        if (!(opts == null ? void 0 : opts.considerAllShapes) && !isOverlapping(children[i]))
          continue;
        getIndicesBetween((_a5 = children[i - 1]) == null ? void 0 : _a5.index, children[i].index, state.selectIndex - i).forEach(
          (index3, k) => {
            const child = children[i + k + 1];
            if (!moving.has(child))
              return;
            changes.push({ ...child, index: index3 });
          }
        );
        state = { name: "skipping" };
        break;
      }
    }
  }
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/rotation.mjs
function getRotationSnapshot({
  editor,
  ids
}) {
  const shapes = compact(ids.map((id) => editor.getShape(id)));
  const rotation = editor.getShapesSharedRotation(ids);
  const rotatedPageBounds = editor.getShapesRotatedPageBounds(ids);
  if (!rotatedPageBounds) {
    return null;
  }
  const initialPageCenter = rotatedPageBounds.center.clone().rotWith(rotatedPageBounds.point, rotation);
  return {
    initialPageCenter,
    initialCursorAngle: initialPageCenter.angle(editor.inputs.originPagePoint),
    initialShapesRotation: rotation,
    shapeSnapshots: shapes.map((shape) => ({
      shape,
      initialPagePoint: editor.getShapePageTransform(shape.id).point()
    }))
  };
}
function applyRotationToSnapshotShapes({
  delta,
  editor,
  snapshot,
  stage,
  centerOverride
}) {
  const { initialPageCenter, shapeSnapshots } = snapshot;
  editor.updateShapes(
    shapeSnapshots.map(({ shape, initialPagePoint }) => {
      const parentTransform = isShapeId(shape.parentId) ? editor.getShapePageTransform(shape.parentId) : Mat.Identity();
      const newPagePoint = Vec.RotWith(initialPagePoint, centerOverride ?? initialPageCenter, delta);
      const newLocalPoint = Mat.applyToPoint(
        // use the current parent transform in case it has moved/resized since the start
        // (e.g. if rotating a shape at the edge of a group)
        Mat.Inverse(parentTransform),
        newPagePoint
      );
      const newRotation = canonicalizeRotation(shape.rotation + delta);
      return {
        id: shape.id,
        type: shape.type,
        x: newLocalPoint.x,
        y: newLocalPoint.y,
        rotation: newRotation
      };
    })
  );
  const changes = [];
  shapeSnapshots.forEach(({ shape }) => {
    var _a5, _b, _c;
    const current = editor.getShape(shape.id);
    if (!current)
      return;
    const util = editor.getShapeUtil(shape);
    if (stage === "start" || stage === "one-off") {
      const changeStart = (_a5 = util.onRotateStart) == null ? void 0 : _a5.call(util, shape);
      if (changeStart)
        changes.push(changeStart);
    }
    const changeUpdate = (_b = util.onRotate) == null ? void 0 : _b.call(util, shape, current);
    if (changeUpdate)
      changes.push(changeUpdate);
    if (stage === "end" || stage === "one-off") {
      const changeEnd = (_c = util.onRotateEnd) == null ? void 0 : _c.call(util, shape, current);
      if (changeEnd)
        changes.push(changeEnd);
    }
  });
  if (changes.length > 0) {
    editor.updateShapes(changes);
  }
}

// node_modules/@tldraw/editor/dist-esm/lib/editor/derivations/bindingsIndex.mjs
var bindingsIndex = (editor) => {
  const { store } = editor;
  const bindingsHistory = store.query.filterHistory("binding");
  const bindingsQuery = store.query.records("binding");
  function fromScratch() {
    const allBindings = bindingsQuery.get();
    const shape2Binding = /* @__PURE__ */ new Map();
    for (const binding of allBindings) {
      const { fromId, toId } = binding;
      const bindingsForFromShape = shape2Binding.get(fromId);
      if (!bindingsForFromShape) {
        shape2Binding.set(fromId, [binding]);
      } else {
        bindingsForFromShape.push(binding);
      }
      const bindingsForToShape = shape2Binding.get(toId);
      if (!bindingsForToShape) {
        shape2Binding.set(toId, [binding]);
      } else {
        bindingsForToShape.push(binding);
      }
    }
    return shape2Binding;
  }
  return computed("arrowBindingsIndex", (_lastValue, lastComputedEpoch) => {
    if (isUninitialized(_lastValue)) {
      return fromScratch();
    }
    const lastValue = _lastValue;
    const diff = bindingsHistory.getDiffSince(lastComputedEpoch);
    if (diff === RESET_VALUE) {
      return fromScratch();
    }
    let nextValue = void 0;
    function removingBinding(binding) {
      nextValue ?? (nextValue = new Map(lastValue));
      const prevFrom = nextValue.get(binding.fromId);
      const nextFrom = prevFrom == null ? void 0 : prevFrom.filter((b) => b.id !== binding.id);
      if (!(nextFrom == null ? void 0 : nextFrom.length)) {
        nextValue.delete(binding.fromId);
      } else {
        nextValue.set(binding.fromId, nextFrom);
      }
      const prevTo = nextValue.get(binding.toId);
      const nextTo = prevTo == null ? void 0 : prevTo.filter((b) => b.id !== binding.id);
      if (!(nextTo == null ? void 0 : nextTo.length)) {
        nextValue.delete(binding.toId);
      } else {
        nextValue.set(binding.toId, nextTo);
      }
    }
    function ensureNewArray(shapeId) {
      nextValue ?? (nextValue = new Map(lastValue));
      let result = nextValue.get(shapeId);
      if (!result) {
        result = [];
        nextValue.set(shapeId, result);
      } else if (result === lastValue.get(shapeId)) {
        result = result.slice(0);
        nextValue.set(shapeId, result);
      }
      return result;
    }
    function addBinding(binding) {
      ensureNewArray(binding.fromId).push(binding);
      ensureNewArray(binding.toId).push(binding);
    }
    for (const changes of diff) {
      for (const newBinding of objectMapValues(changes.added)) {
        addBinding(newBinding);
      }
      for (const [prev, next] of objectMapValues(changes.updated)) {
        removingBinding(prev);
        addBinding(next);
      }
      for (const prev of objectMapValues(changes.removed)) {
        removingBinding(prev);
      }
    }
    return nextValue ?? lastValue;
  });
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/derivations/notVisibleShapes.mjs
function isShapeNotVisible(editor, id, viewportPageBounds) {
  const maskedPageBounds = editor.getShapeMaskedPageBounds(id);
  if (maskedPageBounds === void 0)
    return true;
  return !viewportPageBounds.includes(maskedPageBounds);
}
var notVisibleShapes = (editor) => {
  function fromScratch(editor2) {
    const shapes = editor2.getCurrentPageShapeIds();
    const viewportPageBounds = editor2.getViewportPageBounds();
    const notVisibleShapes2 = /* @__PURE__ */ new Set();
    shapes.forEach((id) => {
      if (isShapeNotVisible(editor2, id, viewportPageBounds)) {
        notVisibleShapes2.add(id);
      }
    });
    return notVisibleShapes2;
  }
  return computed("notVisibleShapes", (prevValue) => {
    if (isUninitialized(prevValue)) {
      return fromScratch(editor);
    }
    const nextValue = fromScratch(editor);
    if (prevValue.size !== nextValue.size)
      return nextValue;
    for (const prev of prevValue) {
      if (!nextValue.has(prev)) {
        return nextValue;
      }
    }
    return prevValue;
  });
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/derivations/parentsToChildren.mjs
var parentsToChildren = (store) => {
  const shapeIdsQuery = store.query.ids("shape");
  const shapeHistory = store.query.filterHistory("shape");
  function fromScratch() {
    const result = {};
    const shapeIds = shapeIdsQuery.get();
    const shapes = Array(shapeIds.size);
    shapeIds.forEach((id) => shapes.push(store.get(id)));
    shapes.sort(sortByIndex);
    shapes.forEach((shape) => {
      if (!result[shape.parentId]) {
        result[shape.parentId] = [];
      }
      result[shape.parentId].push(shape.id);
    });
    return result;
  }
  return computed(
    "parentsToChildrenWithIndexes",
    (lastValue, lastComputedEpoch) => {
      if (isUninitialized(lastValue)) {
        return fromScratch();
      }
      const diff = shapeHistory.getDiffSince(lastComputedEpoch);
      if (diff === RESET_VALUE) {
        return fromScratch();
      }
      if (diff.length === 0)
        return lastValue;
      let newValue = null;
      const ensureNewArray = (parentId) => {
        if (!newValue) {
          newValue = { ...lastValue };
        }
        if (!newValue[parentId]) {
          newValue[parentId] = [];
        } else if (newValue[parentId] === lastValue[parentId]) {
          newValue[parentId] = [...newValue[parentId]];
        }
      };
      const toSort = /* @__PURE__ */ new Set();
      let changes;
      for (let i = 0, n = diff.length; i < n; i++) {
        changes = diff[i];
        for (const record of Object.values(changes.added)) {
          if (!isShape(record))
            continue;
          ensureNewArray(record.parentId);
          newValue[record.parentId].push(record.id);
          toSort.add(newValue[record.parentId]);
        }
        for (const [from2, to] of Object.values(changes.updated)) {
          if (!isShape(to))
            continue;
          if (!isShape(from2))
            continue;
          if (from2.parentId !== to.parentId) {
            ensureNewArray(from2.parentId);
            ensureNewArray(to.parentId);
            newValue[from2.parentId].splice(newValue[from2.parentId].indexOf(to.id), 1);
            newValue[to.parentId].push(to.id);
            toSort.add(newValue[to.parentId]);
          } else if (from2.index !== to.index) {
            ensureNewArray(to.parentId);
            const idx = newValue[to.parentId].indexOf(to.id);
            newValue[to.parentId][idx] = to.id;
            toSort.add(newValue[to.parentId]);
          }
        }
        for (const record of Object.values(changes.removed)) {
          if (!isShape(record))
            continue;
          ensureNewArray(record.parentId);
          newValue[record.parentId].splice(newValue[record.parentId].indexOf(record.id), 1);
        }
      }
      for (const arr of toSort) {
        const shapesInArr = compact(arr.map((id) => store.get(id)));
        shapesInArr.sort(sortByIndex);
        arr.splice(0, arr.length, ...shapesInArr.map((shape) => shape.id));
      }
      return newValue ?? lastValue;
    }
  );
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/derivations/shapeIdsInCurrentPage.mjs
var isShapeInPage = (store, pageId, shape) => {
  while (!isPageId(shape.parentId)) {
    const parent = store.get(shape.parentId);
    if (!parent)
      return false;
    shape = parent;
  }
  return shape.parentId === pageId;
};
var deriveShapeIdsInCurrentPage = (store, getCurrentPageId) => {
  const shapesIndex = store.query.ids("shape");
  let lastPageId = null;
  function fromScratch() {
    const currentPageId = getCurrentPageId();
    lastPageId = currentPageId;
    return new Set(
      [...shapesIndex.get()].filter((id) => isShapeInPage(store, currentPageId, store.get(id)))
    );
  }
  return computed("_shapeIdsInCurrentPage", (prevValue, lastComputedEpoch) => {
    if (isUninitialized(prevValue)) {
      return fromScratch();
    }
    const currentPageId = getCurrentPageId();
    if (currentPageId !== lastPageId) {
      return fromScratch();
    }
    const diff = store.history.getDiffSince(lastComputedEpoch);
    if (diff === RESET_VALUE) {
      return fromScratch();
    }
    const builder = new IncrementalSetConstructor(
      prevValue
    );
    for (const changes of diff) {
      for (const record of Object.values(changes.added)) {
        if (isShape(record) && isShapeInPage(store, currentPageId, record)) {
          builder.add(record.id);
        }
      }
      for (const [_from, to] of Object.values(changes.updated)) {
        if (isShape(to)) {
          if (isShapeInPage(store, currentPageId, to)) {
            builder.add(to.id);
          } else {
            builder.remove(to.id);
          }
        }
      }
      for (const id of Object.keys(changes.removed)) {
        if (isShapeId(id)) {
          builder.remove(id);
        }
      }
    }
    const result = builder.get();
    if (!result) {
      return prevValue;
    }
    return withDiff(result.value, result.diff);
  });
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/ClickManager.mjs
var __create3 = Object.create;
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __knownSymbol3 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError3 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name3 = (target, value) => __defProp3(target, "name", { value, configurable: true });
var __decoratorStart3 = (base2) => [, , , __create3((base2 == null ? void 0 : base2[__knownSymbol3("metadata")]) ?? null)];
var __decoratorStrings3 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn3 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError3("Function expected") : fn2;
var __decoratorContext3 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings3[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError3("Already initialized") : fns.push(__expectFn3(fn2 || null)) });
var __decoratorMetadata3 = (array2, target) => __defNormalProp3(target, __knownSymbol3("metadata"), array2[3]);
var __runInitializers3 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement3 = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings3[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc3(k < 4 ? target : { get [name]() {
    return __privateGet4(this, extra);
  }, set [name](x) {
    return __privateSet4(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name3(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name3(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext3(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn3(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet4 : __privateMethod3)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet4(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn3(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError3("Object expected");
    else
      __expectFn3(fn2 = it.get) && (desc.get = fn2), __expectFn3(fn2 = it.set) && (desc.set = fn2), __expectFn3(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata3(array2, target), desc && __defProp3(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField4 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck3 = (obj, member, msg2) => member.has(obj) || __typeError3("Cannot " + msg2);
var __privateIn3 = (member, obj) => Object(obj) !== obj ? __typeError3('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet4 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet4 = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck3(obj, member, "access private method"), method);
var _cancelDoubleClickTimeout_dec;
var __getClickTimeout_dec;
var _init3;
var MAX_CLICK_DISTANCE = 40;
__getClickTimeout_dec = [bind], _cancelDoubleClickTimeout_dec = [bind];
var ClickManager = class {
  constructor(editor) {
    this.editor = editor;
    __runInitializers3(_init3, 5, this);
    __publicField4(this, "_clickId", "");
    __publicField4(this, "_clickTimeout");
    __publicField4(this, "_clickScreenPoint");
    __publicField4(this, "_previousScreenPoint");
    __publicField4(this, "_clickState", "idle");
    __publicField4(this, "lastPointerInfo", {});
  }
  _getClickTimeout(state, id = uniqueId()) {
    this._clickId = id;
    clearTimeout(this._clickTimeout);
    this._clickTimeout = this.editor.timers.setTimeout(
      () => {
        if (this._clickState === state && this._clickId === id) {
          switch (this._clickState) {
            case "pendingTriple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "double_click",
                phase: "settle"
              });
              break;
            }
            case "pendingQuadruple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "triple_click",
                phase: "settle"
              });
              break;
            }
            case "pendingOverflow": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "quadruple_click",
                phase: "settle"
              });
              break;
            }
            default: {
            }
          }
          this._clickState = "idle";
        }
      },
      state === "idle" || state === "pendingDouble" ? this.editor.options.doubleClickDurationMs : this.editor.options.multiClickDurationMs
    );
  }
  /**
   * The current click state.
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get clickState() {
    return this._clickState;
  }
  handlePointerEvent(info) {
    switch (info.name) {
      case "pointer_down": {
        if (!this._clickState)
          return info;
        this._clickScreenPoint = Vec.From(info.point);
        if (this._previousScreenPoint && Vec.Dist2(this._previousScreenPoint, this._clickScreenPoint) > MAX_CLICK_DISTANCE ** 2) {
          this._clickState = "idle";
        }
        this._previousScreenPoint = this._clickScreenPoint;
        this.lastPointerInfo = info;
        switch (this._clickState) {
          case "pendingDouble": {
            this._clickState = "pendingTriple";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "double_click",
              phase: "down"
            };
          }
          case "pendingTriple": {
            this._clickState = "pendingQuadruple";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "triple_click",
              phase: "down"
            };
          }
          case "pendingQuadruple": {
            this._clickState = "pendingOverflow";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "quadruple_click",
              phase: "down"
            };
          }
          case "idle": {
            this._clickState = "pendingDouble";
            break;
          }
          case "pendingOverflow": {
            this._clickState = "overflow";
            break;
          }
          default: {
          }
        }
        this._clickTimeout = this._getClickTimeout(this._clickState);
        return info;
      }
      case "pointer_up": {
        if (!this._clickState)
          return info;
        this._clickScreenPoint = Vec.From(info.point);
        switch (this._clickState) {
          case "pendingTriple": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "double_click",
              phase: "up"
            };
          }
          case "pendingQuadruple": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "triple_click",
              phase: "up"
            };
          }
          case "pendingOverflow": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "quadruple_click",
              phase: "up"
            };
          }
          default: {
          }
        }
        return info;
      }
      case "pointer_move": {
        if (this._clickState !== "idle" && this._clickScreenPoint && Vec.Dist2(this._clickScreenPoint, this.editor.inputs.currentScreenPoint) > (this.editor.getInstanceState().isCoarsePointer ? this.editor.options.coarseDragDistanceSquared : this.editor.options.dragDistanceSquared)) {
          this.cancelDoubleClickTimeout();
        }
        return info;
      }
    }
    return info;
  }
  cancelDoubleClickTimeout() {
    this._clickTimeout = clearTimeout(this._clickTimeout);
    this._clickState = "idle";
  }
};
_init3 = __decoratorStart3(null);
__decorateElement3(_init3, 1, "_getClickTimeout", __getClickTimeout_dec, ClickManager);
__decorateElement3(_init3, 1, "cancelDoubleClickTimeout", _cancelDoubleClickTimeout_dec, ClickManager);
__decoratorMetadata3(_init3, ClickManager);

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/EdgeScrollManager.mjs
var EdgeScrollManager = class {
  constructor(editor) {
    __publicField(this, "_isEdgeScrolling", false);
    __publicField(this, "_edgeScrollDuration", -1);
    this.editor = editor;
  }
  /**
   * Update the camera position when the mouse is close to the edge of the screen.
   * Run this on every tick when in a state where edge scrolling is enabled.
   *
   * @public
   */
  updateEdgeScrolling(elapsed) {
    const { editor } = this;
    const edgeScrollProximityFactor = this.getEdgeScroll();
    if (edgeScrollProximityFactor.x === 0 && edgeScrollProximityFactor.y === 0) {
      if (this._isEdgeScrolling) {
        this._isEdgeScrolling = false;
        this._edgeScrollDuration = 0;
      }
    } else {
      if (!this._isEdgeScrolling) {
        this._isEdgeScrolling = true;
        this._edgeScrollDuration = 0;
      }
      this._edgeScrollDuration += elapsed;
      if (this._edgeScrollDuration > editor.options.edgeScrollDelay) {
        const eased = editor.options.edgeScrollEaseDuration > 0 ? EASINGS.easeInCubic(
          Math.min(
            1,
            this._edgeScrollDuration / (editor.options.edgeScrollDelay + editor.options.edgeScrollEaseDuration)
          )
        ) : 1;
        this.moveCameraWhenCloseToEdge({
          x: edgeScrollProximityFactor.x * eased,
          y: edgeScrollProximityFactor.y * eased
        });
      }
    }
  }
  /**
   * Helper function to get the scroll proximity factor for a given position.
   * @param position - The mouse position on the axis.
   * @param dimension - The component dimension on the axis.
   * @param isCoarse - Whether the pointer is coarse.
   * @param insetStart - Whether the pointer is inset at the start of the axis.
   * @param insetEnd - Whether the pointer is inset at the end of the axis.
   * @internal
   */
  getEdgeProximityFactors(position, dimension, isCoarse, insetStart, insetEnd) {
    const { editor } = this;
    const dist = editor.options.edgeScrollDistance;
    const pw = isCoarse ? editor.options.coarsePointerWidth : 0;
    const pMin = position - pw;
    const pMax = position + pw;
    const min4 = insetStart ? 0 : dist;
    const max3 = insetEnd ? dimension : dimension - dist;
    if (pMin < min4) {
      return Math.min(1, (min4 - pMin) / dist);
    } else if (pMax > max3) {
      return -Math.min(1, (pMax - max3) / dist);
    }
    return 0;
  }
  getEdgeScroll() {
    const { editor } = this;
    const {
      inputs: {
        currentScreenPoint: { x, y }
      }
    } = editor;
    const screenBounds = editor.getViewportScreenBounds();
    const {
      isCoarsePointer,
      insets: [t2, r, b, l]
    } = editor.getInstanceState();
    const proximityFactorX = this.getEdgeProximityFactors(x, screenBounds.w, isCoarsePointer, l, r);
    const proximityFactorY = this.getEdgeProximityFactors(y, screenBounds.h, isCoarsePointer, t2, b);
    return {
      x: proximityFactorX,
      y: proximityFactorY
    };
  }
  /**
   * Moves the camera when the mouse is close to the edge of the screen.
   * @public
   */
  moveCameraWhenCloseToEdge(proximityFactor) {
    const { editor } = this;
    if (!editor.inputs.isDragging || editor.inputs.isPanning || editor.getCameraOptions().isLocked)
      return;
    if (proximityFactor.x === 0 && proximityFactor.y === 0)
      return;
    const screenBounds = editor.getViewportScreenBounds();
    const screenSizeFactorX = screenBounds.w < 1e3 ? 0.612 : 1;
    const screenSizeFactorY = screenBounds.h < 1e3 ? 0.612 : 1;
    const zoomLevel = editor.getZoomLevel();
    const pxSpeed = editor.user.getEdgeScrollSpeed() * editor.options.edgeScrollSpeed;
    const scrollDeltaX = pxSpeed * proximityFactor.x * screenSizeFactorX / zoomLevel;
    const scrollDeltaY = pxSpeed * proximityFactor.y * screenSizeFactorY / zoomLevel;
    const { x, y, z } = editor.getCamera();
    editor.setCamera(new Vec(x + scrollDeltaX, y + scrollDeltaY, z));
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/FocusManager.mjs
var FocusManager = class {
  constructor(editor, autoFocus) {
    __publicField(this, "disposeSideEffectListener");
    this.editor = editor;
    this.disposeSideEffectListener = editor.sideEffects.registerAfterChangeHandler(
      "instance",
      (prev, next) => {
        if (prev.isFocused !== next.isFocused) {
          this.updateContainerClass();
        }
      }
    );
    const currentFocusState = editor.getInstanceState().isFocused;
    if (autoFocus !== currentFocusState) {
      editor.updateInstanceState({ isFocused: !!autoFocus });
    }
    this.updateContainerClass();
    document.body.addEventListener("keydown", this.handleKeyDown.bind(this));
    document.body.addEventListener("mousedown", this.handleMouseDown.bind(this));
  }
  /**
   * The editor's focus state and the container's focus state
   * are not necessarily always in sync. For that reason we
   * can't rely on the css `:focus` or `:focus-within` selectors to style the
   * editor when it is in focus.
   *
   * For that reason we synchronize the editor's focus state with a
   * special class on the container: tl-container__focused
   */
  updateContainerClass() {
    const container = this.editor.getContainer();
    const instanceState = this.editor.getInstanceState();
    if (instanceState.isFocused) {
      container.classList.add("tl-container__focused");
    } else {
      container.classList.remove("tl-container__focused");
    }
    container.classList.add("tl-container__no-focus-ring");
  }
  handleKeyDown(keyEvent2) {
    const container = this.editor.getContainer();
    if (["Tab", "ArrowUp", "ArrowDown"].includes(keyEvent2.key)) {
      container.classList.remove("tl-container__no-focus-ring");
    }
  }
  handleMouseDown() {
    const container = this.editor.getContainer();
    container.classList.add("tl-container__no-focus-ring");
  }
  focus() {
    this.editor.getContainer().focus();
  }
  blur() {
    this.editor.complete();
    this.editor.getContainer().blur();
  }
  dispose() {
    var _a5;
    document.body.removeEventListener("keydown", this.handleKeyDown.bind(this));
    document.body.removeEventListener("mousedown", this.handleMouseDown.bind(this));
    (_a5 = this.disposeSideEffectListener) == null ? void 0 : _a5.call(this);
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/FontManager.mjs
var FontManager = class {
  constructor(editor, assetUrls) {
    __publicField(this, "shapeFontFacesCache");
    __publicField(this, "shapeFontLoadStateCache");
    __publicField(this, "fontStates", new AtomMap("font states"));
    __publicField(this, "fontsToLoad", /* @__PURE__ */ new Set());
    this.editor = editor;
    this.assetUrls = assetUrls;
    this.shapeFontFacesCache = editor.store.createComputedCache(
      "shape font faces",
      (shape) => {
        const shapeUtil = this.editor.getShapeUtil(shape);
        return shapeUtil.getFontFaces(shape);
      },
      { areResultsEqual: areArraysShallowEqual, areRecordsEqual: (a, b) => a.props === b.props }
    );
    this.shapeFontLoadStateCache = editor.store.createCache(
      (id) => {
        const fontFacesComputed = computed("font faces", () => this.getShapeFontFaces(id));
        return computed(
          "font load state",
          () => {
            const states = fontFacesComputed.get().map((face) => this.getFontState(face));
            return states;
          },
          { isEqual: areArraysShallowEqual }
        );
      }
    );
  }
  getShapeFontFaces(shape) {
    const shapeId = typeof shape === "string" ? shape : shape.id;
    return this.shapeFontFacesCache.get(shapeId) ?? EMPTY_ARRAY;
  }
  trackFontsForShape(shape) {
    const shapeId = typeof shape === "string" ? shape : shape.id;
    this.shapeFontLoadStateCache.get(shapeId);
  }
  async loadRequiredFontsForCurrentPage(limit = Infinity) {
    const neededFonts = /* @__PURE__ */ new Set();
    for (const shapeId of this.editor.getCurrentPageShapeIds()) {
      for (const font of this.getShapeFontFaces(this.editor.getShape(shapeId))) {
        neededFonts.add(font);
      }
    }
    if (neededFonts.size > limit) {
      return;
    }
    const promises = Array.from(neededFonts, (font) => this.ensureFontIsLoaded(font));
    await Promise.all(promises);
  }
  getFontState(font) {
    return this.fontStates.get(font) ?? null;
  }
  ensureFontIsLoaded(font) {
    const existingState = this.getFontState(font);
    if (existingState)
      return existingState.loadingPromise;
    const instance = this.findOrCreateFontFace(font);
    const state = {
      state: "loading",
      instance,
      loadingPromise: instance.load().then(() => {
        document.fonts.add(instance);
        this.fontStates.update(font, (s) => ({ ...s, state: "ready" }));
      }).catch((err) => {
        console.error(err);
        this.fontStates.update(font, (s) => ({ ...s, state: "error" }));
      })
    };
    this.fontStates.set(font, state);
    return state.loadingPromise;
  }
  requestFonts(fonts) {
    if (!this.fontsToLoad.size) {
      queueMicrotask(() => {
        if (this.editor.isDisposed)
          return;
        const toLoad = this.fontsToLoad;
        this.fontsToLoad = /* @__PURE__ */ new Set();
        transact(() => {
          for (const font of toLoad) {
            this.ensureFontIsLoaded(font);
          }
        });
      });
    }
    for (const font of fonts) {
      this.fontsToLoad.add(font);
    }
  }
  findOrCreateFontFace(font) {
    var _a5;
    for (const existing of document.fonts) {
      if (existing.family === font.family && objectMapEntries(defaultFontFaceDescriptors).every(
        ([key, defaultValue]) => existing[key] === (font[key] ?? defaultValue)
      )) {
        return existing;
      }
    }
    const url = ((_a5 = this.assetUrls) == null ? void 0 : _a5[font.src.url]) ?? font.src.url;
    const instance = new FontFace(font.family, `url(${JSON.stringify(url)})`, {
      ...mapObjectMapValues(defaultFontFaceDescriptors, (key) => font[key]),
      display: "swap"
    });
    document.fonts.add(instance);
    return instance;
  }
  async toEmbeddedCssDeclaration(font) {
    var _a5;
    const url = ((_a5 = this.assetUrls) == null ? void 0 : _a5[font.src.url]) ?? font.src.url;
    const dataUrl = await FileHelpers.urlToDataUrl(url);
    const src = compact([
      `url("${dataUrl}")`,
      font.src.format ? `format(${font.src.format})` : null,
      font.src.tech ? `tech(${font.src.tech})` : null
    ]).join(" ");
    return compact([
      `@font-face {`,
      `  font-family: "${font.family}";`,
      font.ascentOverride ? `  ascent-override: ${font.ascentOverride};` : null,
      font.descentOverride ? `  descent-override: ${font.descentOverride};` : null,
      font.stretch ? `  font-stretch: ${font.stretch};` : null,
      font.style ? `  font-style: ${font.style};` : null,
      font.weight ? `  font-weight: ${font.weight};` : null,
      font.featureSettings ? `  font-feature-settings: ${font.featureSettings};` : null,
      font.lineGapOverride ? `  line-gap-override: ${font.lineGapOverride};` : null,
      font.unicodeRange ? `  unicode-range: ${font.unicodeRange};` : null,
      `  src: ${src};`,
      `}`
    ]).join("\n");
  }
};
var defaultFontFaceDescriptors = {
  style: "normal",
  weight: "normal",
  stretch: "normal",
  unicodeRange: "U+0-10FFFF",
  featureSettings: "normal",
  ascentOverride: "normal",
  descentOverride: "normal",
  lineGapOverride: "normal"
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/Stack.mjs
function stack(items) {
  if (items) {
    let result = EMPTY_STACK_ITEM;
    while (items.length) {
      result = result.push(items.pop());
    }
    return result;
  }
  return EMPTY_STACK_ITEM;
}
var EmptyStackItem = class {
  constructor() {
    __publicField(this, "length", 0);
    __publicField(this, "head", null);
    __publicField(this, "tail", this);
  }
  push(head) {
    return new StackItem(head, this);
  }
  toArray() {
    return EMPTY_ARRAY;
  }
  [Symbol.iterator]() {
    return {
      next() {
        return { value: void 0, done: true };
      }
    };
  }
};
var EMPTY_STACK_ITEM = new EmptyStackItem();
var StackItem = class _StackItem {
  constructor(head, tail) {
    __publicField(this, "length");
    this.head = head;
    this.tail = tail;
    this.length = tail.length + 1;
  }
  push(head) {
    return new _StackItem(head, this);
  }
  toArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let stack2 = this;
    return {
      next() {
        if (stack2.length) {
          const value = stack2.head;
          stack2 = stack2.tail;
          return { value, done: false };
        } else {
          return { value: void 0, done: true };
        }
      }
    };
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/HistoryManager.mjs
var HistoryRecorderState = ((HistoryRecorderState2) => {
  HistoryRecorderState2["Recording"] = "recording";
  HistoryRecorderState2["RecordingPreserveRedoStack"] = "recordingPreserveRedoStack";
  HistoryRecorderState2["Paused"] = "paused";
  return HistoryRecorderState2;
})(HistoryRecorderState || {});
var HistoryManager = class {
  constructor(opts) {
    __publicField(this, "store");
    __publicField(this, "dispose");
    __publicField(this, "state", "recording");
    __publicField(this, "pendingDiff", new PendingDiff());
    __publicField(this, "stacks", atom(
      "HistoryManager.stacks",
      {
        undos: stack(),
        redos: stack()
      },
      {
        isEqual: (a, b) => a.undos === b.undos && a.redos === b.redos
      }
    ));
    __publicField(this, "annotateError");
    /** @internal */
    __publicField(this, "_isInBatch", false);
    this.store = opts.store;
    this.annotateError = opts.annotateError ?? noop;
    this.dispose = this.store.addHistoryInterceptor((entry2, source) => {
      if (source !== "user")
        return;
      switch (this.state) {
        case "recording":
          this.pendingDiff.apply(entry2.changes);
          this.stacks.update(({ undos }) => ({ undos, redos: stack() }));
          break;
        case "recordingPreserveRedoStack":
          this.pendingDiff.apply(entry2.changes);
          break;
        case "paused":
          break;
        default:
          exhaustiveSwitchError(this.state);
      }
    });
  }
  flushPendingDiff() {
    if (this.pendingDiff.isEmpty())
      return;
    const diff = this.pendingDiff.clear();
    this.stacks.update(({ undos, redos }) => ({
      undos: undos.push({ type: "diff", diff }),
      redos
    }));
  }
  getNumUndos() {
    return this.stacks.get().undos.length + (this.pendingDiff.isEmpty() ? 0 : 1);
  }
  getNumRedos() {
    return this.stacks.get().redos.length;
  }
  batch(fn2, opts) {
    const previousState = this.state;
    if (previousState !== "paused" && (opts == null ? void 0 : opts.history)) {
      this.state = modeToState[opts.history];
    }
    try {
      if (this._isInBatch) {
        transact(fn2);
        return this;
      }
      this._isInBatch = true;
      try {
        transact(fn2);
      } catch (error) {
        this.annotateError(error);
        throw error;
      } finally {
        this._isInBatch = false;
      }
      return this;
    } finally {
      this.state = previousState;
    }
  }
  // History
  _undo({ pushToRedoStack, toMark = void 0 }) {
    var _a5;
    const previousState = this.state;
    this.state = "paused";
    try {
      let { undos, redos } = this.stacks.get();
      const pendingDiff = this.pendingDiff.clear();
      const isPendingDiffEmpty = isRecordsDiffEmpty(pendingDiff);
      const diffToUndo = reverseRecordsDiff(pendingDiff);
      if (pushToRedoStack && !isPendingDiffEmpty) {
        redos = redos.push({ type: "diff", diff: pendingDiff });
      }
      let didFindMark = false;
      if (isPendingDiffEmpty) {
        while (((_a5 = undos.head) == null ? void 0 : _a5.type) === "stop") {
          const mark = undos.head;
          undos = undos.tail;
          if (pushToRedoStack) {
            redos = redos.push(mark);
          }
          if (mark.id === toMark) {
            didFindMark = true;
            break;
          }
        }
      }
      if (!didFindMark) {
        loop:
          while (undos.head) {
            const undo2 = undos.head;
            undos = undos.tail;
            if (pushToRedoStack) {
              redos = redos.push(undo2);
            }
            switch (undo2.type) {
              case "diff":
                squashRecordDiffsMutable(diffToUndo, [reverseRecordsDiff(undo2.diff)]);
                break;
              case "stop":
                if (!toMark)
                  break loop;
                if (undo2.id === toMark) {
                  didFindMark = true;
                  break loop;
                }
                break;
              default:
                exhaustiveSwitchError(undo2);
            }
          }
      }
      if (!didFindMark && toMark) {
        return this;
      }
      this.store.applyDiff(diffToUndo, { ignoreEphemeralKeys: true });
      this.store.ensureStoreIsUsable();
      this.stacks.set({ undos, redos });
    } finally {
      this.state = previousState;
    }
    return this;
  }
  undo() {
    this._undo({ pushToRedoStack: true });
    return this;
  }
  redo() {
    var _a5;
    const previousState = this.state;
    this.state = "paused";
    try {
      this.flushPendingDiff();
      let { undos, redos } = this.stacks.get();
      if (redos.length === 0) {
        return this;
      }
      while (((_a5 = redos.head) == null ? void 0 : _a5.type) === "stop") {
        undos = undos.push(redos.head);
        redos = redos.tail;
      }
      const diffToRedo = createEmptyRecordsDiff();
      while (redos.head) {
        const redo2 = redos.head;
        undos = undos.push(redo2);
        redos = redos.tail;
        if (redo2.type === "diff") {
          squashRecordDiffsMutable(diffToRedo, [redo2.diff]);
        } else {
          break;
        }
      }
      this.store.applyDiff(diffToRedo, { ignoreEphemeralKeys: true });
      this.store.ensureStoreIsUsable();
      this.stacks.set({ undos, redos });
    } finally {
      this.state = previousState;
    }
    return this;
  }
  bail() {
    this._undo({ pushToRedoStack: false });
    return this;
  }
  bailToMark(id) {
    this._undo({ pushToRedoStack: false, toMark: id });
    return this;
  }
  squashToMark(id) {
    var _a5;
    let top2 = this.stacks.get().undos;
    const popped = [];
    while (top2.head && !(top2.head.type === "stop" && top2.head.id === id)) {
      if (top2.head.type === "diff") {
        popped.push(top2.head.diff);
      }
      top2 = top2.tail;
    }
    if (!top2.head || ((_a5 = top2.head) == null ? void 0 : _a5.id) !== id) {
      console.error("Could not find mark to squash to: ", id);
      return this;
    }
    if (popped.length === 0) {
      return this;
    }
    const diff = createEmptyRecordsDiff();
    squashRecordDiffsMutable(diff, popped.reverse());
    this.stacks.update(({ redos }) => ({
      undos: top2.push({
        type: "diff",
        diff
      }),
      redos
    }));
    return this;
  }
  /** @internal */
  _mark(id) {
    transact(() => {
      this.flushPendingDiff();
      this.stacks.update(({ undos, redos }) => ({ undos: undos.push({ type: "stop", id }), redos }));
    });
  }
  clear() {
    this.stacks.set({ undos: stack(), redos: stack() });
    this.pendingDiff.clear();
  }
  /** @internal */
  getMarkIdMatching(idSubstring) {
    let top2 = this.stacks.get().undos;
    while (top2.head) {
      if (top2.head.type === "stop" && top2.head.id.includes(idSubstring)) {
        return top2.head.id;
      }
      top2 = top2.tail;
    }
    return null;
  }
  /** @internal */
  debug() {
    const { undos, redos } = this.stacks.get();
    return {
      undos: undos.toArray(),
      redos: redos.toArray(),
      pendingDiff: this.pendingDiff.debug(),
      state: this.state
    };
  }
};
var modeToState = {
  record: "recording",
  "record-preserveRedoStack": "recordingPreserveRedoStack",
  ignore: "paused"
  /* Paused */
};
var PendingDiff = class {
  constructor() {
    __publicField(this, "diff", createEmptyRecordsDiff());
    __publicField(this, "isEmptyAtom", atom("PendingDiff.isEmpty", true));
  }
  clear() {
    const diff = this.diff;
    this.diff = createEmptyRecordsDiff();
    this.isEmptyAtom.set(true);
    return diff;
  }
  isEmpty() {
    return this.isEmptyAtom.get();
  }
  apply(diff) {
    squashRecordDiffsMutable(this.diff, [diff]);
    this.isEmptyAtom.set(isRecordsDiffEmpty(this.diff));
  }
  debug() {
    return { diff: this.diff, isEmpty: this.isEmpty() };
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/ScribbleManager.mjs
var ScribbleManager = class {
  constructor(editor) {
    __publicField(this, "scribbleItems", /* @__PURE__ */ new Map());
    __publicField(this, "state", "paused");
    this.editor = editor;
  }
  addScribble(scribble, id = uniqueId()) {
    const item = {
      id,
      scribble: {
        id,
        size: 20,
        color: "accent",
        opacity: 0.8,
        delay: 0,
        points: [],
        shrink: 0.1,
        taper: true,
        ...scribble,
        state: "starting"
      },
      timeoutMs: 0,
      delayRemaining: scribble.delay ?? 0,
      prev: null,
      next: null
    };
    this.scribbleItems.set(id, item);
    return item;
  }
  reset() {
    this.editor.updateInstanceState({ scribbles: [] });
    this.scribbleItems.clear();
  }
  /**
   * Start stopping the scribble. The scribble won't be removed until its last point is cleared.
   *
   * @public
   */
  stop(id) {
    const item = this.scribbleItems.get(id);
    if (!item)
      throw Error(`Scribble with id ${id} not found`);
    item.delayRemaining = Math.min(item.delayRemaining, 200);
    item.scribble.state = "stopping";
    return item;
  }
  /**
   * Set the scribble's next point.
   *
   * @param id - The id of the scribble to add a point to.
   * @param x - The x coordinate of the point.
   * @param y - The y coordinate of the point.
   * @param z - The z coordinate of the point.
   * @public
   */
  addPoint(id, x, y, z = 0.5) {
    const item = this.scribbleItems.get(id);
    if (!item)
      throw Error(`Scribble with id ${id} not found`);
    const { prev } = item;
    const point = { x, y, z };
    if (!prev || Vec.Dist(prev, point) >= 1) {
      item.next = point;
    }
    return item;
  }
  /**
   * Update on each animation frame.
   *
   * @param elapsed - The number of milliseconds since the last tick.
   * @public
   */
  tick(elapsed) {
    if (this.scribbleItems.size === 0)
      return;
    this.editor.run(() => {
      this.scribbleItems.forEach((item) => {
        if (item.scribble.state === "starting") {
          const { next: next2, prev: prev2 } = item;
          if (next2 && next2 !== prev2) {
            item.prev = next2;
            item.scribble.points.push(next2);
          }
          if (item.scribble.points.length > 8) {
            item.scribble.state = "active";
          }
          return;
        }
        if (item.delayRemaining > 0) {
          item.delayRemaining = Math.max(0, item.delayRemaining - elapsed);
        }
        item.timeoutMs += elapsed;
        if (item.timeoutMs >= 16) {
          item.timeoutMs = 0;
        }
        const { delayRemaining, timeoutMs, prev, next, scribble } = item;
        switch (scribble.state) {
          case "active": {
            if (next && next !== prev) {
              item.prev = next;
              scribble.points.push(next);
              if (delayRemaining === 0) {
                if (scribble.points.length > 8) {
                  scribble.points.shift();
                }
              }
            } else {
              if (timeoutMs === 0) {
                if (scribble.points.length > 1) {
                  scribble.points.shift();
                } else {
                  item.delayRemaining = scribble.delay;
                }
              }
            }
            break;
          }
          case "stopping": {
            if (item.delayRemaining === 0) {
              if (timeoutMs === 0) {
                if (scribble.points.length === 1) {
                  this.scribbleItems.delete(item.id);
                  return;
                }
                if (scribble.shrink) {
                  scribble.size = Math.max(1, scribble.size * (1 - scribble.shrink));
                }
                scribble.points.shift();
              }
            }
            break;
          }
          case "paused": {
            break;
          }
        }
      });
      this.editor.updateInstanceState({
        scribbles: Array.from(this.scribbleItems.values()).map(({ scribble }) => ({
          ...scribble,
          points: [...scribble.points]
        })).slice(-5)
        // limit to three as a minor sanity check
      });
    });
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/SnapManager/BoundsSnaps.mjs
var __create4 = Object.create;
var __defProp4 = Object.defineProperty;
var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
var __knownSymbol4 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError4 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name4 = (target, value) => __defProp4(target, "name", { value, configurable: true });
var __decoratorStart4 = (base2) => [, , , __create4((base2 == null ? void 0 : base2[__knownSymbol4("metadata")]) ?? null)];
var __decoratorStrings4 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn4 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError4("Function expected") : fn2;
var __decoratorContext4 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings4[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError4("Already initialized") : fns.push(__expectFn4(fn2 || null)) });
var __decoratorMetadata4 = (array2, target) => __defNormalProp4(target, __knownSymbol4("metadata"), array2[3]);
var __runInitializers4 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement4 = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings4[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc4(k < 4 ? target : { get [name]() {
    return __privateGet5(this, extra);
  }, set [name](x) {
    return __privateSet5(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name4(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name4(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext4(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn4(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet5 : __privateMethod4)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet5(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn4(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError4("Object expected");
    else
      __expectFn4(fn2 = it.get) && (desc.get = fn2), __expectFn4(fn2 = it.set) && (desc.set = fn2), __expectFn4(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata4(array2, target), desc && __defProp4(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField5 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck4 = (obj, member, msg2) => member.has(obj) || __typeError4("Cannot " + msg2);
var __privateIn4 = (member, obj) => Object(obj) !== obj ? __typeError4('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet5 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet5 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod4 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
var _getVisibleGaps_dec;
var _getSnappableGapNodes_dec;
var _getSnappablePoints_dec;
var _getSnapPointsCache_dec;
var _init4;
var round = (x) => {
  const decimalPlacesTolerance = 8;
  return Math.round(x * 10 ** decimalPlacesTolerance) / 10 ** decimalPlacesTolerance;
};
function findAdjacentGaps(gaps, shapeId, gapLength, direction, intersection) {
  const matches2 = gaps.filter(
    (gap) => (direction === "forward" ? gap.startNode.id === shapeId : gap.endNode.id === shapeId) && round(gap.length) === round(gapLength) && rangeIntersection(
      gap.breadthIntersection[0],
      gap.breadthIntersection[1],
      intersection[0],
      intersection[1]
    )
  );
  if (matches2.length === 0)
    return [];
  const nextNodes = /* @__PURE__ */ new Set();
  matches2.forEach((match) => {
    const node = direction === "forward" ? match.endNode.id : match.startNode.id;
    if (!nextNodes.has(node)) {
      nextNodes.add(node);
      const foundGaps = findAdjacentGaps(
        gaps,
        node,
        gapLength,
        direction,
        rangeIntersection(
          match.breadthIntersection[0],
          match.breadthIntersection[1],
          intersection[0],
          intersection[1]
        )
      );
      matches2.push(...foundGaps);
    }
  });
  return matches2;
}
function dedupeGapSnaps(snaps) {
  snaps.sort((a, b) => b.gaps.length - a.gaps.length);
  for (let i = snaps.length - 1; i > 0; i--) {
    const snap = snaps[i];
    for (let j = i - 1; j >= 0; j--) {
      const otherSnap = snaps[j];
      if (otherSnap.direction === snap.direction && snap.gaps.every(
        (gap) => otherSnap.gaps.some(
          (otherGap) => round(gap.startEdge[0].x) === round(otherGap.startEdge[0].x) && round(gap.startEdge[0].y) === round(otherGap.startEdge[0].y) && round(gap.startEdge[1].x) === round(otherGap.startEdge[1].x) && round(gap.startEdge[1].y) === round(otherGap.startEdge[1].y)
        ) && otherSnap.gaps.some(
          (otherGap) => round(gap.endEdge[0].x) === round(otherGap.endEdge[0].x) && round(gap.endEdge[0].y) === round(otherGap.endEdge[0].y) && round(gap.endEdge[1].x) === round(otherGap.endEdge[1].x) && round(gap.endEdge[1].y) === round(otherGap.endEdge[1].y)
        )
      )) {
        snaps.splice(i, 1);
        break;
      }
    }
  }
}
_getSnapPointsCache_dec = [computed], _getSnappablePoints_dec = [computed], _getSnappableGapNodes_dec = [computed], _getVisibleGaps_dec = [computed];
var BoundsSnaps = class {
  constructor(manager) {
    this.manager = manager;
    __runInitializers4(_init4, 5, this);
    __publicField5(this, "editor");
    this.editor = manager.editor;
  }
  getSnapPointsCache() {
    const { editor } = this;
    return editor.store.createComputedCache("snapPoints", (shape) => {
      const pageTransform = editor.getShapePageTransform(shape.id);
      if (!pageTransform)
        return void 0;
      const boundsSnapGeometry = editor.getShapeUtil(shape).getBoundsSnapGeometry(shape);
      const snapPoints = boundsSnapGeometry.points ?? editor.getShapeGeometry(shape).bounds.cornersAndCenter;
      if (!pageTransform || !snapPoints)
        return void 0;
      return snapPoints.map((point, i) => {
        const { x, y } = Mat.applyToPoint(pageTransform, point);
        return { x, y, id: `${shape.id}:${i}` };
      });
    });
  }
  getSnapPoints(shapeId) {
    return this.getSnapPointsCache().get(shapeId) ?? [];
  }
  getSnappablePoints() {
    const snapPointsCache = this.getSnapPointsCache();
    const snappableShapes = this.manager.getSnappableShapes();
    const result = [];
    for (const shapeId of snappableShapes) {
      const snapPoints = snapPointsCache.get(shapeId);
      if (snapPoints) {
        result.push(...snapPoints);
      }
    }
    return result;
  }
  getSnappableGapNodes() {
    return Array.from(this.manager.getSnappableShapes(), (shapeId) => ({
      id: shapeId,
      pageBounds: assertExists(this.editor.getShapePageBounds(shapeId))
    }));
  }
  getVisibleGaps() {
    const horizontal = [];
    const vertical = [];
    let startNode, endNode;
    const sortedShapesOnCurrentPageHorizontal = this.getSnappableGapNodes().sort((a, b) => {
      return a.pageBounds.minX - b.pageBounds.minX;
    });
    for (let i = 0; i < sortedShapesOnCurrentPageHorizontal.length; i++) {
      startNode = sortedShapesOnCurrentPageHorizontal[i];
      for (let j = i + 1; j < sortedShapesOnCurrentPageHorizontal.length; j++) {
        endNode = sortedShapesOnCurrentPageHorizontal[j];
        if (
          // is there space between the boxes
          startNode.pageBounds.maxX < endNode.pageBounds.minX && // and they overlap in the y axis
          rangesOverlap(
            startNode.pageBounds.minY,
            startNode.pageBounds.maxY,
            endNode.pageBounds.minY,
            endNode.pageBounds.maxY
          )
        ) {
          horizontal.push({
            startNode,
            endNode,
            startEdge: [
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.minY),
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.maxY)
            ],
            endEdge: [
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.minY),
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.maxY)
            ],
            length: endNode.pageBounds.minX - startNode.pageBounds.maxX,
            breadthIntersection: rangeIntersection(
              startNode.pageBounds.minY,
              startNode.pageBounds.maxY,
              endNode.pageBounds.minY,
              endNode.pageBounds.maxY
            )
          });
        }
      }
    }
    const sortedShapesOnCurrentPageVertical = sortedShapesOnCurrentPageHorizontal.sort((a, b) => {
      return a.pageBounds.minY - b.pageBounds.minY;
    });
    for (let i = 0; i < sortedShapesOnCurrentPageVertical.length; i++) {
      startNode = sortedShapesOnCurrentPageVertical[i];
      for (let j = i + 1; j < sortedShapesOnCurrentPageVertical.length; j++) {
        endNode = sortedShapesOnCurrentPageVertical[j];
        if (
          // is there space between the boxes
          startNode.pageBounds.maxY < endNode.pageBounds.minY && // do they overlap in the x axis
          rangesOverlap(
            startNode.pageBounds.minX,
            startNode.pageBounds.maxX,
            endNode.pageBounds.minX,
            endNode.pageBounds.maxX
          )
        ) {
          vertical.push({
            startNode,
            endNode,
            startEdge: [
              new Vec(startNode.pageBounds.minX, startNode.pageBounds.maxY),
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.maxY)
            ],
            endEdge: [
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.minY),
              new Vec(endNode.pageBounds.maxX, endNode.pageBounds.minY)
            ],
            length: endNode.pageBounds.minY - startNode.pageBounds.maxY,
            breadthIntersection: rangeIntersection(
              startNode.pageBounds.minX,
              startNode.pageBounds.maxX,
              endNode.pageBounds.minX,
              endNode.pageBounds.maxX
            )
          });
        }
      }
    }
    return { horizontal, vertical };
  }
  snapTranslateShapes({
    lockedAxis,
    initialSelectionPageBounds,
    initialSelectionSnapPoints,
    dragDelta
  }) {
    var _a5, _b;
    const snapThreshold = this.manager.getSnapThreshold();
    const visibleSnapPointsNotInSelection = this.getSnappablePoints();
    const selectionPageBounds = initialSelectionPageBounds.clone().translate(dragDelta);
    const selectionSnapPoints = initialSelectionSnapPoints.map(
      ({ x, y }, i) => ({
        id: "selection:" + i,
        x: x + dragDelta.x,
        y: y + dragDelta.y
      })
    );
    const otherNodeSnapPoints = visibleSnapPointsNotInSelection;
    const nearestSnapsX = [];
    const nearestSnapsY = [];
    const minOffset = new Vec(snapThreshold, snapThreshold);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    this.collectGapSnaps({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY,
      minOffset
    });
    const nudge = new Vec(
      lockedAxis === "x" ? 0 : ((_a5 = nearestSnapsX[0]) == null ? void 0 : _a5.nudge) ?? 0,
      lockedAxis === "y" ? 0 : ((_b = nearestSnapsY[0]) == null ? void 0 : _b.nudge) ?? 0
    );
    minOffset.x = 0;
    minOffset.y = 0;
    nearestSnapsX.length = 0;
    nearestSnapsY.length = 0;
    selectionSnapPoints.forEach((s) => {
      s.x += nudge.x;
      s.y += nudge.y;
    });
    selectionPageBounds.translate(nudge);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    this.collectGapSnaps({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY,
      minOffset
    });
    const pointSnapsLines = this.getPointSnapLines({
      nearestSnapsX,
      nearestSnapsY
    });
    const gapSnapLines = this.getGapSnapLines({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY
    });
    this.manager.setIndicators([...gapSnapLines, ...pointSnapsLines]);
    return { nudge };
  }
  snapResizeShapes({
    initialSelectionPageBounds,
    dragDelta,
    handle: originalHandle,
    isAspectRatioLocked,
    isResizingFromCenter
  }) {
    var _a5, _b;
    const snapThreshold = this.manager.getSnapThreshold();
    const {
      box: unsnappedResizedPageBounds,
      scaleX,
      scaleY
    } = Box.Resize(
      initialSelectionPageBounds,
      originalHandle,
      isResizingFromCenter ? dragDelta.x * 2 : dragDelta.x,
      isResizingFromCenter ? dragDelta.y * 2 : dragDelta.y,
      isAspectRatioLocked
    );
    let handle = originalHandle;
    if (scaleX < 0) {
      handle = flipSelectionHandleX(handle);
    }
    if (scaleY < 0) {
      handle = flipSelectionHandleY(handle);
    }
    if (isResizingFromCenter) {
      unsnappedResizedPageBounds.center = initialSelectionPageBounds.center;
    }
    const isXLocked = handle === "top" || handle === "bottom";
    const isYLocked = handle === "left" || handle === "right";
    const selectionSnapPoints = getResizeSnapPointsForHandle(handle, unsnappedResizedPageBounds);
    const otherNodeSnapPoints = this.getSnappablePoints();
    const nearestSnapsX = [];
    const nearestSnapsY = [];
    const minOffset = new Vec(snapThreshold, snapThreshold);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    const nudge = new Vec(
      isXLocked ? 0 : ((_a5 = nearestSnapsX[0]) == null ? void 0 : _a5.nudge) ?? 0,
      isYLocked ? 0 : ((_b = nearestSnapsY[0]) == null ? void 0 : _b.nudge) ?? 0
    );
    if (isAspectRatioLocked && isSelectionCorner(handle) && nudge.len() !== 0) {
      const primaryNudgeAxis = nearestSnapsX.length && nearestSnapsY.length ? Math.abs(nudge.x) < Math.abs(nudge.y) ? "x" : "y" : nearestSnapsX.length ? "x" : "y";
      const ratio = initialSelectionPageBounds.aspectRatio;
      if (primaryNudgeAxis === "x") {
        nearestSnapsY.length = 0;
        nudge.y = nudge.x / ratio;
        if (handle === "bottom_left" || handle === "top_right") {
          nudge.y = -nudge.y;
        }
      } else {
        nearestSnapsX.length = 0;
        nudge.x = nudge.y * ratio;
        if (handle === "bottom_left" || handle === "top_right") {
          nudge.x = -nudge.x;
        }
      }
    }
    const snappedDelta = Vec.Add(dragDelta, nudge);
    const { box: snappedResizedPageBounds } = Box.Resize(
      initialSelectionPageBounds,
      originalHandle,
      isResizingFromCenter ? snappedDelta.x * 2 : snappedDelta.x,
      isResizingFromCenter ? snappedDelta.y * 2 : snappedDelta.y,
      isAspectRatioLocked
    );
    if (isResizingFromCenter) {
      snappedResizedPageBounds.center = initialSelectionPageBounds.center;
    }
    const snappedSelectionPoints = getResizeSnapPointsForHandle("any", snappedResizedPageBounds);
    nearestSnapsX.length = 0;
    nearestSnapsY.length = 0;
    minOffset.x = 0;
    minOffset.y = 0;
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints: snappedSelectionPoints
    });
    const pointSnaps = this.getPointSnapLines({
      nearestSnapsX,
      nearestSnapsY
    });
    this.manager.setIndicators([...pointSnaps]);
    return { nudge };
  }
  collectPointSnaps({
    selectionSnapPoints,
    otherNodeSnapPoints,
    minOffset,
    nearestSnapsX,
    nearestSnapsY
  }) {
    for (const thisSnapPoint of selectionSnapPoints) {
      for (const otherSnapPoint of otherNodeSnapPoints) {
        const offset5 = Vec.Sub(thisSnapPoint, otherSnapPoint);
        const offsetX = Math.abs(offset5.x);
        const offsetY = Math.abs(offset5.y);
        if (round(offsetX) <= round(minOffset.x)) {
          if (round(offsetX) < round(minOffset.x)) {
            nearestSnapsX.length = 0;
          }
          nearestSnapsX.push({
            type: "points",
            points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
            nudge: otherSnapPoint.x - thisSnapPoint.x
          });
          minOffset.x = offsetX;
        }
        if (round(offsetY) <= round(minOffset.y)) {
          if (round(offsetY) < round(minOffset.y)) {
            nearestSnapsY.length = 0;
          }
          nearestSnapsY.push({
            type: "points",
            points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
            nudge: otherSnapPoint.y - thisSnapPoint.y
          });
          minOffset.y = offsetY;
        }
      }
    }
  }
  collectGapSnaps({
    selectionPageBounds,
    minOffset,
    nearestSnapsX,
    nearestSnapsY
  }) {
    const { horizontal, vertical } = this.getVisibleGaps();
    for (const gap of horizontal) {
      if (!rangesOverlap(
        gap.breadthIntersection[0],
        gap.breadthIntersection[1],
        selectionPageBounds.minY,
        selectionPageBounds.maxY
      )) {
        continue;
      }
      const gapMidX = gap.startEdge[0].x + gap.length / 2;
      const centerNudge = gapMidX - selectionPageBounds.center.x;
      const gapIsLargerThanSelection = gap.length > selectionPageBounds.width;
      if (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.x)) {
        if (round(Math.abs(centerNudge)) < round(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(centerNudge);
        const snap = {
          type: "gap_center",
          gap,
          nudge: centerNudge
        };
        const otherCenterSnap = nearestSnapsX.find(({ type }) => type === "gap_center");
        const gapBreadthsOverlap = otherCenterSnap && rangeIntersection(
          gap.breadthIntersection[0],
          gap.breadthIntersection[1],
          otherCenterSnap.gap.breadthIntersection[0],
          otherCenterSnap.gap.breadthIntersection[1]
        );
        if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
          nearestSnapsX[nearestSnapsX.indexOf(otherCenterSnap)] = snap;
        } else if (!otherCenterSnap || !gapBreadthsOverlap) {
          nearestSnapsX.push(snap);
        }
      }
      const duplicationLeftX = gap.startNode.pageBounds.minX - gap.length;
      const selectionRightX = selectionPageBounds.maxX;
      const duplicationLeftNudge = duplicationLeftX - selectionRightX;
      if (round(Math.abs(duplicationLeftNudge)) <= round(minOffset.x)) {
        if (round(Math.abs(duplicationLeftNudge)) < round(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(duplicationLeftNudge);
        nearestSnapsX.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "left",
          nudge: duplicationLeftNudge
        });
      }
      const duplicationRightX = gap.endNode.pageBounds.maxX + gap.length;
      const selectionLeftX = selectionPageBounds.minX;
      const duplicationRightNudge = duplicationRightX - selectionLeftX;
      if (round(Math.abs(duplicationRightNudge)) <= round(minOffset.x)) {
        if (round(Math.abs(duplicationRightNudge)) < round(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(duplicationRightNudge);
        nearestSnapsX.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "right",
          nudge: duplicationRightNudge
        });
      }
    }
    for (const gap of vertical) {
      if (!rangesOverlap(
        gap.breadthIntersection[0],
        gap.breadthIntersection[1],
        selectionPageBounds.minX,
        selectionPageBounds.maxX
      )) {
        continue;
      }
      const gapMidY = gap.startEdge[0].y + gap.length / 2;
      const centerNudge = gapMidY - selectionPageBounds.center.y;
      const gapIsLargerThanSelection = gap.length > selectionPageBounds.height;
      if (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.y)) {
        if (round(Math.abs(centerNudge)) < round(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(centerNudge);
        const snap = {
          type: "gap_center",
          gap,
          nudge: centerNudge
        };
        const otherCenterSnap = nearestSnapsY.find(({ type }) => type === "gap_center");
        const gapBreadthsOverlap = otherCenterSnap && rangesOverlap(
          otherCenterSnap.gap.breadthIntersection[0],
          otherCenterSnap.gap.breadthIntersection[1],
          gap.breadthIntersection[0],
          gap.breadthIntersection[1]
        );
        if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
          nearestSnapsY[nearestSnapsY.indexOf(otherCenterSnap)] = snap;
        } else if (!otherCenterSnap || !gapBreadthsOverlap) {
          nearestSnapsY.push(snap);
        }
        continue;
      }
      const duplicationTopY = gap.startNode.pageBounds.minY - gap.length;
      const selectionBottomY = selectionPageBounds.maxY;
      const duplicationTopNudge = duplicationTopY - selectionBottomY;
      if (round(Math.abs(duplicationTopNudge)) <= round(minOffset.y)) {
        if (round(Math.abs(duplicationTopNudge)) < round(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(duplicationTopNudge);
        nearestSnapsY.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "top",
          nudge: duplicationTopNudge
        });
      }
      const duplicationBottomY = gap.endNode.pageBounds.maxY + gap.length;
      const selectionTopY = selectionPageBounds.minY;
      const duplicationBottomNudge = duplicationBottomY - selectionTopY;
      if (round(Math.abs(duplicationBottomNudge)) <= round(minOffset.y)) {
        if (round(Math.abs(duplicationBottomNudge)) < round(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(duplicationBottomNudge);
        nearestSnapsY.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "bottom",
          nudge: duplicationBottomNudge
        });
      }
    }
  }
  getPointSnapLines({
    nearestSnapsX,
    nearestSnapsY
  }) {
    const snapGroupsX = {};
    const snapGroupsY = {};
    if (nearestSnapsX.length > 0) {
      for (const snap of nearestSnapsX) {
        if (snap.type === "points") {
          const key = round(snap.points.otherPoint.x);
          if (!snapGroupsX[key]) {
            snapGroupsX[key] = [];
          }
          snapGroupsX[key].push(snap.points);
        }
      }
    }
    if (nearestSnapsY.length > 0) {
      for (const snap of nearestSnapsY) {
        if (snap.type === "points") {
          const key = round(snap.points.otherPoint.y);
          if (!snapGroupsY[key]) {
            snapGroupsY[key] = [];
          }
          snapGroupsY[key].push(snap.points);
        }
      }
    }
    return Object.values(snapGroupsX).concat(Object.values(snapGroupsY)).map((snapGroup) => ({
      id: uniqueId(),
      type: "points",
      points: dedupe(
        snapGroup.map((snap) => Vec.From(snap.otherPoint)).concat(snapGroup.map((snap) => Vec.From(snap.thisPoint))),
        (a, b) => a.equals(b)
      )
    }));
  }
  getGapSnapLines({
    selectionPageBounds,
    nearestSnapsX,
    nearestSnapsY
  }) {
    const { vertical, horizontal } = this.getVisibleGaps();
    const selectionSides = {
      top: selectionPageBounds.sides[0],
      right: selectionPageBounds.sides[1],
      // need bottom and left to be sorted asc, which .sides is not.
      bottom: [selectionPageBounds.corners[3], selectionPageBounds.corners[2]],
      left: [selectionPageBounds.corners[0], selectionPageBounds.corners[3]]
    };
    const result = [];
    if (nearestSnapsX.length > 0) {
      for (const snap of nearestSnapsX) {
        if (snap.type === "points")
          continue;
        const {
          gap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge }
        } = snap;
        switch (snap.type) {
          case "gap_center": {
            const newGapsLength = (length - selectionPageBounds.width) / 2;
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minY,
              selectionPageBounds.maxY
            );
            result.push({
              type: "gaps",
              direction: "horizontal",
              id: uniqueId(),
              gaps: [
                ...findAdjacentGaps(
                  horizontal,
                  startNode.id,
                  newGapsLength,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge,
                  endEdge: selectionSides.left
                },
                {
                  startEdge: selectionSides.right,
                  endEdge
                },
                ...findAdjacentGaps(
                  horizontal,
                  endNode.id,
                  newGapsLength,
                  "forward",
                  gapBreadthIntersection
                )
              ]
            });
            break;
          }
          case "gap_duplicate": {
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minY,
              selectionPageBounds.maxY
            );
            result.push({
              type: "gaps",
              direction: "horizontal",
              id: uniqueId(),
              gaps: snap.protrusionDirection === "left" ? [
                {
                  startEdge: selectionSides.right,
                  endEdge: startEdge.map(
                    (v) => v.clone().addXY(-startNode.pageBounds.width, 0)
                  )
                },
                { startEdge, endEdge },
                ...findAdjacentGaps(
                  horizontal,
                  endNode.id,
                  length,
                  "forward",
                  gapBreadthIntersection
                )
              ] : [
                ...findAdjacentGaps(
                  horizontal,
                  startNode.id,
                  length,
                  "backward",
                  gapBreadthIntersection
                ),
                { startEdge, endEdge },
                {
                  startEdge: endEdge.map(
                    (v) => v.clone().addXY(snap.gap.endNode.pageBounds.width, 0)
                  ),
                  endEdge: selectionSides.left
                }
              ]
            });
            break;
          }
        }
      }
    }
    if (nearestSnapsY.length > 0) {
      for (const snap of nearestSnapsY) {
        if (snap.type === "points")
          continue;
        const {
          gap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge }
        } = snap;
        switch (snap.type) {
          case "gap_center": {
            const newGapsLength = (length - selectionPageBounds.height) / 2;
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minX,
              selectionPageBounds.maxX
            );
            result.push({
              type: "gaps",
              direction: "vertical",
              id: uniqueId(),
              gaps: [
                ...findAdjacentGaps(
                  vertical,
                  startNode.id,
                  newGapsLength,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge,
                  endEdge: selectionSides.top
                },
                {
                  startEdge: selectionSides.bottom,
                  endEdge
                },
                ...findAdjacentGaps(
                  vertical,
                  snap.gap.endNode.id,
                  newGapsLength,
                  "forward",
                  gapBreadthIntersection
                )
              ]
            });
            break;
          }
          case "gap_duplicate":
            {
              const gapBreadthIntersection = rangeIntersection(
                breadthIntersection[0],
                breadthIntersection[1],
                selectionPageBounds.minX,
                selectionPageBounds.maxX
              );
              result.push({
                type: "gaps",
                direction: "vertical",
                id: uniqueId(),
                gaps: snap.protrusionDirection === "top" ? [
                  {
                    startEdge: selectionSides.bottom,
                    endEdge: startEdge.map(
                      (v) => v.clone().addXY(0, -startNode.pageBounds.height)
                    )
                  },
                  { startEdge, endEdge },
                  ...findAdjacentGaps(
                    vertical,
                    endNode.id,
                    length,
                    "forward",
                    gapBreadthIntersection
                  )
                ] : [
                  ...findAdjacentGaps(
                    vertical,
                    startNode.id,
                    length,
                    "backward",
                    gapBreadthIntersection
                  ),
                  { startEdge, endEdge },
                  {
                    startEdge: endEdge.map(
                      (v) => v.clone().addXY(0, endNode.pageBounds.height)
                    ),
                    endEdge: selectionSides.top
                  }
                ]
              });
            }
            break;
        }
      }
    }
    dedupeGapSnaps(result);
    return result;
  }
};
_init4 = __decoratorStart4(null);
__decorateElement4(_init4, 1, "getSnapPointsCache", _getSnapPointsCache_dec, BoundsSnaps);
__decorateElement4(_init4, 1, "getSnappablePoints", _getSnappablePoints_dec, BoundsSnaps);
__decorateElement4(_init4, 1, "getSnappableGapNodes", _getSnappableGapNodes_dec, BoundsSnaps);
__decorateElement4(_init4, 1, "getVisibleGaps", _getVisibleGaps_dec, BoundsSnaps);
__decoratorMetadata4(_init4, BoundsSnaps);
function getResizeSnapPointsForHandle(handle, selectionPageBounds) {
  const { minX, maxX, minY, maxY } = selectionPageBounds;
  const result = [];
  switch (handle) {
    case "top":
    case "left":
    case "top_left":
    case "any":
      result.push({
        id: "top_left",
        handle: "top_left",
        x: minX,
        y: minY
      });
  }
  switch (handle) {
    case "top":
    case "right":
    case "top_right":
    case "any":
      result.push({
        id: "top_right",
        handle: "top_right",
        x: maxX,
        y: minY
      });
  }
  switch (handle) {
    case "bottom":
    case "right":
    case "bottom_right":
    case "any":
      result.push({
        id: "bottom_right",
        handle: "bottom_right",
        x: maxX,
        y: maxY
      });
  }
  switch (handle) {
    case "bottom":
    case "left":
    case "bottom_left":
    case "any":
      result.push({
        id: "bottom_left",
        handle: "bottom_left",
        x: minX,
        y: maxY
      });
  }
  return result;
}

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/SnapManager/HandleSnaps.mjs
var __create5 = Object.create;
var __defProp5 = Object.defineProperty;
var __getOwnPropDesc5 = Object.getOwnPropertyDescriptor;
var __knownSymbol5 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError5 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name5 = (target, value) => __defProp5(target, "name", { value, configurable: true });
var __decoratorStart5 = (base2) => [, , , __create5((base2 == null ? void 0 : base2[__knownSymbol5("metadata")]) ?? null)];
var __decoratorStrings5 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn5 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError5("Function expected") : fn2;
var __decoratorContext5 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings5[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError5("Already initialized") : fns.push(__expectFn5(fn2 || null)) });
var __decoratorMetadata5 = (array2, target) => __defNormalProp5(target, __knownSymbol5("metadata"), array2[3]);
var __runInitializers5 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement5 = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings5[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc5(k < 4 ? target : { get [name]() {
    return __privateGet6(this, extra);
  }, set [name](x) {
    return __privateSet6(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name5(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name5(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext5(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn5(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet6 : __privateMethod5)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet6(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn5(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError5("Object expected");
    else
      __expectFn5(fn2 = it.get) && (desc.get = fn2), __expectFn5(fn2 = it.set) && (desc.set = fn2), __expectFn5(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata5(array2, target), desc && __defProp5(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField6 = (obj, key, value) => __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck5 = (obj, member, msg2) => member.has(obj) || __typeError5("Cannot " + msg2);
var __privateIn5 = (member, obj) => Object(obj) !== obj ? __typeError5('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet6 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet6 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod5 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var _getSnapGeometryCache_dec;
var _init5;
var defaultGetSelfSnapOutline = () => null;
var defaultGetSelfSnapPoints = () => [];
_getSnapGeometryCache_dec = [computed];
var HandleSnaps = class {
  constructor(manager) {
    this.manager = manager;
    __runInitializers5(_init5, 5, this);
    __publicField6(this, "editor");
    this.editor = manager.editor;
  }
  getSnapGeometryCache() {
    const { editor } = this;
    return editor.store.createComputedCache("handle snap geometry", (shape) => {
      const snapGeometry = editor.getShapeUtil(shape).getHandleSnapGeometry(shape);
      const getSelfSnapOutline = snapGeometry.getSelfSnapOutline ? snapGeometry.getSelfSnapOutline.bind(snapGeometry) : defaultGetSelfSnapOutline;
      const getSelfSnapPoints = snapGeometry.getSelfSnapPoints ? snapGeometry.getSelfSnapPoints.bind(snapGeometry) : defaultGetSelfSnapPoints;
      return {
        outline: snapGeometry.outline === void 0 ? editor.getShapeGeometry(shape) : snapGeometry.outline,
        points: snapGeometry.points ?? [],
        getSelfSnapOutline,
        getSelfSnapPoints
      };
    });
  }
  *iterateSnapPointsInPageSpace(currentShapeId, currentHandle) {
    var _a5, _b;
    const selfSnapPoints = (_a5 = this.getSnapGeometryCache().get(currentShapeId)) == null ? void 0 : _a5.getSelfSnapPoints(currentHandle);
    if (selfSnapPoints && selfSnapPoints.length) {
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(currentShapeId));
      for (const point of selfSnapPoints) {
        yield shapePageTransform.applyToPoint(point);
      }
    }
    for (const shapeId of this.manager.getSnappableShapes()) {
      if (shapeId === currentShapeId)
        continue;
      const snapPoints = (_b = this.getSnapGeometryCache().get(shapeId)) == null ? void 0 : _b.points;
      if (!snapPoints || !snapPoints.length)
        continue;
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(shapeId));
      for (const point of snapPoints) {
        yield shapePageTransform.applyToPoint(point);
      }
    }
  }
  *iterateSnapOutlines(currentShapeId, currentHandle) {
    var _a5, _b;
    const selfSnapOutline = (_a5 = this.getSnapGeometryCache().get(currentShapeId)) == null ? void 0 : _a5.getSelfSnapOutline(currentHandle);
    if (selfSnapOutline) {
      yield { shapeId: currentShapeId, outline: selfSnapOutline };
    }
    for (const shapeId of this.manager.getSnappableShapes()) {
      if (shapeId === currentShapeId)
        continue;
      const snapOutline = (_b = this.getSnapGeometryCache().get(shapeId)) == null ? void 0 : _b.outline;
      if (!snapOutline)
        continue;
      yield { shapeId, outline: snapOutline };
    }
  }
  getHandleSnapPosition({
    currentShapeId,
    handle,
    handleInPageSpace
  }) {
    const snapThreshold = this.manager.getSnapThreshold();
    let minDistanceForSnapPoint = snapThreshold;
    let nearestSnapPoint = null;
    for (const snapPoint of this.iterateSnapPointsInPageSpace(currentShapeId, handle)) {
      if (Vec.DistMin(handleInPageSpace, snapPoint, minDistanceForSnapPoint)) {
        minDistanceForSnapPoint = Vec.Dist(handleInPageSpace, snapPoint);
        nearestSnapPoint = snapPoint;
      }
    }
    if (nearestSnapPoint)
      return nearestSnapPoint;
    let minDistanceForOutline = snapThreshold;
    let nearestPointOnOutline = null;
    for (const { shapeId, outline } of this.iterateSnapOutlines(currentShapeId, handle)) {
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(shapeId));
      const pointInShapeSpace = this.editor.getPointInShapeSpace(shapeId, handleInPageSpace);
      const nearestShapePointInShapeSpace = outline.nearestPoint(pointInShapeSpace);
      const nearestInPageSpace = shapePageTransform.applyToPoint(nearestShapePointInShapeSpace);
      if (Vec.DistMin(handleInPageSpace, nearestInPageSpace, minDistanceForOutline)) {
        minDistanceForOutline = Vec.Dist(handleInPageSpace, nearestInPageSpace);
        nearestPointOnOutline = nearestInPageSpace;
      }
    }
    if (nearestPointOnOutline)
      return nearestPointOnOutline;
    return null;
  }
  snapHandle({
    currentShapeId,
    handle
  }) {
    const currentShapeTransform = assertExists(this.editor.getShapePageTransform(currentShapeId));
    const handleInPageSpace = currentShapeTransform.applyToPoint(handle);
    const snapPosition = this.getHandleSnapPosition({ currentShapeId, handle, handleInPageSpace });
    if (snapPosition) {
      this.manager.setIndicators([
        {
          id: uniqueId(),
          type: "points",
          points: [snapPosition]
        }
      ]);
      return { nudge: Vec.Sub(snapPosition, handleInPageSpace) };
    }
    return null;
  }
};
_init5 = __decoratorStart5(null);
__decorateElement5(_init5, 1, "getSnapGeometryCache", _getSnapGeometryCache_dec, HandleSnaps);
__decoratorMetadata5(_init5, HandleSnaps);

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/SnapManager/SnapManager.mjs
var __create6 = Object.create;
var __defProp6 = Object.defineProperty;
var __getOwnPropDesc6 = Object.getOwnPropertyDescriptor;
var __knownSymbol6 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError6 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name6 = (target, value) => __defProp6(target, "name", { value, configurable: true });
var __decoratorStart6 = (base2) => [, , , __create6((base2 == null ? void 0 : base2[__knownSymbol6("metadata")]) ?? null)];
var __decoratorStrings6 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn6 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError6("Function expected") : fn2;
var __decoratorContext6 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings6[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError6("Already initialized") : fns.push(__expectFn6(fn2 || null)) });
var __decoratorMetadata6 = (array2, target) => __defNormalProp6(target, __knownSymbol6("metadata"), array2[3]);
var __runInitializers6 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement6 = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings6[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc6(k < 4 ? target : { get [name]() {
    return __privateGet7(this, extra);
  }, set [name](x) {
    return __privateSet7(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name6(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name6(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext6(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn6(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet7 : __privateMethod6)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet7(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn6(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError6("Object expected");
    else
      __expectFn6(fn2 = it.get) && (desc.get = fn2), __expectFn6(fn2 = it.set) && (desc.set = fn2), __expectFn6(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata6(array2, target), desc && __defProp6(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField7 = (obj, key, value) => __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck6 = (obj, member, msg2) => member.has(obj) || __typeError6("Cannot " + msg2);
var __privateIn6 = (member, obj) => Object(obj) !== obj ? __typeError6('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet7 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet7 = (obj, member, value, setter) => (__accessCheck6(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod6 = (obj, member, method) => (__accessCheck6(obj, member, "access private method"), method);
var _getCurrentCommonAncestor_dec;
var _getSnappableShapes_dec;
var _getSnapThreshold_dec;
var _init6;
_getSnapThreshold_dec = [computed], _getSnappableShapes_dec = [computed], _getCurrentCommonAncestor_dec = [computed];
var SnapManager = class {
  constructor(editor) {
    this.editor = editor;
    __runInitializers6(_init6, 5, this);
    __publicField7(this, "shapeBounds");
    __publicField7(this, "handles");
    __publicField7(this, "_snapIndicators", atom("snapLines", void 0));
    this.shapeBounds = new BoundsSnaps(this);
    this.handles = new HandleSnaps(this);
  }
  getIndicators() {
    return this._snapIndicators.get() ?? EMPTY_ARRAY;
  }
  clearIndicators() {
    if (this.getIndicators().length) {
      this._snapIndicators.set(void 0);
    }
  }
  setIndicators(indicators) {
    this._snapIndicators.set(indicators);
  }
  getSnapThreshold() {
    return 8 / this.editor.getZoomLevel();
  }
  getSnappableShapes() {
    const { editor } = this;
    const renderingBounds = editor.getViewportPageBounds();
    const selectedShapeIds = editor.getSelectedShapeIds();
    const snappableShapes = /* @__PURE__ */ new Set();
    const collectSnappableShapesFromParent = (parentId) => {
      if (isShapeId(parentId)) {
        const parent = editor.getShape(parentId);
        if (parent && editor.isShapeOfType(parent, "frame")) {
          snappableShapes.add(parentId);
        }
      }
      const sortedChildIds = editor.getSortedChildIdsForParent(parentId);
      for (const childId of sortedChildIds) {
        if (selectedShapeIds.includes(childId))
          continue;
        const childShape = editor.getShape(childId);
        if (!childShape)
          continue;
        const util = editor.getShapeUtil(childShape);
        if (!util.canSnap(childShape))
          continue;
        const pageBounds = editor.getShapePageBounds(childId);
        if (!(pageBounds && renderingBounds.includes(pageBounds)))
          continue;
        if (editor.isShapeOfType(childShape, "group")) {
          collectSnappableShapesFromParent(childId);
          continue;
        }
        snappableShapes.add(childId);
      }
    };
    collectSnappableShapesFromParent(this.getCurrentCommonAncestor() ?? editor.getCurrentPageId());
    return snappableShapes;
  }
  getCurrentCommonAncestor() {
    return this.editor.findCommonAncestor(this.editor.getSelectedShapes());
  }
};
_init6 = __decoratorStart6(null);
__decorateElement6(_init6, 1, "getSnapThreshold", _getSnapThreshold_dec, SnapManager);
__decorateElement6(_init6, 1, "getSnappableShapes", _getSnappableShapes_dec, SnapManager);
__decorateElement6(_init6, 1, "getCurrentCommonAncestor", _getCurrentCommonAncestor_dec, SnapManager);
__decoratorMetadata6(_init6, SnapManager);

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/TextManager.mjs
var fixNewLines = /\r?\n|\r/g;
function normalizeTextForDom(text) {
  return text.replace(fixNewLines, "\n").split("\n").map((x) => x || " ").join("\n");
}
var textAlignmentsForLtr = {
  start: "left",
  "start-legacy": "left",
  middle: "center",
  "middle-legacy": "center",
  end: "right",
  "end-legacy": "right"
};
var spaceCharacterRegex = /\s/;
var TextManager = class {
  constructor(editor) {
    __publicField(this, "baseElem");
    this.editor = editor;
    this.baseElem = document.createElement("div");
    this.baseElem.classList.add("tl-text");
    this.baseElem.classList.add("tl-text-measure");
    this.baseElem.tabIndex = -1;
  }
  measureText(textToMeasure, opts) {
    const div2 = document.createElement("div");
    div2.textContent = normalizeTextForDom(textToMeasure);
    return this.measureHtml(div2.innerHTML, opts);
  }
  measureHtml(html, opts) {
    const wrapperElm = this.baseElem.cloneNode();
    this.editor.getContainer().appendChild(wrapperElm);
    wrapperElm.innerHTML = html;
    this.baseElem.insertAdjacentElement("afterend", wrapperElm);
    wrapperElm.setAttribute("dir", "auto");
    wrapperElm.style.setProperty("unicode-bidi", "plaintext");
    wrapperElm.style.setProperty("font-family", opts.fontFamily);
    wrapperElm.style.setProperty("font-style", opts.fontStyle);
    wrapperElm.style.setProperty("font-weight", opts.fontWeight);
    wrapperElm.style.setProperty("font-size", opts.fontSize + "px");
    wrapperElm.style.setProperty("line-height", opts.lineHeight * opts.fontSize + "px");
    wrapperElm.style.setProperty("max-width", opts.maxWidth === null ? null : opts.maxWidth + "px");
    wrapperElm.style.setProperty("min-width", opts.minWidth === null ? null : opts.minWidth + "px");
    wrapperElm.style.setProperty("padding", opts.padding);
    wrapperElm.style.setProperty(
      "overflow-wrap",
      opts.disableOverflowWrapBreaking ? "normal" : "break-word"
    );
    if (opts.otherStyles) {
      for (const [key, value] of Object.entries(opts.otherStyles)) {
        wrapperElm.style.setProperty(key, value);
      }
    }
    const scrollWidth = wrapperElm.scrollWidth;
    const rect = wrapperElm.getBoundingClientRect();
    wrapperElm.remove();
    return {
      x: 0,
      y: 0,
      w: rect.width,
      h: rect.height,
      scrollWidth
    };
  }
  /**
   * Given an html element, measure the position of each span of unbroken
   * word/white-space characters within any text nodes it contains.
   */
  measureElementTextNodeSpans(element, { shouldTruncateToFirstLine = false } = {}) {
    const spans = [];
    const elmBounds = element.getBoundingClientRect();
    const offsetX = -elmBounds.left;
    const offsetY = -elmBounds.top;
    const range = new Range();
    const textNode = element.childNodes[0];
    let idx = 0;
    let currentSpan = null;
    let prevCharWasSpaceCharacter = null;
    let prevCharTop = 0;
    let prevCharLeftForRTLTest = 0;
    let didTruncate = false;
    for (const childNode of element.childNodes) {
      if (childNode.nodeType !== Node.TEXT_NODE)
        continue;
      for (const char of childNode.textContent ?? "") {
        range.setStart(textNode, idx);
        range.setEnd(textNode, idx + char.length);
        const rects = range.getClientRects();
        const rect = rects[rects.length - 1];
        const top2 = rect.top + offsetY;
        const left2 = rect.left + offsetX;
        const right2 = rect.right + offsetX;
        const isRTL2 = left2 < prevCharLeftForRTLTest;
        const isSpaceCharacter = spaceCharacterRegex.test(char);
        if (
          // If we're at a word boundary...
          isSpaceCharacter !== prevCharWasSpaceCharacter || // ...or we're on a different line...
          top2 !== prevCharTop || // ...or we're at the start of the text and haven't created a span yet...
          !currentSpan
        ) {
          if (currentSpan) {
            if (shouldTruncateToFirstLine && top2 !== prevCharTop) {
              didTruncate = true;
              break;
            }
            spans.push(currentSpan);
          }
          currentSpan = {
            box: { x: left2, y: top2, w: rect.width, h: rect.height },
            text: char
          };
          prevCharLeftForRTLTest = left2;
        } else {
          if (isRTL2) {
            currentSpan.box.x = left2;
          }
          currentSpan.box.w = isRTL2 ? currentSpan.box.w + rect.width : right2 - currentSpan.box.x;
          currentSpan.text += char;
        }
        if (char === "\n") {
          prevCharLeftForRTLTest = 0;
        }
        prevCharWasSpaceCharacter = isSpaceCharacter;
        prevCharTop = top2;
        idx += char.length;
      }
    }
    if (currentSpan) {
      spans.push(currentSpan);
    }
    return { spans, didTruncate };
  }
  /**
   * Measure text into individual spans. Spans are created by rendering the
   * text, then dividing it up according to line breaks and word boundaries.
   *
   * It works by having the browser render the text, then measuring the
   * position of each character. You can use this to replicate the text-layout
   * algorithm of the current browser in e.g. an SVG export.
   */
  measureTextSpans(textToMeasure, opts) {
    if (textToMeasure === "")
      return [];
    const elm = this.baseElem.cloneNode();
    this.editor.getContainer().appendChild(elm);
    const elementWidth = Math.ceil(opts.width - opts.padding * 2);
    elm.setAttribute("dir", "auto");
    elm.style.setProperty("unicode-bidi", "plaintext");
    elm.style.setProperty("width", `${elementWidth}px`);
    elm.style.setProperty("height", "min-content");
    elm.style.setProperty("font-size", `${opts.fontSize}px`);
    elm.style.setProperty("font-family", opts.fontFamily);
    elm.style.setProperty("font-weight", opts.fontWeight);
    elm.style.setProperty("line-height", `${opts.lineHeight * opts.fontSize}px`);
    elm.style.setProperty("text-align", textAlignmentsForLtr[opts.textAlign]);
    elm.style.setProperty("font-style", opts.fontStyle);
    if (opts.otherStyles) {
      for (const [key, value] of Object.entries(opts.otherStyles)) {
        elm.style.setProperty(key, value);
      }
    }
    const shouldTruncateToFirstLine = opts.overflow === "truncate-ellipsis" || opts.overflow === "truncate-clip";
    if (shouldTruncateToFirstLine) {
      elm.style.setProperty("overflow-wrap", "anywhere");
      elm.style.setProperty("word-break", "break-all");
    }
    const normalizedText = normalizeTextForDom(textToMeasure);
    elm.textContent = normalizedText;
    const { spans, didTruncate } = this.measureElementTextNodeSpans(elm, {
      shouldTruncateToFirstLine
    });
    if (opts.overflow === "truncate-ellipsis" && didTruncate) {
      elm.textContent = "…";
      const ellipsisWidth = Math.ceil(this.measureElementTextNodeSpans(elm).spans[0].box.w);
      elm.style.setProperty("width", `${elementWidth - ellipsisWidth}px`);
      elm.textContent = normalizedText;
      const truncatedSpans = this.measureElementTextNodeSpans(elm, {
        shouldTruncateToFirstLine: true
      }).spans;
      const lastSpan = truncatedSpans[truncatedSpans.length - 1];
      truncatedSpans.push({
        text: "…",
        box: {
          x: Math.min(lastSpan.box.x + lastSpan.box.w, opts.width - opts.padding - ellipsisWidth),
          y: lastSpan.box.y,
          w: ellipsisWidth,
          h: lastSpan.box.h
        }
      });
      return truncatedSpans;
    }
    elm.remove();
    return spans;
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/TickManager.mjs
var __create7 = Object.create;
var __defProp7 = Object.defineProperty;
var __getOwnPropDesc7 = Object.getOwnPropertyDescriptor;
var __knownSymbol7 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError7 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name7 = (target, value) => __defProp7(target, "name", { value, configurable: true });
var __decoratorStart7 = (base2) => [, , , __create7((base2 == null ? void 0 : base2[__knownSymbol7("metadata")]) ?? null)];
var __decoratorStrings7 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn7 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError7("Function expected") : fn2;
var __decoratorContext7 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings7[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError7("Already initialized") : fns.push(__expectFn7(fn2 || null)) });
var __decoratorMetadata7 = (array2, target) => __defNormalProp7(target, __knownSymbol7("metadata"), array2[3]);
var __runInitializers7 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement7 = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings7[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc7(k < 4 ? target : { get [name]() {
    return __privateGet8(this, extra);
  }, set [name](x) {
    return __privateSet8(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name7(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name7(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext7(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn7(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet8 : __privateMethod7)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet8(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn7(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError7("Object expected");
    else
      __expectFn7(fn2 = it.get) && (desc.get = fn2), __expectFn7(fn2 = it.set) && (desc.set = fn2), __expectFn7(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata7(array2, target), desc && __defProp7(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField8 = (obj, key, value) => __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck7 = (obj, member, msg2) => member.has(obj) || __typeError7("Cannot " + msg2);
var __privateIn7 = (member, obj) => Object(obj) !== obj ? __typeError7('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet8 = (obj, member, getter) => (__accessCheck7(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet8 = (obj, member, value, setter) => (__accessCheck7(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod7 = (obj, member, method) => (__accessCheck7(obj, member, "access private method"), method);
var _dispose_dec;
var _tick_dec;
var _init7;
var throttleToNextFrame2 = typeof process !== "undefined" && false ? (
  // At test time we should use actual raf and not throttle, because throttle was set up to evaluate immediately during tests, which causes stack overflow
  // for the tick manager since it sets up a raf loop.
  function mockThrottle(cb) {
    const frame2 = requestAnimationFrame(cb);
    return () => cancelAnimationFrame(frame2);
  }
) : throttleToNextFrame;
_tick_dec = [bind], _dispose_dec = [bind];
var TickManager = class {
  constructor(editor) {
    this.editor = editor;
    __runInitializers7(_init7, 5, this);
    __publicField8(this, "cancelRaf");
    __publicField8(this, "isPaused", true);
    __publicField8(this, "now", 0);
    __publicField8(this, "prevPoint", new Vec());
    this.editor.disposables.add(this.dispose);
    this.start();
  }
  start() {
    var _a5;
    this.isPaused = false;
    (_a5 = this.cancelRaf) == null ? void 0 : _a5.call(this);
    this.cancelRaf = throttleToNextFrame2(this.tick);
    this.now = Date.now();
  }
  tick() {
    if (this.isPaused) {
      return;
    }
    const now = Date.now();
    const elapsed = now - this.now;
    this.now = now;
    this.updatePointerVelocity(elapsed);
    this.editor.emit("frame", elapsed);
    this.editor.emit("tick", elapsed);
    this.cancelRaf = throttleToNextFrame2(this.tick);
  }
  dispose() {
    var _a5;
    this.isPaused = true;
    (_a5 = this.cancelRaf) == null ? void 0 : _a5.call(this);
  }
  updatePointerVelocity(elapsed) {
    const {
      prevPoint,
      editor: {
        inputs: { currentScreenPoint, pointerVelocity }
      }
    } = this;
    if (elapsed === 0)
      return;
    const delta = Vec.Sub(currentScreenPoint, prevPoint);
    this.prevPoint = currentScreenPoint.clone();
    const length = delta.len();
    const direction = length ? delta.div(length) : new Vec(0, 0);
    const next = pointerVelocity.clone().lrp(direction.mul(length / elapsed), 0.5);
    if (Math.abs(next.x) < 0.01)
      next.x = 0;
    if (Math.abs(next.y) < 0.01)
      next.y = 0;
    if (!pointerVelocity.equals(next)) {
      this.editor.inputs.pointerVelocity = next;
    }
  }
};
_init7 = __decoratorStart7(null);
__decorateElement7(_init7, 1, "tick", _tick_dec, TickManager);
__decorateElement7(_init7, 1, "dispose", _dispose_dec, TickManager);
__decoratorMetadata7(_init7, TickManager);

// node_modules/@tldraw/editor/dist-esm/lib/editor/managers/UserPreferencesManager.mjs
var __create8 = Object.create;
var __defProp8 = Object.defineProperty;
var __getOwnPropDesc8 = Object.getOwnPropertyDescriptor;
var __knownSymbol8 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError8 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name8 = (target, value) => __defProp8(target, "name", { value, configurable: true });
var __decoratorStart8 = (base2) => [, , , __create8((base2 == null ? void 0 : base2[__knownSymbol8("metadata")]) ?? null)];
var __decoratorStrings8 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn8 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError8("Function expected") : fn2;
var __decoratorContext8 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings8[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError8("Already initialized") : fns.push(__expectFn8(fn2 || null)) });
var __decoratorMetadata8 = (array2, target) => __defNormalProp8(target, __knownSymbol8("metadata"), array2[3]);
var __runInitializers8 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement8 = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings8[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc8(k < 4 ? target : { get [name]() {
    return __privateGet9(this, extra);
  }, set [name](x) {
    return __privateSet9(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name8(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name8(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext8(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn8(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet9 : __privateMethod8)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet9(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn8(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError8("Object expected");
    else
      __expectFn8(fn2 = it.get) && (desc.get = fn2), __expectFn8(fn2 = it.set) && (desc.set = fn2), __expectFn8(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata8(array2, target), desc && __defProp8(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField9 = (obj, key, value) => __defNormalProp8(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck8 = (obj, member, msg2) => member.has(obj) || __typeError8("Cannot " + msg2);
var __privateIn8 = (member, obj) => Object(obj) !== obj ? __typeError8('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet9 = (obj, member, getter) => (__accessCheck8(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet9 = (obj, member, value, setter) => (__accessCheck8(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod8 = (obj, member, method) => (__accessCheck8(obj, member, "access private method"), method);
var _getIsPasteAtCursorMode_dec;
var _getIsDynamicResizeMode_dec;
var _getIsWrapMode_dec;
var _getIsSnapMode_dec;
var _getColor_dec;
var _getLocale_dec;
var _getName_dec;
var _getId_dec;
var _getAnimationSpeed_dec;
var _getEdgeScrollSpeed_dec;
var _getIsDarkMode_dec;
var _getUserPreferences_dec;
var _init8;
_getUserPreferences_dec = [computed], _getIsDarkMode_dec = [computed], _getEdgeScrollSpeed_dec = [computed], _getAnimationSpeed_dec = [computed], _getId_dec = [computed], _getName_dec = [computed], _getLocale_dec = [computed], _getColor_dec = [computed], _getIsSnapMode_dec = [computed], _getIsWrapMode_dec = [computed], _getIsDynamicResizeMode_dec = [computed], _getIsPasteAtCursorMode_dec = [computed];
var UserPreferencesManager = class {
  constructor(user, inferDarkMode) {
    this.user = user;
    this.inferDarkMode = inferDarkMode;
    __runInitializers8(_init8, 5, this);
    __publicField9(this, "systemColorScheme", atom("systemColorScheme", "light"));
    __publicField9(this, "disposables", /* @__PURE__ */ new Set());
    if (typeof window === "undefined" || !("matchMedia" in window))
      return;
    const darkModeMediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    if (darkModeMediaQuery == null ? void 0 : darkModeMediaQuery.matches) {
      this.systemColorScheme.set("dark");
    }
    const handleChange = (e) => {
      if (e.matches) {
        this.systemColorScheme.set("dark");
      } else {
        this.systemColorScheme.set("light");
      }
    };
    darkModeMediaQuery == null ? void 0 : darkModeMediaQuery.addEventListener("change", handleChange);
    this.disposables.add(() => darkModeMediaQuery == null ? void 0 : darkModeMediaQuery.removeEventListener("change", handleChange));
  }
  dispose() {
    this.disposables.forEach((d) => d());
  }
  updateUserPreferences(userPreferences) {
    this.user.setUserPreferences({
      ...this.user.userPreferences.get(),
      ...userPreferences
    });
  }
  getUserPreferences() {
    return {
      id: this.getId(),
      name: this.getName(),
      locale: this.getLocale(),
      color: this.getColor(),
      animationSpeed: this.getAnimationSpeed(),
      isSnapMode: this.getIsSnapMode(),
      colorScheme: this.user.userPreferences.get().colorScheme,
      isDarkMode: this.getIsDarkMode(),
      isWrapMode: this.getIsWrapMode(),
      isDynamicResizeMode: this.getIsDynamicResizeMode()
    };
  }
  getIsDarkMode() {
    switch (this.user.userPreferences.get().colorScheme) {
      case "dark":
        return true;
      case "light":
        return false;
      case "system":
        return this.systemColorScheme.get() === "dark";
      default:
        return this.inferDarkMode ? this.systemColorScheme.get() === "dark" : false;
    }
  }
  getEdgeScrollSpeed() {
    return this.user.userPreferences.get().edgeScrollSpeed ?? defaultUserPreferences.edgeScrollSpeed;
  }
  getAnimationSpeed() {
    return this.user.userPreferences.get().animationSpeed ?? defaultUserPreferences.animationSpeed;
  }
  getId() {
    return this.user.userPreferences.get().id;
  }
  getName() {
    var _a5;
    return ((_a5 = this.user.userPreferences.get().name) == null ? void 0 : _a5.trim()) ?? defaultUserPreferences.name;
  }
  getLocale() {
    return this.user.userPreferences.get().locale ?? defaultUserPreferences.locale;
  }
  getColor() {
    return this.user.userPreferences.get().color ?? defaultUserPreferences.color;
  }
  getIsSnapMode() {
    return this.user.userPreferences.get().isSnapMode ?? defaultUserPreferences.isSnapMode;
  }
  getIsWrapMode() {
    return this.user.userPreferences.get().isWrapMode ?? defaultUserPreferences.isWrapMode;
  }
  getIsDynamicResizeMode() {
    return this.user.userPreferences.get().isDynamicSizeMode ?? defaultUserPreferences.isDynamicSizeMode;
  }
  getIsPasteAtCursorMode() {
    return this.user.userPreferences.get().isPasteAtCursorMode ?? defaultUserPreferences.isPasteAtCursorMode;
  }
};
_init8 = __decoratorStart8(null);
__decorateElement8(_init8, 1, "getUserPreferences", _getUserPreferences_dec, UserPreferencesManager);
__decorateElement8(_init8, 1, "getIsDarkMode", _getIsDarkMode_dec, UserPreferencesManager);
__decorateElement8(_init8, 1, "getEdgeScrollSpeed", _getEdgeScrollSpeed_dec, UserPreferencesManager);
__decorateElement8(_init8, 1, "getAnimationSpeed", _getAnimationSpeed_dec, UserPreferencesManager);
__decorateElement8(_init8, 1, "getId", _getId_dec, UserPreferencesManager);
__decorateElement8(_init8, 1, "getName", _getName_dec, UserPreferencesManager);
__decorateElement8(_init8, 1, "getLocale", _getLocale_dec, UserPreferencesManager);
__decorateElement8(_init8, 1, "getColor", _getColor_dec, UserPreferencesManager);
__decorateElement8(_init8, 1, "getIsSnapMode", _getIsSnapMode_dec, UserPreferencesManager);
__decorateElement8(_init8, 1, "getIsWrapMode", _getIsWrapMode_dec, UserPreferencesManager);
__decorateElement8(_init8, 1, "getIsDynamicResizeMode", _getIsDynamicResizeMode_dec, UserPreferencesManager);
__decorateElement8(_init8, 1, "getIsPasteAtCursorMode", _getIsPasteAtCursorMode_dec, UserPreferencesManager);
__decoratorMetadata8(_init8, UserPreferencesManager);

// node_modules/@tldraw/editor/dist-esm/lib/editor/types/event-types.mjs
var EVENT_NAME_MAP = {
  wheel: "onWheel",
  pointer_down: "onPointerDown",
  pointer_move: "onPointerMove",
  long_press: "onLongPress",
  pointer_up: "onPointerUp",
  right_click: "onRightClick",
  middle_click: "onMiddleClick",
  key_down: "onKeyDown",
  key_up: "onKeyUp",
  key_repeat: "onKeyRepeat",
  cancel: "onCancel",
  complete: "onComplete",
  interrupt: "onInterrupt",
  double_click: "onDoubleClick",
  triple_click: "onTripleClick",
  quadruple_click: "onQuadrupleClick",
  tick: "onTick"
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/tools/StateNode.mjs
var STATE_NODES_TO_MEASURE = [
  "brushing",
  "cropping",
  "dragging",
  "dragging_handle",
  "drawing",
  "erasing",
  "lasering",
  "resizing",
  "rotating",
  "scribble_brushing",
  "translating"
];
var StateNode = class {
  constructor(editor, parent) {
    __publicField(this, "performanceTracker");
    __publicField(this, "id");
    __publicField(this, "type");
    __publicField(this, "shapeType");
    __publicField(this, "initial");
    __publicField(this, "children");
    __publicField(this, "isLockable");
    __publicField(this, "useCoalescedEvents");
    __publicField(this, "parent");
    __publicField(this, "_path");
    __publicField(this, "_current");
    __publicField(this, "_isActive");
    /**
     * This is a hack / escape hatch that will tell the editor to
     * report a different state as active (in `getCurrentToolId()`) when
     * this state is active. This is usually used when a tool transitions
     * to a child of a different state for a certain interaction and then
     * returns to the original tool when that interaction completes; and
     * where we would want to show the original tool as active in the UI.
     *
     * @public
     */
    __publicField(this, "_currentToolIdMask", atom("curent tool id mask", void 0));
    this.editor = editor;
    const { id, children, initial, isLockable, useCoalescedEvents } = this.constructor;
    this.id = id;
    this._isActive = atom("toolIsActive" + this.id, false);
    this._current = atom("toolState" + this.id, void 0);
    this._path = computed("toolPath" + this.id, () => {
      const current = this.getCurrent();
      return this.id + (current ? `.${current.getPath()}` : "");
    });
    this.parent = parent ?? {};
    if (this.parent) {
      if (children && initial) {
        this.type = "branch";
        this.initial = initial;
        this.children = Object.fromEntries(
          children().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])
        );
        this._current.set(this.children[this.initial]);
      } else {
        this.type = "leaf";
      }
    } else {
      this.type = "root";
      if (children && initial) {
        this.initial = initial;
        this.children = Object.fromEntries(
          children().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])
        );
        this._current.set(this.children[this.initial]);
      }
    }
    this.isLockable = isLockable;
    this.useCoalescedEvents = useCoalescedEvents;
    this.performanceTracker = new PerformanceTracker();
  }
  /**
   * This node's path of active state nodes
   *
   * @public
   */
  getPath() {
    return this._path.get();
  }
  /**
   * This node's current active child node, if any.
   *
   * @public
   */
  getCurrent() {
    return this._current.get();
  }
  /**
   * Whether this node is active.
   *
   * @public
   */
  getIsActive() {
    return this._isActive.get();
  }
  /**
   * Transition to a new active child state node.
   *
   * @example
   * ```ts
   * parentState.transition('childStateA')
   * parentState.transition('childStateB', { myData: 4 })
   *```
   *
   * @param id - The id of the child state node to transition to.
   * @param info - Any data to pass to the `onEnter` and `onExit` handlers.
   *
   * @public
   */
  transition(id, info = {}) {
    var _a5;
    const path = id.split(".");
    let currState = this;
    for (let i = 0; i < path.length; i++) {
      const id2 = path[i];
      const prevChildState = currState.getCurrent();
      const nextChildState = (_a5 = currState.children) == null ? void 0 : _a5[id2];
      if (!nextChildState) {
        throw Error(`${currState.id} - no child state exists with the id ${id2}.`);
      }
      if ((prevChildState == null ? void 0 : prevChildState.id) !== nextChildState.id) {
        prevChildState == null ? void 0 : prevChildState.exit(info, id2);
        currState._current.set(nextChildState);
        nextChildState.enter(info, (prevChildState == null ? void 0 : prevChildState.id) || "initial");
        if (!nextChildState.getIsActive())
          break;
      }
      currState = nextChildState;
    }
    return this;
  }
  handleEvent(info) {
    var _a5;
    const cbName = EVENT_NAME_MAP[info.name];
    const currentActiveChild = this._current.__unsafe__getWithoutCapture();
    (_a5 = this[cbName]) == null ? void 0 : _a5.call(this, info);
    if (this._isActive.__unsafe__getWithoutCapture() && currentActiveChild && currentActiveChild === this._current.__unsafe__getWithoutCapture()) {
      currentActiveChild.handleEvent(info);
    }
  }
  // todo: move this logic into transition
  enter(info, from2) {
    var _a5;
    if (debugFlags.measurePerformance.get() && STATE_NODES_TO_MEASURE.includes(this.id)) {
      this.performanceTracker.start(this.id);
    }
    this._isActive.set(true);
    (_a5 = this.onEnter) == null ? void 0 : _a5.call(this, info, from2);
    if (this.children && this.initial && this.getIsActive()) {
      const initial = this.children[this.initial];
      this._current.set(initial);
      initial.enter(info, from2);
    }
  }
  // todo: move this logic into transition
  exit(info, from2) {
    var _a5, _b;
    if (debugFlags.measurePerformance.get() && this.performanceTracker.isStarted()) {
      this.performanceTracker.stop();
    }
    this._isActive.set(false);
    (_a5 = this.onExit) == null ? void 0 : _a5.call(this, info, from2);
    if (!this.getIsActive()) {
      (_b = this.getCurrent()) == null ? void 0 : _b.exit(info, from2);
    }
  }
  getCurrentToolIdMask() {
    return this._currentToolIdMask.get();
  }
  setCurrentToolIdMask(id) {
    this._currentToolIdMask.set(id);
  }
};
__publicField(StateNode, "id");
__publicField(StateNode, "initial");
__publicField(StateNode, "children");
__publicField(StateNode, "isLockable", true);
__publicField(StateNode, "useCoalescedEvents", false);

// node_modules/@tldraw/editor/dist-esm/lib/editor/tools/RootState.mjs
var RootState = class extends StateNode {
  static children() {
    return [];
  }
  onKeyDown(info) {
    var _a5;
    switch (info.code) {
      case "KeyZ": {
        if (!(info.shiftKey || info.ctrlKey)) {
          const currentTool = this.getCurrent();
          if (currentTool && ((_a5 = currentTool.getCurrent()) == null ? void 0 : _a5.id) === "idle" && this.children["zoom"]) {
            this.editor.setCurrentTool("zoom", { ...info, onInteractionEnd: currentTool.id });
          }
        }
        break;
      }
    }
  }
};
__publicField(RootState, "id", "root");
__publicField(RootState, "initial", "");

// node_modules/@tldraw/editor/dist-esm/lib/editor/Editor.mjs
var __create9 = Object.create;
var __defProp9 = Object.defineProperty;
var __getOwnPropDesc9 = Object.getOwnPropertyDescriptor;
var __knownSymbol9 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError9 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name9 = (target, value) => __defProp9(target, "name", { value, configurable: true });
var __decoratorStart9 = (base2) => [, , , __create9((base2 == null ? void 0 : base2[__knownSymbol9("metadata")]) ?? null)];
var __decoratorStrings9 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn9 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError9("Function expected") : fn2;
var __decoratorContext9 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings9[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError9("Already initialized") : fns.push(__expectFn9(fn2 || null)) });
var __decoratorMetadata9 = (array2, target) => __defNormalProp9(target, __knownSymbol9("metadata"), array2[3]);
var __runInitializers9 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement9 = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings9[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc9(k < 4 ? target : { get [name]() {
    return __privateGet10(this, extra);
  }, set [name](x) {
    return __privateSet10(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name9(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name9(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext9(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn9(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet10 : __privateMethod9)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet10(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn9(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError9("Object expected");
    else
      __expectFn9(fn2 = it.get) && (desc.get = fn2), __expectFn9(fn2 = it.set) && (desc.set = fn2), __expectFn9(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata9(array2, target), desc && __defProp9(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField10 = (obj, key, value) => __defNormalProp9(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck9 = (obj, member, msg2) => member.has(obj) || __typeError9("Cannot " + msg2);
var __privateIn9 = (member, obj) => Object(obj) !== obj ? __typeError9('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet10 = (obj, member, getter) => (__accessCheck9(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet10 = (obj, member, value, setter) => (__accessCheck9(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod9 = (obj, member, method) => (__accessCheck9(obj, member, "access private method"), method);
var __setMetaKeyTimeout_dec;
var __setCtrlKeyTimeout_dec;
var __setAltKeyTimeout_dec;
var __setShiftKeyTimeout_dec;
var _getIsReadonly_dec;
var _getIsFocused_dec;
var _getSharedOpacity_dec;
var _getSharedStyles_dec;
var __getSelectionSharedStyles_dec;
var __getBindingsIndexCache_dec;
var _getCurrentPageRenderingShapesSorted_dec;
var _getCurrentPageShapesSorted_dec;
var _getCurrentPageShapes_dec;
var _getCurrentPageBounds_dec;
var _getCulledShapes_dec;
var __notVisibleShapes_dec;
var __getShapeMaskedPageBoundsCache_dec;
var __getShapeMaskCache_dec;
var __getShapeClipPathCache_dec;
var __getShapePageBoundsCache_dec;
var __getShapePageTransformCache_dec;
var __getShapeHandlesCache_dec;
var __getAllAssetsQuery_dec;
var _getCurrentPageShapeIdsSorted_dec;
var _getCurrentPageId_dec;
var _getPages_dec;
var __getAllPagesQuery_dec;
var _getRenderingShapes_dec;
var _getCollaboratorsOnCurrentPage_dec;
var _getCollaborators_dec;
var __getCollaboratorsQuery_dec;
var _getViewportPageBounds_dec;
var _getViewportScreenCenter_dec;
var _getViewportScreenBounds_dec;
var _getZoomLevel_dec;
var _getCameraForFollowing_dec;
var _getViewportPageBoundsForFollowing_dec;
var _getCamera_dec;
var __unsafe_getCameraId_dec;
var _getErasingShapes_dec;
var _getErasingShapeIds_dec;
var _getHintingShape_dec;
var _getHintingShapeIds_dec;
var _getHoveredShape_dec;
var _getHoveredShapeId_dec;
var _getRichTextEditor_dec;
var _getEditingShape_dec;
var _getEditingShapeId_dec;
var _getFocusedGroup_dec;
var _getFocusedGroupId_dec;
var _getSelectionRotatedScreenBounds_dec;
var _getSelectionRotatedPageBounds_dec;
var _getSelectionRotation_dec;
var _getSelectionPageBounds_dec;
var _getOnlySelectedShape_dec;
var _getOnlySelectedShapeId_dec;
var _getCurrentPageShapesInReadingOrder_dec;
var _getSelectedShapes_dec;
var _getSelectedShapeIds_dec;
var __getCurrentPageStateId_dec;
var _getCurrentPageState_dec;
var __getPageStatesQuery_dec;
var _getPageStates_dec;
var _getIsMenuOpen_dec;
var _getOpenMenus_dec;
var _getInstanceState_dec;
var _getDocumentSettings_dec;
var _getCurrentToolId_dec;
var _getCurrentTool_dec;
var _getPath_dec;
var _getCanRedo_dec;
var _getCanUndo_dec;
var _getIsShapeHiddenCache_dec;
var _a2;
var _init9;
var Editor = class extends (_a2 = import_eventemitter3.default, _getIsShapeHiddenCache_dec = [computed], _getCanUndo_dec = [computed], _getCanRedo_dec = [computed], _getPath_dec = [computed], _getCurrentTool_dec = [computed], _getCurrentToolId_dec = [computed], _getDocumentSettings_dec = [computed], _getInstanceState_dec = [computed], _getOpenMenus_dec = [computed], _getIsMenuOpen_dec = [computed], _getPageStates_dec = [computed], __getPageStatesQuery_dec = [computed], _getCurrentPageState_dec = [computed], __getCurrentPageStateId_dec = [computed], _getSelectedShapeIds_dec = [computed], _getSelectedShapes_dec = [computed], _getCurrentPageShapesInReadingOrder_dec = [computed], _getOnlySelectedShapeId_dec = [computed], _getOnlySelectedShape_dec = [computed], _getSelectionPageBounds_dec = [computed], _getSelectionRotation_dec = [computed], _getSelectionRotatedPageBounds_dec = [computed], _getSelectionRotatedScreenBounds_dec = [computed], _getFocusedGroupId_dec = [computed], _getFocusedGroup_dec = [computed], _getEditingShapeId_dec = [computed], _getEditingShape_dec = [computed], _getRichTextEditor_dec = [computed], _getHoveredShapeId_dec = [computed], _getHoveredShape_dec = [computed], _getHintingShapeIds_dec = [computed], _getHintingShape_dec = [computed], _getErasingShapeIds_dec = [computed], _getErasingShapes_dec = [computed], __unsafe_getCameraId_dec = [computed], _getCamera_dec = [computed], _getViewportPageBoundsForFollowing_dec = [computed], _getCameraForFollowing_dec = [computed], _getZoomLevel_dec = [computed], _getViewportScreenBounds_dec = [computed], _getViewportScreenCenter_dec = [computed], _getViewportPageBounds_dec = [computed], __getCollaboratorsQuery_dec = [computed], _getCollaborators_dec = [computed], _getCollaboratorsOnCurrentPage_dec = [computed], _getRenderingShapes_dec = [computed], __getAllPagesQuery_dec = [computed], _getPages_dec = [computed], _getCurrentPageId_dec = [computed], _getCurrentPageShapeIdsSorted_dec = [computed], __getAllAssetsQuery_dec = [computed], __getShapeHandlesCache_dec = [computed], __getShapePageTransformCache_dec = [computed], __getShapePageBoundsCache_dec = [computed], __getShapeClipPathCache_dec = [computed], __getShapeMaskCache_dec = [computed], __getShapeMaskedPageBoundsCache_dec = [computed], __notVisibleShapes_dec = [computed], _getCulledShapes_dec = [computed], _getCurrentPageBounds_dec = [computed], _getCurrentPageShapes_dec = [computed], _getCurrentPageShapesSorted_dec = [computed], _getCurrentPageRenderingShapesSorted_dec = [computed], __getBindingsIndexCache_dec = [computed], __getSelectionSharedStyles_dec = [computed], _getSharedStyles_dec = [computed({ isEqual: (a, b) => a.equals(b) })], _getSharedOpacity_dec = [computed], _getIsFocused_dec = [computed], _getIsReadonly_dec = [computed], __setShiftKeyTimeout_dec = [bind], __setAltKeyTimeout_dec = [bind], __setCtrlKeyTimeout_dec = [bind], __setMetaKeyTimeout_dec = [bind], _a2) {
  constructor({
    store,
    user,
    shapeUtils,
    bindingUtils,
    tools,
    getContainer,
    cameraOptions,
    textOptions,
    initialState: initialState2,
    autoFocus,
    inferDarkMode,
    options: options2,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    isShapeHidden,
    getShapeVisibility,
    fontAssetUrls
  }) {
    var _a5;
    super();
    __runInitializers9(_init9, 5, this);
    __publicField10(this, "id", uniqueId());
    __publicField10(this, "_getShapeVisibility");
    __publicField10(this, "options");
    __publicField10(this, "contextId", uniqueId());
    __publicField10(this, "store");
    __publicField10(this, "root");
    __publicField10(this, "disposables", /* @__PURE__ */ new Set());
    __publicField10(this, "isDisposed", false);
    __publicField10(this, "_tickManager");
    __publicField10(this, "snaps");
    __publicField10(this, "timers", tltime.forContext(this.contextId));
    __publicField10(this, "user");
    __publicField10(this, "textMeasure");
    __publicField10(this, "fonts");
    __publicField10(this, "environment", tlenv);
    __publicField10(this, "scribbles");
    __publicField10(this, "sideEffects");
    __publicField10(this, "edgeScrollManager");
    __publicField10(this, "focusManager");
    __publicField10(this, "getContainer");
    __publicField10(this, "shapeUtils");
    __publicField10(this, "styleProps");
    __publicField10(this, "bindingUtils");
    __publicField10(this, "history");
    __publicField10(this, "_shouldIgnoreShapeLock", false);
    __publicField10(this, "_crashingError", null);
    __publicField10(this, "_isChangingStyleTimeout", -1);
    __publicField10(this, "menus", tlmenus.forContext(this.contextId));
    __publicField10(this, "_currentRichTextEditor", atom("rich text editor", null));
    __publicField10(this, "_textOptions");
    __publicField10(this, "_cameraOptions", atom("camera options", DEFAULT_CAMERA_OPTIONS));
    __publicField10(this, "_viewportAnimation", null);
    __publicField10(this, "_willSetInitialBounds", true);
    __publicField10(this, "_isLockedOnFollowingUser", atom("isLockedOnFollowingUser", false));
    __publicField10(this, "_cameraState", atom("camera state", "idle"));
    __publicField10(this, "_cameraStateTimeoutRemaining", 0);
    __publicField10(this, "_currentPageShapeIds");
    __publicField10(this, "_shapeGeometryCaches", {});
    __publicField10(this, "_shapePageGeometryCaches", {});
    __publicField10(this, "_parentIdsToChildIds");
    __publicField10(this, "animatingShapes", /* @__PURE__ */ new Map());
    __publicField10(this, "externalAssetContentHandlers", {
      file: null,
      url: null
    });
    __publicField10(this, "temporaryAssetPreview", /* @__PURE__ */ new Map());
    __publicField10(this, "externalContentHandlers", {
      text: null,
      files: null,
      embed: null,
      "svg-text": null,
      url: null,
      tldraw: null,
      excalidraw: null
    });
    __publicField10(this, "inputs", {
      /** The most recent pointer down's position in the current page space. */
      originPagePoint: new Vec(),
      /** The most recent pointer down's position in screen space. */
      originScreenPoint: new Vec(),
      /** The previous pointer position in the current page space. */
      previousPagePoint: new Vec(),
      /** The previous pointer position in screen space. */
      previousScreenPoint: new Vec(),
      /** The most recent pointer position in the current page space. */
      currentPagePoint: new Vec(),
      /** The most recent pointer position in screen space. */
      currentScreenPoint: new Vec(),
      /** A set containing the currently pressed keys. */
      keys: /* @__PURE__ */ new Set(),
      /** A set containing the currently pressed buttons. */
      buttons: /* @__PURE__ */ new Set(),
      /** Whether the input is from a pe. */
      isPen: false,
      /** Whether the shift key is currently pressed. */
      shiftKey: false,
      /** Whether the meta key is currently pressed. */
      metaKey: false,
      /** Whether the control or command key is currently pressed. */
      ctrlKey: false,
      /** Whether the alt or option key is currently pressed. */
      altKey: false,
      /** Whether the user is dragging. */
      isDragging: false,
      /** Whether the user is pointing. */
      isPointing: false,
      /** Whether the user is pinching. */
      isPinching: false,
      /** Whether the user is editing. */
      isEditing: false,
      /** Whether the user is panning. */
      isPanning: false,
      /** Whether the user is spacebar panning. */
      isSpacebarPanning: false,
      /** Velocity of mouse pointer, in pixels per millisecond */
      pointerVelocity: new Vec()
    });
    __publicField10(this, "_clickManager", new ClickManager(this));
    __publicField10(this, "_prevCursor", "default");
    __publicField10(this, "_shiftKeyTimeout", -1);
    __publicField10(this, "_altKeyTimeout", -1);
    __publicField10(this, "_ctrlKeyTimeout", -1);
    __publicField10(this, "_metaKeyTimeout", -1);
    __publicField10(this, "_restoreToolId", "select");
    __publicField10(this, "_pinchStart", 1);
    __publicField10(this, "_didPinch", false);
    __publicField10(this, "_selectedShapeIdsAtPointerDown", []);
    __publicField10(this, "_longPressTimeout", -1);
    __publicField10(this, "capturedPointerId", null);
    __publicField10(this, "performanceTracker");
    __publicField10(this, "performanceTrackerTimeout", -1);
    __publicField10(this, "_pendingEventsForNextTick", []);
    assert(
      !(isShapeHidden && getShapeVisibility),
      "Cannot use both isShapeHidden and getShapeVisibility"
    );
    this._getShapeVisibility = isShapeHidden ? (
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      (shape, editor) => isShapeHidden(shape, editor) ? "hidden" : "inherit"
    ) : getShapeVisibility;
    this.options = { ...defaultTldrawOptions, ...options2 };
    this.store = store;
    this.history = new HistoryManager({
      store,
      annotateError: (error) => {
        this.annotateError(error, { origin: "history.batch", willCrashApp: true });
        this.crash(error);
      }
    });
    this.snaps = new SnapManager(this);
    this.disposables.add(this.timers.dispose);
    this._cameraOptions.set({ ...DEFAULT_CAMERA_OPTIONS, ...cameraOptions });
    this._textOptions = atom("text options", textOptions ?? null);
    this.user = new UserPreferencesManager(user ?? createTLUser(), inferDarkMode ?? false);
    this.disposables.add(() => this.user.dispose());
    this.getContainer = getContainer;
    this.textMeasure = new TextManager(this);
    this.fonts = new FontManager(this, fontAssetUrls);
    this._tickManager = new TickManager(this);
    class NewRoot extends RootState {
    }
    __publicField(NewRoot, "initial", initialState2 ?? "");
    this.root = new NewRoot(this);
    this.root.children = {};
    const allShapeUtils = checkShapesAndAddCore(shapeUtils);
    const _shapeUtils = {};
    const _styleProps = {};
    const allStylesById = /* @__PURE__ */ new Map();
    for (const Util of allShapeUtils) {
      const util = new Util(this);
      _shapeUtils[Util.type] = util;
      const propKeysByStyle = getShapePropKeysByStyle(Util.props ?? {});
      _styleProps[Util.type] = propKeysByStyle;
      for (const style2 of propKeysByStyle.keys()) {
        if (!allStylesById.has(style2.id)) {
          allStylesById.set(style2.id, style2);
        } else if (allStylesById.get(style2.id) !== style2) {
          throw Error(
            `Multiple style props with id "${style2.id}" in use. Style prop IDs must be unique.`
          );
        }
      }
    }
    this.shapeUtils = _shapeUtils;
    this.styleProps = _styleProps;
    const allBindingUtils = checkBindings(bindingUtils);
    const _bindingUtils = {};
    for (const Util of allBindingUtils) {
      const util = new Util(this);
      _bindingUtils[Util.type] = util;
    }
    this.bindingUtils = _bindingUtils;
    for (const Tool of [...tools]) {
      if (hasOwnProperty(this.root.children, Tool.id)) {
        throw Error(`Can't override tool with id "${Tool.id}"`);
      }
      this.root.children[Tool.id] = new Tool(this, this.root);
    }
    this.scribbles = new ScribbleManager(this);
    const cleanupInstancePageState = (prevPageState, shapesNoLongerInPage) => {
      let nextPageState = null;
      const selectedShapeIds = prevPageState.selectedShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (selectedShapeIds.length !== prevPageState.selectedShapeIds.length) {
        if (!nextPageState)
          nextPageState = { ...prevPageState };
        nextPageState.selectedShapeIds = selectedShapeIds;
      }
      const erasingShapeIds = prevPageState.erasingShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (erasingShapeIds.length !== prevPageState.erasingShapeIds.length) {
        if (!nextPageState)
          nextPageState = { ...prevPageState };
        nextPageState.erasingShapeIds = erasingShapeIds;
      }
      if (prevPageState.hoveredShapeId && shapesNoLongerInPage.has(prevPageState.hoveredShapeId)) {
        if (!nextPageState)
          nextPageState = { ...prevPageState };
        nextPageState.hoveredShapeId = null;
      }
      if (prevPageState.editingShapeId && shapesNoLongerInPage.has(prevPageState.editingShapeId)) {
        if (!nextPageState)
          nextPageState = { ...prevPageState };
        nextPageState.editingShapeId = null;
      }
      const hintingShapeIds = prevPageState.hintingShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (hintingShapeIds.length !== prevPageState.hintingShapeIds.length) {
        if (!nextPageState)
          nextPageState = { ...prevPageState };
        nextPageState.hintingShapeIds = hintingShapeIds;
      }
      if (prevPageState.focusedGroupId && shapesNoLongerInPage.has(prevPageState.focusedGroupId)) {
        if (!nextPageState)
          nextPageState = { ...prevPageState };
        nextPageState.focusedGroupId = null;
      }
      return nextPageState;
    };
    this.sideEffects = this.store.sideEffects;
    let deletedBindings = /* @__PURE__ */ new Map();
    const deletedShapeIds = /* @__PURE__ */ new Set();
    const invalidParents = /* @__PURE__ */ new Set();
    let invalidBindingTypes = /* @__PURE__ */ new Set();
    this.disposables.add(
      this.sideEffects.registerOperationCompleteHandler(() => {
        var _a6, _b, _c, _d;
        deletedShapeIds.clear();
        for (const parentId of invalidParents) {
          invalidParents.delete(parentId);
          const parent = this.getShape(parentId);
          if (!parent)
            continue;
          const util = this.getShapeUtil(parent);
          const changes = (_a6 = util.onChildrenChange) == null ? void 0 : _a6.call(util, parent);
          if (changes == null ? void 0 : changes.length) {
            this.updateShapes(changes);
          }
        }
        if (invalidBindingTypes.size) {
          const t2 = invalidBindingTypes;
          invalidBindingTypes = /* @__PURE__ */ new Set();
          for (const type of t2) {
            const util = this.getBindingUtil(type);
            (_b = util.onOperationComplete) == null ? void 0 : _b.call(util);
          }
        }
        if (deletedBindings.size) {
          const t2 = deletedBindings;
          deletedBindings = /* @__PURE__ */ new Map();
          for (const opts of t2.values()) {
            (_d = (_c = this.getBindingUtil(opts.binding)).onAfterDelete) == null ? void 0 : _d.call(_c, opts);
          }
        }
        this.emit("update");
      })
    );
    this.disposables.add(
      this.sideEffects.register({
        shape: {
          afterChange: (shapeBefore, shapeAfter) => {
            var _a6, _b, _c, _d;
            for (const binding of this.getBindingsInvolvingShape(shapeAfter)) {
              invalidBindingTypes.add(binding.type);
              if (binding.fromId === shapeAfter.id) {
                (_b = (_a6 = this.getBindingUtil(binding)).onAfterChangeFromShape) == null ? void 0 : _b.call(_a6, {
                  binding,
                  shapeBefore,
                  shapeAfter
                });
              }
              if (binding.toId === shapeAfter.id) {
                (_d = (_c = this.getBindingUtil(binding)).onAfterChangeToShape) == null ? void 0 : _d.call(_c, {
                  binding,
                  shapeBefore,
                  shapeAfter
                });
              }
            }
            if (shapeBefore.parentId !== shapeAfter.parentId) {
              const notifyBindingAncestryChange = (id) => {
                var _a7, _b2, _c2, _d2;
                const descendantShape = this.getShape(id);
                if (!descendantShape)
                  return;
                for (const binding of this.getBindingsInvolvingShape(descendantShape)) {
                  invalidBindingTypes.add(binding.type);
                  if (binding.fromId === descendantShape.id) {
                    (_b2 = (_a7 = this.getBindingUtil(binding)).onAfterChangeFromShape) == null ? void 0 : _b2.call(_a7, {
                      binding,
                      shapeBefore: descendantShape,
                      shapeAfter: descendantShape
                    });
                  }
                  if (binding.toId === descendantShape.id) {
                    (_d2 = (_c2 = this.getBindingUtil(binding)).onAfterChangeToShape) == null ? void 0 : _d2.call(_c2, {
                      binding,
                      shapeBefore: descendantShape,
                      shapeAfter: descendantShape
                    });
                  }
                }
              };
              notifyBindingAncestryChange(shapeAfter.id);
              this.visitDescendants(shapeAfter.id, notifyBindingAncestryChange);
            }
            if (shapeBefore.parentId !== shapeAfter.parentId && isPageId(shapeAfter.parentId)) {
              const allMovingIds = /* @__PURE__ */ new Set([shapeBefore.id]);
              this.visitDescendants(shapeBefore.id, (id) => {
                allMovingIds.add(id);
              });
              for (const instancePageState of this.getPageStates()) {
                if (instancePageState.pageId === shapeAfter.parentId)
                  continue;
                const nextPageState = cleanupInstancePageState(instancePageState, allMovingIds);
                if (nextPageState) {
                  this.store.put([nextPageState]);
                }
              }
            }
            if (shapeBefore.parentId && isShapeId(shapeBefore.parentId)) {
              invalidParents.add(shapeBefore.parentId);
            }
            if (shapeAfter.parentId !== shapeBefore.parentId && isShapeId(shapeAfter.parentId)) {
              invalidParents.add(shapeAfter.parentId);
            }
          },
          beforeDelete: (shape) => {
            var _a6, _b, _c, _d;
            if (deletedShapeIds.has(shape.id))
              return;
            if (shape.parentId && isShapeId(shape.parentId)) {
              invalidParents.add(shape.parentId);
            }
            deletedShapeIds.add(shape.id);
            const deleteBindingIds = [];
            for (const binding of this.getBindingsInvolvingShape(shape)) {
              invalidBindingTypes.add(binding.type);
              deleteBindingIds.push(binding.id);
              const util = this.getBindingUtil(binding);
              if (binding.fromId === shape.id) {
                (_a6 = util.onBeforeIsolateToShape) == null ? void 0 : _a6.call(util, { binding, removedShape: shape });
                (_b = util.onBeforeDeleteFromShape) == null ? void 0 : _b.call(util, { binding, shape });
              } else {
                (_c = util.onBeforeIsolateFromShape) == null ? void 0 : _c.call(util, { binding, removedShape: shape });
                (_d = util.onBeforeDeleteToShape) == null ? void 0 : _d.call(util, { binding, shape });
              }
            }
            if (deleteBindingIds.length) {
              this.deleteBindings(deleteBindingIds);
            }
            const deletedIds = /* @__PURE__ */ new Set([shape.id]);
            const updates = compact(
              this.getPageStates().map((pageState) => {
                return cleanupInstancePageState(pageState, deletedIds);
              })
            );
            if (updates.length) {
              this.store.put(updates);
            }
          }
        },
        binding: {
          beforeCreate: (binding) => {
            var _a6, _b;
            const next = (_b = (_a6 = this.getBindingUtil(binding)).onBeforeCreate) == null ? void 0 : _b.call(_a6, { binding });
            if (next)
              return next;
            return binding;
          },
          afterCreate: (binding) => {
            var _a6, _b;
            invalidBindingTypes.add(binding.type);
            (_b = (_a6 = this.getBindingUtil(binding)).onAfterCreate) == null ? void 0 : _b.call(_a6, { binding });
          },
          beforeChange: (bindingBefore, bindingAfter) => {
            var _a6, _b;
            const updated = (_b = (_a6 = this.getBindingUtil(bindingAfter)).onBeforeChange) == null ? void 0 : _b.call(_a6, {
              bindingBefore,
              bindingAfter
            });
            if (updated)
              return updated;
            return bindingAfter;
          },
          afterChange: (bindingBefore, bindingAfter) => {
            var _a6, _b;
            invalidBindingTypes.add(bindingAfter.type);
            (_b = (_a6 = this.getBindingUtil(bindingAfter)).onAfterChange) == null ? void 0 : _b.call(_a6, { bindingBefore, bindingAfter });
          },
          beforeDelete: (binding) => {
            var _a6, _b;
            (_b = (_a6 = this.getBindingUtil(binding)).onBeforeDelete) == null ? void 0 : _b.call(_a6, { binding });
          },
          afterDelete: (binding) => {
            var _a6, _b;
            (_b = (_a6 = this.getBindingUtil(binding)).onAfterDelete) == null ? void 0 : _b.call(_a6, { binding });
            invalidBindingTypes.add(binding.type);
          }
        },
        page: {
          afterCreate: (record) => {
            const cameraId = CameraRecordType.createId(record.id);
            const _pageStateId = InstancePageStateRecordType.createId(record.id);
            if (!this.store.has(cameraId)) {
              this.store.put([CameraRecordType.create({ id: cameraId })]);
            }
            if (!this.store.has(_pageStateId)) {
              this.store.put([
                InstancePageStateRecordType.create({ id: _pageStateId, pageId: record.id })
              ]);
            }
          },
          afterDelete: (record, source) => {
            var _a6, _b;
            if (((_a6 = this.getInstanceState()) == null ? void 0 : _a6.currentPageId) === record.id) {
              const backupPageId = (_b = this.getPages().find((p) => p.id !== record.id)) == null ? void 0 : _b.id;
              if (backupPageId) {
                this.store.put([{ ...this.getInstanceState(), currentPageId: backupPageId }]);
              } else if (source === "user") {
                this.store.ensureStoreIsUsable();
              }
            }
            const cameraId = CameraRecordType.createId(record.id);
            const instance_PageStateId = InstancePageStateRecordType.createId(record.id);
            this.store.remove([cameraId, instance_PageStateId]);
          }
        },
        instance: {
          afterChange: (prev, next, source) => {
            var _a6;
            if (!this.store.has(next.currentPageId)) {
              const backupPageId = this.store.has(prev.currentPageId) ? prev.currentPageId : (_a6 = this.getPages()[0]) == null ? void 0 : _a6.id;
              if (backupPageId) {
                this.store.update(next.id, (instance) => ({
                  ...instance,
                  currentPageId: backupPageId
                }));
              } else if (source === "user") {
                this.store.ensureStoreIsUsable();
              }
            }
          }
        },
        instance_page_state: {
          afterChange: (prev, next) => {
            if ((prev == null ? void 0 : prev.selectedShapeIds) !== (next == null ? void 0 : next.selectedShapeIds)) {
              const filtered = next.selectedShapeIds.filter((id) => {
                var _a6, _b;
                let parentId = (_a6 = this.getShape(id)) == null ? void 0 : _a6.parentId;
                while (isShapeId(parentId)) {
                  if (next.selectedShapeIds.includes(parentId)) {
                    return false;
                  }
                  parentId = (_b = this.getShape(parentId)) == null ? void 0 : _b.parentId;
                }
                return true;
              });
              let nextFocusedGroupId = null;
              if (filtered.length > 0) {
                const commonGroupAncestor = this.findCommonAncestor(
                  compact(filtered.map((id) => this.getShape(id))),
                  (shape) => this.isShapeOfType(shape, "group")
                );
                if (commonGroupAncestor) {
                  nextFocusedGroupId = commonGroupAncestor;
                }
              } else {
                if (next == null ? void 0 : next.focusedGroupId) {
                  nextFocusedGroupId = next.focusedGroupId;
                }
              }
              if (filtered.length !== next.selectedShapeIds.length || nextFocusedGroupId !== next.focusedGroupId) {
                this.store.put([
                  {
                    ...next,
                    selectedShapeIds: filtered,
                    focusedGroupId: nextFocusedGroupId ?? null
                  }
                ]);
              }
            }
          }
        }
      })
    );
    this._currentPageShapeIds = deriveShapeIdsInCurrentPage(
      this.store,
      () => this.getCurrentPageId()
    );
    this._parentIdsToChildIds = parentsToChildren(this.store);
    this.disposables.add(
      this.store.listen((changes) => {
        this.emit("change", changes);
      })
    );
    this.disposables.add(this.history.dispose);
    this.run(
      () => {
        this.store.ensureStoreIsUsable();
        this._updateCurrentPageState({
          editingShapeId: null,
          hoveredShapeId: null,
          erasingShapeIds: []
        });
      },
      { history: "ignore" }
    );
    if (initialState2 && this.root.children[initialState2] === void 0) {
      throw Error(`No state found for initialState "${initialState2}".`);
    }
    this.root.enter(void 0, "initial");
    this.edgeScrollManager = new EdgeScrollManager(this);
    this.focusManager = new FocusManager(this, autoFocus);
    this.disposables.add(this.focusManager.dispose.bind(this.focusManager));
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    this.on("tick", this._flushEventsForTick);
    this.timers.requestAnimationFrame(() => {
      this._tickManager.start();
    });
    this.performanceTracker = new PerformanceTracker();
    if ((_a5 = this.store.props.collaboration) == null ? void 0 : _a5.mode) {
      const mode = this.store.props.collaboration.mode;
      this.disposables.add(
        react("update collaboration mode", () => {
          this.store.put([{ ...this.getInstanceState(), isReadonly: mode.get() === "readonly" }]);
        })
      );
    }
  }
  getIsShapeHiddenCache() {
    if (!this._getShapeVisibility)
      return null;
    return this.store.createComputedCache("isShapeHidden", (shape) => {
      const visibility = this._getShapeVisibility(shape, this);
      const isParentHidden = PageRecordType.isId(shape.parentId) ? false : this.isShapeHidden(shape.parentId);
      if (isParentHidden)
        return visibility !== "visible";
      return visibility === "hidden";
    });
  }
  isShapeHidden(shapeOrId) {
    if (!this._getShapeVisibility)
      return false;
    return !!this.getIsShapeHiddenCache().get(
      typeof shapeOrId === "string" ? shapeOrId : shapeOrId.id
    );
  }
  /**
   * Dispose the editor.
   *
   * @public
   */
  dispose() {
    this.disposables.forEach((dispose) => dispose());
    this.disposables.clear();
    this.store.dispose();
    this.isDisposed = true;
  }
  getShapeUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    const shapeUtil = getOwnProperty(this.shapeUtils, type);
    assert(shapeUtil, `No shape util found for type "${type}"`);
    return shapeUtil;
  }
  hasShapeUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    return hasOwnProperty(this.shapeUtils, type);
  }
  getBindingUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    const bindingUtil = getOwnProperty(this.bindingUtils, type);
    assert(bindingUtil, `No binding util found for type "${type}"`);
    return bindingUtil;
  }
  /**
   * Undo to the last mark.
   *
   * @example
   * ```ts
   * editor.undo()
   * ```
   *
   * @public
   */
  undo() {
    this._flushEventsForTick(0);
    this.complete();
    this.history.undo();
    return this;
  }
  getCanUndo() {
    return this.history.getNumUndos() > 0;
  }
  /**
   * Redo to the next mark.
   *
   * @example
   * ```ts
   * editor.redo()
   * ```
   *
   * @public
   */
  redo() {
    this._flushEventsForTick(0);
    this.complete();
    this.history.redo();
    return this;
  }
  clearHistory() {
    this.history.clear();
    return this;
  }
  getCanRedo() {
    return this.history.getNumRedos() > 0;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos.
   *
   * @example
   * ```ts
   * editor.mark()
   * editor.mark('flip shapes')
   * ```
   *
   * @param markId - The mark's id, usually the reason for adding the mark.
   *
   * @public
   * @deprecated use {@link Editor.markHistoryStoppingPoint} instead
   */
  mark(markId) {
    if (typeof markId === "string") {
      console.warn(
        `[tldraw] \`editor.history.mark("${markId}")\` is deprecated. Please use \`const myMarkId = editor.markHistoryStoppingPoint()\` instead.`
      );
    } else {
      console.warn(
        "[tldraw] `editor.mark()` is deprecated. Use `editor.markHistoryStoppingPoint()` instead."
      );
    }
    this.history._mark(markId ?? uniqueId());
    return this;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos. You typically want to do this just before a user interaction begins or is handled.
   *
   * @example
   * ```ts
   * editor.markHistoryStoppingPoint()
   * editor.flipShapes(editor.getSelectedShapes())
   * ```
   * @example
   * ```ts
   * const beginRotateMark = editor.markHistoryStoppingPoint()
   * // if the use cancels the rotation, you can bail back to this mark
   * editor.bailToMark(beginRotateMark)
   * ```
   *
   * @public
   * @param name - The name of the mark, useful for debugging the undo/redo stacks
   * @returns a unique id for the mark that can be used with `squashToMark` or `bailToMark`.
   */
  markHistoryStoppingPoint(name) {
    const id = `[${name ?? "stop"}]_${uniqueId()}`;
    this.history._mark(id);
    return id;
  }
  /**
   * @internal this is only used to implement some backwards-compatibility logic. Should be fine to delete after 6 months or whatever.
   */
  getMarkIdMatching(idSubstring) {
    return this.history.getMarkIdMatching(idSubstring);
  }
  /**
   * Coalesces all changes since the given mark into a single change, removing any intermediate marks.
   *
   * This is useful if you need to 'compress' the recent history to simplify the undo/redo experience of a complex interaction.
   *
   * @example
   * ```ts
   * const bumpShapesMark = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.squashToMark(bumpShapesMark)
   * ```
   *
   * @param markId - The mark id to squash to.
   */
  squashToMark(markId) {
    this.history.squashToMark(markId);
    return this;
  }
  /**
   * Undo to the closest mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * editor.bail()
   * ```
   *
   * @public
   */
  bail() {
    this.history.bail();
    return this;
  }
  /**
   * Undo to the given mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * const beginDrag = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.bailToMark(beginDrag)
   * ```
   *
   * @public
   */
  bailToMark(id) {
    this.history.bailToMark(id);
    return this;
  }
  /**
   * Run a function in a transaction with optional options for context.
   * You can use the options to change the way that history is treated
   * or allow changes to locked shapes.
   *
   * @example
   * ```ts
   * // updating with
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * }, { history: "ignore" })
   *
   * // forcing changes / deletions for locked shapes
   * editor.toggleLock([myShape])
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * 	editor.deleteShape(myShape)
   * }, { ignoreShapeLock: true }, )
   * ```
   *
   * @param fn - The callback function to run.
   * @param opts - The options for the batch.
   *
   *
   * @public
   */
  run(fn2, opts) {
    const previousIgnoreShapeLock = this._shouldIgnoreShapeLock;
    this._shouldIgnoreShapeLock = (opts == null ? void 0 : opts.ignoreShapeLock) ?? previousIgnoreShapeLock;
    try {
      this.history.batch(fn2, opts);
    } finally {
      this._shouldIgnoreShapeLock = previousIgnoreShapeLock;
    }
    return this;
  }
  /**
   * @deprecated Use `Editor.run` instead.
   */
  batch(fn2, opts) {
    return this.run(fn2, opts);
  }
  /* --------------------- Errors --------------------- */
  /** @internal */
  annotateError(error, {
    origin,
    willCrashApp,
    tags,
    extras
  }) {
    const defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp);
    annotateError(error, {
      tags: { ...defaultAnnotations.tags, ...tags },
      extras: { ...defaultAnnotations.extras, ...extras }
    });
    if (willCrashApp) {
      this.store.markAsPossiblyCorrupted();
    }
    return this;
  }
  /** @internal */
  createErrorAnnotations(origin, willCrashApp) {
    try {
      const editingShapeId = this.getEditingShapeId();
      return {
        tags: {
          origin,
          willCrashApp
        },
        extras: {
          activeStateNode: this.root.getPath(),
          selectedShapes: this.getSelectedShapes().map((s) => {
            const { props, ...rest } = s;
            const { text: _text, richText: _richText, ...restProps } = props;
            return {
              ...rest,
              props: restProps
            };
          }),
          selectionCount: this.getSelectedShapes().length,
          editingShape: editingShapeId ? this.getShape(editingShapeId) : void 0,
          inputs: this.inputs,
          pageState: this.getCurrentPageState(),
          instanceState: this.getInstanceState(),
          collaboratorCount: this.getCollaboratorsOnCurrentPage().length
        }
      };
    } catch {
      return {
        tags: {
          origin,
          willCrashApp
        },
        extras: {}
      };
    }
  }
  /**
   * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,
   * we're in a transaction that's about to be rolled back due to the same error we're currently
   * reporting.
   *
   * Instead, to listen to changes to this value, you need to listen to app's `crash` event.
   *
   * @internal
   */
  getCrashingError() {
    return this._crashingError;
  }
  /** @internal */
  crash(error) {
    this._crashingError = error;
    this.store.markAsPossiblyCorrupted();
    this.emit("crash", { error });
    return this;
  }
  getPath() {
    return this.root.getPath().split("root.")[1];
  }
  /**
   * Get whether a certain tool (or other state node) is currently active.
   *
   * @example
   * ```ts
   * editor.isIn('select')
   * editor.isIn('select.brushing')
   * ```
   *
   * @param path - The path of active states, separated by periods.
   *
   * @public
   */
  isIn(path) {
    const ids = path.split(".").reverse();
    let state = this.root;
    while (ids.length > 0) {
      const id = ids.pop();
      if (!id)
        return true;
      const current = state.getCurrent();
      if ((current == null ? void 0 : current.id) === id) {
        if (ids.length === 0)
          return true;
        state = current;
        continue;
      } else
        return false;
    }
    return false;
  }
  /**
   * Get whether the state node is in any of the given active paths.
   *
   * @example
   * ```ts
   * state.isInAny('select', 'erase')
   * state.isInAny('select.brushing', 'erase.idle')
   * ```
   *
   * @public
   */
  isInAny(...paths) {
    return paths.some((path) => this.isIn(path));
  }
  /**
   * Set the selected tool.
   *
   * @example
   * ```ts
   * editor.setCurrentTool('hand')
   * editor.setCurrentTool('hand', { date: Date.now() })
   * ```
   *
   * @param id - The id of the tool to select.
   * @param info - Arbitrary data to pass along into the transition.
   *
   * @public
   */
  setCurrentTool(id, info = {}) {
    this.root.transition(id, info);
    return this;
  }
  getCurrentTool() {
    return this.root.getCurrent();
  }
  getCurrentToolId() {
    const currentTool = this.getCurrentTool();
    if (!currentTool)
      return "";
    return currentTool.getCurrentToolIdMask() ?? currentTool.id;
  }
  /**
   * Get a descendant by its path.
   *
   * @example
   * ```ts
   * editor.getStateDescendant('select')
   * editor.getStateDescendant('select.brushing')
   * ```
   *
   * @param path - The descendant's path of state ids, separated by periods.
   *
   * @public
   */
  getStateDescendant(path) {
    var _a5;
    const ids = path.split(".").reverse();
    let state = this.root;
    while (ids.length > 0) {
      const id = ids.pop();
      if (!id)
        return state;
      const childState = (_a5 = state.children) == null ? void 0 : _a5[id];
      if (!childState)
        return void 0;
      state = childState;
    }
    return state;
  }
  getDocumentSettings() {
    return this.store.get(TLDOCUMENT_ID);
  }
  /**
   * Update the global document settings that apply to all users.
   *
   * @public
   **/
  updateDocumentSettings(settings) {
    this.run(
      () => {
        this.store.put([{ ...this.getDocumentSettings(), ...settings }]);
      },
      { history: "ignore" }
    );
    return this;
  }
  getInstanceState() {
    return this.store.get(TLINSTANCE_ID);
  }
  /**
   * Update the instance's state.
   *
   * @param partial - A partial object to update the instance state with.
   * @param historyOptions - History batch options.
   *
   * @public
   */
  updateInstanceState(partial, historyOptions) {
    this._updateInstanceState(partial, { history: "ignore", ...historyOptions });
    if (partial.isChangingStyle !== void 0) {
      clearTimeout(this._isChangingStyleTimeout);
      if (partial.isChangingStyle === true) {
        this._isChangingStyleTimeout = this.timers.setTimeout(() => {
          this._updateInstanceState({ isChangingStyle: false }, { history: "ignore" });
        }, 1e3);
      }
    }
    return this;
  }
  /** @internal */
  _updateInstanceState(partial, opts) {
    this.run(() => {
      this.store.put([
        {
          ...this.getInstanceState(),
          ...partial
        }
      ]);
    }, opts);
  }
  getOpenMenus() {
    return this.menus.getOpenMenus();
  }
  /**
   * @deprecated Use `editor.menus.addOpenMenu` instead.
   *
   * @public
   */
  addOpenMenu(id) {
    this.menus.addOpenMenu(id);
    return this;
  }
  /**
   * @deprecated Use `editor.menus.deleteOpenMenu` instead.
   *
   * @public
   */
  deleteOpenMenu(id) {
    this.menus.deleteOpenMenu(id);
    return this;
  }
  /**
   * @deprecated Use `editor.menus.clearOpenMenus` instead.
   *
   * @public
   */
  clearOpenMenus() {
    this.menus.clearOpenMenus();
    return this;
  }
  getIsMenuOpen() {
    return this.menus.hasAnyOpenMenus();
  }
  /* --------------------- Cursor --------------------- */
  /**
   * Set the cursor.
   *
   * @param cursor - The cursor to set.
   * @public
   */
  setCursor(cursor) {
    this.updateInstanceState({ cursor: { ...this.getInstanceState().cursor, ...cursor } });
    return this;
  }
  getPageStates() {
    return this._getPageStatesQuery().get();
  }
  _getPageStatesQuery() {
    return this.store.query.records("instance_page_state");
  }
  getCurrentPageState() {
    return this.store.get(this._getCurrentPageStateId());
  }
  _getCurrentPageStateId() {
    return InstancePageStateRecordType.createId(this.getCurrentPageId());
  }
  /**
   * Update this instance's page state.
   *
   * @example
   * ```ts
   * editor.updateCurrentPageState({ id: 'page1', editingShapeId: 'shape:123' })
   * ```
   *
   * @param partial - The partial of the page state object containing the changes.
   *
   * @public
   */
  updateCurrentPageState(partial) {
    this._updateCurrentPageState(partial);
    return this;
  }
  _updateCurrentPageState(partial) {
    this.store.update(partial.id ?? this.getCurrentPageState().id, (state) => ({
      ...state,
      ...partial
    }));
  }
  getSelectedShapeIds() {
    return this.getCurrentPageState().selectedShapeIds;
  }
  getSelectedShapes() {
    return compact(this.getSelectedShapeIds().map((id) => this.store.get(id)));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.setSelectedShapes(['id1'])
   * editor.setSelectedShapes(['id1', 'id2'])
   * ```
   *
   * @param shapes - The shape (or shape ids) to select.
   *
   * @public
   */
  setSelectedShapes(shapes) {
    return this.run(
      () => {
        const ids = shapes.map((shape) => typeof shape === "string" ? shape : shape.id);
        const { selectedShapeIds: prevSelectedShapeIds } = this.getCurrentPageState();
        const prevSet = new Set(prevSelectedShapeIds);
        if (ids.length === prevSet.size && ids.every((id) => prevSet.has(id)))
          return null;
        this.store.put([{ ...this.getCurrentPageState(), selectedShapeIds: ids }]);
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Determine whether or not any of a shape's ancestors are selected.
   *
   * @param shape - The shape (or shape id) of the shape to check.
   *
   * @public
   */
  isAncestorSelected(shape) {
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    const _shape = this.getShape(id);
    if (!_shape)
      return false;
    const selectedShapeIds = this.getSelectedShapeIds();
    return !!this.findShapeAncestor(_shape, (parent) => selectedShapeIds.includes(parent.id));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.select('id1')
   * editor.select('id1', 'id2')
   * ```
   *
   * @param shapes - The shape (or the shape ids) to select.
   *
   * @public
   */
  select(...shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    this.setSelectedShapes(ids);
    return this;
  }
  /**
   * Remove a shape from the existing set of selected shapes.
   *
   * @example
   * ```ts
   * editor.deselect(shape.id)
   * ```
   *
   * @public
   */
  deselect(...shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    const selectedShapeIds = this.getSelectedShapeIds();
    if (selectedShapeIds.length > 0 && ids.length > 0) {
      this.setSelectedShapes(selectedShapeIds.filter((id) => !ids.includes(id)));
    }
    return this;
  }
  /**
   * Select all direct children of the current page.
   *
   * @example
   * ```ts
   * editor.selectAll()
   * ```
   *
   * @public
   */
  selectAll() {
    const ids = this.getSortedChildIdsForParent(this.getCurrentPageId());
    if (ids.length <= 0)
      return this;
    this.setSelectedShapes(this._getUnlockedShapeIds(ids));
    return this;
  }
  /**
   * Select the next shape in the reading order or in cardinal order.
   *
   * @example
   * ```ts
   * editor.selectAdjacentShape('next')
   * ```
   *
   * @public
   */
  selectAdjacentShape(direction) {
    var _a5, _b;
    const selectedShapeIds = this.getSelectedShapeIds();
    const firstParentId = selectedShapeIds[0] ? (_a5 = this.getShape(selectedShapeIds[0])) == null ? void 0 : _a5.parentId : null;
    const isSelectedWithinContainer = firstParentId && selectedShapeIds.every((shapeId) => {
      var _a6;
      return ((_a6 = this.getShape(shapeId)) == null ? void 0 : _a6.parentId) === firstParentId;
    }) && !isPageId(firstParentId);
    const readingOrderShapes = isSelectedWithinContainer ? this._getShapesInReadingOrder(
      this.getCurrentPageShapes().filter((shape2) => shape2.parentId === firstParentId)
    ) : this.getCurrentPageShapesInReadingOrder();
    const currentShapeId = selectedShapeIds.length === 1 ? selectedShapeIds[0] : (_b = readingOrderShapes.find((shape2) => selectedShapeIds.includes(shape2.id))) == null ? void 0 : _b.id;
    let adjacentShapeId;
    if (direction === "next" || direction === "prev") {
      const shapeIds = readingOrderShapes.map((shape2) => shape2.id);
      const currentIndex = currentShapeId ? shapeIds.indexOf(currentShapeId) : -1;
      const adjacentIndex = (currentIndex + (direction === "next" ? 1 : -1) + shapeIds.length) % shapeIds.length;
      adjacentShapeId = shapeIds[adjacentIndex];
    } else {
      if (!currentShapeId)
        return;
      adjacentShapeId = this.getNearestAdjacentShape(currentShapeId, direction);
    }
    const shape = this.getShape(adjacentShapeId);
    if (!shape)
      return;
    this._selectShapesAndZoom([shape.id]);
  }
  getCurrentPageShapesInReadingOrder() {
    const shapes = this.getCurrentPageShapes().filter((shape) => isPageId(shape.parentId));
    return this._getShapesInReadingOrder(shapes);
  }
  _getShapesInReadingOrder(shapes) {
    const SHALLOW_ANGLE = 20;
    const ROW_THRESHOLD = 100;
    const tabbableShapes = shapes.filter((shape) => this.getShapeUtil(shape).canTabTo(shape));
    if (tabbableShapes.length <= 1)
      return tabbableShapes;
    const shapesWithCenters = tabbableShapes.map((shape) => ({
      shape,
      center: this.getShapePageBounds(shape).center
    }));
    shapesWithCenters.sort((a, b) => a.center.y - b.center.y);
    const rows = [];
    for (const shapeWithCenter of shapesWithCenters) {
      let rowIndex = -1;
      for (let i = rows.length - 1; i >= 0; i--) {
        const row = rows[i];
        const lastShapeInRow = row[row.length - 1];
        if (Math.abs(shapeWithCenter.center.y - lastShapeInRow.center.y) < ROW_THRESHOLD) {
          rowIndex = i;
          break;
        }
      }
      if (rowIndex === -1) {
        rows.push([shapeWithCenter]);
      } else {
        rows[rowIndex].push(shapeWithCenter);
      }
    }
    for (const row of rows) {
      row.sort((a, b) => a.center.x - b.center.x);
    }
    for (const row of rows) {
      if (row.length <= 2)
        continue;
      for (let i = 0; i < row.length - 2; i++) {
        const currentShape = row[i];
        const nextShape = row[i + 1];
        const nextNextShape = row[i + 2];
        const dist1 = Vec.Dist2(currentShape.center, nextShape.center);
        const dist2 = Vec.Dist2(currentShape.center, nextNextShape.center);
        if (dist2 < dist1 * 0.9) {
          const angle = Math.abs(
            Vec.Angle(currentShape.center, nextNextShape.center) * (180 / Math.PI)
          );
          if (angle <= SHALLOW_ANGLE) {
            ;
            [row[i + 1], row[i + 2]] = [row[i + 2], row[i + 1]];
          }
        }
      }
    }
    return rows.flat().map((item) => item.shape);
  }
  /**
   * Find the nearest adjacent shape in a specific direction.
   *
   * @public
   */
  getNearestAdjacentShape(currentShapeId, direction) {
    const directionToAngle = { right: 0, left: 180, down: 90, up: 270 };
    const currentShape = this.getShape(currentShapeId);
    if (!currentShape)
      return currentShapeId;
    const shapes = this.getCurrentPageShapes();
    const tabbableShapes = shapes.filter(
      (shape) => this.getShapeUtil(shape).canTabTo(shape) && shape.id !== currentShapeId
    );
    if (!tabbableShapes.length)
      return currentShapeId;
    const currentCenter = this.getShapePageBounds(currentShape).center;
    const shapesWithCenters = tabbableShapes.map((shape) => ({
      shape,
      center: this.getShapePageBounds(shape).center
    }));
    const shapesInDirection = shapesWithCenters.filter(({ center }) => {
      const isRight = center.x > currentCenter.x;
      const isDown = center.y > currentCenter.y;
      const xDist = center.x - currentCenter.x;
      const yDist = center.y - currentCenter.y;
      const isInXDirection = Math.abs(yDist) < Math.abs(xDist) * 2;
      const isInYDirection = Math.abs(xDist) < Math.abs(yDist) * 2;
      if (direction === "left" || direction === "right") {
        return isInXDirection && (direction === "right" ? isRight : !isRight);
      }
      if (direction === "up" || direction === "down") {
        return isInYDirection && (direction === "down" ? isDown : !isDown);
      }
    });
    if (shapesInDirection.length === 0)
      return currentShapeId;
    const lowestScoringShape = minBy(shapesInDirection, ({ center }) => {
      const distance = Vec.Dist2(currentCenter, center);
      const dirProp = ["left", "right"].includes(direction) ? "x" : "y";
      const directionalDistance = Math.abs(center[dirProp] - currentCenter[dirProp]);
      const offProp = ["left", "right"].includes(direction) ? "y" : "x";
      const offAxisDeviation = Math.abs(center[offProp] - currentCenter[offProp]);
      const angle = Math.abs(Vec.Angle(currentCenter, center) * (180 / Math.PI));
      const angleDeviation = Math.abs(angle - directionToAngle[direction]);
      return distance * 1 + // Base distance
      offAxisDeviation * 2 + // Heavy penalty for off-axis deviation
      (distance - directionalDistance) * 1.5 + // Penalty for diagonal distance
      angleDeviation * 0.5;
    });
    return lowestScoringShape.shape.id;
  }
  selectParentShape() {
    const selectedShape = this.getOnlySelectedShape();
    if (!selectedShape)
      return;
    const parentShape = this.getShape(selectedShape.parentId);
    if (!parentShape)
      return;
    this._selectShapesAndZoom([parentShape.id]);
  }
  selectFirstChildShape() {
    const selectedShapes = this.getSelectedShapes();
    if (!selectedShapes.length)
      return;
    const selectedShape = selectedShapes[0];
    const children = this.getSortedChildIdsForParent(selectedShape.id).map((id) => this.getShape(id)).filter((i) => i);
    const sortedChildren = this._getShapesInReadingOrder(children);
    if (sortedChildren.length === 0)
      return;
    this._selectShapesAndZoom([sortedChildren[0].id]);
  }
  _selectShapesAndZoom(ids) {
    this.setSelectedShapes(ids);
    this.zoomToSelectionIfOffscreen(256, {
      animation: {
        duration: this.options.animationMediumMs
      },
      inset: 0
    });
  }
  /**
   * Clear the selection.
   *
   * @example
   * ```ts
   * editor.selectNone()
   * ```
   *
   * @public
   */
  selectNone() {
    if (this.getSelectedShapeIds().length > 0) {
      this.setSelectedShapes([]);
    }
    return this;
  }
  getOnlySelectedShapeId() {
    var _a5;
    return ((_a5 = this.getOnlySelectedShape()) == null ? void 0 : _a5.id) ?? null;
  }
  getOnlySelectedShape() {
    const selectedShapes = this.getSelectedShapes();
    return selectedShapes.length === 1 ? selectedShapes[0] : null;
  }
  /**
   * @internal
   */
  getShapesPageBounds(shapeIds) {
    const bounds = compact(shapeIds.map((id) => this.getShapePageBounds(id)));
    if (bounds.length === 0)
      return null;
    return Box.Common(bounds);
  }
  getSelectionPageBounds() {
    return this.getShapesPageBounds(this.getSelectedShapeIds());
  }
  /**
   * @internal
   */
  getShapesSharedRotation(shapeIds) {
    let foundFirst = false;
    let rotation = 0;
    for (let i = 0, n = shapeIds.length; i < n; i++) {
      const pageTransform = this.getShapePageTransform(shapeIds[i]);
      if (!pageTransform)
        continue;
      if (foundFirst) {
        if (pageTransform.rotation() !== rotation) {
          return 0;
        }
      } else {
        foundFirst = true;
        rotation = pageTransform.rotation();
      }
    }
    return rotation;
  }
  getSelectionRotation() {
    return this.getShapesSharedRotation(this.getSelectedShapeIds());
  }
  /**
   * @internal
   */
  getShapesRotatedPageBounds(shapeIds) {
    if (shapeIds.length === 0) {
      return void 0;
    }
    const selectionRotation = this.getShapesSharedRotation(shapeIds);
    if (selectionRotation === 0) {
      return this.getShapesPageBounds(shapeIds) ?? void 0;
    }
    if (shapeIds.length === 1) {
      const bounds = this.getShapeGeometry(shapeIds[0]).bounds.clone();
      const pageTransform = this.getShapePageTransform(shapeIds[0]);
      bounds.point = pageTransform.applyToPoint(bounds.point);
      return bounds;
    }
    const boxFromRotatedVertices = Box.FromPoints(
      shapeIds.flatMap((id) => {
        const pageTransform = this.getShapePageTransform(id);
        if (!pageTransform)
          return [];
        return pageTransform.applyToPoints(this.getShapeGeometry(id).bounds.corners);
      }).map((p) => p.rot(-selectionRotation))
    );
    boxFromRotatedVertices.point = boxFromRotatedVertices.point.rot(selectionRotation);
    return boxFromRotatedVertices;
  }
  getSelectionRotatedPageBounds() {
    return this.getShapesRotatedPageBounds(this.getSelectedShapeIds());
  }
  getSelectionRotatedScreenBounds() {
    const bounds = this.getSelectionRotatedPageBounds();
    if (!bounds)
      return void 0;
    const { x, y } = this.pageToScreen(bounds.point);
    const zoom = this.getZoomLevel();
    return new Box(x, y, bounds.width * zoom, bounds.height * zoom);
  }
  getFocusedGroupId() {
    return this.getCurrentPageState().focusedGroupId ?? this.getCurrentPageId();
  }
  getFocusedGroup() {
    const focusedGroupId = this.getFocusedGroupId();
    return focusedGroupId ? this.getShape(focusedGroupId) : void 0;
  }
  /**
   * Set the current focused group shape.
   *
   * @param shape - The group shape id (or group shape's id) to set as the focused group shape.
   *
   * @public
   */
  setFocusedGroup(shape) {
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    if (id !== null) {
      const shape2 = this.getShape(id);
      if (!shape2) {
        throw Error(`Editor.setFocusedGroup: Shape with id ${id} does not exist`);
      }
      if (!this.isShapeOfType(shape2, "group")) {
        throw Error(
          `Editor.setFocusedGroup: Cannot set focused group to shape of type ${shape2.type}`
        );
      }
    }
    if (id === this.getFocusedGroupId())
      return this;
    return this.run(
      () => {
        this.store.update(this.getCurrentPageState().id, (s) => ({ ...s, focusedGroupId: id }));
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Exit the current focused group, moving up to the next parent group if there is one.
   *
   * @public
   */
  popFocusedGroupId() {
    const focusedGroup = this.getFocusedGroup();
    if (focusedGroup) {
      const match = this.findShapeAncestor(
        focusedGroup,
        (shape) => this.isShapeOfType(shape, "group")
      );
      this.setFocusedGroup((match == null ? void 0 : match.id) ?? null);
      this.select(focusedGroup.id);
    } else {
      this.setFocusedGroup(null);
      this.selectNone();
    }
    return this;
  }
  getEditingShapeId() {
    return this.getCurrentPageState().editingShapeId;
  }
  getEditingShape() {
    const editingShapeId = this.getEditingShapeId();
    return editingShapeId ? this.getShape(editingShapeId) : void 0;
  }
  /**
   * Set the current editing shape.
   *
   * @example
   * ```ts
   * editor.setEditingShape(myShape)
   * editor.setEditingShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as editing.
   *
   * @public
   */
  setEditingShape(shape) {
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    this.setRichTextEditor(null);
    const prevEditingShapeId = this.getEditingShapeId();
    if (id !== prevEditingShapeId) {
      if (id) {
        const shape2 = this.getShape(id);
        if (shape2 && this.getShapeUtil(shape2).canEdit(shape2)) {
          this.run(
            () => {
              var _a5, _b, _c, _d;
              this._updateCurrentPageState({ editingShapeId: id });
              if (prevEditingShapeId) {
                const prevEditingShape = this.getShape(prevEditingShapeId);
                if (prevEditingShape) {
                  (_b = (_a5 = this.getShapeUtil(prevEditingShape)).onEditEnd) == null ? void 0 : _b.call(_a5, prevEditingShape);
                }
              }
              (_d = (_c = this.getShapeUtil(shape2)).onEditStart) == null ? void 0 : _d.call(_c, shape2);
            },
            { history: "ignore" }
          );
          return this;
        }
      }
      this.run(
        () => {
          var _a5, _b;
          this._updateCurrentPageState({ editingShapeId: null });
          this._currentRichTextEditor.set(null);
          if (prevEditingShapeId) {
            const prevEditingShape = this.getShape(prevEditingShapeId);
            if (prevEditingShape) {
              (_b = (_a5 = this.getShapeUtil(prevEditingShape)).onEditEnd) == null ? void 0 : _b.call(_a5, prevEditingShape);
            }
          }
        },
        { history: "ignore" }
      );
    }
    return this;
  }
  getRichTextEditor() {
    return this._currentRichTextEditor.get();
  }
  /**
   * Set the current editing shape's rich text editor.
   *
   * @example
   * ```ts
   * editor.setRichTextEditor(richTextEditorView)
   * ```
   *
   * @param textEditor - The text editor to set as the current editing shape's text editor.
   *
   * @public
   */
  setRichTextEditor(textEditor) {
    this._currentRichTextEditor.set(textEditor);
    return this;
  }
  getHoveredShapeId() {
    return this.getCurrentPageState().hoveredShapeId;
  }
  getHoveredShape() {
    const hoveredShapeId = this.getHoveredShapeId();
    return hoveredShapeId ? this.getShape(hoveredShapeId) : void 0;
  }
  /**
   * Set the editor's current hovered shape.
   *
   * @example
   * ```ts
   * editor.setHoveredShape(myShape)
   * editor.setHoveredShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as hovered.
   *
   * @public
   */
  setHoveredShape(shape) {
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    if (id === this.getHoveredShapeId())
      return this;
    this.run(
      () => {
        this.updateCurrentPageState({ hoveredShapeId: id });
      },
      { history: "ignore" }
    );
    return this;
  }
  getHintingShapeIds() {
    return this.getCurrentPageState().hintingShapeIds;
  }
  getHintingShape() {
    const hintingShapeIds = this.getHintingShapeIds();
    return compact(hintingShapeIds.map((id) => this.getShape(id)));
  }
  /**
   * Set the editor's current hinting shapes.
   *
   * @example
   * ```ts
   * editor.setHintingShapes([myShape])
   * editor.setHintingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setHintingShapes(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    this.run(
      () => {
        this._updateCurrentPageState({ hintingShapeIds: dedupe(ids) });
      },
      { history: "ignore" }
    );
    return this;
  }
  getErasingShapeIds() {
    return this.getCurrentPageState().erasingShapeIds;
  }
  getErasingShapes() {
    const erasingShapeIds = this.getErasingShapeIds();
    return compact(erasingShapeIds.map((id) => this.getShape(id)));
  }
  /**
   * Set the editor's current erasing shapes.
   *
   * @example
   * ```ts
   * editor.setErasingShapes([myShape])
   * editor.setErasingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setErasingShapes(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    ids.sort();
    const erasingShapeIds = this.getErasingShapeIds();
    this.run(
      () => {
        if (ids.length === erasingShapeIds.length) {
          for (let i = 0; i < ids.length; i++) {
            if (ids[i] !== erasingShapeIds[i]) {
              this._updateCurrentPageState({ erasingShapeIds: ids });
              break;
            }
          }
        } else {
          this._updateCurrentPageState({ erasingShapeIds: ids });
        }
      },
      { history: "ignore" }
    );
    return this;
  }
  // Cropping
  /**
   * The current cropping shape's id.
   *
   * @public
   */
  getCroppingShapeId() {
    return this.getCurrentPageState().croppingShapeId;
  }
  /**
   * Set the current cropping shape.
   *
   * @example
   * ```ts
   * editor.setCroppingShape(myShape)
   * editor.setCroppingShape(myShape.id)
   * ```
   *
   *
   * @param shape - The shape (or shape id) to set as cropping.
   *
   * @public
   */
  setCroppingShape(shape) {
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    if (id !== this.getCroppingShapeId()) {
      this.run(
        () => {
          if (!id) {
            this.updateCurrentPageState({ croppingShapeId: null });
          } else {
            const shape2 = this.getShape(id);
            const util = this.getShapeUtil(shape2);
            if (shape2 && util.canCrop(shape2)) {
              this.updateCurrentPageState({ croppingShapeId: id });
            }
          }
        },
        { history: "ignore" }
      );
    }
    return this;
  }
  /**
   * Get the current text options.
   *
   * @example
   * ```ts
   * editor.getTextOptions()
   * ```
   *
   *  @public */
  getTextOptions() {
    return assertExists(this._textOptions.get(), "Cannot use text without setting textOptions");
  }
  _unsafe_getCameraId() {
    return CameraRecordType.createId(this.getCurrentPageId());
  }
  getCamera() {
    const baseCamera = this.store.get(this._unsafe_getCameraId());
    if (this._isLockedOnFollowingUser.get()) {
      const followingCamera = this.getCameraForFollowing();
      if (followingCamera) {
        return { ...baseCamera, ...followingCamera };
      }
    }
    return baseCamera;
  }
  _getFollowingPresence(targetUserId) {
    const visited = [this.user.getId()];
    const collaborators = this.getCollaborators();
    let leaderPresence = null;
    while (targetUserId && !visited.includes(targetUserId)) {
      leaderPresence = collaborators.find((c) => c.userId === targetUserId) ?? null;
      targetUserId = (leaderPresence == null ? void 0 : leaderPresence.followingUserId) ?? null;
      if (leaderPresence) {
        visited.push(leaderPresence.userId);
      }
    }
    return leaderPresence;
  }
  getViewportPageBoundsForFollowing() {
    const leaderPresence = this._getFollowingPresence(this.getInstanceState().followingUserId);
    if (!(leaderPresence == null ? void 0 : leaderPresence.camera) || !(leaderPresence == null ? void 0 : leaderPresence.screenBounds))
      return null;
    const { w: lw, h: lh } = leaderPresence.screenBounds;
    const { x: lx, y: ly, z: lz2 } = leaderPresence.camera;
    const theirViewport = new Box(-lx, -ly, lw / lz2, lh / lz2);
    const ourViewport = this.getViewportScreenBounds().clone();
    const ourAspectRatio = ourViewport.width / ourViewport.height;
    ourViewport.width = theirViewport.width;
    ourViewport.height = ourViewport.width / ourAspectRatio;
    if (ourViewport.height < theirViewport.height) {
      ourViewport.height = theirViewport.height;
      ourViewport.width = ourViewport.height * ourAspectRatio;
    }
    ourViewport.center = theirViewport.center;
    return ourViewport;
  }
  getCameraForFollowing() {
    const viewport2 = this.getViewportPageBoundsForFollowing();
    if (!viewport2)
      return null;
    return {
      x: -viewport2.x,
      y: -viewport2.y,
      z: this.getViewportScreenBounds().w / viewport2.width
    };
  }
  getZoomLevel() {
    return this.getCamera().z;
  }
  /**
   * Get the camera's initial or reset zoom level.
   *
   * @example
   * ```ts
   * editor.getInitialZoom()
   * ```
   *
   * @public */
  getInitialZoom() {
    const cameraOptions = this.getCameraOptions();
    if (!cameraOptions.constraints)
      return 1;
    if (cameraOptions.constraints.initialZoom === "default")
      return 1;
    const { zx, zy } = getCameraFitXFitY(this, cameraOptions);
    switch (cameraOptions.constraints.initialZoom) {
      case "fit-min": {
        return Math.max(zx, zy);
      }
      case "fit-max": {
        return Math.min(zx, zy);
      }
      case "fit-x": {
        return zx;
      }
      case "fit-y": {
        return zy;
      }
      case "fit-min-100": {
        return Math.min(1, Math.max(zx, zy));
      }
      case "fit-max-100": {
        return Math.min(1, Math.min(zx, zy));
      }
      case "fit-x-100": {
        return Math.min(1, zx);
      }
      case "fit-y-100": {
        return Math.min(1, zy);
      }
      default: {
        throw exhaustiveSwitchError(cameraOptions.constraints.initialZoom);
      }
    }
  }
  /**
   * Get the camera's base level for calculating actual zoom levels based on the zoom steps.
   *
   * @example
   * ```ts
   * editor.getBaseZoom()
   * ```
   *
   * @public */
  getBaseZoom() {
    const cameraOptions = this.getCameraOptions();
    if (!cameraOptions.constraints)
      return 1;
    if (cameraOptions.constraints.baseZoom === "default")
      return 1;
    const { zx, zy } = getCameraFitXFitY(this, cameraOptions);
    switch (cameraOptions.constraints.baseZoom) {
      case "fit-min": {
        return Math.max(zx, zy);
      }
      case "fit-max": {
        return Math.min(zx, zy);
      }
      case "fit-x": {
        return zx;
      }
      case "fit-y": {
        return zy;
      }
      case "fit-min-100": {
        return Math.min(1, Math.max(zx, zy));
      }
      case "fit-max-100": {
        return Math.min(1, Math.min(zx, zy));
      }
      case "fit-x-100": {
        return Math.min(1, zx);
      }
      case "fit-y-100": {
        return Math.min(1, zy);
      }
      default: {
        throw exhaustiveSwitchError(cameraOptions.constraints.baseZoom);
      }
    }
  }
  /**
   * Get the current camera options.
   *
   * @example
   * ```ts
   * editor.getCameraOptions()
   * ```
   *
   *  @public */
  getCameraOptions() {
    return this._cameraOptions.get();
  }
  /**
   * Set the camera options. Changing the options won't immediately change the camera itself, so you may want to call `setCamera` after changing the options.
   *
   * @example
   * ```ts
   * editor.setCameraOptions(myCameraOptions)
   * editor.setCamera(editor.getCamera())
   * ```
   *
   * @param opts - The camera options to set.
   *
   * @public */
  setCameraOptions(opts) {
    var _a5;
    const next = structuredClone({
      ...this._cameraOptions.__unsafe__getWithoutCapture(),
      ...opts
    });
    if (((_a5 = next.zoomSteps) == null ? void 0 : _a5.length) < 1)
      next.zoomSteps = [1];
    this._cameraOptions.set(next);
    this.setCamera(this.getCamera());
    return this;
  }
  /** @internal */
  getConstrainedCamera(point, opts) {
    const currentCamera = this.getCamera();
    let { x, y, z = currentCamera.z } = point;
    if (!(opts == null ? void 0 : opts.force)) {
      const cameraOptions = this.getCameraOptions();
      const zoomMin = cameraOptions.zoomSteps[0];
      const zoomMax = last(cameraOptions.zoomSteps);
      const vsb = this.getViewportScreenBounds();
      if (cameraOptions.constraints) {
        const { constraints } = cameraOptions;
        const py = Math.min(constraints.padding.y, vsb.w / 2);
        const px = Math.min(constraints.padding.x, vsb.h / 2);
        const bounds = Box.From(cameraOptions.constraints.bounds);
        const zx = (vsb.w - px * 2) / bounds.w;
        const zy = (vsb.h - py * 2) / bounds.h;
        const baseZoom = this.getBaseZoom();
        const maxZ = zoomMax * baseZoom;
        const minZ = zoomMin * baseZoom;
        if (opts == null ? void 0 : opts.reset) {
          z = this.getInitialZoom();
        }
        if (z < minZ || z > maxZ) {
          const { x: cx, y: cy, z: cz } = currentCamera;
          const cxA = -cx + vsb.w / cz / 2;
          const cyA = -cy + vsb.h / cz / 2;
          z = clamp(z, minZ, maxZ);
          const cxB = -cx + vsb.w / z / 2;
          const cyB = -cy + vsb.h / z / 2;
          x = cx + cxB - cxA;
          y = cy + cyB - cyA;
        }
        const minX = px / z - bounds.x;
        const minY = py / z - bounds.y;
        const freeW = (vsb.w - px * 2) / z - bounds.w;
        const freeH = (vsb.h - py * 2) / z - bounds.h;
        const originX = minX + freeW * constraints.origin.x;
        const originY = minY + freeH * constraints.origin.y;
        const behaviorX = typeof constraints.behavior === "string" ? constraints.behavior : constraints.behavior.x;
        const behaviorY = typeof constraints.behavior === "string" ? constraints.behavior : constraints.behavior.y;
        if (opts == null ? void 0 : opts.reset) {
          x = originX;
          y = originY;
        } else {
          switch (behaviorX) {
            case "fixed": {
              x = originX;
              break;
            }
            case "contain": {
              if (z < zx)
                x = originX;
              else
                x = clamp(x, minX + freeW, minX);
              break;
            }
            case "inside": {
              if (z < zx)
                x = clamp(x, minX, (vsb.w - px) / z - bounds.w);
              else
                x = clamp(x, minX + freeW, minX);
              break;
            }
            case "outside": {
              x = clamp(x, px / z - bounds.w, (vsb.w - px) / z);
              break;
            }
            case "free": {
              break;
            }
            default: {
              throw exhaustiveSwitchError(behaviorX);
            }
          }
          switch (behaviorY) {
            case "fixed": {
              y = originY;
              break;
            }
            case "contain": {
              if (z < zy)
                y = originY;
              else
                y = clamp(y, minY + freeH, minY);
              break;
            }
            case "inside": {
              if (z < zy)
                y = clamp(y, minY, (vsb.h - py) / z - bounds.h);
              else
                y = clamp(y, minY + freeH, minY);
              break;
            }
            case "outside": {
              y = clamp(y, py / z - bounds.h, (vsb.h - py) / z);
              break;
            }
            case "free": {
              break;
            }
            default: {
              throw exhaustiveSwitchError(behaviorY);
            }
          }
        }
      } else {
        if (z > zoomMax || z < zoomMin) {
          const { x: cx, y: cy, z: cz } = currentCamera;
          z = clamp(z, zoomMin, zoomMax);
          x = cx + (-cx + vsb.w / z / 2) - (-cx + vsb.w / cz / 2);
          y = cy + (-cy + vsb.h / z / 2) - (-cy + vsb.h / cz / 2);
        }
      }
    }
    return { x, y, z };
  }
  /** @internal */
  _setCamera(point, opts) {
    const currentCamera = this.getCamera();
    const { x, y, z } = this.getConstrainedCamera(point, opts);
    if (currentCamera.x === x && currentCamera.y === y && currentCamera.z === z) {
      return this;
    }
    transact(() => {
      const camera = { ...currentCamera, x, y, z };
      this.run(
        () => {
          this.store.put([camera]);
        },
        { history: "ignore" }
      );
      const { currentScreenPoint, currentPagePoint } = this.inputs;
      const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
      if (currentScreenPoint.x / z - x !== currentPagePoint.x || currentScreenPoint.y / z - y !== currentPagePoint.y) {
        const event = {
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          // weird but true: we need to put the screen point back into client space
          point: Vec.AddXY(currentScreenPoint, screenBounds.x, screenBounds.y),
          pointerId: INTERNAL_POINTER_IDS.CAMERA_MOVE,
          ctrlKey: this.inputs.ctrlKey,
          altKey: this.inputs.altKey,
          shiftKey: this.inputs.shiftKey,
          metaKey: this.inputs.metaKey,
          accelKey: isAccelKey(this.inputs),
          button: 0,
          isPen: this.getInstanceState().isPenMode ?? false
        };
        if (opts == null ? void 0 : opts.immediate) {
          this._flushEventForTick(event);
        } else {
          this.dispatch(event);
        }
      }
      this._tickCameraState();
    });
    return this;
  }
  /**
   * Set the current camera.
   *
   * @example
   * ```ts
   * editor.setCamera({ x: 0, y: 0})
   * editor.setCamera({ x: 0, y: 0, z: 1.5})
   * editor.setCamera({ x: 0, y: 0, z: 1.5}, { animation: { duration: 1000, easing: (t) => t * t } })
   * ```
   *
   * @param point - The new camera position.
   * @param opts - The camera move options.
   *
   * @public
   */
  setCamera(point, opts) {
    const { isLocked } = this._cameraOptions.__unsafe__getWithoutCapture();
    if (isLocked && !(opts == null ? void 0 : opts.force))
      return this;
    this.stopCameraAnimation();
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    const _point = Vec.Cast(point);
    if (!Number.isFinite(_point.x))
      _point.x = 0;
    if (!Number.isFinite(_point.y))
      _point.y = 0;
    if (_point.z === void 0 || !Number.isFinite(_point.z))
      point.z = this.getZoomLevel();
    const camera = this.getConstrainedCamera(_point, opts);
    if (opts == null ? void 0 : opts.animation) {
      const { width, height } = this.getViewportScreenBounds();
      this._animateToViewport(
        new Box(-camera.x, -camera.y, width / camera.z, height / camera.z),
        opts
      );
    } else {
      this._setCamera(camera, {
        ...opts,
        // we already did the constraining, so we don't need to do it again
        force: true
      });
    }
    return this;
  }
  /**
   * Center the camera on a point (in the current page space).
   *
   * @example
   * ```ts
   * editor.centerOnPoint({ x: 100, y: 100 })
   * editor.centerOnPoint({ x: 100, y: 100 }, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The point in the current page space to center on.
   * @param opts - The camera move options.
   *
   * @public
   */
  centerOnPoint(point, opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force))
      return this;
    const { width: pw, height: ph } = this.getViewportPageBounds();
    this.setCamera(new Vec(-(point.x - pw / 2), -(point.y - ph / 2), this.getCamera().z), opts);
    return this;
  }
  /**
   * Zoom the camera to fit the current page's content in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToFit()
   * editor.zoomToFit({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToFit(opts) {
    const ids = [...this.getCurrentPageShapeIds()];
    if (ids.length <= 0)
      return this;
    const pageBounds = Box.Common(compact(ids.map((id) => this.getShapePageBounds(id))));
    this.zoomToBounds(pageBounds, opts);
    return this;
  }
  /**
   * Set the zoom back to 100%.
   *
   * @example
   * ```ts
   * editor.resetZoom()
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  resetZoom(point = this.getViewportScreenCenter(), opts) {
    const { isLocked, constraints } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force))
      return this;
    const currentCamera = this.getCamera();
    const { x: cx, y: cy, z: cz } = currentCamera;
    const { x, y } = point;
    let z = 1;
    if (constraints) {
      const initialZoom = this.getInitialZoom();
      if (cz !== initialZoom) {
        z = initialZoom;
      }
    }
    this.setCamera(
      new Vec(cx + (x / z - x) - (x / cz - x), cy + (y / z - y) - (y / cz - y), z),
      opts
    );
    return this;
  }
  /**
   * Zoom the camera in.
   *
   * @example
   * ```ts
   * editor.zoomIn()
   * editor.zoomIn(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.zoomIn(editor.inputs.currentScreenPoint, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom in on. Defaults to the screen center
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomIn(point = this.getViewportScreenCenter(), opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force))
      return this;
    const { x: cx, y: cy, z: cz } = this.getCamera();
    const { zoomSteps } = this.getCameraOptions();
    if (zoomSteps !== null && zoomSteps.length > 1) {
      const baseZoom = this.getBaseZoom();
      let zoom = last(zoomSteps) * baseZoom;
      for (let i = 1; i < zoomSteps.length; i++) {
        const z1 = zoomSteps[i - 1] * baseZoom;
        const z2 = zoomSteps[i] * baseZoom;
        if (z2 - cz <= (z2 - z1) / 2)
          continue;
        zoom = z2;
        break;
      }
      this.setCamera(
        new Vec(
          cx + (point.x / zoom - point.x) - (point.x / cz - point.x),
          cy + (point.y / zoom - point.y) - (point.y / cz - point.y),
          zoom
        ),
        opts
      );
    }
    return this;
  }
  /**
   * Zoom the camera out.
   *
   * @example
   * ```ts
   * editor.zoomOut()
   * editor.zoomOut(editor.getViewportScreenCenter(), { animation: { duration: 120 } })
   * editor.zoomOut(editor.inputs.currentScreenPoint, { animation: { duration: 120 } })
   * ```
   *
   * @param point - The point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomOut(point = this.getViewportScreenCenter(), opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force))
      return this;
    const { zoomSteps } = this.getCameraOptions();
    if (zoomSteps !== null && zoomSteps.length > 1) {
      const baseZoom = this.getBaseZoom();
      const { x: cx, y: cy, z: cz } = this.getCamera();
      let zoom = zoomSteps[0] * baseZoom;
      for (let i = zoomSteps.length - 1; i > 0; i--) {
        const z1 = zoomSteps[i - 1] * baseZoom;
        const z2 = zoomSteps[i] * baseZoom;
        if (z2 - cz >= (z2 - z1) / 2)
          continue;
        zoom = z1;
        break;
      }
      this.setCamera(
        new Vec(
          cx + (point.x / zoom - point.x) - (point.x / cz - point.x),
          cy + (point.y / zoom - point.y) - (point.y / cz - point.y),
          zoom
        ),
        opts
      );
    }
    return this;
  }
  /**
   * Zoom the camera to fit the current selection in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToSelection()
   * editor.zoomToSelection({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToSelection(opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force))
      return this;
    const selectionPageBounds = this.getSelectionPageBounds();
    if (selectionPageBounds) {
      this.zoomToBounds(selectionPageBounds, {
        targetZoom: Math.max(1, this.getZoomLevel()),
        ...opts
      });
    }
    return this;
  }
  /**
   * Zoom the camera to the current selection if offscreen.
   *
   * @public
   */
  zoomToSelectionIfOffscreen(padding = 16, opts) {
    const selectionPageBounds = this.getSelectionPageBounds();
    const viewportPageBounds = this.getViewportPageBounds();
    if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
      const eb = selectionPageBounds.clone().expandBy(padding / this.getZoomLevel()).expand(viewportPageBounds);
      const nextBounds = viewportPageBounds.clone().translate({
        x: (eb.center.x - viewportPageBounds.center.x) * 2,
        y: (eb.center.y - viewportPageBounds.center.y) * 2
      });
      this.zoomToBounds(nextBounds, opts);
    }
  }
  /**
   * Zoom the camera to fit a bounding box (in the current page space).
   *
   * @example
   * ```ts
   * editor.zoomToBounds(myBounds)
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 } })
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 }, inset: 0, targetZoom: 1 })
   * ```
   *
   * @param bounds - The bounding box.
   * @param opts - The camera move options, target zoom, or custom inset amount.
   *
   * @public
   */
  zoomToBounds(bounds, opts) {
    const cameraOptions = this._cameraOptions.__unsafe__getWithoutCapture();
    if (cameraOptions.isLocked && !(opts == null ? void 0 : opts.force))
      return this;
    const viewportScreenBounds = this.getViewportScreenBounds();
    const inset = (opts == null ? void 0 : opts.inset) ?? Math.min(ZOOM_TO_FIT_PADDING, viewportScreenBounds.width * 0.28);
    const baseZoom = this.getBaseZoom();
    const zoomMin = cameraOptions.zoomSteps[0];
    const zoomMax = last(cameraOptions.zoomSteps);
    let zoom = clamp(
      Math.min(
        (viewportScreenBounds.width - inset) / bounds.w,
        (viewportScreenBounds.height - inset) / bounds.h
      ),
      zoomMin * baseZoom,
      zoomMax * baseZoom
    );
    if ((opts == null ? void 0 : opts.targetZoom) !== void 0) {
      zoom = Math.min(opts.targetZoom, zoom);
    }
    this.setCamera(
      new Vec(
        -bounds.x + (viewportScreenBounds.width - bounds.w * zoom) / 2 / zoom,
        -bounds.y + (viewportScreenBounds.height - bounds.h * zoom) / 2 / zoom,
        zoom
      ),
      opts
    );
    return this;
  }
  /**
   * Stop the current camera animation, if any.
   *
   * @example
   * ```ts
   * editor.stopCameraAnimation()
   * ```
   *
   * @public
   */
  stopCameraAnimation() {
    this.emit("stop-camera-animation");
    return this;
  }
  /** @internal */
  _animateViewport(ms) {
    if (!this._viewportAnimation)
      return;
    this._viewportAnimation.elapsed += ms;
    const { elapsed, easing, duration, start: start2, end: end2 } = this._viewportAnimation;
    if (elapsed > duration) {
      this.off("tick", this._animateViewport);
      this._viewportAnimation = null;
      this._setCamera(new Vec(-end2.x, -end2.y, this.getViewportScreenBounds().width / end2.width));
      return;
    }
    const remaining = duration - elapsed;
    const t2 = easing(1 - remaining / duration);
    const left2 = start2.minX + (end2.minX - start2.minX) * t2;
    const top2 = start2.minY + (end2.minY - start2.minY) * t2;
    const right2 = start2.maxX + (end2.maxX - start2.maxX) * t2;
    this._setCamera(new Vec(-left2, -top2, this.getViewportScreenBounds().width / (right2 - left2)), {
      force: true
    });
  }
  /** @internal */
  _animateToViewport(targetViewportPage, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    const { animation, ...rest } = opts;
    if (!animation)
      return;
    const { duration = 0, easing = EASINGS.easeInOutCubic } = animation;
    const animationSpeed = this.user.getAnimationSpeed();
    const viewportPageBounds = this.getViewportPageBounds();
    this.stopCameraAnimation();
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    if (duration === 0 || animationSpeed === 0) {
      return this._setCamera(
        new Vec(
          -targetViewportPage.x,
          -targetViewportPage.y,
          this.getViewportScreenBounds().width / targetViewportPage.width
        ),
        { ...rest }
      );
    }
    this._viewportAnimation = {
      elapsed: 0,
      duration: duration / animationSpeed,
      easing,
      start: viewportPageBounds.clone(),
      end: targetViewportPage.clone()
    };
    this.once("stop-camera-animation", () => {
      this.off("tick", this._animateViewport);
      this._viewportAnimation = null;
    });
    this.on("tick", this._animateViewport);
    return this;
  }
  /**
   * Slide the camera in a certain direction.
   *
   * @example
   * ```ts
   * editor.slideCamera({ speed: 1, direction: { x: 1, y: 0 }, friction: 0.1 })
   * ```
   *
   * @param opts - Options for the slide
   * @public
   */
  slideCamera(opts = {}) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force))
      return this;
    const animationSpeed = this.user.getAnimationSpeed();
    if (animationSpeed === 0)
      return this;
    this.stopCameraAnimation();
    const {
      speed,
      friction = this.options.cameraSlideFriction,
      direction,
      speedThreshold = 0.01
    } = opts;
    let currentSpeed = Math.min(speed, 1);
    const cancel = () => {
      this.off("tick", moveCamera);
      this.off("stop-camera-animation", cancel);
    };
    this.once("stop-camera-animation", cancel);
    const moveCamera = (elapsed) => {
      const { x: cx, y: cy, z: cz } = this.getCamera();
      const movementVec = Vec.Mul(direction, currentSpeed * elapsed / cz);
      currentSpeed *= 1 - friction;
      if (currentSpeed < speedThreshold) {
        cancel();
      } else {
        this._setCamera(new Vec(cx + movementVec.x, cy + movementVec.y, cz));
      }
    };
    this.on("tick", moveCamera);
    return this;
  }
  /**
   * Animate the camera to a user's cursor position. This also briefly show the user's cursor if it's not currently visible.
   *
   * @example
   * ```ts
   * editor.zoomToUser(myUserId)
   * editor.zoomToUser(myUserId, { animation: { duration: 200 } })
   * ```
   *
   * @param userId - The id of the user to animate to.
   * @param opts - The camera move options.
   * @public
   */
  zoomToUser(userId, opts = { animation: { duration: 500 } }) {
    const presence = this.getCollaborators().find((c) => c.userId === userId);
    if (!presence)
      return this;
    const cursor = presence.cursor;
    if (!cursor)
      return this;
    this.run(() => {
      if (this.getInstanceState().followingUserId !== null) {
        this.stopFollowingUser();
      }
      const isOnSamePage = presence.currentPageId === this.getCurrentPageId();
      if (!isOnSamePage) {
        this.setCurrentPage(presence.currentPageId);
      }
      if (opts && opts.animation && !isOnSamePage) {
        opts.animation = void 0;
      }
      this.centerOnPoint(cursor, opts);
      const { highlightedUserIds } = this.getInstanceState();
      this.updateInstanceState({ highlightedUserIds: [...highlightedUserIds, userId] });
      this.timers.setTimeout(() => {
        const highlightedUserIds2 = [...this.getInstanceState().highlightedUserIds];
        const index3 = highlightedUserIds2.indexOf(userId);
        if (index3 < 0)
          return;
        highlightedUserIds2.splice(index3, 1);
        this.updateInstanceState({ highlightedUserIds: highlightedUserIds2 });
      }, this.options.collaboratorIdleTimeoutMs);
    });
    return this;
  }
  /**
   * Update the viewport. The viewport will measure the size and screen position of its container
   * element. This should be done whenever the container's position on the screen changes.
   *
   * @example
   * ```ts
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024))
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024), true)
   * ```
   *
   * @param screenBounds - The new screen bounds of the viewport.
   * @param center - Whether to preserve the viewport page center as the viewport changes.
   *
   * @public
   */
  updateViewportScreenBounds(screenBounds, center = false) {
    if (screenBounds instanceof HTMLElement) {
      const rect = screenBounds.getBoundingClientRect();
      screenBounds = new Box(
        rect.left || rect.x,
        rect.top || rect.y,
        Math.max(rect.width, 1),
        Math.max(rect.height, 1)
      );
    } else {
      screenBounds.width = Math.max(screenBounds.width, 1);
      screenBounds.height = Math.max(screenBounds.height, 1);
    }
    const insets = [
      // top
      screenBounds.minY !== 0,
      // right
      !approximately(document.body.scrollWidth, screenBounds.maxX, 1),
      // bottom
      !approximately(document.body.scrollHeight, screenBounds.maxY, 1),
      // left
      screenBounds.minX !== 0
    ];
    const { _willSetInitialBounds } = this;
    this._willSetInitialBounds = false;
    const { screenBounds: prevScreenBounds, insets: prevInsets } = this.getInstanceState();
    if (screenBounds.equals(prevScreenBounds) && insets.every((v, i) => v === prevInsets[i])) {
      return this;
    }
    if (_willSetInitialBounds) {
      this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
      this.setCamera(this.getCamera());
    } else {
      if (center && !this.getInstanceState().followingUserId) {
        const before = this.getViewportPageBounds().center;
        this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
        this.centerOnPoint(before);
      } else {
        this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
        this._setCamera(Vec.From({ ...this.getCamera() }));
      }
    }
    this._tickCameraState();
    return this;
  }
  getViewportScreenBounds() {
    const { x, y, w, h } = this.getInstanceState().screenBounds;
    return new Box(x, y, w, h);
  }
  getViewportScreenCenter() {
    const viewportScreenBounds = this.getViewportScreenBounds();
    return new Vec(
      viewportScreenBounds.midX - viewportScreenBounds.minX,
      viewportScreenBounds.midY - viewportScreenBounds.minY
    );
  }
  getViewportPageBounds() {
    const { w, h } = this.getViewportScreenBounds();
    const { x: cx, y: cy, z: cz } = this.getCamera();
    return new Box(-cx, -cy, w / cz, h / cz);
  }
  /**
   * Convert a point in screen space to a point in the current page space.
   *
   * @example
   * ```ts
   * editor.screenToPage({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in screen space.
   *
   * @public
   */
  screenToPage(point) {
    const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec(
      (point.x - screenBounds.x) / cz - cx,
      (point.y - screenBounds.y) / cz - cy,
      point.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current screen space.
   *
   * @example
   * ```ts
   * editor.pageToScreen({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToScreen(point) {
    const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec(
      (point.x + cx) * cz + screenBounds.x,
      (point.y + cy) * cz + screenBounds.y,
      point.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current viewport space.
   *
   * @example
   * ```ts
   * editor.pageToViewport({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToViewport(point) {
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec((point.x + cx) * cz, (point.y + cy) * cz, point.z ?? 0.5);
  }
  _getCollaboratorsQuery() {
    return this.store.query.records("instance_presence", () => ({
      userId: { neq: this.user.getId() }
    }));
  }
  getCollaborators() {
    const allPresenceRecords = this._getCollaboratorsQuery().get();
    if (!allPresenceRecords.length)
      return EMPTY_ARRAY;
    const userIds = [...new Set(allPresenceRecords.map((c) => c.userId))].sort();
    return userIds.map((id) => {
      const latestPresence = maxBy(
        allPresenceRecords.filter((c) => c.userId === id),
        (p) => p.lastActivityTimestamp ?? 0
      );
      return latestPresence;
    });
  }
  getCollaboratorsOnCurrentPage() {
    const currentPageId = this.getCurrentPageId();
    return this.getCollaborators().filter((c) => c.currentPageId === currentPageId);
  }
  /**
   * Start viewport-following a user.
   *
   * @example
   * ```ts
   * editor.startFollowingUser(myUserId)
   * ```
   *
   * @param userId - The id of the user to follow.
   *
   * @public
   */
  startFollowingUser(userId) {
    this.stopFollowingUser();
    const thisUserId = this.user.getId();
    if (!thisUserId) {
      console.warn("You should set the userId for the current instance before following a user");
    }
    const leaderPresence = this._getFollowingPresence(userId);
    if (!leaderPresence) {
      return this;
    }
    const latestLeaderPresence = computed("latestLeaderPresence", () => {
      return this._getFollowingPresence(userId);
    });
    transact(() => {
      this.updateInstanceState({ followingUserId: userId }, { history: "ignore" });
      const dispose = react("update current page", () => {
        const leaderPresence2 = latestLeaderPresence.get();
        if (!leaderPresence2) {
          this.stopFollowingUser();
          return;
        }
        if (leaderPresence2.currentPageId !== this.getCurrentPageId() && this.getPage(leaderPresence2.currentPageId)) {
          this.run(
            () => {
              this.store.put([
                { ...this.getInstanceState(), currentPageId: leaderPresence2.currentPageId }
              ]);
              this._isLockedOnFollowingUser.set(true);
            },
            { history: "ignore" }
          );
        }
      });
      const cancel = () => {
        dispose();
        this._isLockedOnFollowingUser.set(false);
        this.off("frame", moveTowardsUser);
        this.off("stop-following", cancel);
      };
      const moveTowardsUser = () => {
        const leaderPresence2 = latestLeaderPresence.get();
        if (!leaderPresence2) {
          this.stopFollowingUser();
          return;
        }
        if (this._isLockedOnFollowingUser.get())
          return;
        const animationSpeed = this.user.getAnimationSpeed();
        if (animationSpeed === 0) {
          this._isLockedOnFollowingUser.set(true);
          return;
        }
        const targetViewport = this.getViewportPageBoundsForFollowing();
        if (!targetViewport) {
          this.stopFollowingUser();
          return;
        }
        const currentViewport = this.getViewportPageBounds();
        const diffX = Math.abs(targetViewport.minX - currentViewport.minX) + Math.abs(targetViewport.maxX - currentViewport.maxX);
        const diffY = Math.abs(targetViewport.minY - currentViewport.minY) + Math.abs(targetViewport.maxY - currentViewport.maxY);
        if (diffX < this.options.followChaseViewportSnap && diffY < this.options.followChaseViewportSnap) {
          this._isLockedOnFollowingUser.set(true);
          return;
        }
        const t2 = clamp(animationSpeed * 0.5, 0.1, 0.8);
        const nextViewport = new Box(
          lerp(currentViewport.minX, targetViewport.minX, t2),
          lerp(currentViewport.minY, targetViewport.minY, t2),
          lerp(currentViewport.width, targetViewport.width, t2),
          lerp(currentViewport.height, targetViewport.height, t2)
        );
        const nextCamera = new Vec(
          -nextViewport.x,
          -nextViewport.y,
          this.getViewportScreenBounds().width / nextViewport.width
        );
        this.stopCameraAnimation();
        this._setCamera(nextCamera);
      };
      this.once("stop-following", cancel);
      this.addListener("frame", moveTowardsUser);
      moveTowardsUser();
    });
    return this;
  }
  /**
   * Stop viewport-following a user.
   *
   * @example
   * ```ts
   * editor.stopFollowingUser()
   * ```
   * @public
   */
  stopFollowingUser() {
    this.run(
      () => {
        this.store.put([this.getCamera()]);
        this._isLockedOnFollowingUser.set(false);
        this.updateInstanceState({ followingUserId: null });
        this.emit("stop-following");
      },
      { history: "ignore" }
    );
    return this;
  }
  /** @internal */
  getUnorderedRenderingShapes(useEditorState) {
    const renderingShapes = [];
    let nextIndex = this.options.maxShapesPerPage * 2;
    let nextBackgroundIndex = this.options.maxShapesPerPage;
    const erasingShapeIds = this.getErasingShapeIds();
    const addShapeById = (id, opacity, isAncestorErasing) => {
      const shape = this.getShape(id);
      if (!shape)
        return;
      if (this.isShapeHidden(shape)) {
        const isErasing = isAncestorErasing || erasingShapeIds.includes(id);
        for (const childId of this.getSortedChildIdsForParent(id)) {
          addShapeById(childId, opacity, isErasing);
        }
        return;
      }
      opacity *= shape.opacity;
      let isShapeErasing = false;
      const util = this.getShapeUtil(shape);
      if (useEditorState) {
        isShapeErasing = !isAncestorErasing && erasingShapeIds.includes(id);
        if (isShapeErasing) {
          opacity *= 0.32;
        }
      }
      renderingShapes.push({
        id,
        shape,
        util,
        index: nextIndex,
        backgroundIndex: nextBackgroundIndex,
        opacity
      });
      nextIndex += 1;
      nextBackgroundIndex += 1;
      const childIds = this.getSortedChildIdsForParent(id);
      if (!childIds.length)
        return;
      let backgroundIndexToRestore = null;
      if (util.providesBackgroundForChildren(shape)) {
        backgroundIndexToRestore = nextBackgroundIndex;
        nextBackgroundIndex = nextIndex;
        nextIndex += this.options.maxShapesPerPage;
      }
      for (const childId of childIds) {
        addShapeById(childId, opacity, isAncestorErasing || isShapeErasing);
      }
      if (backgroundIndexToRestore !== null) {
        nextBackgroundIndex = backgroundIndexToRestore;
      }
    };
    const pages = useEditorState ? [this.getCurrentPage()] : this.getPages();
    for (const page of pages) {
      for (const childId of this.getSortedChildIdsForParent(page.id)) {
        addShapeById(childId, 1, false);
      }
    }
    return renderingShapes;
  }
  _decayCameraStateTimeout(elapsed) {
    this._cameraStateTimeoutRemaining -= elapsed;
    if (this._cameraStateTimeoutRemaining > 0)
      return;
    this.off("tick", this._decayCameraStateTimeout);
    this._cameraState.set("idle");
  }
  _tickCameraState() {
    this._cameraStateTimeoutRemaining = this.options.cameraMovingTimeoutMs;
    if (this._cameraState.__unsafe__getWithoutCapture() !== "idle")
      return;
    this._cameraState.set("moving");
    this.on("tick", this._decayCameraStateTimeout);
  }
  /**
   * Whether the camera is moving or idle.
   *
   * @example
   * ```ts
   * editor.getCameraState()
   * ```
   *
   * @public
   */
  getCameraState() {
    return this._cameraState.get();
  }
  getRenderingShapes() {
    const renderingShapes = this.getUnorderedRenderingShapes(true);
    return renderingShapes.sort(sortById);
  }
  _getAllPagesQuery() {
    return this.store.query.records("page");
  }
  getPages() {
    return Array.from(this._getAllPagesQuery().get()).sort(sortByIndex);
  }
  /**
   * The current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPage()
   * ```
   *
   * @public
   */
  getCurrentPage() {
    return this.getPage(this.getCurrentPageId());
  }
  getCurrentPageId() {
    return this.getInstanceState().currentPageId;
  }
  /**
   * Get a page.
   *
   * @example
   * ```ts
   * editor.getPage(myPage.id)
   * editor.getPage(myPage)
   * ```
   *
   * @param page - The page (or the page id) to get.
   *
   * @public
   */
  getPage(page) {
    return this.store.get(typeof page === "string" ? page : page.id);
  }
  /**
   * An array of all of the shapes on the current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPageIds()
   * ```
   *
   * @public
   */
  getCurrentPageShapeIds() {
    return this._currentPageShapeIds.get();
  }
  getCurrentPageShapeIdsSorted() {
    return Array.from(this.getCurrentPageShapeIds()).sort();
  }
  /**
   * Get the ids of shapes on a page.
   *
   * @example
   * ```ts
   * const idsOnPage1 = editor.getPageShapeIds('page1')
   * const idsOnPage2 = editor.getPageShapeIds(myPage2)
   * ```
   *
   * @param page - The page (or the page id) to get the shape ids for.
   *
   * @public
   **/
  getPageShapeIds(page) {
    const pageId = typeof page === "string" ? page : page.id;
    const result = this.store.query.exec("shape", { parentId: { eq: pageId } });
    return this.getShapeAndDescendantIds(result.map((s) => s.id));
  }
  /**
   * Set the current page.
   *
   * @example
   * ```ts
   * editor.setCurrentPage('page1')
   * editor.setCurrentPage(myPage1)
   * ```
   *
   * @param page - The page (or the page id) to set as the current page.
   *
   * @public
   */
  setCurrentPage(page) {
    const pageId = typeof page === "string" ? page : page.id;
    if (!this.store.has(pageId)) {
      console.error("Tried to set the current page id to a page that doesn't exist.");
      return this;
    }
    this.stopFollowingUser();
    this.complete();
    return this.run(
      () => {
        this.store.put([{ ...this.getInstanceState(), currentPageId: pageId }]);
        this.setCamera(this.getCamera());
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Update a page.
   *
   * @example
   * ```ts
   * editor.updatePage({ id: 'page2', name: 'Page 2' })
   * ```
   *
   * @param partial - The partial of the shape to update.
   *
   * @public
   */
  updatePage(partial) {
    if (this.getIsReadonly())
      return this;
    const prev = this.getPage(partial.id);
    if (!prev)
      return this;
    return this.run(() => this.store.update(partial.id, (page) => ({ ...page, ...partial })));
  }
  /**
   * Create a page whilst ensuring that the page name is unique.
   *
   * @example
   * ```ts
   * editor.createPage(myPage)
   * editor.createPage({ name: 'Page 2' })
   * ```
   *
   * @param page - The page (or page partial) to create.
   *
   * @public
   */
  createPage(page) {
    this.run(() => {
      if (this.getIsReadonly())
        return;
      if (this.getPages().length >= this.options.maxPages)
        return;
      const pages = this.getPages();
      const name = getIncrementedName(
        page.name ?? "Page 1",
        pages.map((p) => p.name)
      );
      let index3 = page.index;
      if (!index3 || pages.some((p) => p.index === index3)) {
        index3 = getIndexAbove(pages[pages.length - 1].index);
      }
      const newPage = PageRecordType.create({
        meta: {},
        ...page,
        name,
        index: index3
      });
      this.store.put([newPage]);
    });
    return this;
  }
  /**
   * Delete a page.
   *
   * @example
   * ```ts
   * editor.deletePage('page1')
   * ```
   *
   * @param page - The page (or the page id) to delete.
   *
   * @public
   */
  deletePage(page) {
    const id = typeof page === "string" ? page : page.id;
    this.run(() => {
      if (this.getIsReadonly())
        return;
      const pages = this.getPages();
      if (pages.length === 1)
        return;
      const deletedPage = this.getPage(id);
      if (!deletedPage)
        return;
      if (id === this.getCurrentPageId()) {
        const index3 = pages.findIndex((page2) => page2.id === id);
        const next = pages[index3 - 1] ?? pages[index3 + 1];
        this.setCurrentPage(next.id);
      }
      this.store.remove([deletedPage.id]);
    });
    return this;
  }
  /**
   * Duplicate a page.
   *
   * @param page - The page (or the page id) to duplicate. Defaults to the current page.
   * @param createId - The id of the new page. Defaults to a new id.
   *
   * @public
   */
  duplicatePage(page, createId = PageRecordType.createId()) {
    if (this.getPages().length >= this.options.maxPages)
      return this;
    const id = typeof page === "string" ? page : page.id;
    const freshPage = this.getPage(id);
    if (!freshPage)
      return this;
    const prevCamera = { ...this.getCamera() };
    const content = this.getContentFromCurrentPage(this.getSortedChildIdsForParent(freshPage.id));
    this.run(() => {
      var _a5;
      const pages = this.getPages();
      const index3 = getIndexBetween(freshPage.index, (_a5 = pages[pages.indexOf(freshPage) + 1]) == null ? void 0 : _a5.index);
      this.createPage({ name: freshPage.name + " Copy", id: createId, index: index3 });
      this.setCurrentPage(createId);
      this.setCamera(prevCamera);
      if (content) {
        return this.putContentOntoCurrentPage(content);
      }
    });
    return this;
  }
  /**
   * Rename a page.
   *
   * @example
   * ```ts
   * editor.renamePage('page1', 'My Page')
   * ```
   *
   * @param page - The page (or the page id) to rename.
   * @param name - The new name.
   *
   * @public
   */
  renamePage(page, name) {
    const id = typeof page === "string" ? page : page.id;
    if (this.getIsReadonly())
      return this;
    this.updatePage({ id, name });
    return this;
  }
  _getAllAssetsQuery() {
    return this.store.query.records("asset");
  }
  /**
   * Get all assets in the editor.
   *
   * @public
   */
  getAssets() {
    return this._getAllAssetsQuery().get();
  }
  /**
   * Create one or more assets.
   *
   * @example
   * ```ts
   * editor.createAssets([...myAssets])
   * ```
   *
   * @param assets - The assets to create.
   *
   * @public
   */
  createAssets(assets) {
    if (this.getIsReadonly())
      return this;
    if (assets.length <= 0)
      return this;
    this.run(() => this.store.put(assets), { history: "ignore" });
    return this;
  }
  /**
   * Update one or more assets.
   *
   * @example
   * ```ts
   * editor.updateAssets([{ id: 'asset1', name: 'New name' }])
   * ```
   *
   * @param assets - The assets to update.
   *
   * @public
   */
  updateAssets(assets) {
    if (this.getIsReadonly())
      return this;
    if (assets.length <= 0)
      return this;
    this.run(
      () => {
        this.store.put(
          assets.map((partial) => ({
            ...this.store.get(partial.id),
            ...partial
          }))
        );
      },
      { history: "ignore" }
    );
    return this;
  }
  /**
   * Delete one or more assets.
   *
   * @example
   * ```ts
   * editor.deleteAssets(['asset1', 'asset2'])
   * ```
   *
   * @param assets - The assets (or asset ids) to delete.
   *
   * @public
   */
  deleteAssets(assets) {
    if (this.getIsReadonly())
      return this;
    const ids = typeof assets[0] === "string" ? assets : assets.map((a) => a.id);
    if (ids.length <= 0)
      return this;
    this.run(
      () => {
        var _a5, _b;
        (_b = (_a5 = this.store.props.assets).remove) == null ? void 0 : _b.call(_a5, ids);
        this.store.remove(ids);
      },
      { history: "ignore" }
    );
    return this;
  }
  /**
   * Get an asset by its id.
   *
   * @example
   * ```ts
   * editor.getAsset('asset1')
   * ```
   *
   * @param asset - The asset (or asset id) to get.
   *
   * @public
   */
  getAsset(asset) {
    return this.store.get(typeof asset === "string" ? asset : asset.id);
  }
  async resolveAssetUrl(assetId, context) {
    if (!assetId)
      return null;
    const asset = this.getAsset(assetId);
    if (!asset)
      return null;
    const {
      screenScale = 1,
      shouldResolveToOriginal = false,
      dpr = this.getInstanceState().devicePixelRatio
    } = context;
    const zoomStepFunction = (zoom) => Math.pow(2, Math.ceil(Math.log2(zoom)));
    const steppedScreenScale = zoomStepFunction(screenScale);
    const networkEffectiveType = "connection" in navigator ? navigator.connection.effectiveType : null;
    return await this.store.props.assets.resolve(asset, {
      screenScale: screenScale || 1,
      steppedScreenScale,
      dpr,
      networkEffectiveType,
      shouldResolveToOriginal
    });
  }
  /**
   * Upload an asset to the store's asset service, returning a URL that can be used to resolve the
   * asset.
   */
  async uploadAsset(asset, file, abortSignal) {
    return await this.store.props.assets.upload(asset, file, abortSignal);
  }
  /**
   * Get the geometry of a shape in shape-space.
   *
   * @example
   * ```ts
   * editor.getShapeGeometry(myShape)
   * editor.getShapeGeometry(myShapeId)
   * editor.getShapeGeometry(myShapeId, { context: "arrow" })
   * ```
   *
   * @param shape - The shape (or shape id) to get the geometry for.
   * @param opts - Additional options about the request for geometry. Passed to {@link ShapeUtil.getGeometry}.
   *
   * @public
   */
  getShapeGeometry(shape, opts) {
    const context = (opts == null ? void 0 : opts.context) ?? "none";
    if (!this._shapeGeometryCaches[context]) {
      this._shapeGeometryCaches[context] = this.store.createComputedCache(
        "bounds",
        (shape2) => {
          this.fonts.trackFontsForShape(shape2);
          return this.getShapeUtil(shape2).getGeometry(shape2, opts);
        },
        { areRecordsEqual: areShapesContentEqual }
      );
    }
    return this._shapeGeometryCaches[context].get(
      typeof shape === "string" ? shape : shape.id
    );
  }
  /**
   * Get the geometry of a shape in page-space.
   *
   * @example
   * ```ts
   * editor.getShapePageGeometry(myShape)
   * editor.getShapePageGeometry(myShapeId)
   * editor.getShapePageGeometry(myShapeId, { context: "arrow" })
   * ```
   *
   * @param shape - The shape (or shape id) to get the geometry for.
   * @param opts - Additional options about the request for geometry. Passed to {@link ShapeUtil.getGeometry}.
   *
   * @public
   */
  getShapePageGeometry(shape, opts) {
    const context = (opts == null ? void 0 : opts.context) ?? "none";
    if (!this._shapePageGeometryCaches[context]) {
      this._shapePageGeometryCaches[context] = this.store.createComputedCache(
        "bounds",
        (shape2) => {
          const geometry = this.getShapeGeometry(shape2.id, opts);
          const pageTransform = this.getShapePageTransform(shape2.id);
          return geometry.transform(pageTransform);
        },
        {
          // we only depend directly on the shape id, and changing geometry/transform will update us anyway
          areRecordsEqual: () => true
        }
      );
    }
    return this._shapePageGeometryCaches[context].get(
      typeof shape === "string" ? shape : shape.id
    );
  }
  _getShapeHandlesCache() {
    return this.store.createComputedCache(
      "handles",
      (shape) => {
        var _a5, _b;
        return (_b = (_a5 = this.getShapeUtil(shape)).getHandles) == null ? void 0 : _b.call(_a5, shape);
      },
      {
        areRecordsEqual: areShapesContentEqual
      }
    );
  }
  /**
   * Get the handles (if any) for a shape.
   *
   * @example
   * ```ts
   * editor.getShapeHandles(myShape)
   * editor.getShapeHandles(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the handles for.
   * @public
   */
  getShapeHandles(shape) {
    return this._getShapeHandlesCache().get(typeof shape === "string" ? shape : shape.id);
  }
  /**
   * Get the local transform for a shape as a matrix model. This transform reflects both its
   * translation (x, y) from from either its parent's top left corner, if the shape's parent is
   * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
   * shape's rotation.
   *
   * @example
   * ```ts
   * editor.getShapeLocalTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the local transform for.
   *
   * @public
   */
  getShapeLocalTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape)
      throw Error("Editor.getTransform: shape not found");
    return Mat.Identity().translate(freshShape.x, freshShape.y).rotate(freshShape.rotation);
  }
  _getShapePageTransformCache() {
    return this.store.createComputedCache("pageTransformCache", (shape) => {
      if (isPageId(shape.parentId)) {
        return this.getShapeLocalTransform(shape);
      }
      const parentTransform = this._getShapePageTransformCache().get(shape.parentId) ?? Mat.Identity();
      return Mat.Compose(parentTransform, this.getShapeLocalTransform(shape));
    });
  }
  /**
   * Get the local transform of a shape's parent as a matrix model.
   *
   * @example
   * ```ts
   * editor.getShapeParentTransform(myShape)
   * ```
   *
   * @param shape - The shape (or shape id) to get the parent transform for.
   *
   * @public
   */
  getShapeParentTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape || isPageId(freshShape.parentId))
      return Mat.Identity();
    return this._getShapePageTransformCache().get(freshShape.parentId) ?? Mat.Identity();
  }
  /**
   * Get the transform of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageTransform(myShape)
   * editor.getShapePageTransform(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the page transform for.
   *
   * @public
   */
  getShapePageTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this._getShapePageTransformCache().get(id) ?? Mat.Identity();
  }
  _getShapePageBoundsCache() {
    return this.store.createComputedCache("pageBoundsCache", (shape) => {
      return this.getShapePageGeometry(shape).bounds;
    });
  }
  /**
   * Get the bounds of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageBounds(myShape)
   * editor.getShapePageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the bounds for.
   *
   * @public
   */
  getShapePageBounds(shape) {
    return this._getShapePageBoundsCache().get(typeof shape === "string" ? shape : shape.id);
  }
  _getShapeClipPathCache() {
    return this.store.createComputedCache("clipPathCache", (shape) => {
      const pageMask = this._getShapeMaskCache().get(shape.id);
      if (!pageMask)
        return void 0;
      if (pageMask.length === 0) {
        return `polygon(0px 0px, 0px 0px, 0px 0px)`;
      }
      const pageTransform = this._getShapePageTransformCache().get(shape.id);
      if (!pageTransform)
        return void 0;
      const localMask = Mat.applyToPoints(Mat.Inverse(pageTransform), pageMask);
      return `polygon(${localMask.map((p) => `${p.x}px ${p.y}px`).join(",")})`;
    });
  }
  /**
   * Get the clip path for a shape.
   *
   * @example
   * ```ts
   * const clipPath = editor.getShapeClipPath(shape)
   * const clipPath = editor.getShapeClipPath(shape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to get the clip path for.
   *
   * @returns The clip path or undefined.
   *
   * @public
   */
  getShapeClipPath(shape) {
    return this._getShapeClipPathCache().get(typeof shape === "string" ? shape : shape.id);
  }
  _getShapeMaskCache() {
    return this.store.createComputedCache("pageMaskCache", (shape) => {
      if (isPageId(shape.parentId))
        return void 0;
      const frameAncestors = this.getShapeAncestors(shape.id).filter(
        (shape2) => this.isShapeOfType(shape2, "frame")
      );
      if (frameAncestors.length === 0)
        return void 0;
      const pageMask = frameAncestors.map(
        (s) => (
          // Apply the frame transform to the frame outline to get the frame outline in the current page space
          this.getShapePageGeometry(s.id).vertices
        )
      ).reduce((acc, b) => {
        if (!(b && acc))
          return void 0;
        const intersection = intersectPolygonPolygon(acc, b);
        if (intersection) {
          return intersection.map(Vec.Cast);
        }
        return [];
      });
      return pageMask;
    });
  }
  /**
   * Get the mask (in the current page space) for a shape.
   *
   * @example
   * ```ts
   * const pageMask = editor.getShapeMask(shape.id)
   * ```
   *
   * @param shape - The shape (or the shape id) of the shape to get the mask for.
   *
   * @returns The mask for the shape.
   *
   * @public
   */
  getShapeMask(shape) {
    return this._getShapeMaskCache().get(typeof shape === "string" ? shape : shape.id);
  }
  /**
   * Get the bounds of a shape in the current page space, incorporating any masks. For example, if the
   * shape were the child of a frame and was half way out of the frame, the bounds would be the half
   * of the shape that was in the frame.
   *
   * @example
   * ```ts
   * editor.getShapeMaskedPageBounds(myShape)
   * editor.getShapeMaskedPageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape to get the masked bounds for.
   *
   * @public
   */
  getShapeMaskedPageBounds(shape) {
    if (typeof shape !== "string")
      shape = shape.id;
    return this._getShapeMaskedPageBoundsCache().get(shape);
  }
  _getShapeMaskedPageBoundsCache() {
    return this.store.createComputedCache("shapeMaskedPageBoundsCache", (shape) => {
      const pageBounds = this._getShapePageBoundsCache().get(shape.id);
      if (!pageBounds)
        return;
      const pageMask = this._getShapeMaskCache().get(shape.id);
      if (pageMask) {
        if (pageMask.length === 0)
          return void 0;
        const { corners } = pageBounds;
        if (corners.every((p, i) => p && Vec.Equals(p, pageMask[i])))
          return pageBounds.clone();
        const intersection = intersectPolygonPolygon(pageMask, corners);
        if (!intersection)
          return;
        return Box.FromPoints(intersection);
      }
      return pageBounds;
    });
  }
  /**
   * Get the ancestors of a shape.
   *
   * @example
   * ```ts
   * const ancestors = editor.getShapeAncestors(myShape)
   * const ancestors = editor.getShapeAncestors(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the ancestors for.
   * @param acc - The accumulator.
   *
   * @public
   */
  getShapeAncestors(shape, acc = []) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape)
      return acc;
    const parentId = freshShape.parentId;
    if (isPageId(parentId)) {
      acc.reverse();
      return acc;
    }
    const parent = this.store.get(parentId);
    if (!parent)
      return acc;
    acc.push(parent);
    return this.getShapeAncestors(parent, acc);
  }
  /**
   * Find the first ancestor matching the given predicate
   *
   * @example
   * ```ts
   * const ancestor = editor.findShapeAncestor(myShape)
   * const ancestor = editor.findShapeAncestor(myShape.id)
   * const ancestor = editor.findShapeAncestor(myShape.id, (shape) => shape.type === 'frame')
   * ```
   *
   * @param shape - The shape to check the ancestors for.
   * @param predicate - The predicate to match.
   *
   * @public
   */
  findShapeAncestor(shape, predicate) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape)
      return;
    const parentId = freshShape.parentId;
    if (isPageId(parentId))
      return;
    const parent = this.getShape(parentId);
    if (!parent)
      return;
    return predicate(parent) ? parent : this.findShapeAncestor(parent, predicate);
  }
  /**
   * Returns true if the the given shape has the given ancestor.
   *
   * @param shape - The shape.
   * @param ancestorId - The id of the ancestor.
   *
   * @public
   */
  hasAncestor(shape, ancestorId) {
    const id = typeof shape === "string" ? shape : shape == null ? void 0 : shape.id;
    const freshShape = id && this.getShape(id);
    if (!freshShape)
      return false;
    if (freshShape.parentId === ancestorId)
      return true;
    return this.hasAncestor(this.getShapeParent(freshShape), ancestorId);
  }
  /**
   * Get the common ancestor of two or more shapes that matches a predicate.
   *
   * @param shapes - The shapes (or shape ids) to check.
   * @param predicate - The predicate to match.
   */
  findCommonAncestor(shapes, predicate) {
    var _a5;
    if (shapes.length === 0) {
      return;
    }
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const freshShapes = compact(ids.map((id) => this.getShape(id)));
    if (freshShapes.length === 1) {
      const parentId = freshShapes[0].parentId;
      if (isPageId(parentId)) {
        return;
      }
      return predicate ? (_a5 = this.findShapeAncestor(freshShapes[0], predicate)) == null ? void 0 : _a5.id : parentId;
    }
    const [nodeA, ...others] = freshShapes;
    let ancestor = this.getShapeParent(nodeA);
    while (ancestor) {
      if (predicate && !predicate(ancestor)) {
        ancestor = this.getShapeParent(ancestor);
        continue;
      }
      if (others.every((shape) => this.hasAncestor(shape, ancestor.id))) {
        return ancestor.id;
      }
      ancestor = this.getShapeParent(ancestor);
    }
    return void 0;
  }
  isShapeOrAncestorLocked(arg) {
    const shape = typeof arg === "string" ? this.getShape(arg) : arg;
    if (shape === void 0)
      return false;
    if (shape.isLocked)
      return true;
    return this.isShapeOrAncestorLocked(this.getShapeParent(shape));
  }
  _notVisibleShapes() {
    return notVisibleShapes(this);
  }
  getCulledShapes() {
    const notVisibleShapes2 = this._notVisibleShapes().get();
    const selectedShapeIds = this.getSelectedShapeIds();
    const editingId = this.getEditingShapeId();
    const culledShapes = new Set(notVisibleShapes2);
    if (editingId) {
      culledShapes.delete(editingId);
    }
    selectedShapeIds.forEach((id) => {
      culledShapes.delete(id);
    });
    return culledShapes;
  }
  getCurrentPageBounds() {
    let commonBounds;
    this.getCurrentPageShapeIdsSorted().forEach((shapeId) => {
      const bounds = this.getShapeMaskedPageBounds(shapeId);
      if (!bounds)
        return;
      if (!commonBounds) {
        commonBounds = bounds.clone();
      } else {
        commonBounds = commonBounds.expand(bounds);
      }
    });
    return commonBounds;
  }
  /**
   * Get the top-most selected shape at the given point, ignoring groups.
   *
   * @param point - The point to check.
   *
   * @returns The top-most selected shape at the given point, or undefined if there is no shape at the point.
   */
  getSelectedShapeAtPoint(point) {
    const selectedShapeIds = this.getSelectedShapeIds();
    return this.getCurrentPageShapesSorted().filter((shape) => shape.type !== "group" && selectedShapeIds.includes(shape.id)).reverse().find((shape) => this.isPointInShape(shape, point, { hitInside: true, margin: 0 }));
  }
  /**
   * Get the shape at the current point.
   *
   * @param point - The point to check.
   * @param opts - Options for the check: `hitInside` to check if the point is inside the shape, `margin` to check if the point is within a margin of the shape, `hitFrameInside` to check if the point is inside the frame, and `filter` to filter the shapes to check.
   *
   * @returns The shape at the given point, or undefined if there is no shape at the point.
   */
  getShapeAtPoint(point, opts = {}) {
    var _a5;
    const zoomLevel = this.getZoomLevel();
    const viewportPageBounds = this.getViewportPageBounds();
    const {
      filter: filter2,
      margin = 0,
      hitLocked = false,
      hitLabels = false,
      hitInside = false,
      hitFrameInside = false
    } = opts;
    let inHollowSmallestArea = Infinity;
    let inHollowSmallestAreaHit = null;
    let inMarginClosestToEdgeDistance = Infinity;
    let inMarginClosestToEdgeHit = null;
    const shapesToCheck = (opts.renderingOnly ? this.getCurrentPageRenderingShapesSorted() : this.getCurrentPageShapesSorted()).filter((shape) => {
      if (shape.isLocked && !hitLocked || this.isShapeHidden(shape) || this.isShapeOfType(shape, "group"))
        return false;
      const pageMask = this.getShapeMask(shape);
      if (pageMask && !pointInPolygon(point, pageMask))
        return false;
      if (filter2)
        return filter2(shape);
      return true;
    });
    for (let i = shapesToCheck.length - 1; i >= 0; i--) {
      const shape = shapesToCheck[i];
      const geometry = this.getShapeGeometry(shape);
      const isGroup = geometry instanceof Group2d;
      const pointInShapeSpace = this.getPointInShapeSpace(shape, point);
      if (this.isShapeOfType(shape, "frame") || this.isShapeOfType(shape, "arrow") && shape.props.text.trim() || (this.isShapeOfType(shape, "note") || this.isShapeOfType(shape, "geo") && shape.props.fill === "none") && ((_a5 = this.getShapeUtil(shape).getText(shape)) == null ? void 0 : _a5.trim())) {
        for (const childGeometry of geometry.children) {
          if (childGeometry.isLabel && childGeometry.isPointInBounds(pointInShapeSpace)) {
            return shape;
          }
        }
      }
      if (this.isShapeOfType(shape, "frame")) {
        const distance2 = geometry.distanceToPoint(pointInShapeSpace, hitInside);
        if (Math.abs(distance2) <= margin) {
          return inMarginClosestToEdgeHit || shape;
        }
        if (geometry.hitTestPoint(pointInShapeSpace, 0, true)) {
          return inMarginClosestToEdgeHit || inHollowSmallestAreaHit || (hitFrameInside ? shape : void 0);
        }
        continue;
      }
      let distance;
      if (isGroup) {
        let minDistance = Infinity;
        for (const childGeometry of geometry.children) {
          if (childGeometry.isLabel && !hitLabels)
            continue;
          const tDistance = childGeometry.distanceToPoint(pointInShapeSpace, hitInside);
          if (tDistance < minDistance) {
            minDistance = tDistance;
          }
        }
        distance = minDistance;
      } else {
        if (margin === 0 && (geometry.bounds.w < 1 || geometry.bounds.h < 1)) {
          distance = geometry.distanceToPoint(pointInShapeSpace, hitInside);
        } else {
          if (geometry.bounds.containsPoint(pointInShapeSpace, margin)) {
            distance = geometry.distanceToPoint(pointInShapeSpace, hitInside);
          } else {
            distance = Infinity;
          }
        }
      }
      if (geometry.isClosed) {
        if (distance <= margin) {
          if (geometry.isFilled || isGroup && geometry.children[0].isFilled) {
            return inMarginClosestToEdgeHit || shape;
          } else {
            if (this.getShapePageBounds(shape).contains(viewportPageBounds))
              continue;
            if (Math.abs(distance) < margin) {
              if (Math.abs(distance) < inMarginClosestToEdgeDistance) {
                inMarginClosestToEdgeDistance = Math.abs(distance);
                inMarginClosestToEdgeHit = shape;
              }
            } else if (!inMarginClosestToEdgeHit) {
              const { area } = geometry;
              if (area < inHollowSmallestArea) {
                inHollowSmallestArea = area;
                inHollowSmallestAreaHit = shape;
              }
            }
          }
        }
      } else {
        if (distance < this.options.hitTestMargin / zoomLevel) {
          return shape;
        }
      }
    }
    return inMarginClosestToEdgeHit || inHollowSmallestAreaHit || void 0;
  }
  /**
   * Get the shapes, if any, at a given page point.
   *
   * @example
   * ```ts
   * editor.getShapesAtPoint({ x: 100, y: 100 })
   * editor.getShapesAtPoint({ x: 100, y: 100 }, { hitInside: true, exact: true })
   * ```
   *
   * @param point - The page point to test.
   * @param opts - The options for the hit point testing.
   *
   * @public
   */
  getShapesAtPoint(point, opts = {}) {
    return this.getCurrentPageShapes().filter(
      (shape) => !this.isShapeHidden(shape) && this.isPointInShape(shape, point, opts)
    );
  }
  /**
   * Test whether a point (in the current page space) will will a shape. This method takes into account masks,
   * such as when a shape is the child of a frame and is partially clipped by the frame.
   *
   * @example
   * ```ts
   * editor.isPointInShape({ x: 100, y: 100 }, myShape)
   * ```
   *
   * @param shape - The shape to test against.
   * @param point - The page point to test (in the current page space).
   * @param opts - The options for the hit point testing.
   *
   * @public
   */
  isPointInShape(shape, point, opts = {}) {
    const { hitInside = false, margin = 0 } = opts;
    const id = typeof shape === "string" ? shape : shape.id;
    const pageMask = this.getShapeMask(id);
    if (pageMask && !pointInPolygon(point, pageMask))
      return false;
    return this.getShapeGeometry(id).hitTestPoint(
      this.getPointInShapeSpace(shape, point),
      margin,
      hitInside
    );
  }
  /**
   * Convert a point in the current page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInShapeSpace(shape, point) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this._getShapePageTransformCache().get(id).clone().invert().applyToPoint(point);
  }
  /**
   * Convert a delta in the current page space to a point in the local space of a shape's parent.
   *
   * @example
   * ```ts
   * editor.getPointInParentSpace(myShape.id, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInParentSpace(shape, point) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape)
      return new Vec(0, 0);
    if (isPageId(freshShape.parentId))
      return Vec.From(point);
    const parentTransform = this.getShapePageTransform(freshShape.parentId);
    if (!parentTransform)
      return Vec.From(point);
    return parentTransform.clone().invert().applyToPoint(point);
  }
  getCurrentPageShapes() {
    return Array.from(this.getCurrentPageShapeIds(), (id) => this.store.get(id));
  }
  getCurrentPageShapesSorted() {
    const result = [];
    const topLevelShapes = this.getSortedChildIdsForParent(this.getCurrentPageId());
    for (let i = 0, n = topLevelShapes.length; i < n; i++) {
      pushShapeWithDescendants(this, topLevelShapes[i], result);
    }
    return result;
  }
  getCurrentPageRenderingShapesSorted() {
    const culledShapes = this.getCulledShapes();
    return this.getCurrentPageShapesSorted().filter(
      ({ id }) => !culledShapes.has(id) && !this.isShapeHidden(id)
    );
  }
  isShapeOfType(arg, type) {
    const shape = typeof arg === "string" ? this.getShape(arg) : arg;
    if (!shape)
      return false;
    return shape.type === type;
  }
  /**
   * Get a shape by its id.
   *
   * @example
   * ```ts
   * editor.getShape('box1')
   * ```
   *
   * @param shape - The shape (or the id of the shape) to get.
   *
   * @public
   */
  getShape(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    if (!isShapeId(id))
      return void 0;
    return this.store.get(id);
  }
  /**
   * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
   * the page.
   *
   * @example
   * ```ts
   * editor.getShapeParent(myShape)
   * ```
   *
   * @public
   */
  getShapeParent(shape) {
    const id = typeof shape === "string" ? shape : shape == null ? void 0 : shape.id;
    if (!id)
      return void 0;
    const freshShape = this.getShape(id);
    if (freshShape === void 0 || !isShapeId(freshShape.parentId))
      return void 0;
    return this.store.get(freshShape.parentId);
  }
  /**
   * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an
   * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns
   * undefined.
   *
   * @internal
   */
  getShapeNearestSibling(siblingShape, targetShape) {
    if (!targetShape) {
      return void 0;
    }
    if (targetShape.parentId === siblingShape.parentId) {
      return targetShape;
    }
    const ancestor = this.findShapeAncestor(
      targetShape,
      (ancestor2) => ancestor2.parentId === siblingShape.parentId
    );
    return ancestor;
  }
  /**
   * Get whether the given shape is the descendant of the given page.
   *
   * @example
   * ```ts
   * editor.isShapeInPage(myShape)
   * editor.isShapeInPage(myShape, 'page1')
   * ```
   *
   * @param shape - The shape to check.
   * @param pageId - The id of the page to check against. Defaults to the current page.
   *
   * @public
   */
  isShapeInPage(shape, pageId = this.getCurrentPageId()) {
    const id = typeof shape === "string" ? shape : shape.id;
    const shapeToCheck = this.getShape(id);
    if (!shapeToCheck)
      return false;
    let shapeIsInPage = false;
    if (shapeToCheck.parentId === pageId) {
      shapeIsInPage = true;
    } else {
      let parent = this.getShape(shapeToCheck.parentId);
      isInPageSearch:
        while (parent) {
          if (parent.parentId === pageId) {
            shapeIsInPage = true;
            break isInPageSearch;
          }
          parent = this.getShape(parent.parentId);
        }
    }
    return shapeIsInPage;
  }
  /**
   * Get the id of the containing page for a given shape.
   *
   * @param shape - The shape to get the page id for.
   *
   * @returns The id of the page that contains the shape, or undefined if the shape is undefined.
   *
   * @public
   */
  getAncestorPageId(shape) {
    const id = typeof shape === "string" ? shape : shape == null ? void 0 : shape.id;
    const _shape = id && this.getShape(id);
    if (!_shape)
      return void 0;
    if (isPageId(_shape.parentId)) {
      return _shape.parentId;
    } else {
      return this.getAncestorPageId(this.getShape(_shape.parentId));
    }
  }
  /**
   * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
   * rotations.
   *
   * @example
   * ```ts
   * editor.reparentShapes([box1, box2], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1', 4)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to reparent.
   * @param parentId - The id of the new parent shape.
   * @param insertIndex - The index to insert the children.
   *
   * @public
   */
  reparentShapes(shapes, parentId, insertIndex) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length === 0)
      return this;
    const changes = [];
    const parentTransform = isPageId(parentId) ? Mat.Identity() : this.getShapePageTransform(parentId);
    const parentPageRotation = parentTransform.rotation();
    let indices = [];
    const sibs = compact(this.getSortedChildIdsForParent(parentId).map((id) => this.getShape(id)));
    if (insertIndex) {
      const sibWithInsertIndex = sibs.find((s) => s.index === insertIndex);
      if (sibWithInsertIndex) {
        const sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1];
        if (sibAbove) {
          indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length);
        } else {
          indices = getIndicesAbove(insertIndex, ids.length);
        }
      } else {
        const sibAbove = sibs.sort(sortByIndex).find((s) => s.index > insertIndex);
        if (sibAbove) {
          indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length);
        } else {
          indices = getIndicesAbove(insertIndex, ids.length);
        }
      }
    } else {
      const sib = sibs.length && sibs[sibs.length - 1];
      indices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length);
    }
    const invertedParentTransform = parentTransform.clone().invert();
    const shapesToReparent = compact(ids.map((id) => this.getShape(id))).sort(sortByIndex);
    this.run(
      () => {
        for (let i = 0; i < shapesToReparent.length; i++) {
          const shape = shapesToReparent[i];
          const pageTransform = this.getShapePageTransform(shape);
          if (!pageTransform)
            continue;
          const pagePoint = pageTransform.point();
          if (!pagePoint)
            continue;
          const newPoint = invertedParentTransform.applyToPoint(pagePoint);
          const newRotation = pageTransform.rotation() - parentPageRotation;
          changes.push({
            id: shape.id,
            type: shape.type,
            parentId,
            x: newPoint.x,
            y: newPoint.y,
            rotation: newRotation,
            index: indices[i]
          });
        }
        this.updateShapes(changes);
      },
      { ignoreShapeLock: true }
    );
    return this;
  }
  /**
   * Get the index above the highest child of a given parent.
   *
   * @param parent - The parent (or the id) of the parent.
   *
   * @returns The index.
   *
   * @public
   */
  getHighestIndexForParent(parent) {
    const parentId = typeof parent === "string" ? parent : parent.id;
    const children = this._parentIdsToChildIds.get()[parentId];
    if (!children || children.length === 0) {
      return "a1";
    }
    const shape = this.getShape(children[children.length - 1]);
    return getIndexAbove(shape.index);
  }
  /**
   * Get an array of all the children of a shape.
   *
   * @example
   * ```ts
   * editor.getSortedChildIdsForParent('frame1')
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   *
   * @public
   */
  getSortedChildIdsForParent(parent) {
    const parentId = typeof parent === "string" ? parent : parent.id;
    const ids = this._parentIdsToChildIds.get()[parentId];
    if (!ids)
      return EMPTY_ARRAY;
    return ids;
  }
  /**
   * Run a visitor function for all descendants of a shape.
   *
   * @example
   * ```ts
   * editor.visitDescendants('frame1', myCallback)
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   * @param visitor - The visitor function.
   *
   * @public
   */
  visitDescendants(parent, visitor) {
    const parentId = typeof parent === "string" ? parent : parent.id;
    const children = this.getSortedChildIdsForParent(parentId);
    for (const id of children) {
      if (visitor(id) === false)
        continue;
      this.visitDescendants(id, visitor);
    }
    return this;
  }
  /**
   * Get the shape ids of all descendants of the given shapes (including the shapes themselves). IDs are returned in z-index order.
   *
   * @param ids - The ids of the shapes to get descendants of.
   *
   * @returns The descendant ids.
   *
   * @public
   */
  getShapeAndDescendantIds(ids) {
    const shapeIds = /* @__PURE__ */ new Set();
    for (const shape of ids.map((id) => this.getShape(id)).sort(sortByIndex)) {
      shapeIds.add(shape.id);
      this.visitDescendants(shape, (descendantId) => {
        shapeIds.add(descendantId);
      });
    }
    return shapeIds;
  }
  /**
   * Get the shape that some shapes should be dropped on at a given point.
   *
   * @param point - The point to find the parent for.
   * @param droppingShapes - The shapes that are being dropped.
   *
   * @returns The shape to drop on.
   *
   * @public
   */
  getDroppingOverShape(point, droppingShapes = []) {
    const currentPageShapesSorted = this.getCurrentPageShapesSorted();
    for (let i = currentPageShapesSorted.length - 1; i >= 0; i--) {
      const shape = currentPageShapesSorted[i];
      if (
        // ignore hidden shapes
        this.isShapeHidden(shape) || // don't allow dropping on selected shapes
        this.getSelectedShapeIds().includes(shape.id) || // only allow shapes that can receive children
        !this.getShapeUtil(shape).canDropShapes(shape, droppingShapes) || // don't allow dropping a shape on itself or one of it's children
        droppingShapes.find((s) => s.id === shape.id || this.hasAncestor(shape, s.id))
      ) {
        continue;
      }
      const maskedPageBounds = this.getShapeMaskedPageBounds(shape.id);
      if (maskedPageBounds && maskedPageBounds.containsPoint(point) && this.getShapeGeometry(shape).hitTestPoint(this.getPointInShapeSpace(shape, point), 0, true)) {
        return shape;
      }
    }
  }
  /**
   * Get the shape that should be selected when you click on a given shape, assuming there is
   * nothing already selected. It will not return anything higher than or including the current
   * focus layer.
   *
   * @param shape - The shape to get the outermost selectable shape for.
   * @param filter - A function to filter the selectable shapes.
   *
   * @returns The outermost selectable shape.
   *
   * @public
   */
  getOutermostSelectableShape(shape, filter2) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    let match = freshShape;
    let node = freshShape;
    const focusedGroup = this.getFocusedGroup();
    while (node) {
      if (this.isShapeOfType(node, "group") && (focusedGroup == null ? void 0 : focusedGroup.id) !== node.id && !this.hasAncestor(focusedGroup, node.id) && ((filter2 == null ? void 0 : filter2(node)) ?? true)) {
        match = node;
      } else if ((focusedGroup == null ? void 0 : focusedGroup.id) === node.id) {
        break;
      }
      node = this.getShapeParent(node);
    }
    return match;
  }
  _getBindingsIndexCache() {
    const index3 = bindingsIndex(this);
    return this.store.createComputedCache(
      "bindingsIndex",
      (shape) => {
        return index3.get().get(shape.id);
      },
      // we can ignore the shape equality check here because the index is
      // computed incrementally based on what bindings are in the store
      { areRecordsEqual: () => true }
    );
  }
  /**
   * Get a binding from the store by its ID if it exists.
   */
  getBinding(id) {
    return this.store.get(id);
  }
  /**
   * Get all bindings of a certain type _from_ a particular shape. These are the bindings whose
   * `fromId` matched the shape's ID.
   */
  getBindingsFromShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this.getBindingsInvolvingShape(id).filter(
      (b) => b.fromId === id && b.type === type
    );
  }
  /**
   * Get all bindings of a certain type _to_ a particular shape. These are the bindings whose
   * `toId` matches the shape's ID.
   */
  getBindingsToShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this.getBindingsInvolvingShape(id).filter(
      (b) => b.toId === id && b.type === type
    );
  }
  /**
   * Get all bindings involving a particular shape. This includes bindings where the shape is the
   * `fromId` or `toId`. If a type is provided, only bindings of that type are returned.
   */
  getBindingsInvolvingShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    const result = this._getBindingsIndexCache().get(id) ?? EMPTY_ARRAY;
    if (!type)
      return result;
    return result.filter((b) => b.type === type);
  }
  /**
   * Create bindings from a list of partial bindings. You can omit the ID and most props of a
   * binding, but the `type`, `toId`, and `fromId` must all be provided.
   */
  createBindings(partials) {
    const bindings = [];
    for (const partial of partials) {
      const fromShape = this.getShape(partial.fromId);
      const toShape = this.getShape(partial.toId);
      if (!fromShape || !toShape)
        continue;
      if (!this.canBindShapes({ fromShape, toShape, binding: partial }))
        continue;
      const util = this.getBindingUtil(partial.type);
      const defaultProps2 = util.getDefaultProps();
      const binding = this.store.schema.types.binding.create({
        ...partial,
        id: partial.id ?? createBindingId(),
        props: {
          ...defaultProps2,
          ...partial.props
        }
      });
      bindings.push(binding);
    }
    this.store.put(bindings);
    return this;
  }
  /**
   * Create a single binding from a partial. You can omit the ID and most props of a binding, but
   * the `type`, `toId`, and `fromId` must all be provided.
   */
  createBinding(partial) {
    return this.createBindings([partial]);
  }
  /**
   * Update bindings from a list of partial bindings. Each partial must include an ID, which will
   * be used to match the binding to it's existing record. If there is no existing record, that
   * binding is skipped. The changes from the partial are merged into the existing record.
   */
  updateBindings(partials) {
    const updated = [];
    for (const partial of partials) {
      if (!partial)
        continue;
      const current = this.getBinding(partial.id);
      if (!current)
        continue;
      const updatedBinding = applyPartialToRecordWithProps(current, partial);
      if (updatedBinding === current)
        continue;
      const fromShape = this.getShape(updatedBinding.fromId);
      const toShape = this.getShape(updatedBinding.toId);
      if (!fromShape || !toShape)
        continue;
      if (!this.canBindShapes({ fromShape, toShape, binding: updatedBinding }))
        continue;
      updated.push(updatedBinding);
    }
    this.store.put(updated);
    return this;
  }
  /**
   * Update a binding from a partial binding. Each partial must include an ID, which will be used
   * to match the binding to it's existing record. If there is no existing record, that binding is
   * skipped. The changes from the partial are merged into the existing record.
   */
  updateBinding(partial) {
    return this.updateBindings([partial]);
  }
  /**
   * Delete several bindings by their IDs. If a binding ID doesn't exist, it's ignored.
   */
  deleteBindings(bindings, { isolateShapes = false } = {}) {
    const ids = bindings.map((binding) => typeof binding === "string" ? binding : binding.id);
    if (isolateShapes) {
      this.store.atomic(() => {
        var _a5, _b;
        for (const id of ids) {
          const binding = this.getBinding(id);
          if (!binding)
            continue;
          const util = this.getBindingUtil(binding);
          (_a5 = util.onBeforeIsolateFromShape) == null ? void 0 : _a5.call(util, { binding, removedShape: this.getShape(binding.toId) });
          (_b = util.onBeforeIsolateToShape) == null ? void 0 : _b.call(util, { binding, removedShape: this.getShape(binding.fromId) });
          this.store.remove([id]);
        }
      });
    } else {
      this.store.remove(ids);
    }
    return this;
  }
  /**
   * Delete a binding by its ID. If the binding doesn't exist, it's ignored.
   */
  deleteBinding(binding, opts) {
    return this.deleteBindings([binding], opts);
  }
  canBindShapes({
    fromShape,
    toShape,
    binding
  }) {
    const fromShapeType = typeof fromShape === "string" ? fromShape : fromShape.type;
    const toShapeType = typeof toShape === "string" ? toShape : toShape.type;
    const bindingType = typeof binding === "string" ? binding : binding.type;
    const canBindOpts = { fromShapeType, toShapeType, bindingType };
    if (fromShapeType === toShapeType) {
      return this.getShapeUtil(fromShapeType).canBind(canBindOpts);
    }
    return this.getShapeUtil(fromShapeType).canBind(canBindOpts) && this.getShapeUtil(toShapeType).canBind(canBindOpts);
  }
  /* -------------------- Commands -------------------- */
  /**
   * Rotate shapes by a delta in radians.
   *
   * @example
   * ```ts
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI)
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param delta - The delta in radians to apply to the selection rotation.
   * @param opts - The options for the rotation.
   */
  rotateShapesBy(shapes, delta, opts) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length <= 0)
      return this;
    const snapshot = getRotationSnapshot({ editor: this, ids });
    if (!snapshot)
      return this;
    applyRotationToSnapshotShapes({
      delta,
      snapshot,
      editor: this,
      stage: "one-off",
      centerOverride: opts == null ? void 0 : opts.center
    });
    return this;
  }
  // Gets a shape partial that includes life cycle changes: on translate start, on translate, on translate end
  getChangesToTranslateShape(initialShape, newShapeCoords) {
    var _a5, _b, _c;
    let workingShape = initialShape;
    const util = this.getShapeUtil(initialShape);
    const afterTranslateStart = (_a5 = util.onTranslateStart) == null ? void 0 : _a5.call(util, workingShape);
    if (afterTranslateStart) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslateStart);
    }
    workingShape = applyPartialToRecordWithProps(workingShape, {
      id: initialShape.id,
      type: initialShape.type,
      x: newShapeCoords.x,
      y: newShapeCoords.y
    });
    const afterTranslate = (_b = util.onTranslate) == null ? void 0 : _b.call(util, initialShape, workingShape);
    if (afterTranslate) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslate);
    }
    const afterTranslateEnd = (_c = util.onTranslateEnd) == null ? void 0 : _c.call(util, initialShape, workingShape);
    if (afterTranslateEnd) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslateEnd);
    }
    return workingShape;
  }
  /**
   * Move shapes by a delta.
   *
   * @example
   * ```ts
   * editor.nudgeShapes(['box1', 'box2'], { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param offset - The offset to apply to the shapes.
   */
  nudgeShapes(shapes, offset5) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length <= 0)
      return this;
    const changes = [];
    for (const id of ids) {
      const shape = this.getShape(id);
      const localDelta = Vec.From(offset5);
      const parentTransform = this.getShapeParentTransform(shape);
      if (parentTransform)
        localDelta.rot(-parentTransform.rotation());
      changes.push(this.getChangesToTranslateShape(shape, localDelta.add(shape)));
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Duplicate shapes.
   *
   * @example
   * ```ts
   * editor.duplicateShapes(['box1', 'box2'], { x: 8, y: 8 })
   * editor.duplicateShapes(editor.getSelectedShapes(), { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to duplicate.
   * @param offset - The offset (in pixels) to apply to the duplicated shapes.
   *
   * @public
   */
  duplicateShapes(shapes, offset5) {
    this.run(() => {
      const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
      if (ids.length <= 0)
        return this;
      const initialIds = new Set(ids);
      const shapeIdSet = this.getShapeAndDescendantIds(ids);
      const orderedShapeIds = [...shapeIdSet].reverse();
      const shapeIds = /* @__PURE__ */ new Map();
      for (const shapeId of shapeIdSet) {
        shapeIds.set(shapeId, createShapeId());
      }
      const { shapesToCreateWithOriginals, bindingsToCreate } = withIsolatedShapes(
        this,
        shapeIdSet,
        (bindingIdsToMaintain) => {
          const bindingsToCreate2 = [];
          for (const originalId of bindingIdsToMaintain) {
            const originalBinding = this.getBinding(originalId);
            if (!originalBinding)
              continue;
            const duplicatedId = createBindingId();
            bindingsToCreate2.push({
              ...originalBinding,
              id: duplicatedId,
              fromId: assertExists(shapeIds.get(originalBinding.fromId)),
              toId: assertExists(shapeIds.get(originalBinding.toId))
            });
          }
          const shapesToCreateWithOriginals2 = [];
          for (const originalId of orderedShapeIds) {
            const duplicatedId = assertExists(shapeIds.get(originalId));
            const originalShape = this.getShape(originalId);
            if (!originalShape)
              continue;
            let ox = 0;
            let oy = 0;
            if (offset5 && initialIds.has(originalId)) {
              const parentTransform = this.getShapeParentTransform(originalShape);
              const vec = new Vec(offset5.x, offset5.y).rot(-parentTransform.rotation());
              ox = vec.x;
              oy = vec.y;
            }
            shapesToCreateWithOriginals2.push({
              shape: {
                ...originalShape,
                id: duplicatedId,
                x: originalShape.x + ox,
                y: originalShape.y + oy,
                // Use a dummy index for now, it will get updated outside of the `withIsolatedShapes`
                index: "a1",
                parentId: shapeIds.get(originalShape.parentId) ?? originalShape.parentId
              },
              originalShape
            });
          }
          return { shapesToCreateWithOriginals: shapesToCreateWithOriginals2, bindingsToCreate: bindingsToCreate2 };
        }
      );
      shapesToCreateWithOriginals.forEach(({ shape, originalShape }) => {
        const parentId = originalShape.parentId;
        const siblings = this.getSortedChildIdsForParent(parentId);
        const currentIndex = siblings.indexOf(originalShape.id);
        const siblingAboveId = siblings[currentIndex + 1];
        const siblingAbove = siblingAboveId ? this.getShape(siblingAboveId) : void 0;
        const index3 = getIndexBetween(originalShape.index, siblingAbove == null ? void 0 : siblingAbove.index);
        shape.index = index3;
      });
      const shapesToCreate = shapesToCreateWithOriginals.map(({ shape }) => shape);
      const maxShapesReached = shapesToCreate.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage;
      if (maxShapesReached) {
        alertMaxShapes(this);
        return;
      }
      this.createShapes(shapesToCreate);
      this.createBindings(bindingsToCreate);
      this.setSelectedShapes(compact(ids.map((id) => shapeIds.get(id))));
      if (offset5 !== void 0) {
        const selectionPageBounds = this.getSelectionPageBounds();
        const viewportPageBounds = this.getViewportPageBounds();
        if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
          this.centerOnPoint(selectionPageBounds.center, {
            animation: { duration: this.options.animationMediumMs }
          });
        }
      }
    });
    return this;
  }
  /**
   * Move shapes to page.
   *
   * @example
   * ```ts
   * editor.moveShapesToPage(['box1', 'box2'], 'page1')
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param pageId - The id of the page where the shapes will be moved.
   *
   * @public
   */
  moveShapesToPage(shapes, pageId) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length === 0)
      return this;
    if (this.getIsReadonly())
      return this;
    const currentPageId = this.getCurrentPageId();
    if (pageId === currentPageId)
      return this;
    if (!this.store.has(pageId))
      return this;
    const content = this.getContentFromCurrentPage(ids);
    if (!content)
      return this;
    if (this.getPageShapeIds(pageId).size + content.shapes.length > this.options.maxShapesPerPage) {
      alertMaxShapes(this, pageId);
      return this;
    }
    const fromPageZ = this.getCamera().z;
    this.run(() => {
      this.deleteShapes(ids);
      this.setCurrentPage(pageId);
      this.setFocusedGroup(null);
      this.selectNone();
      this.putContentOntoCurrentPage(content, {
        select: true,
        preserveIds: true,
        preservePosition: true
      });
      this.setCamera({ ...this.getCamera(), z: fromPageZ });
      this.centerOnPoint(this.getSelectionRotatedPageBounds().center);
    });
    return this;
  }
  /**
   * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.
   *
   * @param shapes - The shapes (or shape ids) to toggle.
   *
   * @public
   */
  toggleLock(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (this.getIsReadonly() || ids.length === 0)
      return this;
    let allLocked = true, allUnlocked = true;
    const shapesToToggle = [];
    for (const id of ids) {
      const shape = this.getShape(id);
      if (shape) {
        shapesToToggle.push(shape);
        if (shape.isLocked) {
          allUnlocked = false;
        } else {
          allLocked = false;
        }
      }
    }
    this.run(() => {
      if (allUnlocked) {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))
        );
        this.setSelectedShapes([]);
      } else if (allLocked) {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: false }))
        );
      } else {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))
        );
      }
    });
    return this;
  }
  /**
   * Send shapes to the back of the page's object list.
   *
   * @example
   * ```ts
   * editor.sendToBack(['id1', 'id2'])
   * editor.sendToBack(box1, box2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  sendToBack(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "toBack", ids, {
      considerAllShapes: true
    });
    if (changes)
      this.updateShapes(changes);
    return this;
  }
  /**
   * Send shapes backward in the page's object list.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'])
   * editor.sendBackward([box1, box2])
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the backward operation.
   *
   * @public
   */
  sendBackward(shapes, opts = {}) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "backward", ids, opts);
    if (changes)
      this.updateShapes(changes);
    return this;
  }
  /**
   * Bring shapes forward in the page's object list.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'])
   * editor.bringForward(box1,  box2)
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the forward operation.
   *
   * @public
   */
  bringForward(shapes, opts = {}) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "forward", ids, opts);
    if (changes)
      this.updateShapes(changes);
    return this;
  }
  /**
   * Bring shapes to the front of the page's object list.
   *
   * @example
   * ```ts
   * editor.bringToFront(['id1', 'id2'])
   * editor.bringToFront([box1, box2])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  bringToFront(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "toFront", ids);
    if (changes)
      this.updateShapes(changes);
    return this;
  }
  /**
   * @internal
   */
  collectShapesViaArrowBindings(info) {
    const { initialShapes, resultShapes, resultBounds, bindings, visited } = info;
    for (const binding of bindings) {
      for (const id of [binding.fromId, binding.toId]) {
        if (!visited.has(id)) {
          const aligningShape = initialShapes.find((s) => s.id === id);
          if (aligningShape && !visited.has(aligningShape.id)) {
            visited.add(aligningShape.id);
            const shapePageBounds = this.getShapePageBounds(aligningShape);
            if (!shapePageBounds)
              continue;
            resultShapes.push(aligningShape);
            resultBounds.push(shapePageBounds);
            this.collectShapesViaArrowBindings({
              ...info,
              bindings: this.getBindingsInvolvingShape(aligningShape, "arrow")
            });
          }
        }
      }
    }
  }
  /**
   * Flip shape positions.
   *
   * @example
   * ```ts
   * editor.flipShapes([box1, box2], 'horizontal', 32)
   * editor.flipShapes(editor.getSelectedShapeIds(), 'horizontal', 32)
   * ```
   *
   * @param shapes - The ids of the shapes to flip.
   * @param operation - Whether to flip horizontally or vertically.
   *
   * @public
   */
  flipShapes(shapes, operation) {
    if (this.getIsReadonly())
      return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToFlipFirstPass = compact(ids.map((id) => this.getShape(id)));
    for (const shape of shapesToFlipFirstPass) {
      if (this.isShapeOfType(shape, "group")) {
        const childrenOfGroups = compact(
          this.getSortedChildIdsForParent(shape.id).map((id) => this.getShape(id))
        );
        shapesToFlipFirstPass.push(...childrenOfGroups);
      }
    }
    const shapesToFlip = [];
    const allBounds = [];
    for (const shape of shapesToFlipFirstPass) {
      const util = this.getShapeUtil(shape);
      if (!util.canBeLaidOut(shape, {
        type: "flip",
        shapes: shapesToFlipFirstPass
      })) {
        continue;
      }
      const pageBounds = this.getShapePageBounds(shape);
      const localBounds = this.getShapeGeometry(shape).bounds;
      const pageTransform = this.getShapePageTransform(shape.id);
      if (!(pageBounds && localBounds && pageTransform))
        continue;
      shapesToFlip.push({
        shape,
        localBounds,
        pageTransform,
        isAspectRatioLocked: util.isAspectRatioLocked(shape)
      });
      allBounds.push(pageBounds);
    }
    if (!shapesToFlip.length)
      return this;
    const scaleOriginPage = Box.Common(allBounds).center;
    this.run(() => {
      for (const { shape, localBounds, pageTransform, isAspectRatioLocked } of shapesToFlip) {
        this.resizeShape(
          shape.id,
          { x: operation === "horizontal" ? -1 : 1, y: operation === "vertical" ? -1 : 1 },
          {
            initialBounds: localBounds,
            initialPageTransform: pageTransform,
            initialShape: shape,
            isAspectRatioLocked,
            mode: "scale_shape",
            scaleOrigin: scaleOriginPage,
            scaleAxisRotation: 0
          }
        );
      }
    });
    return this;
  }
  /**
   * Stack shape.
   *
   * @example
   * ```ts
   * editor.stackShapes([box1, box2], 'horizontal')
   * editor.stackShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stack.
   * @param operation - Whether to stack horizontally or vertically.
   * @param gap - The gap to leave between shapes. By default, uses the editor's `adjacentShapeMargin` option.
   *
   * @public
   */
  stackShapes(shapes, operation, gap) {
    var _a5, _b;
    const _gap = gap ?? this.options.adjacentShapeMargin;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (this.getIsReadonly())
      return this;
    const shapesToStackFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToStack = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToStackFirstPass) {
      if (visited.has(shape.id))
        continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds)
        continue;
      if (!((_b = (_a5 = this.getShapeUtil(shape)).canBeLaidOut) == null ? void 0 : _b.call(_a5, shape, {
        type: "stack",
        shapes: shapesToStackFirstPass
      }))) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToStackFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds)
        continue;
      shapeClustersToStack.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    const len = shapeClustersToStack.length;
    if (_gap === 0 && len < 3 || len < 2)
      return this;
    let val;
    let min4;
    let max3;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min4 = "minX";
      max3 = "maxX";
      dim = "width";
    } else {
      val = "y";
      min4 = "minY";
      max3 = "maxY";
      dim = "height";
    }
    let shapeGap = 0;
    if (_gap === 0) {
      const gaps = {};
      shapeClustersToStack.sort((a, b) => a.pageBounds[min4] - b.pageBounds[min4]);
      for (let i = 0; i < len - 1; i++) {
        const currCluster = shapeClustersToStack[i];
        const nextCluster = shapeClustersToStack[i + 1];
        const gap2 = nextCluster.pageBounds[min4] - currCluster.pageBounds[max3];
        if (!gaps[gap2]) {
          gaps[gap2] = 0;
        }
        gaps[gap2]++;
      }
      let maxCount = 1;
      for (const [gap2, count3] of Object.entries(gaps)) {
        if (count3 > maxCount) {
          maxCount = count3;
          shapeGap = parseFloat(gap2);
        }
      }
      if (maxCount === 1) {
        let totalCount = 0;
        for (const [gap2, count3] of Object.entries(gaps)) {
          shapeGap += parseFloat(gap2) * count3;
          totalCount += count3;
        }
        shapeGap /= totalCount;
      }
    } else {
      shapeGap = _gap;
    }
    const changes = [];
    let v = shapeClustersToStack[0].pageBounds[max3];
    for (let i = 1; i < shapeClustersToStack.length; i++) {
      const { shapes: shapes2, pageBounds } = shapeClustersToStack[i];
      const delta = new Vec();
      delta[val] = v + shapeGap - pageBounds[val];
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform)
            shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
      v += pageBounds[dim] + shapeGap;
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Pack shapes into a grid centered on their current position. Based on potpack (https://github.com/mapbox/potpack).
   *
   * @example
   * ```ts
   * editor.packShapes([box1, box2])
   * editor.packShapes(editor.getSelectedShapeIds(), 32)
   * ```
   *
   *
   * @param shapes - The shapes (or shape ids) to pack.
   * @param gap - The padding to apply to the packed shapes. Defaults to the editor's `adjacentShapeMargin` option.
   */
  packShapes(shapes, _gap) {
    var _a5, _b;
    if (this.getIsReadonly())
      return this;
    const gap = _gap ?? this.options.adjacentShapeMargin;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToPackFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToPack = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToPackFirstPass) {
      if (visited.has(shape.id))
        continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds)
        continue;
      if (!((_b = (_a5 = this.getShapeUtil(shape)).canBeLaidOut) == null ? void 0 : _b.call(_a5, shape, {
        type: "pack",
        shapes: shapesToPackFirstPass
      }))) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToPackFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds)
        continue;
      shapeClustersToPack.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds,
        nextPageBounds: commonPageBounds.clone()
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToPack.length < 2)
      return this;
    let area = 0;
    for (const { pageBounds } of shapeClustersToPack) {
      area += pageBounds.width * pageBounds.height;
    }
    const commonBounds = Box.Common(allBounds);
    const maxWidth = commonBounds.width;
    shapeClustersToPack.sort((a, b) => a.pageBounds.width - b.pageBounds.width).sort((a, b) => a.pageBounds.height - b.pageBounds.height);
    const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);
    const spaces = [new Box(commonBounds.x, commonBounds.y, startWidth, Infinity)];
    let width = 0;
    let height = 0;
    let space;
    let last22;
    for (const { nextPageBounds } of shapeClustersToPack) {
      for (let i = spaces.length - 1; i >= 0; i--) {
        space = spaces[i];
        if (nextPageBounds.width > space.width || nextPageBounds.height > space.height)
          continue;
        nextPageBounds.x = space.x;
        nextPageBounds.y = space.y;
        height = Math.max(height, nextPageBounds.maxY);
        width = Math.max(width, nextPageBounds.maxX);
        if (nextPageBounds.width === space.width && nextPageBounds.height === space.height) {
          last22 = spaces.pop();
          if (i < spaces.length)
            spaces[i] = last22;
        } else if (nextPageBounds.height === space.height) {
          space.x += nextPageBounds.width + gap;
          space.width -= nextPageBounds.width + gap;
        } else if (nextPageBounds.width === space.width) {
          space.y += nextPageBounds.height + gap;
          space.height -= nextPageBounds.height + gap;
        } else {
          spaces.push(
            new Box(
              space.x + (nextPageBounds.width + gap),
              space.y,
              space.width - (nextPageBounds.width + gap),
              nextPageBounds.height
            )
          );
          space.y += nextPageBounds.height + gap;
          space.height -= nextPageBounds.height + gap;
        }
        break;
      }
    }
    const commonAfter = Box.Common(shapeClustersToPack.map((s) => s.nextPageBounds));
    const centerDelta = Vec.Sub(commonBounds.center, commonAfter.center);
    const changes = [];
    for (const { shapes: shapes2, pageBounds, nextPageBounds } of shapeClustersToPack) {
      const delta = Vec.Sub(nextPageBounds.point, pageBounds.point).add(centerDelta);
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapeParentTransform(shape);
          if (parentTransform)
            shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
    }
    if (changes.length) {
      this.updateShapes(changes);
    }
    return this;
  }
  /**
   * Align shape positions.
   *
   * @example
   * ```ts
   * editor.alignShapes([box1, box2], 'left')
   * editor.alignShapes(editor.getSelectedShapeIds(), 'left')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to align.
   * @param operation - The align operation to apply.
   *
   * @public
   */
  alignShapes(shapes, operation) {
    var _a5, _b;
    if (this.getIsReadonly())
      return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToAlignFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToAlign = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToAlignFirstPass) {
      if (visited.has(shape.id))
        continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds)
        continue;
      if (!((_b = (_a5 = this.getShapeUtil(shape)).canBeLaidOut) == null ? void 0 : _b.call(_a5, shape, {
        type: "align",
        shapes: shapesToAlignFirstPass
      }))) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToAlignFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds)
        continue;
      shapeClustersToAlign.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToAlign.length < 2)
      return this;
    const commonBounds = Box.Common(allBounds);
    const changes = [];
    shapeClustersToAlign.forEach(({ shapes: shapes2, pageBounds }) => {
      const delta = new Vec();
      switch (operation) {
        case "top": {
          delta.y = commonBounds.minY - pageBounds.minY;
          break;
        }
        case "center-vertical": {
          delta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2;
          break;
        }
        case "bottom": {
          delta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height;
          break;
        }
        case "left": {
          delta.x = commonBounds.minX - pageBounds.minX;
          break;
        }
        case "center-horizontal": {
          delta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2;
          break;
        }
        case "right": {
          delta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width;
          break;
        }
      }
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform)
            shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
    });
    this.updateShapes(changes);
    return this;
  }
  /**
   * Distribute shape positions.
   *
   * @example
   * ```ts
   * editor.distributeShapes([box1, box2], 'horizontal')
   * editor.distributeShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to distribute.
   * @param operation - Whether to distribute shapes horizontally or vertically.
   *
   * @public
   */
  distributeShapes(shapes, operation) {
    var _a5, _b;
    if (this.getIsReadonly())
      return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToDistributeFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToDistribute = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToDistributeFirstPass) {
      if (visited.has(shape.id))
        continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds)
        continue;
      if (!((_b = (_a5 = this.getShapeUtil(shape)).canBeLaidOut) == null ? void 0 : _b.call(_a5, shape, {
        type: "distribute",
        shapes: shapesToDistributeFirstPass
      }))) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToDistributeFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds)
        continue;
      shapeClustersToDistribute.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToDistribute.length < 3)
      return this;
    let val;
    let min4;
    let max3;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min4 = "minX";
      max3 = "maxX";
      dim = "width";
    } else {
      val = "y";
      min4 = "minY";
      max3 = "maxY";
      dim = "height";
    }
    const changes = [];
    const first2 = shapeClustersToDistribute.sort((a, b) => a.pageBounds[min4] - b.pageBounds[min4])[0];
    const last22 = shapeClustersToDistribute.sort((a, b) => b.pageBounds[max3] - a.pageBounds[max3])[0];
    if (first2 === last22) {
      const excludedShapeIds = new Set(first2.shapes.map((s) => s.id));
      return this.distributeShapes(
        ids.filter((id) => !excludedShapeIds.has(id)),
        operation
      );
    }
    const shapeClustersToMove = shapeClustersToDistribute.filter((shape) => shape !== first2 && shape !== last22).sort((a, b) => {
      if (a.pageBounds[min4] === b.pageBounds[min4]) {
        return a.shapes[0].id < b.shapes[0].id ? -1 : 1;
      }
      return a.pageBounds[min4] - b.pageBounds[min4];
    });
    const maxFirst = first2.pageBounds[max3];
    const range = last22.pageBounds[min4] - maxFirst;
    const summedShapeDimensions = shapeClustersToMove.reduce((acc, s) => acc + s.pageBounds[dim], 0);
    const gap = (range - summedShapeDimensions) / (shapeClustersToMove.length + 1);
    for (let v = maxFirst + gap, i = 0; i < shapeClustersToMove.length; i++) {
      const { shapes: shapes2, pageBounds } = shapeClustersToMove[i];
      const delta = new Vec();
      delta[val] = v - pageBounds[val];
      if (v + pageBounds[dim] > last22.pageBounds[max3] - 1) {
        delta[val] = last22.pageBounds[max3] - pageBounds[max3] - 1;
      }
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform)
            shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
      v += pageBounds[dim] + gap;
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Stretch shape sizes and positions to fill their common bounding box.
   *
   * @example
   * ```ts
   * editor.stretchShapes([box1, box2], 'horizontal')
   * editor.stretchShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stretch.
   * @param operation - Whether to stretch shapes horizontally or vertically.
   *
   * @public
   */
  stretchShapes(shapes, operation) {
    var _a5, _b;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (this.getIsReadonly())
      return this;
    const shapesToStretchFirstPass = compact(ids.map((id) => this.getShape(id))).filter(
      (s) => {
        var _a6;
        return ((_a6 = this.getShapePageTransform(s)) == null ? void 0 : _a6.rotation()) % (PI / 2) === 0;
      }
    );
    const shapeClustersToStretch = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToStretchFirstPass) {
      if (visited.has(shape.id))
        continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds)
        continue;
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      if (!((_b = (_a5 = this.getShapeUtil(shape)).canBeLaidOut) == null ? void 0 : _b.call(_a5, shape, {
        type: "stretch",
        shapes: shapesToStretchFirstPass
      }))) {
        continue;
      }
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToStretchFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds)
        continue;
      shapeClustersToStretch.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToStretch.length < 2)
      return this;
    const commonBounds = Box.Common(allBounds);
    let val;
    let min4;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min4 = "minX";
      dim = "width";
    } else {
      val = "y";
      min4 = "minY";
      dim = "height";
    }
    this.run(() => {
      shapeClustersToStretch.forEach(({ shapes: shapes2, pageBounds }) => {
        const localOffset = new Vec();
        localOffset[val] = commonBounds[min4] - pageBounds[min4];
        const scaleOrigin = pageBounds.center.clone();
        scaleOrigin[val] = commonBounds[min4];
        const scale = new Vec(1, 1);
        scale[val] = commonBounds[dim] / pageBounds[dim];
        for (const shape of shapes2) {
          const shapeLocalOffset = localOffset.clone();
          const parentTransform = this.getShapeParentTransform(shape);
          if (parentTransform)
            localOffset.rot(-parentTransform.rotation());
          shapeLocalOffset.add(shape);
          const changes = this.getChangesToTranslateShape(shape, shapeLocalOffset);
          this.updateShape(changes);
          this.resizeShape(shape.id, scale, {
            initialBounds: this.getShapeGeometry(shape).bounds,
            scaleOrigin,
            isAspectRatioLocked: this.getShapeUtil(shape).isAspectRatioLocked(shape),
            scaleAxisRotation: 0
          });
        }
      });
    });
    return this;
  }
  /**
   * Resize a shape.
   *
   * @param shape - The shape (or the shape id of the shape) to resize.
   * @param scale - The scale factor to apply to the shape.
   * @param opts - Additional options.
   *
   * @public
   */
  resizeShape(shape, scale, opts = {}) {
    var _a5, _b, _c;
    const id = typeof shape === "string" ? shape : shape.id;
    if (this.getIsReadonly())
      return this;
    if (!Number.isFinite(scale.x))
      scale = new Vec(1, scale.y);
    if (!Number.isFinite(scale.y))
      scale = new Vec(scale.x, 1);
    const initialShape = opts.initialShape ?? this.getShape(id);
    if (!initialShape)
      return this;
    const scaleOrigin = opts.scaleOrigin ?? ((_a5 = this.getShapePageBounds(id)) == null ? void 0 : _a5.center);
    if (!scaleOrigin)
      return this;
    const pageTransform = opts.initialPageTransform ? Mat.Cast(opts.initialPageTransform) : this.getShapePageTransform(id);
    if (!pageTransform)
      return this;
    const pageRotation = pageTransform.rotation();
    if (pageRotation == null)
      return this;
    const scaleAxisRotation = opts.scaleAxisRotation ?? pageRotation;
    const initialBounds = opts.initialBounds ?? this.getShapeGeometry(id).bounds;
    if (!initialBounds)
      return this;
    const isAspectRatioLocked = opts.isAspectRatioLocked ?? this.getShapeUtil(initialShape).isAspectRatioLocked(initialShape);
    if (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {
      return this._resizeUnalignedShape(id, scale, {
        ...opts,
        initialBounds,
        scaleOrigin,
        scaleAxisRotation,
        initialPageTransform: pageTransform,
        isAspectRatioLocked,
        initialShape
      });
    }
    const util = this.getShapeUtil(initialShape);
    if (isAspectRatioLocked) {
      if (Math.abs(scale.x) > Math.abs(scale.y)) {
        scale = new Vec(scale.x, Math.sign(scale.y) * Math.abs(scale.x));
      } else {
        scale = new Vec(Math.sign(scale.x) * Math.abs(scale.y), scale.y);
      }
    }
    let didResize = false;
    if (util.onResize && util.canResize(initialShape)) {
      const newPagePoint = this._scalePagePoint(
        Mat.applyToPoint(pageTransform, new Vec(0, 0)),
        scaleOrigin,
        scale,
        scaleAxisRotation
      );
      const newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint);
      const myScale = new Vec(scale.x, scale.y);
      const areWidthAndHeightAlignedWithCorrectAxis = approximately(
        (pageRotation - scaleAxisRotation) % Math.PI,
        0
      );
      myScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y;
      myScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x;
      const initialPagePoint = Mat.applyToPoint(pageTransform, new Vec());
      const { x, y } = this.getPointInParentSpace(initialShape.id, initialPagePoint);
      let workingShape = initialShape;
      if (!opts.skipStartAndEndCallbacks) {
        workingShape = applyPartialToRecordWithProps(
          initialShape,
          ((_b = util.onResizeStart) == null ? void 0 : _b.call(util, initialShape)) ?? void 0
        );
      }
      const resizedShape = util.onResize(
        { ...initialShape, x, y },
        {
          newPoint: newLocalPoint,
          handle: opts.dragHandle ?? "bottom_right",
          // don't set isSingle to true for children
          mode: opts.mode ?? "scale_shape",
          scaleX: myScale.x,
          scaleY: myScale.y,
          initialBounds,
          initialShape
        }
      );
      if (resizedShape) {
        didResize = true;
      }
      workingShape = applyPartialToRecordWithProps(workingShape, {
        id,
        type: initialShape.type,
        x: newLocalPoint.x,
        y: newLocalPoint.y,
        ...resizedShape
      });
      if (!opts.skipStartAndEndCallbacks) {
        workingShape = applyPartialToRecordWithProps(
          workingShape,
          ((_c = util.onResizeEnd) == null ? void 0 : _c.call(util, initialShape, workingShape)) ?? void 0
        );
      }
      this.updateShapes([workingShape]);
    }
    if (!didResize) {
      const initialPageCenter = Mat.applyToPoint(pageTransform, initialBounds.center);
      const newPageCenter = this._scalePagePoint(
        initialPageCenter,
        scaleOrigin,
        scale,
        scaleAxisRotation
      );
      const initialPageCenterInParentSpace = this.getPointInParentSpace(
        initialShape.id,
        initialPageCenter
      );
      const newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter);
      const delta = Vec.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace);
      this.updateShapes([
        {
          id,
          type: initialShape.type,
          x: initialShape.x + delta.x,
          y: initialShape.y + delta.y
        }
      ]);
    }
    return this;
  }
  /** @internal */
  _scalePagePoint(point, scaleOrigin, scale, scaleAxisRotation) {
    const relativePoint = Vec.RotWith(point, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin);
    const newRelativePagePoint = Vec.MulV(relativePoint, scale);
    const destination = Vec.Add(newRelativePagePoint, scaleOrigin).rotWith(
      scaleOrigin,
      scaleAxisRotation
    );
    return destination;
  }
  /** @internal */
  _resizeUnalignedShape(id, scale, options2) {
    const { type } = options2.initialShape;
    const shapeScale = new Vec(scale.x, scale.y);
    if (Math.abs(scale.x) > Math.abs(scale.y)) {
      shapeScale.x = Math.sign(scale.x) * Math.abs(scale.y);
    } else {
      shapeScale.y = Math.sign(scale.y) * Math.abs(scale.x);
    }
    this.resizeShape(id, shapeScale, {
      initialShape: options2.initialShape,
      initialBounds: options2.initialBounds,
      isAspectRatioLocked: options2.isAspectRatioLocked
    });
    if (Math.sign(scale.x) * Math.sign(scale.y) < 0) {
      let { rotation } = Mat.Decompose(options2.initialPageTransform);
      rotation -= 2 * rotation;
      this.updateShapes([{ id, type, rotation }]);
    }
    const preScaleShapePageCenter = Mat.applyToPoint(
      options2.initialPageTransform,
      options2.initialBounds.center
    );
    const postScaleShapePageCenter = this._scalePagePoint(
      preScaleShapePageCenter,
      options2.scaleOrigin,
      scale,
      options2.scaleAxisRotation
    );
    const pageBounds = this.getShapePageBounds(id);
    const pageTransform = this.getShapePageTransform(id);
    const currentPageCenter = pageBounds.center;
    const shapePageTransformOrigin = pageTransform.point();
    if (!currentPageCenter || !shapePageTransformOrigin)
      return this;
    const pageDelta = Vec.Sub(postScaleShapePageCenter, currentPageCenter);
    const postScaleShapePagePoint = Vec.Add(shapePageTransformOrigin, pageDelta);
    const { x, y } = this.getPointInParentSpace(id, postScaleShapePagePoint);
    this.updateShapes([{ id, type, x, y }]);
    return this;
  }
  /**
   * Get the initial meta value for a shape.
   *
   * @example
   * ```ts
   * editor.getInitialMetaForShape = (shape) => {
   *   if (shape.type === 'note') {
   *     return { createdBy: myCurrentUser.id }
   *   }
   * }
   * ```
   *
   * @param shape - The shape to get the initial meta for.
   *
   * @public
   */
  getInitialMetaForShape(_shape) {
    return {};
  }
  /**
   * Create a single shape.
   *
   * @example
   * ```ts
   * editor.createShape(myShape)
   * editor.createShape({ id: 'box1', type: 'text', props: { richText: toRichText("ok") } })
   * ```
   *
   * @param shape - The shape (or shape partial) to create.
   *
   * @public
   */
  createShape(shape) {
    this.createShapes([shape]);
    return this;
  }
  /**
   * Create shapes.
   *
   * @example
   * ```ts
   * editor.createShapes([myShape])
   * editor.createShapes([{ id: 'box1', type: 'text', props: { richText: toRichText("ok") } }])
   * ```
   *
   * @param shapes - The shapes (or shape partials) to create.
   *
   * @public
   */
  createShapes(shapes) {
    if (!Array.isArray(shapes)) {
      throw Error("Editor.createShapes: must provide an array of shapes or shape partials");
    }
    if (this.getIsReadonly())
      return this;
    if (shapes.length <= 0)
      return this;
    const currentPageShapeIds = this.getCurrentPageShapeIds();
    const maxShapesReached = shapes.length + currentPageShapeIds.size > this.options.maxShapesPerPage;
    if (maxShapesReached) {
      alertMaxShapes(this);
      return this;
    }
    const focusedGroupId = this.getFocusedGroupId();
    this.run(() => {
      var _a5, _b;
      const currentPageShapesSorted = this.getCurrentPageShapesSorted();
      const partials = shapes.map((partial) => {
        if (!partial.id) {
          partial = { id: createShapeId(), ...partial };
        }
        if (!partial.parentId || !(this.store.has(partial.parentId) || shapes.some((p) => p.id === partial.parentId))) {
          let parentId = this.getFocusedGroupId();
          for (let i = currentPageShapesSorted.length - 1; i >= 0; i--) {
            const parent = currentPageShapesSorted[i];
            if (!this.isShapeHidden(parent) && this.getShapeUtil(parent).canReceiveNewChildrenOfType(parent, partial.type) && this.isPointInShape(
              parent,
              // If no parent is provided, then we can treat the
              // shape's provided x/y as being in the page's space.
              { x: partial.x ?? 0, y: partial.y ?? 0 },
              {
                margin: 0,
                hitInside: true
              }
            )) {
              parentId = parent.id;
              break;
            }
          }
          const prevParentId = partial.parentId;
          if (parentId === partial.id) {
            parentId = focusedGroupId;
          }
          if (parentId !== prevParentId) {
            partial = { ...partial };
            partial.parentId = parentId;
            if (isShapeId(parentId)) {
              const point = this.getPointInShapeSpace(this.getShape(parentId), {
                x: partial.x ?? 0,
                y: partial.y ?? 0
              });
              partial.x = point.x;
              partial.y = point.y;
              partial.rotation = -this.getShapePageTransform(parentId).rotation() + (partial.rotation ?? 0);
            }
          }
        }
        return partial;
      });
      const parentIndices = /* @__PURE__ */ new Map();
      const shapeRecordsToCreate = [];
      const { opacityForNextShape } = this.getInstanceState();
      for (const partial of partials) {
        const util = this.getShapeUtil(partial);
        let index3 = partial.index;
        if (!index3) {
          const parentId = partial.parentId ?? focusedGroupId;
          if (!parentIndices.has(parentId)) {
            parentIndices.set(parentId, this.getHighestIndexForParent(parentId));
          }
          index3 = parentIndices.get(parentId);
          parentIndices.set(parentId, getIndexAbove(index3));
        }
        const initialProps = util.getDefaultProps();
        for (const [style2, propKey] of this.styleProps[partial.type]) {
          ;
          initialProps[propKey] = this.getStyleForNextShape(style2);
        }
        let shapeRecordToCreate = this.store.schema.types.shape.create({
          ...partial,
          index: index3,
          opacity: partial.opacity ?? opacityForNextShape,
          parentId: partial.parentId ?? focusedGroupId,
          props: "props" in partial ? { ...initialProps, ...partial.props } : initialProps
        });
        if (shapeRecordToCreate.index === void 0) {
          throw Error("no index!");
        }
        const next = (_b = (_a5 = this.getShapeUtil(shapeRecordToCreate)).onBeforeCreate) == null ? void 0 : _b.call(_a5, shapeRecordToCreate);
        if (next) {
          shapeRecordToCreate = next;
        }
        shapeRecordsToCreate.push(shapeRecordToCreate);
      }
      shapeRecordsToCreate.forEach((shape) => {
        shape.meta = {
          ...this.getInitialMetaForShape(shape),
          ...shape.meta
        };
      });
      this.store.put(shapeRecordsToCreate);
    });
    return this;
  }
  /**
   * Animate a shape.
   *
   * @example
   * ```ts
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 })
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 }, { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partial - The shape partial to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShape(partial, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    return this.animateShapes([partial], opts);
  }
  /**
   * Animate shapes.
   *
   * @example
   * ```ts
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }], { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partials - The shape partials to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShapes(partials, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    if (!opts.animation)
      return this;
    const { duration = 500, easing = EASINGS.linear } = opts.animation;
    const animationId = uniqueId();
    let remaining = duration;
    let t2;
    const animations = [];
    let partial, result;
    for (let i = 0, n = partials.length; i < n; i++) {
      partial = partials[i];
      if (!partial)
        continue;
      const shape = this.getShape(partial.id);
      if (!shape)
        continue;
      result = {
        start: structuredClone(shape),
        end: applyPartialToRecordWithProps(structuredClone(shape), partial)
      };
      animations.push(result);
      this.animatingShapes.set(shape.id, animationId);
    }
    const handleTick = (elapsed) => {
      var _a5, _b;
      remaining -= elapsed;
      if (remaining < 0) {
        const { animatingShapes: animatingShapes2 } = this;
        const partialsToUpdate = partials.filter(
          (p) => p && animatingShapes2.get(p.id) === animationId
        );
        if (partialsToUpdate.length) {
          this.updateShapes(partialsToUpdate);
        }
        this.off("tick", handleTick);
        return;
      }
      t2 = easing(1 - remaining / duration);
      const { animatingShapes } = this;
      const updates = [];
      let animationIdForShape;
      for (let i = 0, n = animations.length; i < n; i++) {
        const { start: start2, end: end2 } = animations[i];
        animationIdForShape = animatingShapes.get(start2.id);
        if (animationIdForShape !== animationId)
          continue;
        updates.push({
          ...end2,
          x: start2.x + (end2.x - start2.x) * t2,
          y: start2.y + (end2.y - start2.y) * t2,
          opacity: start2.opacity + (end2.opacity - start2.opacity) * t2,
          rotation: start2.rotation + (end2.rotation - start2.rotation) * t2,
          props: ((_b = (_a5 = this.getShapeUtil(end2)).getInterpolatedProps) == null ? void 0 : _b.call(_a5, start2, end2, t2)) ?? end2.props
        });
      }
      this._updateShapes(updates);
    };
    this.on("tick", handleTick);
    return this;
  }
  groupShapes(shapes, opts = {}) {
    var _a5;
    const { groupId = createShapeId(), select = true } = opts;
    if (!Array.isArray(shapes)) {
      throw Error("Editor.groupShapes: must provide an array of shapes or shape ids");
    }
    if (this.getIsReadonly())
      return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length <= 1)
      return this;
    const shapesToGroup = compact(
      (this._shouldIgnoreShapeLock ? ids : this._getUnlockedShapeIds(ids)).map(
        (id) => this.getShape(id)
      )
    );
    const sortedShapeIds = shapesToGroup.sort(sortByIndex).map((s) => s.id);
    const pageBounds = Box.Common(compact(shapesToGroup.map((id) => this.getShapePageBounds(id))));
    const { x, y } = pageBounds.point;
    const parentId = this.findCommonAncestor(shapesToGroup) ?? this.getCurrentPageId();
    if (this.getCurrentToolId() !== "select")
      return this;
    if (!this.isIn("select.idle")) {
      this.cancel();
    }
    const shapesWithRootParent = shapesToGroup.filter((shape) => shape.parentId === parentId).sort(sortByIndex);
    const highestIndex = (_a5 = shapesWithRootParent[shapesWithRootParent.length - 1]) == null ? void 0 : _a5.index;
    this.run(() => {
      this.createShapes([
        {
          id: groupId,
          type: "group",
          parentId,
          index: highestIndex,
          x,
          y,
          opacity: 1,
          props: {}
        }
      ]);
      this.reparentShapes(sortedShapeIds, groupId);
      if (select) {
        this.select(groupId);
      }
    });
    return this;
  }
  ungroupShapes(shapes, opts = {}) {
    if (this.getIsReadonly())
      return this;
    const { select = true } = opts;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToUngroup = compact(
      (this._shouldIgnoreShapeLock ? ids : this._getUnlockedShapeIds(ids)).map(
        (id) => this.getShape(id)
      )
    );
    if (shapesToUngroup.length === 0)
      return this;
    if (this.getCurrentToolId() !== "select")
      return this;
    if (!this.isIn("select.idle")) {
      this.cancel();
    }
    const idsToSelect = /* @__PURE__ */ new Set();
    const groups = [];
    shapesToUngroup.forEach((shape) => {
      if (this.isShapeOfType(shape, "group")) {
        groups.push(shape);
      } else {
        idsToSelect.add(shape.id);
      }
    });
    if (groups.length === 0)
      return this;
    this.run(() => {
      let group;
      for (let i = 0, n = groups.length; i < n; i++) {
        group = groups[i];
        const childIds = this.getSortedChildIdsForParent(group.id);
        for (let j = 0, n2 = childIds.length; j < n2; j++) {
          idsToSelect.add(childIds[j]);
        }
        this.reparentShapes(childIds, group.parentId, group.index);
      }
      this.deleteShapes(groups.map((group2) => group2.id));
      if (select) {
        this.select(...idsToSelect);
      }
    });
    return this;
  }
  /**
   * Update a shape using a partial of the shape.
   *
   * @example
   * ```ts
   * editor.updateShape({ id: 'box1', type: 'geo', props: { w: 100, h: 100 } })
   * ```
   *
   * @param partial - The shape partial to update.
   *
   * @public
   */
  updateShape(partial) {
    this.updateShapes([partial]);
    return this;
  }
  /**
   * Update shapes using partials of each shape.
   *
   * @example
   * ```ts
   * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])
   * ```
   *
   * @param partials - The shape partials to update.
   *
   * @public
   */
  updateShapes(partials) {
    const compactedPartials = Array(partials.length);
    for (let i = 0, n = partials.length; i < n; i++) {
      const partial = partials[i];
      if (!partial)
        continue;
      const shape = this.getShape(partial.id);
      if (!shape)
        continue;
      if (!this._shouldIgnoreShapeLock) {
        if (shape.isLocked) {
          if (!(Object.hasOwn(partial, "isLocked") && !partial.isLocked)) {
            continue;
          }
        } else if (this.isShapeOrAncestorLocked(shape)) {
          continue;
        }
      }
      this.animatingShapes.delete(partial.id);
      compactedPartials.push(partial);
    }
    this._updateShapes(compactedPartials);
    return this;
  }
  /** @internal */
  _updateShapes(_partials) {
    if (this.getIsReadonly())
      return;
    this.run(() => {
      var _a5, _b;
      const updates = [];
      let shape;
      let updated;
      for (let i = 0, n = _partials.length; i < n; i++) {
        const partial = _partials[i];
        if (!partial)
          continue;
        shape = this.getShape(partial.id);
        if (!shape)
          continue;
        updated = applyPartialToRecordWithProps(shape, partial);
        if (updated === shape)
          continue;
        updated = ((_b = (_a5 = this.getShapeUtil(shape)).onBeforeUpdate) == null ? void 0 : _b.call(_a5, shape, updated)) ?? updated;
        updates.push(updated);
      }
      this.store.put(updates);
    });
  }
  /** @internal */
  _getUnlockedShapeIds(ids) {
    return ids.filter((id) => {
      var _a5;
      return !((_a5 = this.getShape(id)) == null ? void 0 : _a5.isLocked);
    });
  }
  deleteShapes(_ids) {
    if (this.getIsReadonly())
      return this;
    if (!Array.isArray(_ids)) {
      throw Error("Editor.deleteShapes: must provide an array of shapes or shapeIds");
    }
    const shapeIds = typeof _ids[0] === "string" ? _ids : _ids.map((s) => s.id);
    const shapeIdsToDelete = this._shouldIgnoreShapeLock ? shapeIds : this._getUnlockedShapeIds(shapeIds);
    if (shapeIdsToDelete.length === 0)
      return this;
    const allShapeIdsToDelete = new Set(shapeIdsToDelete);
    for (const id of shapeIdsToDelete) {
      this.visitDescendants(id, (childId) => {
        allShapeIdsToDelete.add(childId);
      });
    }
    return this.run(() => this.store.remove([...allShapeIdsToDelete]));
  }
  deleteShape(_id) {
    this.deleteShapes([typeof _id === "string" ? _id : _id.id]);
    return this;
  }
  /* --------------------- Styles --------------------- */
  /**
   * Get all the current styles among the users selected shapes
   *
   * @internal
   */
  _extractSharedStyles(shape, sharedStyleMap) {
    if (this.isShapeOfType(shape, "group")) {
      const childIds = this._parentIdsToChildIds.get()[shape.id];
      if (!childIds)
        return;
      for (let i = 0, n = childIds.length; i < n; i++) {
        this._extractSharedStyles(this.getShape(childIds[i]), sharedStyleMap);
      }
    } else {
      for (const [style2, propKey] of this.styleProps[shape.type]) {
        sharedStyleMap.applyValue(style2, getOwnProperty(shape.props, propKey));
      }
    }
  }
  _getSelectionSharedStyles() {
    const selectedShapes = this.getSelectedShapes();
    const sharedStyles = new SharedStyleMap();
    for (const selectedShape of selectedShapes) {
      this._extractSharedStyles(selectedShape, sharedStyles);
    }
    return sharedStyles;
  }
  /**
   * Get the style for the next shape.
   *
   * @example
   * ```ts
   * const color = editor.getStyleForNextShape(DefaultColorStyle)
   * ```
   *
   * @param style - The style to get.
   *
   * @public */
  getStyleForNextShape(style2) {
    const value = this.getInstanceState().stylesForNextShape[style2.id];
    return value === void 0 ? style2.defaultValue : value;
  }
  getShapeStyleIfExists(shape, style2) {
    const styleKey = this.styleProps[shape.type].get(style2);
    if (styleKey === void 0)
      return void 0;
    return getOwnProperty(shape.props, styleKey);
  }
  getSharedStyles() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      return this._getSelectionSharedStyles();
    }
    const currentTool = this.root.getCurrent();
    const styles = new SharedStyleMap();
    if (!currentTool)
      return styles;
    if (currentTool.shapeType) {
      if (currentTool.shapeType === "frame" && !this.getShapeUtil("frame").options.showColors) {
        for (const style2 of this.styleProps[currentTool.shapeType].keys()) {
          if (style2.id === "tldraw:color")
            continue;
          styles.applyValue(style2, this.getStyleForNextShape(style2));
        }
      } else {
        for (const style2 of this.styleProps[currentTool.shapeType].keys()) {
          styles.applyValue(style2, this.getStyleForNextShape(style2));
        }
      }
    }
    return styles;
  }
  getSharedOpacity() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      const shapesToCheck = [];
      const addShape = (shapeId) => {
        const shape = this.getShape(shapeId);
        if (!shape)
          return;
        if (this.isShapeOfType(shape, "group")) {
          for (const childId of this.getSortedChildIdsForParent(shape.id)) {
            addShape(childId);
          }
        } else {
          shapesToCheck.push(shape);
        }
      };
      for (const shapeId of this.getSelectedShapeIds()) {
        addShape(shapeId);
      }
      let opacity = null;
      for (const shape of shapesToCheck) {
        if (opacity === null) {
          opacity = shape.opacity;
        } else if (opacity !== shape.opacity) {
          return { type: "mixed" };
        }
      }
      if (opacity !== null)
        return { type: "shared", value: opacity };
    }
    return { type: "shared", value: this.getInstanceState().opacityForNextShape };
  }
  /**
   * Set the opacity for the next shapes. This will effect subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForNextShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   * @param historyOptions - The history options for the change.
   */
  setOpacityForNextShapes(opacity, historyOptions) {
    this.updateInstanceState({ opacityForNextShape: opacity }, historyOptions);
    return this;
  }
  /**
   * Set the current opacity. This will effect any selected shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForSelectedShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   */
  setOpacityForSelectedShapes(opacity) {
    const selectedShapes = this.getSelectedShapes();
    if (selectedShapes.length > 0) {
      const shapesToUpdate = [];
      const addShapeById = (shape) => {
        if (this.isShapeOfType(shape, "group")) {
          const childIds = this.getSortedChildIdsForParent(shape);
          for (const childId of childIds) {
            addShapeById(this.getShape(childId));
          }
        } else {
          shapesToUpdate.push(shape);
        }
      };
      for (const id of selectedShapes) {
        addShapeById(id);
      }
      this.updateShapes(
        shapesToUpdate.map((shape) => {
          return {
            id: shape.id,
            type: shape.type,
            opacity
          };
        })
      );
    }
    return this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp} for the next shapes. This change will be applied to subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red')
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red', { ephemeral: true })
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   * @param historyOptions - The history options for the change.
   *
   * @public
   */
  setStyleForNextShapes(style2, value, historyOptions) {
    const stylesForNextShape = this.getInstanceState().stylesForNextShape;
    this.updateInstanceState(
      { stylesForNextShape: { ...stylesForNextShape, [style2.id]: value } },
      historyOptions
    );
    return this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp}. This change will be applied to the currently selected shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   *
   * @public
   */
  setStyleForSelectedShapes(style2, value) {
    const selectedShapes = this.getSelectedShapes();
    if (selectedShapes.length > 0) {
      const updates = [];
      const addShapeById = (shape) => {
        if (this.isShapeOfType(shape, "group")) {
          const childIds = this.getSortedChildIdsForParent(shape.id);
          for (const childId of childIds) {
            addShapeById(this.getShape(childId));
          }
        } else {
          const util = this.getShapeUtil(shape);
          const stylePropKey = this.styleProps[shape.type].get(style2);
          if (stylePropKey) {
            const shapePartial = {
              id: shape.id,
              type: shape.type,
              props: { [stylePropKey]: value }
            };
            updates.push({
              util,
              originalShape: shape,
              updatePartial: shapePartial
            });
          }
        }
      };
      for (const shape of selectedShapes) {
        addShapeById(shape);
      }
      this.updateShapes(updates.map(({ updatePartial }) => updatePartial));
    }
    return this;
  }
  /**
   * Register an external asset handler. This handler will be called when the editor needs to
   * create an asset for some external content, like an image/video file or a bookmark URL. For
   * example, the 'file' type handler will be called when a user drops an image onto the canvas.
   *
   * The handler should extract any relevant metadata for the asset, upload it to blob storage
   * using {@link Editor.uploadAsset} if needed, and return the asset with the metadata & uploaded
   * URL.
   *
   * @example
   * ```ts
   * editor.registerExternalAssetHandler('file', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalAssetHandler(type, handler) {
    this.externalAssetContentHandlers[type] = handler;
    return this;
  }
  /**
   * Register a temporary preview of an asset. This is useful for showing a ghost image of
   * something that is being uploaded. Retrieve the placeholder with
   * {@link Editor.getTemporaryAssetPreview}. Placeholders last for 3 minutes by default, but this
   * can be configured using
   *
   * @example
   * ```ts
   * editor.createTemporaryAssetPreview(assetId, file)
   * ```
   *
   * @param assetId - The asset's id.
   * @param file - The raw file.
   *
   * @public
   */
  createTemporaryAssetPreview(assetId, file) {
    if (this.temporaryAssetPreview.has(assetId)) {
      return this.temporaryAssetPreview.get(assetId);
    }
    const objectUrl = URL.createObjectURL(file);
    this.temporaryAssetPreview.set(assetId, objectUrl);
    setTimeout(() => {
      this.temporaryAssetPreview.delete(assetId);
      URL.revokeObjectURL(objectUrl);
    }, this.options.temporaryAssetPreviewLifetimeMs);
    return objectUrl;
  }
  /**
   * Get temporary preview of an asset. This is useful for showing a ghost
   * image of something that is being uploaded.
   *
   * @example
   * ```ts
   * editor.getTemporaryAssetPreview('someId')
   * ```
   *
   * @param assetId - The asset's id.
   *
   * @public
   */
  getTemporaryAssetPreview(assetId) {
    return this.temporaryAssetPreview.get(assetId);
  }
  /**
   * Get an asset for an external asset content type.
   *
   * @example
   * ```ts
   * const asset = await editor.getAssetForExternalContent({ type: 'file', file: myFile })
   * const asset = await editor.getAssetForExternalContent({ type: 'url', url: myUrl })
   * ```
   *
   * @param info - Info about the external content.
   * @returns The asset.
   */
  async getAssetForExternalContent(info) {
    var _a5, _b;
    return await ((_b = (_a5 = this.externalAssetContentHandlers)[info.type]) == null ? void 0 : _b.call(_a5, info));
  }
  hasExternalAssetHandler(type) {
    return !!this.externalAssetContentHandlers[type];
  }
  /**
   * Register an external content handler. This handler will be called when the editor receives
   * external content of the provided type. For example, the 'image' type handler will be called
   * when a user drops an image onto the canvas.
   *
   * @example
   * ```ts
   * editor.registerExternalContentHandler('text', myHandler)
   * ```
   * @example
   * ```ts
   * editor.registerExternalContentHandler<'embed', MyEmbedType>('embed', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalContentHandler(type, handler) {
    this.externalContentHandlers[type] = handler;
    return this;
  }
  /**
   * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.
   *
   * @param info - Info about the external content.
   */
  async putExternalContent(info) {
    var _a5, _b;
    return (_b = (_a5 = this.externalContentHandlers)[info.type]) == null ? void 0 : _b.call(_a5, info);
  }
  /**
   * Get content that can be exported for the given shape ids.
   *
   * @param shapes - The shapes (or shape ids) to get content for.
   *
   * @returns The exported content.
   *
   * @public
   */
  getContentFromCurrentPage(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (!ids)
      return;
    if (ids.length === 0)
      return;
    const shapeIds = this.getShapeAndDescendantIds(ids);
    return withIsolatedShapes(this, shapeIds, (bindingIdsToKeep) => {
      const bindings = [];
      for (const id of bindingIdsToKeep) {
        const binding = this.getBinding(id);
        if (!binding)
          continue;
        bindings.push(binding);
      }
      const rootShapeIds = [];
      const shapes2 = [];
      for (const shapeId of shapeIds) {
        const shape = this.getShape(shapeId);
        if (!shape)
          continue;
        const isRootShape = !shapeIds.has(shape.parentId);
        if (isRootShape) {
          const pageTransform = this.getShapePageTransform(shape.id);
          const pagePoint = pageTransform.point();
          shapes2.push({
            ...shape,
            x: pagePoint.x,
            y: pagePoint.y,
            rotation: pageTransform.rotation(),
            parentId: this.getCurrentPageId()
          });
          rootShapeIds.push(shape.id);
        } else {
          shapes2.push(shape);
        }
      }
      const assets = [];
      const seenAssetIds = /* @__PURE__ */ new Set();
      for (const shape of shapes2) {
        if (!("assetId" in shape.props))
          continue;
        const assetId = shape.props.assetId;
        if (!assetId || seenAssetIds.has(assetId))
          continue;
        seenAssetIds.add(assetId);
        const asset = this.getAsset(assetId);
        if (!asset)
          continue;
        assets.push(asset);
      }
      return {
        schema: this.store.schema.serialize(),
        shapes: shapes2,
        rootShapeIds,
        bindings,
        assets
      };
    });
  }
  async resolveAssetsInContent(content) {
    if (!content)
      return void 0;
    const assets = [];
    await Promise.allSettled(
      content.assets.map(async (asset) => {
        var _a5, _b, _c;
        if ((asset.type === "image" || asset.type === "video") && !((_a5 = asset.props.src) == null ? void 0 : _a5.startsWith("data:image")) && !((_b = asset.props.src) == null ? void 0 : _b.startsWith("data:video")) && !((_c = asset.props.src) == null ? void 0 : _c.startsWith("http"))) {
          const assetWithDataUrl = structuredClone(asset);
          const objectUrl = await this.store.props.assets.resolve(asset, {
            screenScale: 1,
            steppedScreenScale: 1,
            dpr: 1,
            networkEffectiveType: null,
            shouldResolveToOriginal: true
          });
          assetWithDataUrl.props.src = await FileHelpers.blobToDataUrl(
            await fetch(objectUrl).then((r) => r.blob())
          );
          assets.push(assetWithDataUrl);
        } else {
          assets.push(asset);
        }
      })
    );
    content.assets = assets;
    return content;
  }
  /**
   * Place content into the editor.
   *
   * @param content - The content.
   * @param opts - Options for placing the content.
   *
   * @public
   */
  putContentOntoCurrentPage(content, opts = {}) {
    var _a5, _b, _c;
    if (this.getIsReadonly())
      return this;
    if (!content.schema) {
      throw Error("Could not put content:\ncontent is missing a schema.");
    }
    const { select = false, preserveIds = false, preservePosition = false } = opts;
    let { point = void 0 } = opts;
    const currentPageId = this.getCurrentPageId();
    const { rootShapeIds } = content;
    const assets = [];
    const shapes = [];
    const bindings = [];
    const store = {
      store: {
        ...Object.fromEntries(content.assets.map((asset) => [asset.id, asset])),
        ...Object.fromEntries(content.shapes.map((shape) => [shape.id, shape])),
        ...Object.fromEntries(
          ((_a5 = content.bindings) == null ? void 0 : _a5.map((bindings2) => [bindings2.id, bindings2])) ?? []
        )
      },
      schema: content.schema
    };
    const result = this.store.schema.migrateStoreSnapshot(store);
    if (result.type === "error") {
      throw Error("Could not put content: could not migrate content");
    }
    for (const record of Object.values(result.value)) {
      switch (record.typeName) {
        case "asset": {
          assets.push(record);
          break;
        }
        case "shape": {
          shapes.push(record);
          break;
        }
        case "binding": {
          bindings.push(record);
          break;
        }
      }
    }
    const shapeIdMap = new Map(
      preserveIds ? shapes.map((shape) => [shape.id, shape.id]) : shapes.map((shape) => [shape.id, createShapeId()])
    );
    const bindingIdMap = new Map(
      preserveIds ? bindings.map((binding) => [binding.id, binding.id]) : bindings.map((binding) => [binding.id, createBindingId()])
    );
    let pasteParentId = this.getCurrentPageId();
    let lowestDepth = Infinity;
    let lowestAncestors = [];
    for (const shape of this.getSelectedShapes()) {
      if (lowestDepth === 0)
        break;
      const isFrame = this.isShapeOfType(shape, "frame");
      const ancestors = this.getShapeAncestors(shape);
      if (isFrame)
        ancestors.push(shape);
      const depth = isFrame ? ancestors.length + 1 : ancestors.length;
      if (depth < lowestDepth) {
        lowestDepth = depth;
        lowestAncestors = ancestors;
        pasteParentId = isFrame ? shape.id : shape.parentId;
      } else if (depth === lowestDepth) {
        if (lowestAncestors.length !== ancestors.length) {
          throw Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`);
        }
        if (lowestAncestors.length === 0) {
          pasteParentId = currentPageId;
          break;
        } else {
          pasteParentId = currentPageId;
          for (let i = 0; i < lowestAncestors.length; i++) {
            if (ancestors[i] !== lowestAncestors[i])
              break;
            pasteParentId = ancestors[i].id;
          }
        }
      }
    }
    let isDuplicating = false;
    if (!isPageId(pasteParentId)) {
      const parent = this.getShape(pasteParentId);
      if (parent) {
        if (!this.getViewportPageBounds().includes(this.getShapePageBounds(parent))) {
          pasteParentId = currentPageId;
        } else {
          if (rootShapeIds.length === 1) {
            const rootShape = shapes.find((s) => s.id === rootShapeIds[0]);
            if (this.isShapeOfType(parent, "frame") && this.isShapeOfType(rootShape, "frame") && rootShape.props.w === (parent == null ? void 0 : parent.props.w) && rootShape.props.h === (parent == null ? void 0 : parent.props.h)) {
              isDuplicating = true;
            }
          }
        }
      } else {
        pasteParentId = currentPageId;
      }
    }
    if (!isDuplicating) {
      isDuplicating = shapeIdMap.has(pasteParentId);
    }
    if (isDuplicating) {
      pasteParentId = this.getShape(pasteParentId).parentId;
    }
    let index3 = this.getHighestIndexForParent(pasteParentId);
    const rootShapes = [];
    const newShapes = shapes.map((oldShape) => {
      const newId = shapeIdMap.get(oldShape.id);
      const newShape = { ...oldShape, id: newId };
      if (rootShapeIds.includes(oldShape.id)) {
        newShape.parentId = currentPageId;
        rootShapes.push(newShape);
      }
      if (shapeIdMap.has(newShape.parentId)) {
        newShape.parentId = shapeIdMap.get(oldShape.parentId);
      } else {
        rootShapeIds.push(newShape.id);
        newShape.index = index3;
        index3 = getIndexAbove(index3);
      }
      return newShape;
    });
    if (newShapes.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage) {
      alertMaxShapes(this);
      return this;
    }
    const newBindings = bindings.map(
      (oldBinding) => ({
        ...oldBinding,
        id: assertExists(bindingIdMap.get(oldBinding.id)),
        fromId: assertExists(shapeIdMap.get(oldBinding.fromId)),
        toId: assertExists(shapeIdMap.get(oldBinding.toId))
      })
    );
    const assetsToCreate = [];
    const assetsToUpdate = [];
    for (const asset of assets) {
      if (this.store.has(asset.id)) {
        continue;
      }
      if (asset.type === "image" && ((_b = asset.props.src) == null ? void 0 : _b.startsWith("data:image")) || asset.type === "video" && ((_c = asset.props.src) == null ? void 0 : _c.startsWith("data:video"))) {
        assetsToUpdate.push(structuredClone(asset));
        asset.props.src = null;
      }
      assetsToCreate.push(asset);
    }
    Promise.allSettled(
      assetsToUpdate.map(async (asset) => {
        const file = await dataUrlToFile(
          asset.props.src,
          asset.props.name,
          asset.props.mimeType ?? "image/png"
        );
        const newAsset = await this.getAssetForExternalContent({
          type: "file",
          file,
          assetId: asset.id
        });
        if (!newAsset) {
          this.deleteAssets([asset.id]);
          return;
        }
        this.updateAssets([{ ...newAsset, id: asset.id }]);
      })
    );
    this.run(() => {
      if (assetsToCreate.length > 0) {
        this.createAssets(assetsToCreate);
      }
      this.createShapes(newShapes);
      this.createBindings(newBindings);
      if (select) {
        this.select(...rootShapes.map((s) => s.id));
      }
      if (pasteParentId !== currentPageId) {
        this.reparentShapes(
          rootShapes.map((s) => s.id),
          pasteParentId
        );
      }
      const newCreatedShapes = newShapes.map((s) => this.getShape(s.id));
      const bounds = Box.Common(newCreatedShapes.map((s) => this.getShapePageBounds(s)));
      if (point === void 0) {
        if (!isPageId(pasteParentId)) {
          const shape = this.getShape(pasteParentId);
          point = Mat.applyToPoint(
            this.getShapePageTransform(shape),
            this.getShapeGeometry(shape).bounds.center
          );
        } else {
          const viewportPageBounds = this.getViewportPageBounds();
          if (preservePosition || viewportPageBounds.includes(Box.From(bounds))) {
            point = bounds.center;
          } else {
            point = viewportPageBounds.center;
          }
        }
      }
      if (rootShapes.length === 1) {
        const onlyRoot = rootShapes[0];
        if (this.isShapeOfType(onlyRoot, "frame")) {
          while (this.getShapesAtPoint(point).some(
            (shape) => this.isShapeOfType(shape, "frame") && shape.props.w === onlyRoot.props.w && shape.props.h === onlyRoot.props.h
          )) {
            point.x += bounds.w + 16;
          }
        }
      }
      const pageCenter = Box.Common(
        compact(rootShapes.map(({ id }) => this.getShapePageBounds(id)))
      ).center;
      const offset5 = Vec.Sub(point, pageCenter);
      this.updateShapes(
        rootShapes.map(({ id }) => {
          const s = this.getShape(id);
          const localRotation = this.getShapeParentTransform(id).decompose().rotation;
          const localDelta = Vec.Rot(offset5, -localRotation);
          return { id: s.id, type: s.type, x: s.x + localDelta.x, y: s.y + localDelta.y };
        })
      );
    });
    return this;
  }
  /**
   * Get an exported SVG element of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgElement(shapes, opts = {}) {
    const ids = shapes.length === 0 ? this.getCurrentPageShapeIdsSorted() : typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length === 0)
      return void 0;
    return exportToSvg(this, ids, opts);
  }
  /**
   * Get an exported SVG string of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgString(shapes, opts = {}) {
    const result = await this.getSvgElement(shapes, opts);
    if (!result)
      return void 0;
    const serializer = new XMLSerializer();
    return {
      svg: serializer.serializeToString(result.svg),
      width: result.width,
      height: result.height
    };
  }
  /** @deprecated Use {@link Editor.getSvgString} or {@link Editor.getSvgElement} instead. */
  async getSvg(shapes, opts = {}) {
    const result = await this.getSvgElement(shapes, opts);
    if (!result)
      return void 0;
    return result.svg;
  }
  /**
   * Get an exported image of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns A blob of the image.
   * @public
   */
  async toImage(shapes, opts = {}) {
    const withDefaults = {
      format: "png",
      scale: 1,
      pixelRatio: opts.format === "svg" ? void 0 : 2,
      ...opts
    };
    const result = await this.getSvgString(shapes, withDefaults);
    if (!result)
      throw new Error("Could not create SVG");
    switch (withDefaults.format) {
      case "svg":
        return {
          blob: new Blob([result.svg], { type: "image/svg+xml" }),
          width: result.width,
          height: result.height
        };
      case "jpeg":
      case "png":
      case "webp": {
        const blob = await getSvgAsImage(result.svg, {
          type: withDefaults.format,
          quality: withDefaults.quality,
          pixelRatio: withDefaults.pixelRatio,
          width: result.width,
          height: result.height
        });
        if (!blob) {
          throw new Error("Could not construct image.");
        }
        return {
          blob,
          width: result.width,
          height: result.height
        };
      }
      default: {
        exhaustiveSwitchError(withDefaults.format);
      }
    }
  }
  /**
   * Update the input points from a pointer, pinch, or wheel event.
   *
   * @param info - The event info.
   */
  _updateInputsFromEvent(info) {
    const {
      pointerVelocity,
      previousScreenPoint,
      previousPagePoint,
      currentScreenPoint,
      currentPagePoint
    } = this.inputs;
    const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
    const sx = info.point.x - screenBounds.x;
    const sy = info.point.y - screenBounds.y;
    const sz = info.point.z ?? 0.5;
    previousScreenPoint.setTo(currentScreenPoint);
    previousPagePoint.setTo(currentPagePoint);
    currentScreenPoint.set(sx, sy);
    const nx = sx / cz - cx;
    const ny = sy / cz - cy;
    if (isFinite(nx) && isFinite(ny)) {
      currentPagePoint.set(nx, ny, sz);
    }
    this.inputs.isPen = info.type === "pointer" && info.isPen;
    if (info.name === "pointer_down" || this.inputs.isPinching) {
      pointerVelocity.set(0, 0);
      this.inputs.originScreenPoint.setTo(currentScreenPoint);
      this.inputs.originPagePoint.setTo(currentPagePoint);
    }
    this.run(
      () => {
        var _a5;
        this.store.put([
          {
            id: TLPOINTER_ID,
            typeName: "pointer",
            x: currentPagePoint.x,
            y: currentPagePoint.y,
            lastActivityTimestamp: (
              // If our pointer moved only because we're following some other user, then don't
              // update our last activity timestamp; otherwise, update it to the current timestamp.
              info.type === "pointer" && info.pointerId === INTERNAL_POINTER_IDS.CAMERA_MOVE ? ((_a5 = this.store.unsafeGetWithoutCapture(TLPOINTER_ID)) == null ? void 0 : _a5.lastActivityTimestamp) ?? this._tickManager.now : this._tickManager.now
            ),
            meta: {}
          }
        ]);
      },
      { history: "ignore" }
    );
  }
  /**
   * Dispatch a cancel event.
   *
   * @example
   * ```ts
   * editor.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    this.dispatch({ type: "misc", name: "cancel" });
    return this;
  }
  /**
   * Dispatch an interrupt event.
   *
   * @example
   * ```ts
   * editor.interrupt()
   * ```
   *
   * @public
   */
  interrupt() {
    this.dispatch({ type: "misc", name: "interrupt" });
    return this;
  }
  /**
   * Dispatch a complete event.
   *
   * @example
   * ```ts
   * editor.complete()
   * ```
   *
   * @public
   */
  complete() {
    this.dispatch({ type: "misc", name: "complete" });
    return this;
  }
  /**
   * Puts the editor into focused mode.
   *
   * This makes the editor eligible to receive keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.focus()
   * ```
   *
   * By default this also dispatches a 'focus' event to the container element. To prevent this, pass `focusContainer: false`.
   *
   * @example
   * ```ts
   * editor.focus({ focusContainer: false })
   * ```
   *
   * @public
   */
  focus({ focusContainer = true } = {}) {
    if (this.getIsFocused())
      return this;
    if (focusContainer)
      this.focusManager.focus();
    this.updateInstanceState({ isFocused: true });
    return this;
  }
  /**
   * Switches off the editor's focused mode.
   *
   * This makes the editor ignore keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.blur()
   * ```
   * By default this also dispatches a 'blur' event to the container element. To prevent this, pass `blurContainer: false`.
   *
   * @example
   * ```ts
   * editor.blur({ blurContainer: false })
   * ```
   *
   * @public
   */
  blur({ blurContainer = true } = {}) {
    if (!this.getIsFocused())
      return this;
    if (blurContainer) {
      this.focusManager.blur();
    } else {
      this.complete();
    }
    this.updateInstanceState({ isFocused: false });
    return this;
  }
  getIsFocused() {
    return this.getInstanceState().isFocused;
  }
  getIsReadonly() {
    return this.getInstanceState().isReadonly;
  }
  /**
   * @public
   * @returns a snapshot of the store's UI and document state
   */
  getSnapshot() {
    return getSnapshot(this.store);
  }
  /**
   * Loads a snapshot into the editor.
   * @param snapshot - The snapshot to load.
   * @param opts - The options for loading the snapshot.
   * @returns
   */
  loadSnapshot(snapshot, opts) {
    loadSnapshot(this.store, snapshot, opts);
    return this;
  }
  _zoomToFitPageContentAt100Percent() {
    const bounds = this.getCurrentPageBounds();
    if (bounds) {
      this.zoomToBounds(bounds, { immediate: true, targetZoom: this.getBaseZoom() });
    }
  }
  _navigateToDeepLink(deepLink) {
    this.run(() => {
      switch (deepLink.type) {
        case "page": {
          const page = this.getPage(deepLink.pageId);
          if (page) {
            this.setCurrentPage(page);
          }
          this._zoomToFitPageContentAt100Percent();
          return;
        }
        case "shapes": {
          const allShapes = compact(deepLink.shapeIds.map((id) => this.getShape(id)));
          const byPage = {};
          for (const shape of allShapes) {
            const pageId2 = this.getAncestorPageId(shape);
            if (!pageId2)
              continue;
            byPage[pageId2] ?? (byPage[pageId2] = []);
            byPage[pageId2].push(shape);
          }
          const [pageId, shapes] = Object.entries(byPage).sort(
            ([_, a], [__, b]) => b.length - a.length
          )[0] ?? ["", []];
          if (!pageId || !shapes.length) {
            this._zoomToFitPageContentAt100Percent();
          } else {
            this.setCurrentPage(pageId);
            const bounds = Box.Common(shapes.map((s) => this.getShapePageBounds(s)));
            this.zoomToBounds(bounds, { immediate: true, targetZoom: this.getBaseZoom() });
          }
          return;
        }
        case "viewport": {
          if (deepLink.pageId) {
            if (!this.getPage(deepLink.pageId)) {
              this._zoomToFitPageContentAt100Percent();
              return;
            }
            this.setCurrentPage(deepLink.pageId);
          }
          this.zoomToBounds(deepLink.bounds, { immediate: true, inset: 0 });
          return;
        }
        default:
          exhaustiveSwitchError(deepLink);
      }
    });
  }
  /**
   * Handles navigating to the content specified by the query param in the given URL.
   *
   * Use {@link Editor#createDeepLink} to create a URL with a deep link query param.
   *
   * If no URL is provided, it will look for the param in the current `window.location.href`.
   *
   * @example
   * ```ts
   * editor.navigateToDeepLink()
   * ```
   *
   * The default parameter name is 'd'. You can override this by providing the `param` option.
   *
   * @example
   * ```ts
   * // disable page parameter and change viewport parameter to 'c'
   * editor.navigateToDeepLink({
   *   param: 'x',
   *   url: 'https://my-app.com/my-document?x=200.12.454.23.xyz123',
   * })
   * ```
   *
   * @param opts - Options for loading the state from the URL.
   */
  navigateToDeepLink(opts) {
    if (opts && "type" in opts) {
      this._navigateToDeepLink(opts);
      return this;
    }
    const url = new URL((opts == null ? void 0 : opts.url) ?? window.location.href);
    const deepLinkString = url.searchParams.get((opts == null ? void 0 : opts.param) ?? "d");
    if (!deepLinkString) {
      this._zoomToFitPageContentAt100Percent();
      return this;
    }
    try {
      this._navigateToDeepLink(parseDeepLinkString(deepLinkString));
    } catch (e) {
      console.warn(e);
      this._zoomToFitPageContentAt100Percent();
    }
    return this;
  }
  /**
   * Turns the given URL into a deep link by adding a query parameter.
   *
   * e.g. `https://my-app.com/my-document?d=100.100.200.200.xyz123`
   *
   * If no URL is provided, it will use the current `window.location.href`.
   *
   * @example
   * ```ts
   * // create a deep link to the current page + viewport
   * navigator.clipboard.writeText(editor.createDeepLink())
   * ```
   *
   * You can link to a particular set of shapes by providing a `to` parameter.
   *
   * @example
   * ```ts
   * // create a deep link to the set of currently selected shapes
   * navigator.clipboard.writeText(editor.createDeepLink({
   *   to: { type: 'selection', shapeIds: editor.getSelectedShapeIds() }
   * }))
   * ```
   *
   * The default query param is 'd'. You can override this by providing a `param` parameter.
   *
   * @example
   * ```ts
   * // Use `x` as the param name instead
   * editor.createDeepLink({ param: 'x' })
   * ```
   *
   * @param opts - Options for adding the state to the URL.
   * @returns the updated URL
   */
  createDeepLink(opts) {
    const url = new URL((opts == null ? void 0 : opts.url) ?? window.location.href);
    url.searchParams.set(
      (opts == null ? void 0 : opts.param) ?? "d",
      createDeepLinkString(
        (opts == null ? void 0 : opts.to) ?? {
          type: "viewport",
          pageId: this.options.maxPages === 1 ? void 0 : this.getCurrentPageId(),
          bounds: this.getViewportPageBounds()
        }
      )
    );
    return url;
  }
  /**
   * Register a listener for changes to a deep link for the current document.
   *
   * You'll typically want to use this indirectly via the {@link TldrawEditorBaseProps.deepLinks} prop on the `<Tldraw />` component.
   *
   * By default this will update `window.location` in place, but you can provide a custom callback
   * to handle state changes on your own.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   onChange(url) {
   *     window.history.replaceState({}, document.title, url.toString())
   *   }
   * })
   * ```
   *
   * You can also provide a custom URL to update, in which case you must also provide `onChange`.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   getUrl: () => `https://my-app.com/my-document`,
   *   onChange(url) {
   *     setShareUrl(url.toString())
   *   }
   * })
   * ```
   *
   * By default this will update with a debounce interval of 500ms, but you can provide a custom interval.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ debounceMs: 1000 })
   * ```
   * The default parameter name is `d`. You can override this by providing a `param` option.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ param: 'x' })
   * ```
   * @param opts - Options for setting up the listener.
   * @returns a function that will stop the listener.
   */
  registerDeepLinkListener(opts) {
    if ((opts == null ? void 0 : opts.getUrl) && !(opts == null ? void 0 : opts.onChange)) {
      throw Error(
        "[tldraw:urlStateSync] If you specify getUrl, you must also specify the onChange callback."
      );
    }
    const url$ = computed("url with state", () => {
      var _a5, _b;
      const url = ((_a5 = opts == null ? void 0 : opts.getUrl) == null ? void 0 : _a5.call(opts, this)) ?? window.location.href;
      const urlWithState = this.createDeepLink({
        param: opts == null ? void 0 : opts.param,
        url,
        to: (_b = opts == null ? void 0 : opts.getTarget) == null ? void 0 : _b.call(opts, this)
      });
      return urlWithState.toString();
    });
    const announceChange = (opts == null ? void 0 : opts.onChange) ?? (() => {
      var _a5;
      const url = this.createDeepLink({
        param: opts == null ? void 0 : opts.param,
        to: (_a5 = opts == null ? void 0 : opts.getTarget) == null ? void 0 : _a5.call(opts, this)
      });
      window.history.replaceState({}, document.title, url.toString());
    });
    const scheduleEffect = debounce((execute) => execute(), (opts == null ? void 0 : opts.debounceMs) ?? 500);
    const unlisten = react(
      "update url on state change",
      () => announceChange(new URL(url$.get()), this),
      { scheduleEffect }
    );
    return () => {
      unlisten();
      scheduleEffect.cancel();
    };
  }
  /**
   * Prevent a double click event from firing the next time the user clicks
   *
   * @public
   */
  cancelDoubleClick() {
    this._clickManager.cancelDoubleClickTimeout();
  }
  _setShiftKeyTimeout() {
    this.inputs.shiftKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Shift",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "ShiftLeft"
    });
  }
  _setAltKeyTimeout() {
    this.inputs.altKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Alt",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "AltLeft"
    });
  }
  _setCtrlKeyTimeout() {
    this.inputs.ctrlKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Ctrl",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "ControlLeft"
    });
  }
  _setMetaKeyTimeout() {
    this.inputs.metaKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Meta",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "MetaLeft"
    });
  }
  /**
   * Dispatch an event to the editor.
   *
   * @example
   * ```ts
   * editor.dispatch(myPointerEvent)
   * ```
   *
   * @param info - The event info.
   *
   * @public
   */
  dispatch(info) {
    this._pendingEventsForNextTick.push(info);
    if (!(info.type === "pointer" && info.name === "pointer_move" || info.type === "wheel" || info.type === "pinch")) {
      this._flushEventsForTick(0);
    }
    return this;
  }
  _flushEventsForTick(elapsed) {
    this.run(() => {
      if (this._pendingEventsForNextTick.length > 0) {
        const events = [...this._pendingEventsForNextTick];
        this._pendingEventsForNextTick.length = 0;
        for (const info of events) {
          this._flushEventForTick(info);
        }
      }
      if (elapsed > 0) {
        this.root.handleEvent({ type: "misc", name: "tick", elapsed });
      }
      this.scribbles.tick(elapsed);
    });
  }
  _flushEventForTick(info) {
    if (this.getCrashingError())
      return this;
    this.emit("before-event", info);
    const { inputs } = this;
    const { type } = info;
    if (info.type === "misc") {
      if (info.name === "cancel" || info.name === "complete") {
        this.inputs.isDragging = false;
        if (this.inputs.isPanning) {
          this.inputs.isPanning = false;
          this.inputs.isSpacebarPanning = false;
          this.setCursor({ type: this._prevCursor, rotation: 0 });
        }
      }
      this.root.handleEvent(info);
      return;
    }
    if (info.shiftKey) {
      clearTimeout(this._shiftKeyTimeout);
      this._shiftKeyTimeout = -1;
      inputs.shiftKey = true;
    } else if (!info.shiftKey && inputs.shiftKey && this._shiftKeyTimeout === -1) {
      this._shiftKeyTimeout = this.timers.setTimeout(this._setShiftKeyTimeout, 150);
    }
    if (info.altKey) {
      clearTimeout(this._altKeyTimeout);
      this._altKeyTimeout = -1;
      inputs.altKey = true;
    } else if (!info.altKey && inputs.altKey && this._altKeyTimeout === -1) {
      this._altKeyTimeout = this.timers.setTimeout(this._setAltKeyTimeout, 150);
    }
    if (info.ctrlKey) {
      clearTimeout(this._ctrlKeyTimeout);
      this._ctrlKeyTimeout = -1;
      inputs.ctrlKey = true;
    } else if (!info.ctrlKey && inputs.ctrlKey && this._ctrlKeyTimeout === -1) {
      this._ctrlKeyTimeout = this.timers.setTimeout(this._setCtrlKeyTimeout, 150);
    }
    if (info.metaKey) {
      clearTimeout(this._metaKeyTimeout);
      this._metaKeyTimeout = -1;
      inputs.metaKey = true;
    } else if (!info.metaKey && inputs.metaKey && this._metaKeyTimeout === -1) {
      this._metaKeyTimeout = this.timers.setTimeout(this._setMetaKeyTimeout, 150);
    }
    const { originPagePoint, currentPagePoint } = inputs;
    if (!inputs.isPointing) {
      inputs.isDragging = false;
    }
    const instanceState = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const pageState = this.store.get(this._getCurrentPageStateId());
    const cameraOptions = this._cameraOptions.__unsafe__getWithoutCapture();
    switch (type) {
      case "pinch": {
        if (cameraOptions.isLocked)
          return;
        clearTimeout(this._longPressTimeout);
        this._updateInputsFromEvent(info);
        switch (info.name) {
          case "pinch_start": {
            if (inputs.isPinching)
              return;
            if (!inputs.isEditing) {
              this._pinchStart = this.getCamera().z;
              if (!this._selectedShapeIdsAtPointerDown.length) {
                this._selectedShapeIdsAtPointerDown = [...pageState.selectedShapeIds];
              }
              this._didPinch = true;
              inputs.isPinching = true;
              this.interrupt();
            }
            return;
          }
          case "pinch": {
            if (!inputs.isPinching)
              return;
            const {
              point: { z = 1 },
              delta: { x: dx, y: dy }
            } = info;
            const { x, y } = Vec.SubXY(
              info.point,
              instanceState.screenBounds.x,
              instanceState.screenBounds.y
            );
            this.stopCameraAnimation();
            if (instanceState.followingUserId) {
              this.stopFollowingUser();
            }
            const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
            const { panSpeed } = cameraOptions;
            this._setCamera(
              new Vec(
                cx + dx * panSpeed / cz - x / cz + x / z,
                cy + dy * panSpeed / cz - y / cz + y / z,
                z
              ),
              { immediate: true }
            );
            return;
          }
          case "pinch_end": {
            if (!inputs.isPinching)
              return this;
            inputs.isPinching = false;
            const { _selectedShapeIdsAtPointerDown: shapesToReselect } = this;
            this.setSelectedShapes(this._selectedShapeIdsAtPointerDown);
            this._selectedShapeIdsAtPointerDown = [];
            if (this._didPinch) {
              this._didPinch = false;
              if (shapesToReselect.length > 0) {
                this.once("tick", () => {
                  if (!this._didPinch) {
                    this.setSelectedShapes(shapesToReselect);
                  }
                });
              }
            }
            return;
          }
        }
      }
      case "wheel": {
        if (cameraOptions.isLocked)
          return;
        this._updateInputsFromEvent(info);
        const { panSpeed, zoomSpeed, wheelBehavior } = cameraOptions;
        if (wheelBehavior !== "none") {
          this.stopCameraAnimation();
          if (instanceState.followingUserId) {
            this.stopFollowingUser();
          }
          const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
          const { x: dx, y: dy, z: dz = 0 } = info.delta;
          let behavior = wheelBehavior;
          if (info.ctrlKey)
            behavior = wheelBehavior === "pan" ? "zoom" : "pan";
          switch (behavior) {
            case "zoom": {
              const { x, y } = this.inputs.currentScreenPoint;
              let delta = dz;
              if (wheelBehavior === "zoom") {
                if (Math.abs(dy) > 10) {
                  delta = 10 * Math.sign(dy) / 100;
                } else {
                  delta = dy / 100;
                }
              }
              const zoom = cz + (delta ?? 0) * zoomSpeed * cz;
              this._setCamera(new Vec(cx + x / zoom - x / cz, cy + y / zoom - y / cz, zoom), {
                immediate: true
              });
              this.maybeTrackPerformance("Zooming");
              return;
            }
            case "pan": {
              this._setCamera(new Vec(cx + dx * panSpeed / cz, cy + dy * panSpeed / cz, cz), {
                immediate: true
              });
              this.maybeTrackPerformance("Panning");
              return;
            }
          }
        }
        break;
      }
      case "pointer": {
        if (inputs.isPinching)
          return;
        this._updateInputsFromEvent(info);
        const { isPen } = info;
        const { isPenMode } = instanceState;
        switch (info.name) {
          case "pointer_down": {
            if (isPenMode && !isPen)
              return;
            if (!this.inputs.isPanning) {
              this._longPressTimeout = this.timers.setTimeout(() => {
                const vsb = this.getViewportScreenBounds();
                this.dispatch({
                  ...info,
                  // important! non-obvious!! the screenpoint was adjusted using the
                  // viewport bounds, and will be again when this event is handled...
                  // so we need to counter-adjust from the stored value so that the
                  // new value is set correctly.
                  point: this.inputs.originScreenPoint.clone().addXY(vsb.x, vsb.y),
                  name: "long_press"
                });
              }, this.options.longPressDurationMs);
            }
            this._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds();
            if (info.button === LEFT_MOUSE_BUTTON)
              this.capturedPointerId = info.pointerId;
            inputs.buttons.add(info.button);
            inputs.isPointing = true;
            inputs.isDragging = false;
            if (!isPenMode && isPen)
              this.updateInstanceState({ isPenMode: true });
            if (info.button === STYLUS_ERASER_BUTTON) {
              this._restoreToolId = this.getCurrentToolId();
              this.complete();
              this.setCurrentTool("eraser");
            } else if (info.button === MIDDLE_MOUSE_BUTTON) {
              if (!this.inputs.isPanning) {
                this._prevCursor = this.getInstanceState().cursor.type;
              }
              this.inputs.isPanning = true;
              clearTimeout(this._longPressTimeout);
            }
            if (this.inputs.isPanning) {
              this.stopCameraAnimation();
              this.setCursor({ type: "grabbing", rotation: 0 });
              return this;
            }
            break;
          }
          case "pointer_move": {
            if (!isPen && isPenMode)
              return;
            const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
            if (this.inputs.isPanning && this.inputs.isPointing) {
              const { currentScreenPoint, previousScreenPoint } = this.inputs;
              const offset5 = Vec.Sub(currentScreenPoint, previousScreenPoint);
              this.setCamera(new Vec(cx + offset5.x / cz, cy + offset5.y / cz, cz), {
                immediate: true
              });
              this.maybeTrackPerformance("Panning");
              return;
            }
            if (inputs.isPointing && !inputs.isDragging && Vec.Dist2(originPagePoint, currentPagePoint) * this.getZoomLevel() > (instanceState.isCoarsePointer ? this.options.coarseDragDistanceSquared : this.options.dragDistanceSquared) / cz) {
              inputs.isDragging = true;
              clearTimeout(this._longPressTimeout);
            }
            break;
          }
          case "pointer_up": {
            inputs.isDragging = false;
            inputs.isPointing = false;
            clearTimeout(this._longPressTimeout);
            inputs.buttons.delete(info.button);
            if (instanceState.isPenMode && !isPen)
              return;
            if (this.capturedPointerId === info.pointerId) {
              this.capturedPointerId = null;
              info.button = 0;
            }
            if (inputs.isPanning) {
              if (!inputs.keys.has("Space")) {
                inputs.isPanning = false;
                inputs.isSpacebarPanning = false;
              }
              const slideDirection = this.inputs.pointerVelocity;
              const slideSpeed = Math.min(2, slideDirection.len());
              switch (info.button) {
                case LEFT_MOUSE_BUTTON: {
                  this.setCursor({ type: "grab", rotation: 0 });
                  break;
                }
                case MIDDLE_MOUSE_BUTTON: {
                  if (this.inputs.keys.has(" ")) {
                    this.setCursor({ type: "grab", rotation: 0 });
                  } else {
                    this.setCursor({ type: this._prevCursor, rotation: 0 });
                  }
                }
              }
              if (slideSpeed > 0) {
                this.slideCamera({ speed: slideSpeed, direction: slideDirection });
              }
            } else {
              if (info.button === STYLUS_ERASER_BUTTON) {
                this.complete();
                this.setCurrentTool(this._restoreToolId);
              }
            }
            break;
          }
        }
        break;
      }
      case "keyboard": {
        if (info.key === "ShiftRight")
          info.key = "ShiftLeft";
        if (info.key === "AltRight")
          info.key = "AltLeft";
        if (info.code === "ControlRight")
          info.code = "ControlLeft";
        if (info.code === "MetaRight")
          info.code = "MetaLeft";
        switch (info.name) {
          case "key_down": {
            inputs.keys.add(info.code);
            if (info.code === "Space" && !info.ctrlKey) {
              if (!this.inputs.isPanning) {
                this._prevCursor = instanceState.cursor.type;
              }
              this.inputs.isPanning = true;
              this.inputs.isSpacebarPanning = true;
              clearTimeout(this._longPressTimeout);
              this.setCursor({ type: this.inputs.isPointing ? "grabbing" : "grab", rotation: 0 });
            }
            if (this.inputs.isSpacebarPanning) {
              let offset5;
              switch (info.code) {
                case "ArrowUp": {
                  offset5 = new Vec(0, -1);
                  break;
                }
                case "ArrowRight": {
                  offset5 = new Vec(1, 0);
                  break;
                }
                case "ArrowDown": {
                  offset5 = new Vec(0, 1);
                  break;
                }
                case "ArrowLeft": {
                  offset5 = new Vec(-1, 0);
                  break;
                }
              }
              if (offset5) {
                const bounds = this.getViewportPageBounds();
                const next = bounds.clone().translate(offset5.mulV({ x: bounds.w, y: bounds.h }));
                this._animateToViewport(next, { animation: { duration: 320 } });
              }
            }
            break;
          }
          case "key_up": {
            inputs.keys.delete(info.code);
            if (info.code === "Space") {
              if (this.inputs.buttons.has(MIDDLE_MOUSE_BUTTON)) {
              } else {
                this.inputs.isPanning = false;
                this.inputs.isSpacebarPanning = false;
                this.setCursor({ type: this._prevCursor, rotation: 0 });
              }
            }
            break;
          }
          case "key_repeat": {
            break;
          }
        }
        break;
      }
    }
    if (info.type === "pointer") {
      if (info.button === MIDDLE_MOUSE_BUTTON) {
        info.name = "middle_click";
      } else if (info.button === RIGHT_MOUSE_BUTTON) {
        info.name = "right_click";
      }
      const { isPenMode } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
      if (info.isPen === isPenMode) {
        const clickInfo = this._clickManager.handlePointerEvent(info);
        if (info.name !== clickInfo.name) {
          this.root.handleEvent(info);
          this.emit("event", info);
          this.root.handleEvent(clickInfo);
          this.emit("event", clickInfo);
          return;
        }
      }
    }
    this.root.handleEvent(info);
    this.emit("event", info);
    if (info.type === "pointer" && info.name === "pointer_down") {
      this.menus.clearOpenMenus();
    }
    return this;
  }
  /** @internal */
  maybeTrackPerformance(name) {
    if (debugFlags.measurePerformance.get()) {
      if (this.performanceTracker.isStarted()) {
        clearTimeout(this.performanceTrackerTimeout);
      } else {
        this.performanceTracker.start(name);
      }
      this.performanceTrackerTimeout = this.timers.setTimeout(() => {
        this.performanceTracker.stop();
      }, 50);
    }
  }
};
_init9 = __decoratorStart9(_a2);
__decorateElement9(_init9, 1, "getIsShapeHiddenCache", _getIsShapeHiddenCache_dec, Editor);
__decorateElement9(_init9, 1, "getCanUndo", _getCanUndo_dec, Editor);
__decorateElement9(_init9, 1, "getCanRedo", _getCanRedo_dec, Editor);
__decorateElement9(_init9, 1, "getPath", _getPath_dec, Editor);
__decorateElement9(_init9, 1, "getCurrentTool", _getCurrentTool_dec, Editor);
__decorateElement9(_init9, 1, "getCurrentToolId", _getCurrentToolId_dec, Editor);
__decorateElement9(_init9, 1, "getDocumentSettings", _getDocumentSettings_dec, Editor);
__decorateElement9(_init9, 1, "getInstanceState", _getInstanceState_dec, Editor);
__decorateElement9(_init9, 1, "getOpenMenus", _getOpenMenus_dec, Editor);
__decorateElement9(_init9, 1, "getIsMenuOpen", _getIsMenuOpen_dec, Editor);
__decorateElement9(_init9, 1, "getPageStates", _getPageStates_dec, Editor);
__decorateElement9(_init9, 1, "_getPageStatesQuery", __getPageStatesQuery_dec, Editor);
__decorateElement9(_init9, 1, "getCurrentPageState", _getCurrentPageState_dec, Editor);
__decorateElement9(_init9, 1, "_getCurrentPageStateId", __getCurrentPageStateId_dec, Editor);
__decorateElement9(_init9, 1, "getSelectedShapeIds", _getSelectedShapeIds_dec, Editor);
__decorateElement9(_init9, 1, "getSelectedShapes", _getSelectedShapes_dec, Editor);
__decorateElement9(_init9, 1, "getCurrentPageShapesInReadingOrder", _getCurrentPageShapesInReadingOrder_dec, Editor);
__decorateElement9(_init9, 1, "getOnlySelectedShapeId", _getOnlySelectedShapeId_dec, Editor);
__decorateElement9(_init9, 1, "getOnlySelectedShape", _getOnlySelectedShape_dec, Editor);
__decorateElement9(_init9, 1, "getSelectionPageBounds", _getSelectionPageBounds_dec, Editor);
__decorateElement9(_init9, 1, "getSelectionRotation", _getSelectionRotation_dec, Editor);
__decorateElement9(_init9, 1, "getSelectionRotatedPageBounds", _getSelectionRotatedPageBounds_dec, Editor);
__decorateElement9(_init9, 1, "getSelectionRotatedScreenBounds", _getSelectionRotatedScreenBounds_dec, Editor);
__decorateElement9(_init9, 1, "getFocusedGroupId", _getFocusedGroupId_dec, Editor);
__decorateElement9(_init9, 1, "getFocusedGroup", _getFocusedGroup_dec, Editor);
__decorateElement9(_init9, 1, "getEditingShapeId", _getEditingShapeId_dec, Editor);
__decorateElement9(_init9, 1, "getEditingShape", _getEditingShape_dec, Editor);
__decorateElement9(_init9, 1, "getRichTextEditor", _getRichTextEditor_dec, Editor);
__decorateElement9(_init9, 1, "getHoveredShapeId", _getHoveredShapeId_dec, Editor);
__decorateElement9(_init9, 1, "getHoveredShape", _getHoveredShape_dec, Editor);
__decorateElement9(_init9, 1, "getHintingShapeIds", _getHintingShapeIds_dec, Editor);
__decorateElement9(_init9, 1, "getHintingShape", _getHintingShape_dec, Editor);
__decorateElement9(_init9, 1, "getErasingShapeIds", _getErasingShapeIds_dec, Editor);
__decorateElement9(_init9, 1, "getErasingShapes", _getErasingShapes_dec, Editor);
__decorateElement9(_init9, 1, "_unsafe_getCameraId", __unsafe_getCameraId_dec, Editor);
__decorateElement9(_init9, 1, "getCamera", _getCamera_dec, Editor);
__decorateElement9(_init9, 1, "getViewportPageBoundsForFollowing", _getViewportPageBoundsForFollowing_dec, Editor);
__decorateElement9(_init9, 1, "getCameraForFollowing", _getCameraForFollowing_dec, Editor);
__decorateElement9(_init9, 1, "getZoomLevel", _getZoomLevel_dec, Editor);
__decorateElement9(_init9, 1, "getViewportScreenBounds", _getViewportScreenBounds_dec, Editor);
__decorateElement9(_init9, 1, "getViewportScreenCenter", _getViewportScreenCenter_dec, Editor);
__decorateElement9(_init9, 1, "getViewportPageBounds", _getViewportPageBounds_dec, Editor);
__decorateElement9(_init9, 1, "_getCollaboratorsQuery", __getCollaboratorsQuery_dec, Editor);
__decorateElement9(_init9, 1, "getCollaborators", _getCollaborators_dec, Editor);
__decorateElement9(_init9, 1, "getCollaboratorsOnCurrentPage", _getCollaboratorsOnCurrentPage_dec, Editor);
__decorateElement9(_init9, 1, "getRenderingShapes", _getRenderingShapes_dec, Editor);
__decorateElement9(_init9, 1, "_getAllPagesQuery", __getAllPagesQuery_dec, Editor);
__decorateElement9(_init9, 1, "getPages", _getPages_dec, Editor);
__decorateElement9(_init9, 1, "getCurrentPageId", _getCurrentPageId_dec, Editor);
__decorateElement9(_init9, 1, "getCurrentPageShapeIdsSorted", _getCurrentPageShapeIdsSorted_dec, Editor);
__decorateElement9(_init9, 1, "_getAllAssetsQuery", __getAllAssetsQuery_dec, Editor);
__decorateElement9(_init9, 1, "_getShapeHandlesCache", __getShapeHandlesCache_dec, Editor);
__decorateElement9(_init9, 1, "_getShapePageTransformCache", __getShapePageTransformCache_dec, Editor);
__decorateElement9(_init9, 1, "_getShapePageBoundsCache", __getShapePageBoundsCache_dec, Editor);
__decorateElement9(_init9, 1, "_getShapeClipPathCache", __getShapeClipPathCache_dec, Editor);
__decorateElement9(_init9, 1, "_getShapeMaskCache", __getShapeMaskCache_dec, Editor);
__decorateElement9(_init9, 1, "_getShapeMaskedPageBoundsCache", __getShapeMaskedPageBoundsCache_dec, Editor);
__decorateElement9(_init9, 1, "_notVisibleShapes", __notVisibleShapes_dec, Editor);
__decorateElement9(_init9, 1, "getCulledShapes", _getCulledShapes_dec, Editor);
__decorateElement9(_init9, 1, "getCurrentPageBounds", _getCurrentPageBounds_dec, Editor);
__decorateElement9(_init9, 1, "getCurrentPageShapes", _getCurrentPageShapes_dec, Editor);
__decorateElement9(_init9, 1, "getCurrentPageShapesSorted", _getCurrentPageShapesSorted_dec, Editor);
__decorateElement9(_init9, 1, "getCurrentPageRenderingShapesSorted", _getCurrentPageRenderingShapesSorted_dec, Editor);
__decorateElement9(_init9, 1, "_getBindingsIndexCache", __getBindingsIndexCache_dec, Editor);
__decorateElement9(_init9, 1, "_getSelectionSharedStyles", __getSelectionSharedStyles_dec, Editor);
__decorateElement9(_init9, 1, "getSharedStyles", _getSharedStyles_dec, Editor);
__decorateElement9(_init9, 1, "getSharedOpacity", _getSharedOpacity_dec, Editor);
__decorateElement9(_init9, 1, "getIsFocused", _getIsFocused_dec, Editor);
__decorateElement9(_init9, 1, "getIsReadonly", _getIsReadonly_dec, Editor);
__decorateElement9(_init9, 1, "_setShiftKeyTimeout", __setShiftKeyTimeout_dec, Editor);
__decorateElement9(_init9, 1, "_setAltKeyTimeout", __setAltKeyTimeout_dec, Editor);
__decorateElement9(_init9, 1, "_setCtrlKeyTimeout", __setCtrlKeyTimeout_dec, Editor);
__decorateElement9(_init9, 1, "_setMetaKeyTimeout", __setMetaKeyTimeout_dec, Editor);
__decoratorMetadata9(_init9, Editor);
function alertMaxShapes(editor, pageId = editor.getCurrentPageId()) {
  const name = editor.getPage(pageId).name;
  editor.emit("max-shapes", { name, pageId, count: editor.options.maxShapesPerPage });
}
function applyPartialToRecordWithProps(prev, partial) {
  if (!partial)
    return prev;
  let next = null;
  const entries = Object.entries(partial);
  for (let i = 0, n = entries.length; i < n; i++) {
    const [k, v] = entries[i];
    if (v === void 0)
      continue;
    if (k === "id" || k === "type" || k === "typeName")
      continue;
    if (v === prev[k])
      continue;
    if (!next)
      next = { ...prev };
    if (k === "props" || k === "meta") {
      next[k] = { ...prev[k] };
      for (const [nextKey, nextValue] of Object.entries(v)) {
        ;
        next[k][nextKey] = nextValue;
      }
      continue;
    }
    ;
    next[k] = v;
  }
  if (!next)
    return prev;
  return next;
}
function pushShapeWithDescendants(editor, id, result) {
  const shape = editor.getShape(id);
  if (!shape)
    return;
  result.push(shape);
  const childIds = editor.getSortedChildIdsForParent(id);
  for (let i = 0, n = childIds.length; i < n; i++) {
    pushShapeWithDescendants(editor, childIds[i], result);
  }
}
function withIsolatedShapes(editor, shapeIds, callback) {
  let result;
  editor.run(
    () => {
      const changes = editor.store.extractingChanges(() => {
        const bindingsWithBoth = /* @__PURE__ */ new Set();
        const bindingsToRemove = /* @__PURE__ */ new Set();
        for (const shapeId of shapeIds) {
          const shape = editor.getShape(shapeId);
          if (!shape)
            continue;
          for (const binding of editor.getBindingsInvolvingShape(shapeId)) {
            const hasFrom = shapeIds.has(binding.fromId);
            const hasTo = shapeIds.has(binding.toId);
            if (hasFrom && hasTo) {
              bindingsWithBoth.add(binding.id);
              continue;
            }
            if (!hasFrom || !hasTo) {
              bindingsToRemove.add(binding.id);
            }
          }
        }
        editor.deleteBindings([...bindingsToRemove], { isolateShapes: true });
        try {
          result = Result.ok(callback(bindingsWithBoth));
        } catch (error) {
          result = Result.err(error);
        }
      });
      editor.store.applyDiff(reverseRecordsDiff(changes), { runCallbacks: false });
    },
    { history: "ignore" }
  );
  if (result.ok) {
    return result.value;
  } else {
    throw result.error;
  }
}
function getCameraFitXFitY(editor, cameraOptions) {
  if (!cameraOptions.constraints)
    throw Error("Should have constraints here");
  const {
    padding: { x: px, y: py }
  } = cameraOptions.constraints;
  const vsb = editor.getViewportScreenBounds();
  const bounds = Box.From(cameraOptions.constraints.bounds);
  const zx = (vsb.w - px * 2) / bounds.w;
  const zy = (vsb.h - py * 2) / bounds.h;
  return { zx, zy };
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useIsDarkMode.mjs
function useIsDarkMode() {
  const editor = useEditor();
  const exportContext = useSvgExportContext();
  return useValue("isDarkMode", () => (exportContext == null ? void 0 : exportContext.isDarkMode) ?? editor.user.getIsDarkMode(), [
    exportContext,
    editor
  ]);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useCursor.mjs
var CORNER_SVG = `<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>`;
var EDGE_SVG = `<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>`;
var ROTATE_CORNER_SVG = `<path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/>`;
function getCursorCss(svg, r, tr2, f, color, hotspotX = 16, hotspotY = 16) {
  const a = (-tr2 - r) * (PI / 180);
  const s = Math.sin(a);
  const c = Math.cos(a);
  const dx = 1 * c - 1 * s;
  const dy = 1 * s + 1 * c;
  return `url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${color};'><defs><filter id='shadow' y='-40%' x='-40%' width='180px' height='180%' color-interpolation-filters='sRGB'><feDropShadow dx='${dx}' dy='${dy}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${r + tr2} 16 16)${f ? ` scale(-1,-1) translate(0, -32)` : ""}' filter='url(%23shadow)'>` + svg.replaceAll(`"`, `'`) + `</g></svg>") ${hotspotX} ${hotspotY}, pointer`;
}
var STATIC_CURSORS = [
  "default",
  "pointer",
  "cross",
  "move",
  "grab",
  "grabbing",
  "text",
  "zoom-in",
  "zoom-out"
];
var CURSORS = {
  none: () => "none",
  "ew-resize": (r, f, c) => getCursorCss(EDGE_SVG, r, 0, f, c),
  "ns-resize": (r, f, c) => getCursorCss(EDGE_SVG, r, 90, f, c),
  "nesw-resize": (r, f, c) => getCursorCss(CORNER_SVG, r, 0, f, c),
  "nwse-resize": (r, f, c) => getCursorCss(CORNER_SVG, r, 90, f, c),
  "nwse-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 0, f, c),
  "nesw-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 90, f, c),
  "senw-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 180, f, c),
  "swne-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 270, f, c)
};
function getCursor(cursor, rotation = 0, color = "black") {
  return CURSORS[cursor](radiansToDegrees(rotation), false, color);
}
function useCursor() {
  const editor = useEditor();
  const container = useContainer();
  const isDarkMode = useIsDarkMode();
  useQuickReactor(
    "useCursor",
    () => {
      const { type, rotation } = editor.getInstanceState().cursor;
      if (STATIC_CURSORS.includes(type)) {
        container.style.setProperty("--tl-cursor", `var(--tl-cursor-${type})`);
        return;
      }
      container.style.setProperty(
        "--tl-cursor",
        getCursor(type, rotation, isDarkMode ? "white" : "black")
      );
    },
    [editor, container, isDarkMode]
  );
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useDarkMode.mjs
var import_react38 = __toESM(require_react(), 1);
function useDarkMode() {
  const editor = useEditor();
  const container = useContainer();
  const isDarkMode = useIsDarkMode();
  const forceSrgb = useValue(debugFlags.forceSrgb);
  import_react38.default.useEffect(() => {
    if (isDarkMode) {
      container.setAttribute("data-color-mode", "dark");
      container.classList.remove("tl-theme__light");
      container.classList.add("tl-theme__dark");
    } else {
      container.setAttribute("data-color-mode", "light");
      container.classList.remove("tl-theme__dark");
      container.classList.add("tl-theme__light");
    }
    if (forceSrgb) {
      container.classList.add("tl-theme__force-sRGB");
    } else {
      container.classList.remove("tl-theme__force-sRGB");
    }
  }, [editor, container, forceSrgb, isDarkMode]);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useForceUpdate.mjs
var import_react39 = __toESM(require_react(), 1);
function useForceUpdate() {
  const [_, ss] = (0, import_react39.useState)(0);
  (0, import_react39.useEffect)(() => ss((s) => s + 1), []);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useLocalStore.mjs
var import_react41 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/config/createTLStore.mjs
var defaultAssetResolve = (asset) => asset.props.src;
var inlineBase64AssetStore = {
  upload: async (_, file) => {
    return { src: await FileHelpers.blobToDataUrl(file) };
  }
};
function createTLSchemaFromUtils(opts) {
  if ("schema" in opts && opts.schema)
    return opts.schema;
  return createTLSchema({
    shapes: "shapeUtils" in opts && opts.shapeUtils ? utilsToMap(checkShapesAndAddCore(opts.shapeUtils)) : void 0,
    bindings: "bindingUtils" in opts && opts.bindingUtils ? utilsToMap(checkBindings(opts.bindingUtils)) : void 0,
    migrations: "migrations" in opts ? opts.migrations : void 0
  });
}
function createTLStore({
  initialData,
  defaultName = "",
  id,
  assets = inlineBase64AssetStore,
  onMount: onMount2,
  collaboration,
  ...rest
} = {}) {
  const schema = createTLSchemaFromUtils(rest);
  const store = new Store({
    id,
    schema,
    initialData,
    props: {
      defaultName,
      assets: {
        upload: assets.upload,
        resolve: assets.resolve ?? defaultAssetResolve,
        remove: assets.remove ?? (() => Promise.resolve())
      },
      onMount: (editor) => {
        assert(editor instanceof Editor);
        onMount2 == null ? void 0 : onMount2(editor);
      },
      collaboration
    }
  });
  if (rest.snapshot) {
    if (initialData)
      throw new Error("Cannot provide both initialData and snapshot");
    loadSnapshot(store, rest.snapshot, { forceOverwriteSessionState: true });
  }
  return store;
}
function utilsToMap(utils) {
  return Object.fromEntries(
    utils.map((s) => [
      s.type,
      {
        props: s.props,
        migrations: s.migrations
      }
    ])
  );
}

// node_modules/idb/build/wrap-idb-value.js
var instanceOfAny = (object2, constructors) => constructors.some((c) => object2 instanceof c);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var cursorRequestMap = /* @__PURE__ */ new WeakMap();
var transactionDoneMap = /* @__PURE__ */ new WeakMap();
var transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
var transformCache = /* @__PURE__ */ new WeakMap();
var reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var unwrap = (value) => reverseTransformCache.get(value);

// node_modules/idb/build/index.js
function openDB(name, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
function deleteDB(name, { blocked } = {}) {
  const request = indexedDB.deleteDatabase(name);
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event
    ));
  }
  return wrap(request).then(() => void 0);
}
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));

// node_modules/@tldraw/editor/dist-esm/lib/utils/sync/LocalIndexedDb.mjs
var STORE_PREFIX = "TLDRAW_DOCUMENT_v2";
var LEGACY_ASSET_STORE_PREFIX = "TLDRAW_ASSET_STORE_v1";
var dbNameIndexKey = "TLDRAW_DB_NAME_INDEX_v2";
var Table = {
  Records: "records",
  Schema: "schema",
  SessionState: "session_state",
  Assets: "assets"
};
async function openLocalDb(persistenceKey) {
  const storeId = STORE_PREFIX + persistenceKey;
  addDbName(storeId);
  return await openDB(storeId, 4, {
    upgrade(database) {
      if (!database.objectStoreNames.contains(Table.Records)) {
        database.createObjectStore(Table.Records);
      }
      if (!database.objectStoreNames.contains(Table.Schema)) {
        database.createObjectStore(Table.Schema);
      }
      if (!database.objectStoreNames.contains(Table.SessionState)) {
        database.createObjectStore(Table.SessionState);
      }
      if (!database.objectStoreNames.contains(Table.Assets)) {
        database.createObjectStore(Table.Assets);
      }
    }
  });
}
async function migrateLegacyAssetDbIfNeeded(persistenceKey) {
  const databases = window.indexedDB.databases ? (await window.indexedDB.databases()).map((db) => db.name) : getAllIndexDbNames();
  const oldStoreId = LEGACY_ASSET_STORE_PREFIX + persistenceKey;
  const existing = databases.find((dbName) => dbName === oldStoreId);
  if (!existing)
    return;
  const oldAssetDb = await openDB(oldStoreId, 1, {
    upgrade(database) {
      if (!database.objectStoreNames.contains("assets")) {
        database.createObjectStore("assets");
      }
    }
  });
  if (!oldAssetDb.objectStoreNames.contains("assets"))
    return;
  const oldTx = oldAssetDb.transaction(["assets"], "readonly");
  const oldAssetStore = oldTx.objectStore("assets");
  const oldAssetsKeys = await oldAssetStore.getAllKeys();
  const oldAssets = await Promise.all(
    oldAssetsKeys.map(async (key) => [key, await oldAssetStore.get(key)])
  );
  await oldTx.done;
  const newDb = await openLocalDb(persistenceKey);
  const newTx = newDb.transaction([Table.Assets], "readwrite");
  const newAssetTable = newTx.objectStore(Table.Assets);
  for (const [key, value] of oldAssets) {
    newAssetTable.put(value, key);
  }
  await newTx.done;
  oldAssetDb.close();
  newDb.close();
  await deleteDB(oldStoreId);
}
var _LocalIndexedDb = class _LocalIndexedDb {
  constructor(persistenceKey) {
    __publicField(this, "getDbPromise");
    __publicField(this, "isClosed", false);
    __publicField(this, "pendingTransactionSet", /* @__PURE__ */ new Set());
    _LocalIndexedDb.connectedInstances.add(this);
    this.getDbPromise = (async () => {
      await migrateLegacyAssetDbIfNeeded(persistenceKey);
      return await openLocalDb(persistenceKey);
    })();
  }
  getDb() {
    return this.getDbPromise;
  }
  /**
   * Wait for any pending transactions to be completed. Useful for tests.
   *
   * @internal
   */
  pending() {
    return Promise.allSettled([this.getDbPromise, ...this.pendingTransactionSet]).then(noop);
  }
  async close() {
    if (this.isClosed)
      return;
    this.isClosed = true;
    await this.pending();
    (await this.getDb()).close();
    _LocalIndexedDb.connectedInstances.delete(this);
  }
  tx(mode, names, cb) {
    const txPromise = (async () => {
      assert(!this.isClosed, "db is closed");
      const db = await this.getDb();
      const tx = db.transaction(names, mode);
      const done = tx.done.catch((e) => {
        if (!this.isClosed) {
          throw e;
        }
      });
      try {
        return await cb(tx);
      } finally {
        if (!this.isClosed) {
          await done;
        } else {
          tx.abort();
        }
      }
    })();
    this.pendingTransactionSet.add(txPromise);
    txPromise.finally(() => this.pendingTransactionSet.delete(txPromise));
    return txPromise;
  }
  async load({ sessionId } = {}) {
    return await this.tx(
      "readonly",
      [Table.Records, Table.Schema, Table.SessionState],
      async (tx) => {
        var _a5, _b;
        const recordsStore = tx.objectStore(Table.Records);
        const schemaStore = tx.objectStore(Table.Schema);
        const sessionStateStore = tx.objectStore(Table.SessionState);
        let sessionStateSnapshot = sessionId ? (_a5 = await sessionStateStore.get(sessionId)) == null ? void 0 : _a5.snapshot : null;
        if (!sessionStateSnapshot) {
          const all = await sessionStateStore.getAll();
          sessionStateSnapshot = (_b = all.sort((a, b) => a.updatedAt - b.updatedAt).pop()) == null ? void 0 : _b.snapshot;
        }
        const result = {
          records: await recordsStore.getAll(),
          schema: await schemaStore.get(Table.Schema),
          sessionStateSnapshot
        };
        return result;
      }
    );
  }
  async storeChanges({
    schema,
    changes,
    sessionId,
    sessionStateSnapshot
  }) {
    await this.tx("readwrite", [Table.Records, Table.Schema, Table.SessionState], async (tx) => {
      const recordsStore = tx.objectStore(Table.Records);
      const schemaStore = tx.objectStore(Table.Schema);
      const sessionStateStore = tx.objectStore(Table.SessionState);
      for (const [id, record] of Object.entries(changes.added)) {
        await recordsStore.put(record, id);
      }
      for (const [_prev, updated] of Object.values(changes.updated)) {
        await recordsStore.put(updated, updated.id);
      }
      for (const id of Object.keys(changes.removed)) {
        await recordsStore.delete(id);
      }
      schemaStore.put(schema.serialize(), Table.Schema);
      if (sessionStateSnapshot && sessionId) {
        sessionStateStore.put(
          {
            snapshot: sessionStateSnapshot,
            updatedAt: Date.now(),
            id: sessionId
          },
          sessionId
        );
      } else if (sessionStateSnapshot || sessionId) {
        console.error("sessionStateSnapshot and instanceId must be provided together");
      }
    });
  }
  async storeSnapshot({
    schema,
    snapshot,
    sessionId,
    sessionStateSnapshot
  }) {
    await this.tx("readwrite", [Table.Records, Table.Schema, Table.SessionState], async (tx) => {
      const recordsStore = tx.objectStore(Table.Records);
      const schemaStore = tx.objectStore(Table.Schema);
      const sessionStateStore = tx.objectStore(Table.SessionState);
      await recordsStore.clear();
      for (const [id, record] of Object.entries(snapshot)) {
        await recordsStore.put(record, id);
      }
      schemaStore.put(schema.serialize(), Table.Schema);
      if (sessionStateSnapshot && sessionId) {
        sessionStateStore.put(
          {
            snapshot: sessionStateSnapshot,
            updatedAt: Date.now(),
            id: sessionId
          },
          sessionId
        );
      } else if (sessionStateSnapshot || sessionId) {
        console.error("sessionStateSnapshot and instanceId must be provided together");
      }
    });
  }
  async pruneSessions() {
    await this.tx("readwrite", [Table.SessionState], async (tx) => {
      const sessionStateStore = tx.objectStore(Table.SessionState);
      const all = (await sessionStateStore.getAll()).sort((a, b) => a.updatedAt - b.updatedAt);
      if (all.length < 10) {
        await tx.done;
        return;
      }
      const toDelete = all.slice(0, all.length - 10);
      for (const { id } of toDelete) {
        await sessionStateStore.delete(id);
      }
    });
  }
  async getAsset(assetId) {
    return await this.tx("readonly", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      return await assetsStore.get(assetId);
    });
  }
  async storeAsset(assetId, blob) {
    await this.tx("readwrite", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      await assetsStore.put(blob, assetId);
    });
  }
  async removeAssets(assetId) {
    await this.tx("readwrite", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      for (const id of assetId) {
        await assetsStore.delete(id);
      }
    });
  }
};
/** @internal */
__publicField(_LocalIndexedDb, "connectedInstances", /* @__PURE__ */ new Set());
var LocalIndexedDb = _LocalIndexedDb;
function getAllIndexDbNames() {
  const result = JSON.parse(getFromLocalStorage(dbNameIndexKey) || "[]") ?? [];
  if (!Array.isArray(result)) {
    return [];
  }
  return result;
}
function addDbName(name) {
  const all = new Set(getAllIndexDbNames());
  all.add(name);
  setInLocalStorage(dbNameIndexKey, JSON.stringify([...all]));
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/sync/alerts.mjs
function showCantWriteToIndexDbAlert() {
  window.alert(
    `Oops! We could not save changes to your browser's storage. We now need to reload the page and try again.

Keep seeing this message?
• If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.
• If your hard disk is full, try clearing up some space and then reload the page.`
  );
}
function showCantReadFromIndexDbAlert() {
  window.alert(
    `Oops! We could not access your browser's storage—and the app won't work correctly without that. We now need to reload the page and try again.

Keep seeing this message?
• If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.`
  );
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/sync/TLLocalSyncClient.mjs
var PERSIST_THROTTLE_MS = 350;
var PERSIST_RETRY_THROTTLE_MS = 1e4;
var UPDATE_INSTANCE_STATE = Symbol("UPDATE_INSTANCE_STATE");
var msg = (msg2) => msg2;
var BroadcastChannelMock = class {
  constructor(_name) {
    __publicField(this, "onmessage");
  }
  postMessage(_msg) {
  }
  close() {
  }
};
var BC = typeof BroadcastChannel === "undefined" ? BroadcastChannelMock : BroadcastChannel;
var TLLocalSyncClient = class {
  constructor(store, {
    persistenceKey,
    sessionId = TAB_ID,
    onLoad,
    onLoadError
  }, channel2 = new BC(`tldraw-tab-sync-${persistenceKey}`)) {
    __publicField(this, "disposables", /* @__PURE__ */ new Set());
    __publicField(this, "diffQueue", []);
    __publicField(this, "didDispose", false);
    __publicField(this, "shouldDoFullDBWrite", true);
    __publicField(this, "isReloading", false);
    __publicField(this, "persistenceKey");
    __publicField(this, "sessionId");
    __publicField(this, "serializedSchema");
    __publicField(this, "isDebugging", false);
    __publicField(this, "documentTypes");
    __publicField(this, "$sessionStateSnapshot");
    /** @internal */
    __publicField(this, "db");
    __publicField(this, "initTime", Date.now());
    __publicField(this, "isPersisting", false);
    __publicField(this, "didLastWriteError", false);
    // eslint-disable-next-line no-restricted-globals
    __publicField(this, "scheduledPersistTimeout", null);
    this.store = store;
    this.channel = channel2;
    if (typeof window !== "undefined") {
      ;
      window.tlsync = this;
    }
    this.persistenceKey = persistenceKey;
    this.sessionId = sessionId;
    this.db = new LocalIndexedDb(persistenceKey);
    this.disposables.add(() => this.db.close());
    this.serializedSchema = this.store.schema.serialize();
    this.$sessionStateSnapshot = createSessionStateSnapshotSignal(this.store);
    this.disposables.add(
      // Set up a subscription to changes from the store: When
      // the store changes (and if the change was made by the user)
      // then immediately send the diff to other tabs via postMessage
      // and schedule a persist.
      store.listen(
        ({ changes }) => {
          this.diffQueue.push(changes);
          this.channel.postMessage(
            msg({
              type: "diff",
              storeId: this.store.id,
              changes,
              schema: this.serializedSchema
            })
          );
          this.schedulePersist();
        },
        { source: "user", scope: "document" }
      )
    );
    this.disposables.add(
      store.listen(
        () => {
          this.diffQueue.push(UPDATE_INSTANCE_STATE);
          this.schedulePersist();
        },
        { scope: "session" }
      )
    );
    this.connect(onLoad, onLoadError);
    this.documentTypes = new Set(
      Object.values(this.store.schema.types).filter((t2) => t2.scope === "document").map((t2) => t2.typeName)
    );
  }
  debug(...args) {
    if (this.isDebugging) {
      console.debug(...args);
    }
  }
  async connect(onLoad, onLoadError) {
    this.debug("connecting");
    let data;
    try {
      data = await this.db.load({ sessionId: this.sessionId });
    } catch (error) {
      onLoadError(error);
      showCantReadFromIndexDbAlert();
      return;
    }
    this.debug("loaded data from store", data, "didDispose", this.didDispose);
    if (this.didDispose)
      return;
    try {
      if (data) {
        const documentSnapshot = Object.fromEntries(data.records.map((r) => [r.id, r]));
        const sessionStateSnapshot = data.sessionStateSnapshot ?? extractSessionStateFromLegacySnapshot(documentSnapshot);
        const migrationResult = this.store.schema.migrateStoreSnapshot({
          store: documentSnapshot,
          // eslint-disable-next-line @typescript-eslint/no-deprecated
          schema: data.schema ?? this.store.schema.serializeEarliestVersion()
        });
        if (migrationResult.type === "error") {
          console.error("failed to migrate store", migrationResult);
          onLoadError(new Error(`Failed to migrate store: ${migrationResult.reason}`));
          return;
        }
        const records = Object.values(migrationResult.value).filter(
          (r) => this.documentTypes.has(r.typeName)
        );
        if (records.length > 0) {
          this.store.mergeRemoteChanges(() => {
            this.store.put(records, "initialize");
          });
        }
        if (sessionStateSnapshot) {
          loadSessionStateSnapshotIntoStore(this.store, sessionStateSnapshot, {
            forceOverwrite: true
          });
        }
      }
      this.channel.onmessage = ({ data: data2 }) => {
        var _a5, _b;
        this.debug("got message", data2);
        const msg2 = data2;
        const res = this.store.schema.getMigrationsSince(msg2.schema);
        if (!res.ok) {
          const timeSinceInit = Date.now() - this.initTime;
          if (timeSinceInit < 5e3) {
            onLoadError(new Error("Schema mismatch, please close other tabs and reload the page"));
            return;
          }
          this.debug("reloading");
          this.isReloading = true;
          (_b = (_a5 = window == null ? void 0 : window.location) == null ? void 0 : _a5.reload) == null ? void 0 : _b.call(_a5);
          return;
        } else if (res.value.length > 0) {
          this.debug("telling them to reload");
          this.channel.postMessage({ type: "announce", schema: this.serializedSchema });
          this.shouldDoFullDBWrite = true;
          this.persistIfNeeded();
          return;
        }
        if (msg2.type === "diff") {
          this.debug("applying diff");
          transact(() => {
            this.store.mergeRemoteChanges(() => {
              this.store.applyDiff(msg2.changes);
            });
          });
        }
      };
      this.channel.postMessage({ type: "announce", schema: this.serializedSchema });
      this.disposables.add(() => {
        this.channel.close();
      });
      onLoad(this);
    } catch (e) {
      this.debug("error loading data from store", e);
      if (this.didDispose)
        return;
      onLoadError(e);
      return;
    }
  }
  close() {
    this.debug("closing");
    this.didDispose = true;
    this.disposables.forEach((d) => d());
  }
  /**
   * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too
   * often, and will retry if failed.
   *
   * @internal
   */
  schedulePersist() {
    this.debug("schedulePersist", this.scheduledPersistTimeout);
    if (this.scheduledPersistTimeout)
      return;
    this.scheduledPersistTimeout = setTimeout(
      () => {
        this.scheduledPersistTimeout = null;
        this.persistIfNeeded();
      },
      this.didLastWriteError ? PERSIST_RETRY_THROTTLE_MS : PERSIST_THROTTLE_MS
    );
  }
  /**
   * Persist to IndexedDB only under certain circumstances:
   *
   * - If we're not already persisting
   * - If we're not reloading the page
   * - And we have something to persist (a full db write scheduled or changes in the diff queue)
   *
   * @internal
   */
  persistIfNeeded() {
    this.debug("persistIfNeeded", {
      isPersisting: this.isPersisting,
      isReloading: this.isReloading,
      shouldDoFullDBWrite: this.shouldDoFullDBWrite,
      diffQueueLength: this.diffQueue.length,
      storeIsPossiblyCorrupt: this.store.isPossiblyCorrupted()
    });
    if (this.scheduledPersistTimeout) {
      clearTimeout(this.scheduledPersistTimeout);
      this.scheduledPersistTimeout = null;
    }
    if (this.isPersisting)
      return;
    if (this.isReloading)
      return;
    if (this.store.isPossiblyCorrupted())
      return;
    if (this.shouldDoFullDBWrite || this.diffQueue.length > 0) {
      this.doPersist();
    }
  }
  /**
   * Actually persist to IndexedDB. If the write fails, then we'll retry with a full db write after
   * a short delay.
   */
  async doPersist() {
    assert(!this.isPersisting, "persist already in progress");
    if (this.didDispose)
      return;
    this.isPersisting = true;
    this.debug("doPersist start");
    const diffQueue = this.diffQueue;
    this.diffQueue = [];
    try {
      if (this.shouldDoFullDBWrite) {
        this.shouldDoFullDBWrite = false;
        await this.db.storeSnapshot({
          schema: this.store.schema,
          snapshot: this.store.serialize(),
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      } else {
        const diffs = squashRecordDiffs(
          diffQueue.filter((d) => d !== UPDATE_INSTANCE_STATE)
        );
        await this.db.storeChanges({
          changes: diffs,
          schema: this.store.schema,
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      }
      this.didLastWriteError = false;
    } catch (e) {
      this.shouldDoFullDBWrite = true;
      this.didLastWriteError = true;
      console.error("failed to store changes in indexed db", e);
      showCantWriteToIndexDbAlert();
      if (typeof window !== "undefined") {
        window.location.reload();
      }
    }
    this.isPersisting = false;
    this.debug("doPersist end");
    this.schedulePersist();
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useRefState.mjs
var import_react40 = __toESM(require_react(), 1);
function useRefState(initialValue) {
  const ref = (0, import_react40.useRef)(initialValue);
  const [state, setState] = (0, import_react40.useState)(initialValue);
  if (state !== ref.current) {
    setState(ref.current);
  }
  const update = (0, import_react40.useCallback)((value) => {
    if (typeof value === "function") {
      ref.current = value(ref.current);
    } else {
      ref.current = value;
    }
    setState(ref.current);
  }, []);
  return [state, update];
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useLocalStore.mjs
function useLocalStore(options2) {
  const [state, setState] = useRefState({ status: "loading" });
  options2 = useShallowObjectIdentity(options2);
  (0, import_react41.useEffect)(() => {
    const { persistenceKey, sessionId, ...rest } = options2;
    if (!persistenceKey) {
      setState({
        status: "not-synced",
        store: createTLStore(rest)
      });
      return;
    }
    setState({ status: "loading" });
    const objectURLCache = new WeakCache();
    const assets = {
      upload: async (asset, file) => {
        await client.db.storeAsset(asset.id, file);
        return { src: asset.id };
      },
      resolve: async (asset) => {
        if (!asset.props.src)
          return null;
        if (asset.props.src.startsWith("asset:")) {
          return await objectURLCache.get(asset, async () => {
            const blob = await client.db.getAsset(asset.id);
            if (!blob)
              return null;
            return URL.createObjectURL(blob);
          });
        }
        return asset.props.src;
      },
      remove: async (assetIds) => {
        await client.db.removeAssets(assetIds);
      },
      ...rest.assets
    };
    const store = createTLStore({ ...rest, assets });
    let isClosed = false;
    const client = new TLLocalSyncClient(store, {
      sessionId,
      persistenceKey,
      onLoad() {
        if (isClosed)
          return;
        setState({ store, status: "synced-local" });
      },
      onLoadError(err) {
        if (isClosed)
          return;
        setState({ status: "error", error: err });
      }
    });
    return () => {
      isClosed = true;
      client.close();
    };
  }, [options2, setState]);
  return state;
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useZoomCss.mjs
var React9 = __toESM(require_react(), 1);
function useZoomCss() {
  const editor = useEditor();
  const container = useContainer();
  React9.useEffect(() => {
    const setScale = (s) => container.style.setProperty("--tl-zoom", s.toString());
    const setScaleDebounced = debounce(setScale, 100);
    const scheduler = new EffectScheduler("useZoomCss", () => {
      const numShapes = editor.getCurrentPageShapeIds().size;
      if (numShapes < 300) {
        setScale(editor.getZoomLevel());
      } else {
        setScaleDebounced(editor.getZoomLevel());
      }
    });
    scheduler.attach();
    scheduler.execute();
    return () => {
      scheduler.detach();
      setScaleDebounced.cancel();
    };
  }, [editor, container]);
}

// node_modules/@tldraw/editor/dist-esm/lib/license/LicenseProvider.mjs
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react42 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/utils/licensing.mjs
function str2ab(str) {
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}
function importPublicKey(pemContents) {
  const binaryDerString = atob(pemContents);
  const binaryDer = str2ab(binaryDerString);
  return crypto.subtle.importKey(
    "spki",
    new Uint8Array(binaryDer),
    {
      name: "ECDSA",
      namedCurve: "P-256"
    },
    true,
    ["verify"]
  );
}

// node_modules/@tldraw/editor/dist-esm/lib/license/LicenseManager.mjs
var GRACE_PERIOD_DAYS = 5;
var FLAGS = {
  ANNUAL_LICENSE: 1,
  PERPETUAL_LICENSE: 2,
  INTERNAL_LICENSE: 4,
  WITH_WATERMARK: 8
};
var HIGHEST_FLAG = Math.max(...Object.values(FLAGS));
var PROPERTIES = {
  ID: 0,
  HOSTS: 1,
  FLAGS: 2,
  EXPIRY_DATE: 3
};
var NUMBER_OF_KNOWN_PROPERTIES = Object.keys(PROPERTIES).length;
var LICENSE_EMAIL = "sales@tldraw.com";
var WATERMARK_TRACK_SRC = `${getDefaultCdnBaseUrl()}/watermarks/watermark-track.svg`;
var LicenseManager = class {
  constructor(licenseKey, testPublicKey, testEnvironment) {
    __publicField(this, "publicKey", "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEHJh0uUfxHtCGyerXmmatE368Hd9rI6LH9oPDQihnaCryRFWEVeOvf9U/SPbyxX74LFyJs5tYeAHq5Nc0Ax25LQ");
    __publicField(this, "isDevelopment");
    __publicField(this, "isTest");
    __publicField(this, "isCryptoAvailable");
    __publicField(this, "state", atom(
      "license state",
      "pending"
    ));
    __publicField(this, "verbose", true);
    this.isTest = false;
    this.isDevelopment = this.getIsDevelopment(testEnvironment);
    this.publicKey = testPublicKey || this.publicKey;
    this.isCryptoAvailable = !!crypto.subtle;
    this.getLicenseFromKey(licenseKey).then((result) => {
      const isUnlicensed = isEditorUnlicensed(result);
      if (!this.isDevelopment && isUnlicensed) {
        fetch(WATERMARK_TRACK_SRC);
      }
      if (isUnlicensed) {
        this.state.set("unlicensed");
      } else if (result.isLicensedWithWatermark) {
        this.state.set("licensed-with-watermark");
      } else {
        this.state.set("licensed");
      }
    });
  }
  getIsDevelopment(testEnvironment) {
    if (testEnvironment === "development")
      return true;
    if (testEnvironment === "production")
      return false;
    return !["https:", "vscode-webview:"].includes(window.location.protocol) || window.location.hostname === "localhost";
  }
  async extractLicenseKey(licenseKey) {
    const [data, signature] = licenseKey.split(".");
    const [prefix, encodedData] = data.split("/");
    if (!prefix.startsWith("tldraw-")) {
      throw new Error(`Unsupported prefix '${prefix}'`);
    }
    const publicCryptoKey = await importPublicKey(this.publicKey);
    let isVerified;
    try {
      isVerified = await crypto.subtle.verify(
        {
          name: "ECDSA",
          hash: { name: "SHA-256" }
        },
        publicCryptoKey,
        new Uint8Array(str2ab(atob(signature))),
        new Uint8Array(str2ab(atob(encodedData)))
      );
    } catch (e) {
      console.error(e);
      throw new Error("Could not perform signature validation");
    }
    if (!isVerified) {
      throw new Error("Invalid signature");
    }
    let decodedData;
    try {
      decodedData = JSON.parse(atob(encodedData));
    } catch {
      throw new Error("Could not parse object");
    }
    if (decodedData.length > NUMBER_OF_KNOWN_PROPERTIES) {
      this.outputMessages([
        "License key contains some unknown properties.",
        "You may want to update tldraw packages to a newer version to get access to new functionality."
      ]);
    }
    return {
      id: decodedData[PROPERTIES.ID],
      hosts: decodedData[PROPERTIES.HOSTS],
      flags: decodedData[PROPERTIES.FLAGS],
      expiryDate: decodedData[PROPERTIES.EXPIRY_DATE]
    };
  }
  async getLicenseFromKey(licenseKey) {
    if (!licenseKey) {
      if (!this.isDevelopment) {
        this.outputNoLicenseKeyProvided();
      }
      return { isLicenseParseable: false, reason: "no-key-provided" };
    }
    if (this.isDevelopment && !this.isCryptoAvailable) {
      if (this.verbose) {
        console.log(
          "tldraw: you seem to be in a development environment that does not support crypto. License not verified."
        );
        console.log("You should check that this works in production separately.");
      }
      return { isLicenseParseable: false, reason: "has-key-development-mode" };
    }
    let cleanedLicenseKey = licenseKey.replace(/[\u200B-\u200D\uFEFF]/g, "");
    cleanedLicenseKey = cleanedLicenseKey.replace(/\r?\n|\r/g, "");
    try {
      const licenseInfo = await this.extractLicenseKey(cleanedLicenseKey);
      const expiryDate = new Date(licenseInfo.expiryDate);
      const isAnnualLicense = this.isFlagEnabled(licenseInfo.flags, FLAGS.ANNUAL_LICENSE);
      const isPerpetualLicense = this.isFlagEnabled(licenseInfo.flags, FLAGS.PERPETUAL_LICENSE);
      const result = {
        license: licenseInfo,
        isLicenseParseable: true,
        isDevelopment: this.isDevelopment,
        isDomainValid: this.isDomainValid(licenseInfo),
        expiryDate,
        isAnnualLicense,
        isAnnualLicenseExpired: isAnnualLicense && this.isAnnualLicenseExpired(expiryDate),
        isPerpetualLicense,
        isPerpetualLicenseExpired: isPerpetualLicense && this.isPerpetualLicenseExpired(expiryDate),
        isInternalLicense: this.isFlagEnabled(licenseInfo.flags, FLAGS.INTERNAL_LICENSE),
        isLicensedWithWatermark: this.isFlagEnabled(licenseInfo.flags, FLAGS.WITH_WATERMARK)
      };
      this.outputLicenseInfoIfNeeded(result);
      return result;
    } catch (e) {
      this.outputInvalidLicenseKey(e.message);
      return { isLicenseParseable: false, reason: "invalid-license-key" };
    }
  }
  isDomainValid(licenseInfo) {
    const currentHostname = window.location.hostname.toLowerCase();
    return licenseInfo.hosts.some((host) => {
      const normalizedHost = host.toLowerCase().trim();
      if (normalizedHost === currentHostname || `www.${normalizedHost}` === currentHostname || normalizedHost === `www.${currentHostname}`) {
        return true;
      }
      if (host === "*") {
        return true;
      }
      if (host.includes("*")) {
        const globToRegex = new RegExp(host.replace(/\*/g, ".*?"));
        return globToRegex.test(currentHostname) || globToRegex.test(`www.${currentHostname}`);
      }
      if (window.location.protocol === "vscode-webview:") {
        const currentUrl = new URL(window.location.href);
        const extensionId = currentUrl.searchParams.get("extensionId");
        if (normalizedHost === extensionId) {
          return true;
        }
      }
      return false;
    });
  }
  getExpirationDateWithoutGracePeriod(expiryDate) {
    return new Date(expiryDate.getFullYear(), expiryDate.getMonth(), expiryDate.getDate());
  }
  getExpirationDateWithGracePeriod(expiryDate) {
    return new Date(
      expiryDate.getFullYear(),
      expiryDate.getMonth(),
      expiryDate.getDate() + GRACE_PERIOD_DAYS + 1
      // Add 1 day to include the expiration day
    );
  }
  isAnnualLicenseExpired(expiryDate) {
    const expiration = this.getExpirationDateWithGracePeriod(expiryDate);
    const isExpired = /* @__PURE__ */ new Date() >= expiration;
    if (!isExpired && /* @__PURE__ */ new Date() >= this.getExpirationDateWithoutGracePeriod(expiryDate)) {
      this.outputMessages([
        "tldraw license is about to expire, you are in a grace period.",
        `Please reach out to ${LICENSE_EMAIL} if you would like to renew your license.`
      ]);
    }
    return isExpired;
  }
  isPerpetualLicenseExpired(expiryDate) {
    const expiration = this.getExpirationDateWithGracePeriod(expiryDate);
    const dates = {
      major: new Date(publishDates.major),
      minor: new Date(publishDates.minor)
    };
    return dates.major >= expiration || dates.minor >= expiration;
  }
  isFlagEnabled(flags, flag) {
    return (flags & flag) === flag;
  }
  outputNoLicenseKeyProvided() {
  }
  outputInvalidLicenseKey(msg2) {
    this.outputMessages(["Invalid tldraw license key", `Reason: ${msg2}`]);
  }
  outputLicenseInfoIfNeeded(result) {
    if (result.isAnnualLicenseExpired) {
      this.outputMessages([
        "Your tldraw license has expired!",
        `Please reach out to ${LICENSE_EMAIL} to renew.`
      ]);
    }
    if (!result.isDomainValid && !result.isDevelopment) {
      this.outputMessages([
        "This tldraw license key is not valid for this domain!",
        `Please reach out to ${LICENSE_EMAIL} if you would like to use tldraw on other domains.`
      ]);
    }
    if (result.license.flags >= HIGHEST_FLAG * 2) {
      this.outputMessages([
        "This tldraw license contains some unknown flags.",
        "You may want to update tldraw packages to a newer version to get access to new functionality."
      ]);
    }
  }
  outputMessages(messages) {
    if (this.isTest)
      return;
    if (this.verbose) {
      this.outputDelimiter();
      for (const message of messages) {
        console.log(
          `%c${message}`,
          `color: white; background: crimson; padding: 2px; border-radius: 3px;`
        );
      }
      this.outputDelimiter();
    }
  }
  outputDelimiter() {
    console.log(
      "%c-------------------------------------------------------------------",
      `color: white; background: crimson; padding: 2px; border-radius: 3px;`
    );
  }
};
__publicField(LicenseManager, "className", "tl-watermark_SEE-LICENSE");
function isEditorUnlicensed(result) {
  if (!result.isLicenseParseable)
    return true;
  if (!result.isDomainValid && !result.isDevelopment)
    return true;
  if (result.isPerpetualLicenseExpired || result.isAnnualLicenseExpired) {
    if (result.isInternalLicense) {
      throw new Error("License: Internal license expired.");
    }
    return true;
  }
  return false;
}

// node_modules/@tldraw/editor/dist-esm/lib/license/LicenseProvider.mjs
var LicenseContext = (0, import_react42.createContext)({});
var useLicenseContext = () => (0, import_react42.useContext)(LicenseContext);
function LicenseProvider({
  licenseKey,
  children
}) {
  const [licenseManager] = (0, import_react42.useState)(() => new LicenseManager(licenseKey));
  return (0, import_jsx_runtime33.jsx)(LicenseContext.Provider, { value: licenseManager, children });
}

// node_modules/@tldraw/editor/dist-esm/lib/license/Watermark.mjs
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);

// node_modules/@tldraw/editor/dist-esm/lib/hooks/usePassThroughWheelEvents.mjs
var import_react43 = __toESM(require_react(), 1);
function usePassThroughWheelEvents(ref) {
  if (!ref)
    throw Error("usePassThroughWheelEvents must be passed a ref");
  const container = useContainer();
  (0, import_react43.useEffect)(() => {
    function onWheel(e) {
      if (e.isSpecialRedispatchedEvent)
        return;
      const elm2 = ref.current;
      if (elm2 && elm2.scrollHeight > elm2.clientHeight) {
        return;
      }
      preventDefault(e);
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs)
        return;
      const newEvent = new WheelEvent("wheel", e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    const elm = ref.current;
    if (!elm)
      return;
    elm.addEventListener("wheel", onWheel, { passive: false });
    return () => {
      elm.removeEventListener("wheel", onWheel);
    };
  }, [container, ref]);
}

// node_modules/@tldraw/editor/dist-esm/lib/watermarks.mjs
var watermarkDesktopSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="3001" height="1000" fill="none"><path fill="#000" d="M590.656 300.449c0 49.706-40.294 90-90 90-49.705 0-90-40.294-90-90 0-49.705 40.295-90 90-90 49.706 0 90 40.295 90 90M569.431 719.011c-15.247 32.821-56.006 91.589-98.338 91.438-32.004-.115-38.642-30.904-17.414-50.856 17.381-16.337 28.246-48.075 31.995-72.719.415-2.728-1.556-5.197-4.272-5.679-39.666-7.04-70.746-40.877-70.746-83.417 0-48.23 38.983-87.329 87.07-87.329 39.936 0 70.172 22.237 83.369 52.397 18.839 43.055 7.117 115.733-11.664 156.165M2613.29 385.681V239.319c0-11.363 9.22-20.569 20.59-20.569h8.26c11.37 0 20.59 9.206 20.59 20.569v36.911c0 8.629 7 15.625 15.63 15.625h35.25c8.63 0 15.63-6.996 15.63-15.625v-36.911c0-11.363 9.22-20.569 20.59-20.569h8.17c11.37 0 20.59 9.206 20.59 20.569v146.362c0 11.363-9.22 20.569-20.59 20.569h-8.17c-11.37 0-20.59-9.206-20.59-20.569v-36.999c0-8.63-7-15.625-15.63-15.625h-35.25c-8.63 0-15.63 6.995-15.63 15.625v36.999c0 11.363-9.22 20.569-20.59 20.569h-8.26c-11.37 0-20.59-9.206-20.59-20.569M2391.97 239.319v146.362c0 11.348-9.16 20.569-20.49 20.569h-8.2c-11.33 0-20.49-9.221-20.49-20.569V239.319c0-11.348 9.16-20.569 20.49-20.569h8.2c11.33 0 20.49 9.221 20.49 20.569M2098.23 391.43l-42.69-146.361c-3.85-13.171 6.06-26.319 19.79-26.319h10.6c9.59 0 17.93 6.611 20.08 15.952l17.01 73.045c1.48 6.348 10.47 6.478 12.14.176l19.47-73.838c2.38-9.04 10.57-15.335 19.93-15.335h12.1c9.37 0 17.56 6.3 19.94 15.346l19.49 74.067c1.66 6.305 10.65 6.178 12.13-.171l17.09-73.294c2.15-9.339 10.49-15.948 20.08-15.948h10.53c13.72 0 23.63 13.141 19.79 26.31l-42.63 146.361c-2.56 8.789-10.63 14.829-19.79 14.829h-15.68c-9.12 0-17.16-5.98-19.76-14.709l-21.17-71.059c-1.77-5.948-10.19-5.957-11.97-.012l-21.33 71.071c-2.6 8.729-10.64 14.709-19.76 14.709h-15.59c-9.17 0-17.23-6.035-19.8-14.82M2443.23 218.75h118.59c11.38 0 20.62 9.195 20.62 20.557s-9.24 20.556-20.62 20.556h-24.79c-5.53 0-10 4.477-10 10v115.818c0 11.368-9.25 20.569-20.63 20.569h-7.65c-11.39 0-20.63-9.201-20.63-20.569V269.863c0-5.523-4.48-10-10-10h-24.89c-11.37 0-20.61-9.195-20.61-20.556s9.24-20.557 20.61-20.557M1174.15 218.75h24.64c8.35 0 15.88 5.042 19.04 12.764l34.61 83.942c2.13 5.161 9.44 5.155 11.56-.01l34.43-83.932a20.58 20.58 0 0 1 19.04-12.764h24.64c11.37 0 20.58 9.208 20.58 20.569v146.362c0 11.361-9.21 20.569-20.58 20.569h-7.09c-11.36 0-20.58-9.208-20.58-20.569l-.12-50.645c-.01-6.888-9.53-8.688-12.06-2.283l-23.46 59.332a20.57 20.57 0 0 1-19.14 13.009h-3.03a20.57 20.57 0 0 1-19.15-13.046l-23.47-59.68c-2.52-6.416-12.05-4.623-12.06 2.271l-.13 51.042c0 11.361-9.21 20.569-20.57 20.569h-7.1c-11.36 0-20.57-9.208-20.57-20.569V239.319c0-11.361 9.21-20.569 20.57-20.569"/><path fill="#000" fill-rule="evenodd" d="m1449.94 391.836 6.12-19.392a6.255 6.255 0 0 1 5.96-4.369l50.22-.061a6.24 6.24 0 0 1 5.96 4.348l6.23 19.486c2.71 8.581 10.71 14.402 19.74 14.402h9.34c14.13 0 24.15-13.791 19.61-27.151l-49.74-146.361c-2.85-8.37-10.74-13.988-19.61-13.988h-33.16c-8.87 0-16.77 5.618-19.61 13.988l-49.74 146.361c-4.54 13.36 5.48 27.151 19.61 27.151h9.32c9.04 0 17.04-5.827 19.75-14.414m31.1-98.858c1.85-5.807 10.08-5.796 11.91.016l8.83 27.916c1.28 4.028-1.73 8.134-5.96 8.134h-17.74c-4.23 0-7.24-4.119-5.95-8.151zM1681.81 406.25c18.91 0 35.39-3.686 49.36-11.168 13.97-7.544 24.73-18.394 32.24-32.489 7.56-14.105 11.29-30.866 11.29-50.182 0-19.256-3.73-35.957-11.29-50.004-7.57-14.094-18.35-24.912-32.32-32.397-13.91-7.545-30.4-11.26-49.37-11.26h-49.5c-11.38 0-20.63 9.201-20.63 20.569v146.362c0 11.368 9.25 20.569 20.63 20.569zm23.13-47.701c-6.62 3.215-14.85 4.886-24.79 4.886-10.49 0-19-8.507-19-19v-64.34c0-10.149 8.23-18.376 18.38-18.376 10.18 0 18.56 1.703 25.23 4.974 6.59 3.149 11.63 8.315 15.08 15.633 3.45 7.269 5.28 17.268 5.28 30.162 0 12.891-1.82 22.951-5.28 30.347-3.39 7.319-8.36 12.509-14.9 15.714" clip-rule="evenodd"/><path fill="#000" d="M1804.21 385.681V239.319c0-11.361 9.21-20.569 20.58-20.569h91.28c11.36 0 20.57 9.202 20.57 20.557s-9.21 20.556-20.57 20.556h-54.64a7.807 7.807 0 0 0-7.81 7.813v16.366a7.806 7.806 0 0 0 7.81 7.812h48.13c11.37 0 20.58 9.246 20.58 20.602s-9.21 20.601-20.58 20.601h-48.13a7.806 7.806 0 0 0-7.81 7.812v16.455a7.807 7.807 0 0 0 7.81 7.813h54.64c11.36 0 20.57 9.202 20.57 20.556s-9.21 20.557-20.57 20.557h-91.28c-11.37 0-20.58-9.208-20.58-20.569"/><path fill="#000" fill-rule="evenodd" d="M2875.5 68.75h-2750c-31.066 0-56.25 25.184-56.25 56.25v750c0 31.066 25.184 56.25 56.25 56.25h2750c31.07 0 56.25-25.184 56.25-56.25V125c0-31.066-25.18-56.25-56.25-56.25M125.5 0C56.464 0 .5 55.964.5 125v750c0 69.036 55.965 125 125 125h2750c69.04 0 125-55.964 125-125V125c0-69.036-55.96-125-125-125z" clip-rule="evenodd"/><path fill="#000" d="M2476.06 804.813c-10.54 0-19.82-6.947-22.81-17.068L2390.79 575.7c-4.49-15.248 6.92-30.534 22.8-30.534h27.75c11.1 0 20.72 7.686 23.18 18.52L2489 671.402c2.07 9.093 14.93 9.321 17.32.308l28.83-108.844c2.76-10.435 12.19-17.7 22.98-17.7h25.17c10.8 0 20.25 7.293 22.99 17.755l28.27 107.739c2.36 9.001 15.18 8.829 17.3-.232l25.01-106.888c2.51-10.763 12.1-18.374 23.14-18.374h27.87c15.88 0 27.29 15.286 22.8 30.534l-62.46 212.045a23.78 23.78 0 0 1-22.81 17.068h-32.12c-10.39 0-19.58-6.763-22.69-16.696l-32.08-102.694c-2.62-8.397-14.51-8.331-17.04.095l-30.74 102.346c-3.02 10.061-12.27 16.949-22.76 16.949zM1742.44 804.813h-75.81c-13.09 0-23.71-10.656-23.71-23.801V568.967c0-13.145 10.62-23.801 23.71-23.801h74.8c26.6 0 49.59 5.198 68.95 15.594 19.45 10.312 34.44 25.187 44.96 44.627 10.61 19.355 15.91 42.556 15.91 69.602q0 40.57-15.78 69.73c-10.53 19.355-25.43 34.231-44.71 44.627-19.28 10.311-42.05 15.467-68.32 15.467m-29.3-83.642c0 13.145 10.61 23.801 23.71 23.801h3.06c12.8 0 23.7-2.07 32.71-6.212 9.09-4.141 16-11.283 20.71-21.426q7.2-15.213 7.2-42.345 0-27.13-7.32-42.344c-4.8-10.143-11.87-17.285-21.22-21.426-9.26-4.142-20.63-6.212-34.1-6.212h-1.04c-13.1 0-23.71 10.656-23.71 23.801zM1460.86 804.813c-13.12 0-23.76-10.656-23.76-23.801V568.967c0-13.145 10.64-23.801 23.76-23.801h22.84c13.13 0 23.76 10.656 23.76 23.801v155.247c0 13.145 10.64 23.801 23.76 23.801h57.27c13.12 0 23.76 10.656 23.76 23.801v9.196c0 13.145-10.64 23.801-23.76 23.801zM1204.45 601.964c-13.13 0-23.77-10.656-23.77-23.801v-9.196c0-13.145 10.64-23.801 23.77-23.801h177.89c13.13 0 23.78 10.656 23.78 23.801v9.196c0 13.145-10.65 23.801-23.78 23.801h-39.38c-8.21 0-14.86 6.66-14.86 14.875v164.173c0 13.145-10.64 23.801-23.78 23.801h-21.85c-13.13 0-23.78-10.656-23.78-23.801V616.839c0-8.215-6.65-14.875-14.86-14.875z"/><path fill="#000" fill-rule="evenodd" d="M2223.05 787.891c-3.02 10.047-12.27 16.922-22.74 16.922h-25.43c-16.19 0-27.64-15.862-22.57-31.261l69.88-212.045c3.21-9.753 12.31-16.341 22.56-16.341h61.84c10.25 0 19.35 6.588 22.56 16.341l69.87 212.045c5.08 15.399-6.37 31.261-22.56 31.261h-25.43c-10.48 0-19.72-6.875-22.74-16.922l-6.7-22.2a14.84 14.84 0 0 0-14.21-10.576h-63.42c-6.55 0-12.32 4.296-14.22 10.576zm76.13-96.945-14.13-48.436c-2.46-8.451-14.36-8.602-17.04-.217l-15.46 48.436c-1.84 5.759 2.45 11.645 8.48 11.645h29.6c5.94 0 10.22-5.715 8.55-11.428" clip-rule="evenodd"/><path fill="#000" d="M1939.6 804.813c-13.13 0-23.77-10.656-23.77-23.801V568.967c0-13.145 10.64-23.801 23.77-23.801h88.13c19.24 0 36.08 3.508 50.51 10.523s25.65 17.115 33.67 30.3q12.03 19.779 12.03 47.416c0 18.595-4.14 34.273-12.41 47.036-7.64 11.913-18.18 21.101-31.63 27.564-16.98 8.159-36 11.104-54.7 11.104h-43.07c-76.56 0 4.08-135.84 4.08-84.706v7.996c0 12.117 9.81 21.941 21.91 21.941 8.12 0 16.3-.345 24.04-3.043 5.91-2.113 10.43-5.451 13.55-10.015 3.2-4.565 4.81-10.523 4.81-17.877 0-7.437-1.61-13.481-4.81-18.129-3.12-4.733-7.64-8.199-13.55-10.396-7.05-2.766-14.67-3.423-22.18-3.423-13.13 0-23.77 10.656-23.77 23.801v47.71c0 11.825 11.14 16.003 19.91 20.752 12.31 6.671 7.58 25.389-6.42 25.389-7.45 0-13.49 6.048-13.49 13.508v48.395c0 13.145-10.63 23.801-23.76 23.801zm134.89-106.758 5.41 9.95 33.51 61.622c8.62 15.86-2.84 35.186-20.87 35.186h-22.27c-8.74 0-16.77-4.798-20.92-12.496l-35.05-65.04a15.52 15.52 0 0 0-13.66-8.168c-42.24 0 40.62-82.154 73.85-21.054M931.652 0h68.748v1000h-68.748z"/></svg>';
var watermarkMobileSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="400" height="1601" fill="none"><path fill="#000" d="M72 1319.8c0-10.73 7.071-20.18 17.372-23.22l215.823-63.62c15.519-4.57 31.078 7.05 31.078 23.22v28.26c0 11.31-7.824 21.1-18.85 23.61l-109.636 24.94c-9.254 2.1-9.487 15.2-.313 17.63l110.784 29.37a24.21 24.21 0 0 1 18.015 23.4v25.64c0 11-7.423 20.62-18.071 23.41l-109.659 28.79c-9.162 2.41-8.986 15.47.236 17.63l108.792 25.46c10.955 2.56 18.702 12.33 18.702 23.57v28.39c0 16.17-15.559 27.79-31.078 23.22l-215.823-63.62c-10.3-3.04-17.372-12.49-17.372-23.22v-32.72c0-10.59 6.883-19.95 16.994-23.11l104.523-32.67c8.547-2.67 8.479-14.79-.096-17.36l-104.17-31.3C79.01 1372.42 72 1363 72 1352.31zM72 572.638V495.43c0-13.336 10.846-24.147 24.225-24.147h215.823c13.379 0 24.225 10.811 24.225 24.147v76.179q0 40.645-15.872 70.228-15.743 29.712-45.422 45.79-29.55 16.206-70.843 16.206-41.292 0-70.971-16.078-29.55-16.077-45.422-45.532Q72 612.767 72 572.638m85.132-29.84c-13.379 0-24.225 10.81-24.225 24.146v3.122q0 19.55 6.323 33.313 6.323 13.89 21.807 21.094 15.485 7.332 43.099 7.331t43.1-7.46q15.484-7.33 21.807-21.608 6.323-14.15 6.323-34.728v-1.064c0-13.336-10.846-24.146-24.225-24.146zM72 285.858c0-13.363 10.846-24.197 24.225-24.197h215.823c13.379 0 24.225 10.834 24.225 24.197v23.27c0 13.364-10.846 24.197-24.225 24.197H154.035c-13.379 0-24.225 10.834-24.225 24.197v58.328c0 13.364-10.846 24.197-24.225 24.197h-9.36C82.845 440.047 72 429.214 72 415.85zM278.463 24.72c0-13.374 10.846-24.216 24.225-24.216h9.36c13.379 0 24.225 10.842 24.225 24.216v181.174c0 13.374-10.846 24.216-24.225 24.216h-9.36c-13.379 0-24.225-10.842-24.225-24.216v-40.108c0-8.359-6.779-15.135-15.141-15.135H96.225c-13.38 0-24.225-10.842-24.225-24.216v-22.256c0-13.374 10.846-24.216 24.225-24.216h167.097c8.362 0 15.141-6.776 15.141-15.135z"/><path fill="#000" fill-rule="evenodd" d="M89.224 1062.13C78.997 1059.04 72 1049.63 72 1038.96v-25.9c0-16.486 16.145-28.147 31.818-22.979l215.823 71.169a24.19 24.19 0 0 1 16.632 22.98v62.97c0 10.45-6.706 19.71-16.632 22.98l-215.823 71.17C88.145 1246.51 72 1234.86 72 1218.37v-25.9c0-10.67 6.997-20.08 17.224-23.17l22.595-6.81a15.13 15.13 0 0 0 10.765-14.48v-64.59a15.13 15.13 0 0 0-10.765-14.48zm98.672 77.53 49.299-14.39c8.601-2.51 8.755-14.62.22-17.35l-49.299-15.75c-5.861-1.88-11.852 2.49-11.852 8.64v30.14c0 6.05 5.817 10.41 11.632 8.71" clip-rule="evenodd"/><path fill="#000" d="M72 773.439c0-13.367 10.846-24.203 24.225-24.203h215.823c13.379 0 24.225 10.836 24.225 24.203v89.762q0 29.395-10.711 51.439-10.71 22.046-30.84 34.293t-48.261 12.248q-28.388 0-47.873-12.635-18.187-11.672-28.056-32.218c-8.303-17.289-11.301-36.661-11.301-55.705v-43.867c0-77.976 138.26 4.16 86.215 4.16h-8.138c-12.334 0-22.332 9.989-22.332 22.311 0 8.269.351 16.6 3.097 24.487q3.225 9.024 10.194 13.794 6.968 4.899 18.194 4.899 11.356 0 18.453-4.899 7.226-4.77 10.581-13.794c2.815-7.188 3.484-14.944 3.484-22.596 0-13.366-10.846-24.202-24.225-24.202h-48.56c-12.036 0-16.288 11.345-21.122 20.272-6.79 12.539-25.841 7.72-25.841-6.536 0-7.586-6.156-13.736-13.749-13.736H96.225C82.845 820.916 72 810.08 72 796.714zm108.66 137.378-10.128 5.511-62.72 34.131C91.67 959.243 72 947.569 72 929.205V906.52a24.2 24.2 0 0 1 12.719-21.299l66.199-35.696a15.82 15.82 0 0 0 8.313-13.921c0-43.012 83.618 41.371 21.429 75.213"/></svg>';

// node_modules/@tldraw/editor/dist-esm/lib/license/useLicenseManagerState.mjs
function useLicenseManagerState(licenseManager) {
  return useValue("watermarkState", () => licenseManager.state.get(), [licenseManager]);
}

// node_modules/@tldraw/editor/dist-esm/lib/license/Watermark.mjs
var WATERMARK_DESKTOP_LOCAL_SRC = `data:image/svg+xml;utf8,${encodeURIComponent(watermarkDesktopSvg)}`;
var WATERMARK_MOBILE_LOCAL_SRC = `data:image/svg+xml;utf8,${encodeURIComponent(watermarkMobileSvg)}`;
var Watermark = (0, import_react44.memo)(function Watermark2() {
  const licenseManager = useLicenseContext();
  const editor = useEditor();
  const isMobile = useValue("is mobile", () => editor.getViewportScreenBounds().width < 700, [
    editor
  ]);
  const licenseManagerState = useLicenseManagerState(licenseManager);
  if (!["licensed-with-watermark", "unlicensed"].includes(licenseManagerState))
    return null;
  return (0, import_jsx_runtime34.jsxs)(import_jsx_runtime34.Fragment, { children: [
    (0, import_jsx_runtime34.jsx)(LicenseStyles, {}),
    (0, import_jsx_runtime34.jsx)(WatermarkInner, { src: isMobile ? WATERMARK_MOBILE_LOCAL_SRC : WATERMARK_DESKTOP_LOCAL_SRC })
  ] });
});
var WatermarkInner = (0, import_react44.memo)(function WatermarkInner2({ src }) {
  const editor = useEditor();
  const isDebugMode = useValue("debug mode", () => editor.getInstanceState().isDebugMode, [editor]);
  const isMobile = useValue("is mobile", () => editor.getViewportScreenBounds().width < 700, [
    editor
  ]);
  const events = useCanvasEvents();
  const ref = (0, import_react44.useRef)(null);
  usePassThroughWheelEvents(ref);
  const maskCss = `url('${src}') center 100% / 100% no-repeat`;
  const url = "https://tldraw.dev/?utm_source=dotcom&utm_medium=organic&utm_campaign=watermark";
  return (0, import_jsx_runtime34.jsx)(
    "div",
    {
      ref,
      className: LicenseManager.className,
      "data-debug": isDebugMode,
      "data-mobile": isMobile,
      draggable: false,
      ...events,
      children: (0, import_jsx_runtime34.jsx)(
        "button",
        {
          draggable: false,
          role: "button",
          onPointerDown: (e) => {
            stopEventPropagation(e);
            preventDefault(e);
          },
          title: "made with tldraw",
          onClick: () => runtime.openWindow(url, "_blank"),
          style: { mask: maskCss, WebkitMask: maskCss }
        }
      )
    }
  );
});
var LicenseStyles = (0, import_react44.memo)(function LicenseStyles2() {
  const editor = useEditor();
  const className = LicenseManager.className;
  const CSS2 = `/* ------------------- SEE LICENSE -------------------
The tldraw watermark is part of tldraw's license. It is shown for unlicensed
or "licensed-with-watermark" users. By using this library, you agree to
preserve the watermark's behavior, keeping it visible, unobscured, and
available to user-interaction.

To remove the watermark, please purchase a license at tldraw.dev.
*/

	.${className} {
		position: absolute;
		bottom: var(--space-2);
		right: var(--space-2);
		width: 96px;
		height: 32px;
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: var(--layer-watermark) !important;
		background-color: color-mix(in srgb, var(--color-background) 62%, transparent);
		opacity: 1;
		border-radius: 5px;
		pointer-events: all;
		padding: 2px;
		box-sizing: content-box;
	}

	.${className} > button {
		position: absolute;
		width: 96px;
		height: 32px;
		pointer-events: all;
		cursor: inherit;
		color: var(--color-text);
		opacity: .38;
		border: 0;
		padding: 0;
		background-color: currentColor;
	}

	.${className}[data-debug='true'] {
		bottom: 46px;
	}

	.${className}[data-mobile='true'] {
		border-radius: 4px 0px 0px 4px;
		right: -2px;
		width: 8px;
		height: 48px;
	}

	.${className}[data-mobile='true'] > button {
		width: 8px;
		height: 32px;
	}

	@media (hover: hover) {
		.${className} > button {
			pointer-events: none;
		}

		.${className}:hover {
			background-color: var(--color-background);
			transition: background-color 0.2s ease-in-out;
			transition-delay: 0.32s;
		}

		.${className}:hover > button {
			animation: delayed_link 0.2s forwards ease-in-out;
			animation-delay: 0.32s;
		}

		.${className} > button:focus-visible {
			opacity: 1;
		}
	}


	@keyframes delayed_link {
		0% {
			cursor: inherit;
			opacity: .38;
			pointer-events: none;
		}
		100% {
			cursor: pointer;
			opacity: 1;
			pointer-events: all;
		}
	}`;
  return (0, import_jsx_runtime34.jsx)("style", { nonce: editor.options.nonce, children: CSS2 });
});

// node_modules/@tldraw/editor/dist-esm/lib/TldrawEditor.mjs
var EMPTY_SHAPE_UTILS_ARRAY = [];
var EMPTY_BINDING_UTILS_ARRAY = [];
var EMPTY_TOOLS_ARRAY = [];
var TL_CONTAINER_CLASS = "tl-container";
var TldrawEditor = (0, import_react45.memo)(function TldrawEditor2({
  store,
  components,
  className,
  user: _user,
  options: _options,
  ...rest
}) {
  const [container, setContainer] = (0, import_react45.useState)(null);
  const user = (0, import_react45.useMemo)(() => _user ?? createTLUser(), [_user]);
  const ErrorFallback = (components == null ? void 0 : components.ErrorFallback) === void 0 ? DefaultErrorFallback : components == null ? void 0 : components.ErrorFallback;
  const withDefaults = {
    ...rest,
    shapeUtils: rest.shapeUtils ?? EMPTY_SHAPE_UTILS_ARRAY,
    bindingUtils: rest.bindingUtils ?? EMPTY_BINDING_UTILS_ARRAY,
    tools: rest.tools ?? EMPTY_TOOLS_ARRAY,
    components,
    options: useShallowObjectIdentity(_options)
  };
  return (0, import_jsx_runtime35.jsx)(
    "div",
    {
      ref: setContainer,
      "data-tldraw": version,
      draggable: false,
      className: (0, import_classnames11.default)(`${TL_CONTAINER_CLASS} tl-theme__light`, className),
      onPointerDown: stopEventPropagation,
      tabIndex: -1,
      role: "application",
      "aria-label": (_options == null ? void 0 : _options.branding) ?? "tldraw",
      children: (0, import_jsx_runtime35.jsx)(
        OptionalErrorBoundary,
        {
          fallback: ErrorFallback,
          onError: (error) => annotateError(error, { tags: { origin: "react.tldraw-before-app" } }),
          children: container && (0, import_jsx_runtime35.jsx)(LicenseProvider, { licenseKey: rest.licenseKey, children: (0, import_jsx_runtime35.jsx)(ContainerProvider, { container, children: (0, import_jsx_runtime35.jsx)(EditorComponentsProvider, { overrides: components, children: store ? store instanceof Store ? (
            // Store is ready to go, whether externally synced or not
            (0, import_jsx_runtime35.jsx)(TldrawEditorWithReadyStore, { ...withDefaults, store, user })
          ) : (
            // Store is a synced store, so handle syncing stages internally
            (0, import_jsx_runtime35.jsx)(TldrawEditorWithLoadingStore, { ...withDefaults, store, user })
          ) : (
            // We have no store (it's undefined) so create one and possibly sync it
            (0, import_jsx_runtime35.jsx)(TldrawEditorWithOwnStore, { ...withDefaults, store, user })
          ) }) }) })
        }
      )
    }
  );
});
function TldrawEditorWithOwnStore(props) {
  const {
    defaultName,
    snapshot,
    initialData,
    shapeUtils,
    bindingUtils,
    persistenceKey,
    sessionId,
    user,
    assets,
    migrations
  } = props;
  const syncedStore = useLocalStore({
    shapeUtils,
    bindingUtils,
    initialData,
    persistenceKey,
    sessionId,
    defaultName,
    snapshot,
    assets,
    migrations
  });
  return (0, import_jsx_runtime35.jsx)(TldrawEditorWithLoadingStore, { ...props, store: syncedStore, user });
}
var TldrawEditorWithLoadingStore = (0, import_react45.memo)(function TldrawEditorBeforeLoading({
  store,
  user,
  ...rest
}) {
  const container = useContainer();
  (0, import_react45.useLayoutEffect)(() => {
    if (user.userPreferences.get().colorScheme === "dark") {
      container.classList.remove("tl-theme__light");
      container.classList.add("tl-theme__dark");
    }
  }, [container, user]);
  const { LoadingScreen: LoadingScreen22 } = useEditorComponents();
  switch (store.status) {
    case "error": {
      throw store.error;
    }
    case "loading": {
      return LoadingScreen22 ? (0, import_jsx_runtime35.jsx)(LoadingScreen22, {}) : null;
    }
    case "not-synced": {
      break;
    }
    case "synced-local": {
      break;
    }
    case "synced-remote": {
      break;
    }
  }
  return (0, import_jsx_runtime35.jsx)(TldrawEditorWithReadyStore, { ...rest, store: store.store, user });
});
var noAutoFocus = () => document.location.search.includes("tldraw_preserve_focus");
function TldrawEditorWithReadyStore({
  onMount: onMount2,
  children,
  store,
  tools,
  shapeUtils,
  bindingUtils,
  user,
  initialState: initialState2,
  autoFocus = true,
  inferDarkMode,
  cameraOptions,
  textOptions,
  options: options2,
  licenseKey,
  deepLinks: _deepLinks,
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  isShapeHidden,
  getShapeVisibility,
  assetUrls
}) {
  const { ErrorFallback } = useEditorComponents();
  const container = useContainer();
  const [editor, setEditor] = useRefState(null);
  const canvasRef = (0, import_react45.useRef)(null);
  const deepLinks = useShallowObjectIdentity(_deepLinks === true ? {} : _deepLinks);
  const editorOptionsRef = (0, import_react45.useRef)({
    // for these, it's because they're only used when the editor first mounts:
    autoFocus: autoFocus && !noAutoFocus(),
    inferDarkMode,
    initialState: initialState2,
    // for these, it's because we keep them up to date in a separate effect:
    cameraOptions,
    deepLinks
  });
  (0, import_react45.useLayoutEffect)(() => {
    editorOptionsRef.current = {
      autoFocus: autoFocus && !noAutoFocus(),
      inferDarkMode,
      initialState: initialState2,
      cameraOptions,
      deepLinks
    };
  }, [autoFocus, inferDarkMode, initialState2, cameraOptions, deepLinks]);
  (0, import_react45.useLayoutEffect)(
    () => {
      const { autoFocus: autoFocus2, inferDarkMode: inferDarkMode2, initialState: initialState22, cameraOptions: cameraOptions2, deepLinks: deepLinks2 } = editorOptionsRef.current;
      const editor2 = new Editor({
        store,
        shapeUtils,
        bindingUtils,
        tools,
        getContainer: () => container,
        user,
        initialState: initialState22,
        // we should check for some kind of query parameter that turns off autofocus
        autoFocus: autoFocus2,
        inferDarkMode: inferDarkMode2,
        cameraOptions: cameraOptions2,
        textOptions,
        options: options2,
        licenseKey,
        isShapeHidden,
        getShapeVisibility,
        fontAssetUrls: assetUrls == null ? void 0 : assetUrls.fonts
      });
      editor2.updateViewportScreenBounds(canvasRef.current ?? container);
      if (deepLinks2) {
        if (!(deepLinks2 == null ? void 0 : deepLinks2.getUrl)) {
          editor2.navigateToDeepLink(deepLinks2);
        } else {
          editor2.navigateToDeepLink({ ...deepLinks2, url: deepLinks2.getUrl(editor2) });
        }
      }
      setEditor(editor2);
      return () => {
        editor2.dispose();
      };
    },
    // if any of these change, we need to recreate the editor.
    [
      bindingUtils,
      container,
      options2,
      shapeUtils,
      store,
      tools,
      user,
      setEditor,
      licenseKey,
      isShapeHidden,
      getShapeVisibility,
      textOptions,
      assetUrls
    ]
  );
  (0, import_react45.useLayoutEffect)(() => {
    if (!editor)
      return;
    if (deepLinks) {
      return editor.registerDeepLinkListener(deepLinks);
    }
  }, [editor, deepLinks]);
  (0, import_react45.useLayoutEffect)(() => {
    if (editor && cameraOptions) {
      editor.setCameraOptions(cameraOptions);
    }
  }, [editor, cameraOptions]);
  const crashingError = (0, import_react45.useSyncExternalStore)(
    (0, import_react45.useCallback)(
      (onStoreChange) => {
        if (editor) {
          editor.on("crash", onStoreChange);
          return () => editor.off("crash", onStoreChange);
        }
        return () => {
        };
      },
      [editor]
    ),
    () => (editor == null ? void 0 : editor.getCrashingError()) ?? null
  );
  (0, import_react45.useEffect)(
    function handleFocusOnPointerDownForPreserveFocusMode() {
      if (!editor)
        return;
      function handleFocusOnPointerDown() {
        if (!editor)
          return;
        editor.focus();
      }
      function handleBlurOnPointerDown() {
        if (!editor)
          return;
        editor.blur();
      }
      if (autoFocus && noAutoFocus()) {
        editor.getContainer().addEventListener("pointerdown", handleFocusOnPointerDown);
        document.body.addEventListener("pointerdown", handleBlurOnPointerDown);
        return () => {
          var _a5;
          (_a5 = editor.getContainer()) == null ? void 0 : _a5.removeEventListener("pointerdown", handleFocusOnPointerDown);
          document.body.removeEventListener("pointerdown", handleBlurOnPointerDown);
        };
      }
    },
    [editor, autoFocus]
  );
  const [_fontLoadingState, setFontLoadingState] = (0, import_react45.useState)(null);
  let fontLoadingState = _fontLoadingState;
  if (editor !== (fontLoadingState == null ? void 0 : fontLoadingState.editor)) {
    fontLoadingState = null;
  }
  (0, import_react45.useEffect)(() => {
    if (!editor)
      return;
    let isCancelled = false;
    setFontLoadingState({ editor, isLoaded: false });
    editor.fonts.loadRequiredFontsForCurrentPage(editor.options.maxFontsToLoadBeforeRender).finally(() => {
      if (isCancelled)
        return;
      setFontLoadingState({ editor, isLoaded: true });
    });
    return () => {
      isCancelled = true;
    };
  }, [editor]);
  const { Canvas, LoadingScreen: LoadingScreen22 } = useEditorComponents();
  if (!editor || !(fontLoadingState == null ? void 0 : fontLoadingState.isLoaded)) {
    return (0, import_jsx_runtime35.jsxs)(import_jsx_runtime35.Fragment, { children: [
      LoadingScreen22 && (0, import_jsx_runtime35.jsx)(LoadingScreen22, {}),
      (0, import_jsx_runtime35.jsx)("div", { className: "tl-canvas", ref: canvasRef })
    ] });
  }
  return (
    // the top-level tldraw component also renders an error boundary almost
    // identical to this one. the reason we have two is because this one has
    // access to `App`, which means that here we can enrich errors with data
    // from app for reporting, and also still attempt to render the user's
    // document in the event of an error to reassure them that their work is
    // not lost.
    (0, import_jsx_runtime35.jsx)(OptionalErrorBoundary, {
      fallback: ErrorFallback,
      onError: (error) => editor.annotateError(error, { origin: "react.tldraw", willCrashApp: true }),
      children: crashingError ? (0, import_jsx_runtime35.jsx)(Crash, { crashingError }) : (0, import_jsx_runtime35.jsx)(EditorProvider, { editor, children: (0, import_jsx_runtime35.jsxs)(Layout, { onMount: onMount2, children: [
        children ?? (Canvas ? (0, import_jsx_runtime35.jsx)(Canvas, {}, editor.contextId) : null),
        (0, import_jsx_runtime35.jsx)(Watermark, {})
      ] }) })
    })
  );
}
function Layout({ children, onMount: onMount2 }) {
  useZoomCss();
  useCursor();
  useDarkMode();
  useForceUpdate();
  useOnMount((editor) => {
    const teardownStore = editor.store.props.onMount(editor);
    const teardownCallback = onMount2 == null ? void 0 : onMount2(editor);
    return () => {
      teardownStore == null ? void 0 : teardownStore();
      teardownCallback == null ? void 0 : teardownCallback();
    };
  });
  return children;
}
function Crash({ crashingError }) {
  throw crashingError;
}
function LoadingScreen({ children }) {
  return (0, import_jsx_runtime35.jsx)("div", { className: "tl-loading", "aria-busy": "true", tabIndex: 0, children });
}
function ErrorScreen({ children }) {
  return (0, import_jsx_runtime35.jsx)("div", { className: "tl-loading", children });
}
function useOnMount(onMount2) {
  const editor = useEditor();
  const onMountEvent = useEvent((editor2) => {
    let teardown = void 0;
    editor2.run(
      () => {
        teardown = onMount2 == null ? void 0 : onMount2(editor2);
        editor2.emit("mount");
      },
      { history: "ignore" }
    );
    window.tldrawReady = true;
    return teardown;
  });
  import_react45.default.useLayoutEffect(() => {
    if (editor)
      return onMountEvent == null ? void 0 : onMountEvent(editor);
  }, [editor, onMountEvent]);
}

// node_modules/@tldraw/editor/dist-esm/lib/components/HTMLContainer.mjs
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_classnames12 = __toESM(require_classnames(), 1);
function HTMLContainer({ children, className = "", ...rest }) {
  return (0, import_jsx_runtime36.jsx)("div", { ...rest, className: (0, import_classnames12.default)("tl-html-container", className), children });
}

// node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultSelectionBackground.mjs
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var React11 = __toESM(require_react(), 1);
function DefaultSelectionBackground({ bounds, rotation }) {
  const rDiv = React11.useRef(null);
  useTransform(rDiv, bounds.x, bounds.y, 1, rotation);
  React11.useLayoutEffect(() => {
    const div2 = rDiv.current;
    if (!div2)
      return;
    div2.style.width = toDomPrecision(Math.max(1, bounds.width)) + "px";
    div2.style.height = toDomPrecision(Math.max(1, bounds.height)) + "px";
  }, [bounds.width, bounds.height]);
  return (0, import_jsx_runtime37.jsx)("div", { ref: rDiv, className: "tl-selection__bg", draggable: false });
}

// node_modules/@tldraw/editor/dist-esm/lib/editor/bindings/BindingUtil.mjs
var BindingUtil = class {
  constructor(editor) {
    this.editor = editor;
  }
};
__publicField(BindingUtil, "props");
__publicField(BindingUtil, "migrations");
/**
 * The type of the binding util, which should match the binding's type.
 *
 * @public
 */
__publicField(BindingUtil, "type");

// node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/shared/resizeBox.mjs
function resizeBox(shape, info, opts = {}) {
  const { newPoint, handle, scaleX, scaleY } = info;
  const { minWidth = 1, maxWidth = Infinity, minHeight = 1, maxHeight = Infinity } = opts;
  let w = shape.props.w * scaleX;
  let h = shape.props.h * scaleY;
  const offset5 = new Vec(0, 0);
  if (w > 0) {
    if (w < minWidth) {
      switch (handle) {
        case "top_left":
        case "left":
        case "bottom_left": {
          offset5.x = w - minWidth;
          break;
        }
        case "top":
        case "bottom": {
          offset5.x = (w - minWidth) / 2;
          break;
        }
        default: {
          offset5.x = 0;
        }
      }
      w = minWidth;
    }
  } else {
    offset5.x = w;
    w = -w;
    if (w < minWidth) {
      switch (handle) {
        case "top_left":
        case "left":
        case "bottom_left": {
          offset5.x = -w;
          break;
        }
        default: {
          offset5.x = -minWidth;
        }
      }
      w = minWidth;
    }
  }
  if (h > 0) {
    if (h < minHeight) {
      switch (handle) {
        case "top_left":
        case "top":
        case "top_right": {
          offset5.y = h - minHeight;
          break;
        }
        case "right":
        case "left": {
          offset5.y = (h - minHeight) / 2;
          break;
        }
        default: {
          offset5.y = 0;
        }
      }
      h = minHeight;
    }
  } else {
    offset5.y = h;
    h = -h;
    if (h < minHeight) {
      switch (handle) {
        case "top_left":
        case "top":
        case "top_right": {
          offset5.y = -h;
          break;
        }
        default: {
          offset5.y = -minHeight;
        }
      }
      h = minHeight;
    }
  }
  const { x, y } = offset5.rot(shape.rotation).add(newPoint);
  return {
    ...shape,
    x,
    y,
    props: {
      w: Math.min(maxWidth, w),
      h: Math.min(maxHeight, h)
    }
  };
}

// node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/BaseBoxShapeUtil.mjs
var BaseBoxShapeUtil = class extends ShapeUtil {
  getGeometry(shape) {
    return new Rectangle2d({
      width: shape.props.w,
      height: shape.props.h,
      isFilled: true
    });
  }
  onResize(shape, info) {
    return resizeBox(shape, info);
  }
  getHandleSnapGeometry(shape) {
    return {
      points: this.getGeometry(shape).bounds.cornersAndCenter
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...endShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/shared/resizeScaled.mjs
function resizeScaled(shape, { initialBounds, scaleX, scaleY, newPoint, handle }) {
  let scaleDelta;
  switch (handle) {
    case "bottom_left":
    case "bottom_right":
    case "top_left":
    case "top_right": {
      scaleDelta = Math.max(0.01, Math.max(Math.abs(scaleX), Math.abs(scaleY)));
      break;
    }
    case "left":
    case "right": {
      scaleDelta = Math.max(0.01, Math.abs(scaleX));
      break;
    }
    case "bottom":
    case "top": {
      scaleDelta = Math.max(0.01, Math.abs(scaleY));
      break;
    }
    default: {
      throw exhaustiveSwitchError(handle);
    }
  }
  const offset5 = new Vec(0, 0);
  if (scaleX < 0) {
    offset5.x = -(initialBounds.width * scaleDelta);
  }
  if (scaleY < 0) {
    offset5.y = -(initialBounds.height * scaleDelta);
  }
  const { x, y } = Vec.Add(newPoint, offset5.rot(shape.rotation));
  return {
    x,
    y,
    props: {
      scale: scaleDelta * shape.props.scale
    }
  };
}

// node_modules/@tldraw/editor/dist-esm/lib/editor/tools/BaseBoxShapeTool/children/Idle.mjs
var Idle = class extends StateNode {
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle, "id", "idle");

// node_modules/@tldraw/editor/dist-esm/lib/editor/tools/BaseBoxShapeTool/children/Pointing.mjs
var Pointing = class extends StateNode {
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      const { originPagePoint } = this.editor.inputs;
      const shapeType = this.parent.shapeType;
      const id = createShapeId();
      const creatingMarkId = this.editor.markHistoryStoppingPoint(`creating_box:${id}`);
      const newPoint = maybeSnapToGrid(originPagePoint, this.editor);
      this.editor.createShapes([
        {
          id,
          type: shapeType,
          x: newPoint.x,
          y: newPoint.y,
          props: {
            w: 1,
            h: 1
          }
        }
      ]).select(id);
      const parent = this.parent;
      this.editor.setCurrentTool(
        "select.resizing",
        {
          ...info,
          target: "selection",
          handle: "bottom_right",
          isCreating: true,
          creatingMarkId,
          creationCursorOffset: { x: 1, y: 1 },
          onInteractionEnd: this.parent.id,
          onCreate: parent.onCreate ? (shape) => {
            var _a5;
            return (_a5 = parent.onCreate) == null ? void 0 : _a5.call(parent, shape);
          } : void 0
        }
        /** satisfies ResizingInfo, defined in main tldraw package 😧 */
      );
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { originPagePoint } = this.editor.inputs;
    const shapeType = this.parent.shapeType;
    const id = createShapeId();
    this.editor.markHistoryStoppingPoint(`creating_box:${id}`);
    this.editor.createShapes([
      {
        id,
        type: shapeType,
        x: originPagePoint.x,
        y: originPagePoint.y
      }
    ]);
    const shape = this.editor.getShape(id);
    if (!shape) {
      this.cancel();
      return;
    }
    let { w, h } = shape.props;
    const delta = new Vec(w / 2, h / 2);
    const parentTransform = this.editor.getShapeParentTransform(shape);
    if (parentTransform)
      delta.rot(-parentTransform.rotation());
    let scale = 1;
    if (this.editor.user.getIsDynamicResizeMode()) {
      scale = 1 / this.editor.getZoomLevel();
      w *= scale;
      h *= scale;
      delta.mul(scale);
    }
    const next = structuredClone(shape);
    const newPoint = maybeSnapToGrid(new Vec(shape.x - delta.x, shape.y - delta.y), this.editor);
    next.x = newPoint.x;
    next.y = newPoint.y;
    next.props.w = w;
    next.props.h = h;
    if ("scale" in shape.props) {
      ;
      next.props.scale = scale;
    }
    this.editor.updateShape(next);
    this.editor.setSelectedShapes([id]);
    if (this.editor.getInstanceState().isToolLocked) {
      this.parent.transition("idle");
    } else {
      this.editor.setCurrentTool("select.idle");
    }
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(Pointing, "id", "pointing");
function maybeSnapToGrid(point, editor) {
  const isGridMode = editor.getInstanceState().isGridMode;
  const gridSize = editor.getDocumentSettings().gridSize;
  if (isGridMode)
    return point.clone().snapToGrid(gridSize);
  return point.clone();
}

// node_modules/@tldraw/editor/dist-esm/lib/editor/tools/BaseBoxShapeTool/BaseBoxShapeTool.mjs
var BaseBoxShapeTool = class extends StateNode {
  static children() {
    return [Idle, Pointing];
  }
};
__publicField(BaseBoxShapeTool, "id", "box");
__publicField(BaseBoxShapeTool, "initial", "idle");

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useGlobalMenuIsOpen.mjs
var import_react46 = __toESM(require_react(), 1);
function useGlobalMenuIsOpen(id, onChange, onEvent) {
  const rIsOpen = (0, import_react46.useRef)(false);
  const onOpenChange = (0, import_react46.useCallback)(
    (isOpen2) => {
      rIsOpen.current = isOpen2;
      if (isOpen2) {
        tlmenus.addOpenMenu(id);
      } else {
        tlmenus.deleteOpenMenu(id);
      }
      onChange == null ? void 0 : onChange(isOpen2);
    },
    [id, onChange]
  );
  const isOpen = useValue("is menu open", () => tlmenus.getOpenMenus().includes(id), [id]);
  (0, import_react46.useEffect)(() => {
    if (rIsOpen.current) {
      onEvent == null ? void 0 : onEvent("open-menu");
      tlmenus.addOpenMenu(id);
    }
    return () => {
      if (rIsOpen.current) {
        tlmenus.deleteOpenMenu(id);
        tlmenus.getOpenMenus().forEach((menuId) => {
          if (menuId.startsWith(id)) {
            onEvent == null ? void 0 : onEvent("close-menu");
            tlmenus.deleteOpenMenu(menuId);
          }
        });
        rIsOpen.current = false;
      }
    };
  }, [id, onEvent]);
  return [isOpen, onOpenChange];
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useIsCropping.mjs
function useIsCropping(shapeId) {
  const editor = useEditor();
  return useValue("isCropping", () => editor.getCroppingShapeId() === shapeId, [editor, shapeId]);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useIsEditing.mjs
function useIsEditing(shapeId) {
  const editor = useEditor();
  return useValue("isEditing", () => editor.getEditingShapeId() === shapeId, [editor, shapeId]);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/usePassThroughMouseOverEvents.mjs
var import_react47 = __toESM(require_react(), 1);
function usePassThroughMouseOverEvents(ref) {
  if (!ref)
    throw Error("usePassThroughWheelEvents must be passed a ref");
  const container = useContainer();
  (0, import_react47.useEffect)(() => {
    function onMouseOver(e) {
      if (e.isSpecialRedispatchedEvent)
        return;
      preventDefault(e);
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs)
        return;
      const newEvent = new PointerEvent(e.type, e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    const elm = ref.current;
    if (!elm)
      return;
    elm.addEventListener("mouseover", onMouseOver, { passive: false });
    return () => {
      elm.removeEventListener("mouseover", onMouseOver);
    };
  }, [container, ref]);
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useSelectionEvents.mjs
var import_react48 = __toESM(require_react(), 1);
function useSelectionEvents(handle) {
  const editor = useEditor();
  const events = (0, import_react48.useMemo)(
    function selectionEvents() {
      const onPointerDown = (e) => {
        if (e.isKilled)
          return;
        if (e.button === RIGHT_MOUSE_BUTTON) {
          editor.dispatch({
            type: "pointer",
            target: "selection",
            handle,
            name: "right_click",
            ...getPointerInfo(e)
          });
          return;
        }
        if (e.button !== 0)
          return;
        const elm = loopToHtmlElement(e.currentTarget);
        function releaseCapture() {
          elm.removeEventListener("pointerup", releaseCapture);
          releasePointerCapture(elm, e);
        }
        setPointerCapture(elm, e);
        elm.addEventListener("pointerup", releaseCapture);
        editor.dispatch({
          name: "pointer_down",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(e)
        });
        stopEventPropagation(e);
      };
      let lastX, lastY;
      function onPointerMove(e) {
        if (e.isKilled)
          return;
        if (e.button !== 0)
          return;
        if (e.clientX === lastX && e.clientY === lastY)
          return;
        lastX = e.clientX;
        lastY = e.clientY;
        editor.dispatch({
          name: "pointer_move",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(e)
        });
      }
      const onPointerUp = (e) => {
        if (e.isKilled)
          return;
        if (e.button !== 0)
          return;
        editor.dispatch({
          name: "pointer_up",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(e)
        });
      };
      return {
        onPointerDown,
        onPointerMove,
        onPointerUp
      };
    },
    [editor, handle]
  );
  return events;
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useTLStore.mjs
var import_react49 = __toESM(require_react(), 1);
function useTLStore(opts) {
  const [current, setCurrent] = (0, import_react49.useState)(() => ({ store: createTLStore(opts), opts }));
  if (!areObjectsShallowEqual(current.opts, opts)) {
    const next = { store: createTLStore(opts), opts };
    setCurrent(next);
    return next.store;
  }
  return current.store;
}
function useTLSchemaFromUtils(opts) {
  const [current, setCurrent] = (0, import_react49.useState)(() => ({ opts, schema: createTLSchemaFromUtils(opts) }));
  if (!areObjectsShallowEqual(current.opts, opts)) {
    const next = createTLSchemaFromUtils(opts);
    setCurrent({ opts, schema: next });
    return next;
  }
  return current.schema;
}

// node_modules/@tldraw/editor/dist-esm/lib/hooks/useViewportHeight.mjs
var import_react50 = __toESM(require_react(), 1);
function useViewportHeight() {
  const visualViewport = window.visualViewport;
  const [height, setHeight] = (0, import_react50.useState)(
    () => visualViewport ? visualViewport.height + visualViewport.offsetTop : window.innerHeight
  );
  (0, import_react50.useLayoutEffect)(() => {
    var _a5, _b;
    const handleResize = () => {
      const visualViewport2 = window.visualViewport;
      setHeight(
        () => visualViewport2 ? visualViewport2.height + visualViewport2.offsetTop : window.innerHeight
      );
    };
    (_a5 = window.visualViewport) == null ? void 0 : _a5.addEventListener("resize", handleResize);
    (_b = window.visualViewport) == null ? void 0 : _b.addEventListener("scroll", handleResize);
    return () => {
      var _a6, _b2;
      (_a6 = window.visualViewport) == null ? void 0 : _a6.removeEventListener("resize", handleResize);
      (_b2 = window.visualViewport) == null ? void 0 : _b2.removeEventListener("scroll", handleResize);
    };
  }, []);
  return height;
}

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/geometry-constants.mjs
var SPACING = 20;
var MIN_COUNT = 8;
function getVerticesCountForLength(length, spacing = SPACING) {
  return Math.max(MIN_COUNT, Math.ceil(length / spacing));
}

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Arc2d.mjs
var Arc2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isFilled: false, isClosed: false });
    __publicField(this, "_center");
    __publicField(this, "radius");
    __publicField(this, "start");
    __publicField(this, "end");
    __publicField(this, "largeArcFlag");
    __publicField(this, "sweepFlag");
    __publicField(this, "measure");
    __publicField(this, "angleStart");
    __publicField(this, "angleEnd");
    const { center, sweepFlag, largeArcFlag, start: start2, end: end2 } = config;
    if (start2.equals(end2))
      throw Error(`Arc must have different start and end points.`);
    this.angleStart = Vec.Angle(center, start2);
    this.angleEnd = Vec.Angle(center, end2);
    this.radius = Vec.Dist(center, start2);
    this.measure = getArcMeasure(this.angleStart, this.angleEnd, sweepFlag, largeArcFlag);
    this.start = start2;
    this.end = end2;
    this.sweepFlag = sweepFlag;
    this.largeArcFlag = largeArcFlag;
    this._center = center;
  }
  nearestPoint(point) {
    const { _center, measure, radius, angleEnd, angleStart, start: A, end: B } = this;
    const t2 = getPointInArcT(measure, angleStart, angleEnd, _center.angle(point));
    if (t2 <= 0)
      return A;
    if (t2 >= 1)
      return B;
    const P = Vec.Sub(point, _center).uni().mul(radius).add(_center);
    let nearest;
    let dist = Infinity;
    let d;
    for (const p of [A, B, P]) {
      d = Vec.Dist2(point, p);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest)
      throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    const { _center, radius, measure, angleStart, angleEnd } = this;
    const intersection = intersectLineSegmentCircle(A, B, _center, radius);
    if (intersection === null)
      return false;
    return intersection.some((p) => {
      const result = getPointInArcT(measure, angleStart, angleEnd, _center.angle(p));
      return result >= 0 && result <= 1;
    });
  }
  getVertices() {
    const { _center, measure, length, radius, angleStart } = this;
    const vertices = [];
    for (let i = 0, n = getVerticesCountForLength(Math.abs(length)); i < n + 1; i++) {
      const t2 = i / n * measure;
      const angle = angleStart + t2;
      vertices.push(getPointOnCircle(_center, radius, angle));
    }
    return vertices;
  }
  getSvgPathData(first2 = true) {
    const { start: start2, end: end2, radius, largeArcFlag, sweepFlag } = this;
    return `${first2 ? `M${start2.toFixed()}` : ``} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end2.toFixed()}`;
  }
  getLength() {
    return Math.abs(this.measure * this.radius);
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Circle2d.mjs
var Circle2d = class extends Geometry2d {
  constructor(config) {
    super({ isClosed: true, ...config });
    __publicField(this, "_center");
    __publicField(this, "radius");
    __publicField(this, "x");
    __publicField(this, "y");
    this.config = config;
    const { x = 0, y = 0, radius } = config;
    this.x = x;
    this.y = y;
    this._center = new Vec(radius + x, radius + y);
    this.radius = radius;
  }
  getBounds() {
    return new Box(this.x, this.y, this.radius * 2, this.radius * 2);
  }
  getVertices() {
    const { _center, radius } = this;
    const perimeter = PI2 * radius;
    const vertices = [];
    for (let i = 0, n = getVerticesCountForLength(perimeter); i < n; i++) {
      const angle = i / n * PI2;
      vertices.push(getPointOnCircle(_center, radius, angle));
    }
    return vertices;
  }
  nearestPoint(point) {
    const { _center, radius } = this;
    if (_center.equals(point))
      return Vec.AddXY(_center, radius, 0);
    return Vec.Sub(point, _center).uni().mul(radius).add(_center);
  }
  hitTestLineSegment(A, B, distance = 0) {
    const { _center, radius } = this;
    return intersectLineSegmentCircle(A, B, _center, radius + distance) !== null;
  }
  getSvgPathData() {
    const { _center, radius } = this;
    return `M${_center.x + radius},${_center.y} a${radius},${radius} 0 1,0 ${radius * 2},0a${radius},${radius} 0 1,0 -${radius * 2},0`;
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/CubicBezier2d.mjs
var CubicBezier2d = class _CubicBezier2d extends Polyline2d {
  constructor(config) {
    const { start: a, cp1: b, cp2: c, end: d } = config;
    super({ ...config, points: [a, d] });
    __publicField(this, "a");
    __publicField(this, "b");
    __publicField(this, "c");
    __publicField(this, "d");
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
  }
  getVertices() {
    const vertices = [];
    const { a, b, c, d } = this;
    for (let i = 0, n = 10; i <= n; i++) {
      const t2 = i / n;
      vertices.push(
        new Vec(
          (1 - t2) * (1 - t2) * (1 - t2) * a.x + 3 * ((1 - t2) * (1 - t2)) * t2 * b.x + 3 * (1 - t2) * (t2 * t2) * c.x + t2 * t2 * t2 * d.x,
          (1 - t2) * (1 - t2) * (1 - t2) * a.y + 3 * ((1 - t2) * (1 - t2)) * t2 * b.y + 3 * (1 - t2) * (t2 * t2) * c.y + t2 * t2 * t2 * d.y
        )
      );
    }
    return vertices;
  }
  midPoint() {
    return _CubicBezier2d.GetAtT(this, 0.5);
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let d;
    let p;
    for (const edge of this.segments) {
      p = edge.nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest)
      throw Error("nearest point not found");
    return nearest;
  }
  getSvgPathData(first2 = true) {
    const { a, b, c, d } = this;
    return `${first2 ? `M ${a.toFixed()} ` : ``} C${b.toFixed()} ${c.toFixed()} ${d.toFixed()}`;
  }
  static GetAtT(segment, t2) {
    const { a, b, c, d } = segment;
    return new Vec(
      (1 - t2) * (1 - t2) * (1 - t2) * a.x + 3 * ((1 - t2) * (1 - t2)) * t2 * b.x + 3 * (1 - t2) * (t2 * t2) * c.x + t2 * t2 * t2 * d.x,
      (1 - t2) * (1 - t2) * (1 - t2) * a.y + 3 * ((1 - t2) * (1 - t2)) * t2 * b.y + 3 * (1 - t2) * (t2 * t2) * c.y + t2 * t2 * t2 * d.y
    );
  }
  getLength(filters, precision = 32) {
    let n1, p1 = this.a, length = 0;
    for (let i = 1; i <= precision; i++) {
      n1 = _CubicBezier2d.GetAtT(this, i / precision);
      length += Vec.Dist(p1, n1);
      p1 = n1;
    }
    return length;
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/CubicSpline2d.mjs
var CubicSpline2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: false, isFilled: false });
    __publicField(this, "points");
    __publicField(this, "_segments");
    const { points } = config;
    this.points = points;
  }
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { points } = this;
      const len = points.length;
      const last3 = len - 2;
      const k = 1.25;
      for (let i = 0; i < len - 1; i++) {
        const p0 = i === 0 ? points[0] : points[i - 1];
        const p1 = points[i];
        const p2 = points[i + 1];
        const p3 = i === last3 ? p2 : points[i + 2];
        const start2 = p1, cp1 = i === 0 ? p0 : new Vec(p1.x + (p2.x - p0.x) / 6 * k, p1.y + (p2.y - p0.y) / 6 * k), cp2 = i === last3 ? p2 : new Vec(p2.x - (p3.x - p1.x) / 6 * k, p2.y - (p3.y - p1.y) / 6 * k), end2 = p2;
        this._segments.push(new CubicBezier2d({ start: start2, cp1, cp2, end: end2 }));
      }
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((acc, segment) => acc + segment.length, 0);
  }
  getVertices() {
    const vertices = this.segments.reduce((acc, segment) => {
      return acc.concat(segment.vertices);
    }, []);
    vertices.push(this.points[this.points.length - 1]);
    return vertices;
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let d;
    let p;
    for (const segment of this.segments) {
      p = segment.nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest)
      throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    return this.segments.some((segment) => segment.hitTestLineSegment(A, B));
  }
  getSvgPathData() {
    let d = this.segments.reduce((d2, segment, i) => {
      return d2 + segment.getSvgPathData(i === 0);
    }, "");
    if (this.isClosed) {
      d += "Z";
    }
    return d;
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Ellipse2d.mjs
var Ellipse2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: true });
    __publicField(this, "w");
    __publicField(this, "h");
    __publicField(this, "_edges");
    this.config = config;
    const { width, height } = config;
    this.w = width;
    this.h = height;
  }
  // eslint-disable-next-line no-restricted-syntax
  get edges() {
    if (!this._edges) {
      const { vertices } = this;
      this._edges = [];
      for (let i = 0, n = vertices.length; i < n; i++) {
        const start2 = vertices[i];
        const end2 = vertices[(i + 1) % n];
        this._edges.push(new Edge2d({ start: start2, end: end2 }));
      }
    }
    return this._edges;
  }
  getVertices() {
    const w = Math.max(1, this.w);
    const h = Math.max(1, this.h);
    const cx = w / 2;
    const cy = h / 2;
    const q = Math.pow(cx - cy, 2) / Math.pow(cx + cy, 2);
    const p = PI * (cx + cy) * (1 + 3 * q / (10 + Math.sqrt(4 - 3 * q)));
    const len = getVerticesCountForLength(p);
    const step = PI2 / len;
    const a = Math.cos(step);
    const b = Math.sin(step);
    let sin = 0;
    let cos = 1;
    let ts2 = 0;
    let tc = 1;
    const vertices = Array(len);
    for (let i = 0; i < len; i++) {
      vertices[i] = new Vec(cx + cx * cos, cy + cy * sin);
      ts2 = b * cos + a * sin;
      tc = a * cos - b * sin;
      sin = ts2;
      cos = tc;
    }
    return vertices;
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let d;
    let p;
    for (const edge of this.edges) {
      p = edge.nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest)
      throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    return this.edges.some((edge) => edge.hitTestLineSegment(A, B));
  }
  getBounds() {
    return new Box(0, 0, this.w, this.h);
  }
  getLength() {
    const { w, h } = this;
    const cx = w / 2;
    const cy = h / 2;
    const rx = Math.max(0, cx);
    const ry = Math.max(0, cy);
    return perimeterOfEllipse(rx, ry);
  }
  getSvgPathData(first2 = false) {
    const { w, h } = this;
    const cx = w / 2;
    const cy = h / 2;
    const rx = Math.max(0, cx);
    const ry = Math.max(0, cy);
    return `${first2 ? `M${cx - rx},${cy}` : ``} a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`;
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Point2d.mjs
var Point2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: true, isFilled: true });
    __publicField(this, "point");
    const { point } = config;
    this.point = point;
  }
  getVertices() {
    return [this.point];
  }
  nearestPoint() {
    return this.point;
  }
  hitTestLineSegment(A, B, margin) {
    return Vec.DistanceToLineSegment(A, B, this.point) < margin;
  }
  getSvgPathData() {
    const { point } = this;
    return `M${point.toFixed()}`;
  }
};

// node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Stadium2d.mjs
var Stadium2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: true });
    __publicField(this, "w");
    __publicField(this, "h");
    __publicField(this, "a");
    __publicField(this, "b");
    __publicField(this, "c");
    __publicField(this, "d");
    this.config = config;
    const { width: w, height: h } = config;
    this.w = w;
    this.h = h;
    if (h > w) {
      const r = w / 2;
      this.a = new Arc2d({
        start: new Vec(0, r),
        end: new Vec(w, r),
        center: new Vec(w / 2, r),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this.b = new Edge2d({ start: new Vec(w, r), end: new Vec(w, h - r) });
      this.c = new Arc2d({
        start: new Vec(w, h - r),
        end: new Vec(0, h - r),
        center: new Vec(w / 2, h - r),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this.d = new Edge2d({ start: new Vec(0, h - r), end: new Vec(0, r) });
    } else {
      const r = h / 2;
      this.a = new Arc2d({
        start: new Vec(r, h),
        end: new Vec(r, 0),
        center: new Vec(r, r),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this.b = new Edge2d({ start: new Vec(r, 0), end: new Vec(w - r, 0) });
      this.c = new Arc2d({
        start: new Vec(w - r, 0),
        end: new Vec(w - r, h),
        center: new Vec(w - r, r),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this.d = new Edge2d({ start: new Vec(w - r, h), end: new Vec(r, h) });
    }
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let _d;
    let p;
    const { a, b, c, d } = this;
    for (const part of [a, b, c, d]) {
      p = part.nearestPoint(A);
      _d = Vec.Dist2(p, A);
      if (_d < dist) {
        nearest = p;
        dist = _d;
      }
    }
    if (!nearest)
      throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    const { a, b, c, d } = this;
    return [a, b, c, d].some((edge) => edge.hitTestLineSegment(A, B));
  }
  getVertices() {
    const { a, b, c, d } = this;
    return [a, b, c, d].reduce((a2, p) => {
      a2.push(...p.vertices);
      return a2;
    }, []);
  }
  getBounds() {
    return new Box(0, 0, this.w, this.h);
  }
  getLength() {
    const { h, w } = this;
    if (h > w)
      return (PI * (w / 2) + (h - w)) * 2;
    else
      return (PI * (h / 2) + (w - h)) * 2;
  }
  getSvgPathData() {
    const { a, b, c, d } = this;
    return [a, b, c, d].map((p, i) => p.getSvgPathData(i === 0)).join(" ") + " Z";
  }
};

// node_modules/orderedmap/dist/index.js
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey)
        content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(map2.content.concat(this.subtract(map2).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(this.subtract(map2).content.concat(map2.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map2) {
    var result = this;
    map2 = OrderedMap.from(map2);
    for (var i = 0; i < map2.content.length; i += 2)
      result = result.remove(map2.content[i]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content = [];
  if (value)
    for (var prop in value)
      content.push(prop, value[prop]);
  return new OrderedMap(content);
};
var dist_default = OrderedMap;

// node_modules/prosemirror-model/dist/index.js
function findDiffStart(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size4 = childA.nodeSize;
    if (childA == childB) {
      posA -= size4;
      posB -= size4;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size4;
    posB -= size4;
  }
}
var Fragment12 = class _Fragment {
  /**
  @internal
  */
  constructor(content, size4) {
    this.content = content;
    this.size = size4 || 0;
    if (size4 == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end2 = pos + child.nodeSize;
      if (end2 > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start2 = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start2), Math.min(child.content.size, to - start2), f, nodeStart + start2);
      }
      pos = end2;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text = "", first2 = true;
    this.nodesBetween(from2, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last3 = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last3.isText && last3.sameMarkup(first2)) {
      content[content.length - 1] = last3.withText(last3.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new _Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size4 = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end2 = pos + child.nodeSize;
        if (end2 > from2) {
          if (pos < from2 || end2 > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size4 += child.nodeSize;
        }
        pos = end2;
      }
    return new _Fragment(result, size4);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return _Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new _Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index3, node) {
    let current = this.content[index3];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size4 = this.size + node.nodeSize - current.nodeSize;
    copy2[index3] = node;
    return new _Fragment(copy2, size4);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index3) {
    let found2 = this.content[index3];
    if (!found2)
      throw new RangeError("Index " + index3 + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index3) {
    return this.content[index3] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos, round4 = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end2 = curPos + cur.nodeSize;
      if (end2 >= pos) {
        if (end2 == pos || round4 > 0)
          return retIndex(i + 1, end2);
        return retIndex(i, curPos);
      }
      curPos = end2;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return _Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new _Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array2) {
    if (!array2.length)
      return _Fragment.empty;
    let joined, size4 = 0;
    for (let i = 0; i < array2.length; i++) {
      let node = array2[i];
      size4 += node.nodeSize;
      if (i && node.isText && array2[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array2.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new _Fragment(joined || array2, size4);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return _Fragment.empty;
    if (nodes instanceof _Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new _Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
Fragment12.empty = new Fragment12([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index3, offset5) {
  found.index = index3;
  found.offset = offset5;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array2 = Array.isArray(a);
  if (Array.isArray(b) != array2)
    return false;
  if (array2) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}
var Mark = class _Mark {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type.create(json.attrs);
    type.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return _Mark.none;
    if (marks instanceof _Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
};
Mark.none = [];
var ReplaceError = class extends Error {
};
var Slice = class _Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new _Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return _Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new _Slice(Fragment12.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new _Slice(fragment, openStart, openEnd);
  }
};
Slice.empty = new Slice(Fragment12.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index: index3, offset: offset5 } = content.findIndex(from2), child = content.maybeChild(index3);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset5 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index3 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index3, child.copy(removeRange(child.content, from2 - offset5 - 1, to - offset5 - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index: index3, offset: offset5 } = content.findIndex(dist), child = content.maybeChild(index3);
  if (offset5 == dist || child.isText) {
    if (parent && !parent.canReplace(index3, index3, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset5 - 1, insert);
  return inner && content.replaceChild(index3, child.copy(inner));
}
function replace2($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index3 = $from.index(depth), node = $from.node(depth);
  if (index3 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index3, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start: start2, end: end2 } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start2, end2, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last3 = target.length - 1;
  if (last3 >= 0 && child.isText && child.sameMarkup(target[last3]))
    target[last3] = child.withText(target[last3].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment12(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment12(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment12.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
var ResolvedPos = class _ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index3 = this.index(this.depth);
    if (index3 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index3);
    return dOff ? parent.child(index3).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index3 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index3).cut(0, dOff);
    return index3 == 0 ? null : this.parent.child(index3 - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index3, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index3; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index3 = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index3).marks;
    let main2 = parent.maybeChild(index3 - 1), other = parent.maybeChild(index3);
    if (!main2) {
      let tmp = main2;
      main2 = other;
      other = tmp;
    }
    let marks = main2.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc3, pos) {
    if (!(pos >= 0 && pos <= doc3.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start2 = 0, parentOffset = pos;
    for (let node = doc3; ; ) {
      let { index: index3, offset: offset5 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset5;
      path.push(node, index3, start2 + offset5);
      if (!rem)
        break;
      node = node.child(index3);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start2 += offset5 + 1;
    }
    return new _ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc3, pos) {
    let cache = resolveCache.get(doc3);
    if (cache) {
      for (let i = 0; i < cache.elts.length; i++) {
        let elt = cache.elts[i];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc3, cache = new ResolveCache());
    }
    let result = cache.elts[cache.i] = _ResolvedPos.resolve(doc3, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result;
  }
};
var ResolveCache = class {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
};
var resolveCacheSize = 12;
var resolveCache = /* @__PURE__ */ new WeakMap();
var NodeRange = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node2 = class _Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks = Mark.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment12.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index3) {
    return this.content.child(index3);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index3) {
    return this.content.maybeChild(index3);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new _Node(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start2 = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start2, $to.pos - start2);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace2(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index: index3, offset: offset5 } = node.content.findIndex(pos);
      node = node.maybeChild(index3);
      if (!node)
        return null;
      if (offset5 == pos || node.isText)
        return node;
      pos -= offset5 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index: index3, offset: offset5 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index3), index: index3, offset: offset5 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index3, offset: offset5 } = this.content.findIndex(pos);
    if (offset5 < pos)
      return { node: this.content.child(index3), index: index3, offset: offset5 };
    let node = this.content.child(index3 - 1);
    return { node, index: index3 - 1, offset: offset5 - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index3) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index3);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment12.empty, start2 = 0, end2 = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start2, end2);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start2; i < end2; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start2 = this.contentMatchAt(from2).matchType(type);
    let end2 = start2 && start2.matchFragment(this.content, to);
    return end2 ? end2.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark.none;
    for (let i = 0; i < this.marks.length; i++) {
      let mark = this.marks[i];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment12.fromJSON(schema, json.content);
    let node = schema.nodeType(json.type).create(json.attrs, content, marks);
    node.type.checkAttrs(node.attrs);
    return node;
  }
};
Node2.prototype.text = void 0;
var TextNode = class _TextNode extends Node2 {
  /**
  @internal
  */
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new _TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
};
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
var ContentMatch = class _ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string2, nodeTypes) {
    let stream = new TokenStream(string2, nodeTypes);
    if (stream.next == null)
      return _ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start2 = 0, end2 = frag.childCount) {
    let cur = this;
    for (let i = start2; cur && i < end2; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment12.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed2 = this.computeWrapping(target);
    this.wrapCache.push(target, computed2);
    return computed2;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
};
ContentMatch.empty = new ContentMatch(true);
var TokenStream = class {
  constructor(string2, nodeTypes) {
    this.string = string2;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string2.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
};
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min4 = parseNum(stream), max3 = min4;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max3 = parseNum(stream);
    else
      max3 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min4, max: max3, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.isInGroup(name))
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from2, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile(expr2.expr, from2), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values, type, name) {
  for (let name2 in values)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(typeName, name, attrs[name]);
  return result;
}
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node2(this, this.computeAttrs(attrs), Fragment12.from(content), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment12.from(content);
    this.checkContent(content);
    return new Node2(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment12.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment12.empty, true);
    if (!after)
      return null;
    return new Node2(this, attrs, content.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
function validateType(typeName, attrName, type) {
  let types = type.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
var Attribute = class {
  constructor(typeName, attrName, options2) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options2, "default");
    this.default = options2.default;
    this.validate = typeof options2.validate == "string" ? validateType(typeName, attrName, options2.validate) : options2.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
var MarkType = class _MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark(this, defaults2) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
};
var Schema = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      if (type.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type.isInline || !type.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type;
      }
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(json) {
    return Node2.fromJSON(this, json);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(json) {
    return Mark.fromJSON(this, json);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
var DOMParser2 = class _DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return false;
      let node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options2 = {}) {
    let context = new ParseContext(this, options2, false);
    context.addAll(dom, Mark.none, options2.from, options2.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options2 = {}) {
    let context = new ParseContext(this, options2, true);
    context.addAll(dom, Mark.none, options2.from, options2.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
  }
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = class {
  constructor(type, attrs, marks, solid, match, options2) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.solid = solid;
    this.options = options2;
    this.content = [];
    this.activeMarks = Mark.none;
    this.match = match || (options2 & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment12.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start2 = this.type.contentMatch, wrap3;
        if (wrap3 = start2.findWrapping(node.type)) {
          this.match = start2;
          return wrap3;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last3 = this.content[this.content.length - 1], m;
      if (last3 && last3.isText && (m = /[ \t\r\n\u000c]+$/.exec(last3.text))) {
        let text = last3;
        if (last3.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    let content = Fragment12.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment12.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
};
var ParseContext = class {
  constructor(parser, options2, isOpen) {
    this.parser = parser;
    this.options = options2;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options2.topNode, topContext;
    let topOptions = wsOptionsFor(null, options2.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options2.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options2.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top2 = this.top, preserveWS = top2.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top2.options & OPT_PRESERVE_WS) > 0;
    if (preserveWS === "full" || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top2.content[top2.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS !== "full") {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value), marks);
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top2 = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out:
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom, marks);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent)
          this.open = Math.max(0, this.open - 1);
        else if (rule && rule.skip.nodeType)
          dom = rule.skip;
        let sync, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top2.content.length && top2.content[0].isInline && this.open) {
            this.open--;
            top2 = this.top;
          }
          sync = true;
          if (!top2.type)
            this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom, marks);
          break out;
        }
        let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
        if (innerMarks)
          this.addAll(dom, innerMarks);
        if (sync)
          this.sync(top2);
        this.needsBlock = oldNeedsBlock;
      } else {
        let innerMarks = this.readStyles(dom, marks);
        if (innerMarks)
          this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
      }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom, marks) {
    let styles = dom.style;
    if (styles && styles.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
        if (value)
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m) => !rule.clearMark(m));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks)) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index3 = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end2 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end2; dom = dom.nextSibling, ++index3) {
      this.findAtPoint(parent, index3);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index3);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node, marks) {
    let route, sync;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      marks = this.enterInner(route[i], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node, marks) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node, marks);
    if (innerMarks) {
      this.closeExtra();
      let top2 = this.top;
      if (top2.match)
        top2.match = top2.match.matchType(node.type);
      let nodeMarks = Mark.none;
      for (let m of innerMarks.concat(node.marks))
        if (top2.type ? top2.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
          nodeMarks = m.addToSet(nodeMarks);
      top2.content.push(node.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, marks, preserveWS) {
    let innerMarks = this.findPlace(type.create(attrs), marks);
    if (innerMarks)
      innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type, attrs, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top2 = this.top;
    top2.match = top2.match && top2.match.matchType(type);
    let options2 = wsOptionsFor(type, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
      options2 |= OPT_OPEN_LEFT;
    let applyMarks = Mark.none;
    marks = marks.filter((m) => {
      if (top2.type ? top2.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
        applyMarks = m.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options2));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset5) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset5)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
};
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type, next } = match.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
var DOMSerializer = class _DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options2 = {}, target) {
    if (!target)
      target = doc(options2).createDocumentFragment();
    let top2 = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top2 = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options2);
          if (markDOM) {
            active.push([add, top2]);
            top2.appendChild(markDOM.dom);
            top2 = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top2.appendChild(this.serializeNodeInner(node, options2));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options2) {
    let { dom, contentDOM } = renderSpec(doc(options2), this.nodes[node.type.name](node), null, node.attrs);
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options2, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options2 = {}) {
    let dom = this.serializeNodeInner(node, options2);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap3 = this.serializeMark(node.marks[i], node.isInline, options2);
      if (wrap3) {
        (wrap3.contentDOM || wrap3.dom).appendChild(dom);
        dom = wrap3.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline3, options2 = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc(options2), toDOM(mark, inline3), null, mark.attrs);
  }
  static renderSpec(doc3, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc3, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
};
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options2) {
  return options2.document || window.document;
}
var suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i = 0; i < value.length; i++)
            scan(value[i]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result;
}
function renderSpec(doc3, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc3.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
  let attrs = structure[1], start2 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start2 = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else
          dom.setAttribute(name, attrs[name]);
      }
  }
  for (let i = start2; i < structure.length; i++) {
    let child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start2)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc3, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}

// node_modules/prosemirror-transform/dist/index.js
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index3, offset5) {
  return index3 + offset5 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1;
var DEL_AFTER = 2;
var DEL_ACROSS = 4;
var DEL_SIDE = 8;
var MapResult = class {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
};
var StepMap = class _StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && _StepMap.empty)
      return _StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index3 = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index3; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index3 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end2 = start2 + oldSize;
      if (pos <= end2) {
        let side = !oldSize ? assoc : pos == start2 ? -1 : pos == end2 ? 1 : assoc;
        let result = start2 + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start2 : end2) ? null : makeRecover(i / 3, pos - start2);
        let del2 = pos == start2 ? DEL_AFTER : pos == end2 ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start2 : pos != end2)
          del2 |= DEL_SIDE;
        return new MapResult(result, del2, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index3 = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end2 = start2 + oldSize;
      if (pos <= end2 && i == index3 * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i], oldStart = start2 - (this.inverted ? diff : 0), newStart = start2 + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
};
StepMap.empty = new StepMap([]);
var Mapping = class _Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps, mirror, from2 = 0, to = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new _Mapping(this._maps, this.mirror, from2, to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map2, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map2);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new _Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this._maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map2 = this._maps[i], result = map2.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this._maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
};
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
};
var StepResult = class _StepResult {
  /**
  @internal
  */
  constructor(doc3, failed) {
    this.doc = doc3;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc3) {
    return new _StepResult(doc3, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new _StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc3, from2, to, slice2) {
    try {
      return _StepResult.ok(doc3.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return _StepResult.fail(e.message);
      throw e;
    }
  }
};
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment12.fromArray(mapped);
}
var AddMarkStep = class _AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = class _RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc3), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeMark", RemoveMarkStep);
var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment12.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new _AddNodeMarkStep(this.pos, node.marks[i]);
        return new _AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addNodeMark", AddNodeMarkStep);
var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment12.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
var ReplaceStep = class _ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && contentBetween(doc3, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc3) {
    return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new _ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
};
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc3.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc3, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc3) {
    let gap = this.gapTo - this.gapFrom;
    return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
};
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc3, from2, to) {
  let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start2 = Math.max(pos, from2), end2 = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start2 && removing.mark.eq(marks[i]))
            removing.to = end2;
          else
            removed.push(removing = new RemoveMarkStep(start2, end2, marks[i]));
        }
      }
      if (adding && adding.to == start2)
        adding.to = end2;
      else
        added.push(adding = new AddMarkStep(start2, end2, mark));
    }
  });
  removed.forEach((s) => tr2.step(s));
  added.forEach((s) => tr2.step(s));
}
function removeMark(tr2, from2, to, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end2 = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end2;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end2, step });
        }
      }
    }
  });
  matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end2 = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end2, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr2.step(new RemoveMarkStep(cur, end2, child.marks[j]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment12.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end2;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment12.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr2.step(replSteps[i]);
}
function canCut(node, start2, end2) {
  return (start2 == 0 || node.canReplace(start2, node.childCount)) && (end2 == node.childCount || node.canReplace(0, end2));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index3 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index3, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index3, endIndex))
      break;
  }
  return null;
}
function lift(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start2 = gapStart, end2 = gapEnd;
  let before = Fragment12.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment12.from($from.node(d).copy(before));
      openStart++;
    } else {
      start2--;
    }
  let after = Fragment12.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment12.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end2++;
    }
  tr2.step(new ReplaceAroundStep(start2, end2, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap2(tr2, range, wrappers) {
  let content = Fragment12.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment12.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start2 = range.start, end2 = range.end;
  tr2.step(new ReplaceAroundStep(start2, end2, start2, end2, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr2, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr2, node, pos, mapFrom);
      clearIncompatible(tr2, tr2.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment12.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr2, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr2, node, pos, mapFrom) {
  node.forEach((child, offset5) => {
    if (child.isText) {
      let m, newline = /\r?\n|\r/g;
      while (m = newline.exec(child.text)) {
        let start2 = tr2.mapping.slice(mapFrom).map(pos + 1 + offset5 + m.index);
        tr2.replaceWith(start2, start2 + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr2, node, pos, mapFrom) {
  node.forEach((child, offset5) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start2 = tr2.mapping.slice(mapFrom).map(pos + 1 + offset5);
      tr2.replaceWith(start2, start2 + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc3, pos, type) {
  let $pos = doc3.resolve(pos), index3 = $pos.index();
  return $pos.parent.canReplaceWith(index3, index3 + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs, marks) {
  let node = tr2.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr2.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment12.from(newNode), 0, 0), 1, true));
}
function canSplit(doc3, pos, depth = 1, typesAfter) {
  let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    let node = $pos.node(d), index4 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index4, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index4 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index3 = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index3, index3, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment12.empty, after = Fragment12.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = Fragment12.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment12.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc3, pos) {
  let $pos = doc3.resolve(pos), index3 = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index3, index3 + 1);
}
function canAppendWithSubstitutedLinebreaks(a, b) {
  if (!b.content.size)
    a.type.compatibleContent(b.type);
  let match = a.contentMatchAt(a.childCount);
  let { linebreakReplacement } = a.type.schema;
  for (let i = 0; i < b.childCount; i++) {
    let child = b.child(i);
    let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
    match = match.matchType(type);
    if (!match)
      return false;
    if (!a.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable2(a, b) {
  return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
}
function joinPoint(doc3, pos, dir = -1) {
  let $pos = doc3.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index3 = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index3++;
      after = $pos.node(d).maybeChild(index3);
    } else {
      before = $pos.node(d).maybeChild(index3 - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index3, index3 + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr2, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr2.doc.type.schema;
  let $before = tr2.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr2.steps.length;
  if (convertNewlines === false) {
    let $after = tr2.doc.resolve(pos + depth);
    replaceLinebreaks(tr2, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr2, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr2.mapping.slice(mapFrom), start2 = mapping.map(pos - depth);
  tr2.step(new ReplaceStep(start2, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr2.doc.resolve(start2);
    replaceNewlines(tr2, $full.node(), $full.before(), tr2.steps.length);
  }
  return tr2;
}
function insertPoint(doc3, pos, nodeType) {
  let $pos = doc3.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index3 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index3, index3, nodeType))
        return $pos.before(d + 1);
      if (index3 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index3 = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index3, index3, nodeType))
        return $pos.after(d + 1);
      if (index3 < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc3, pos, slice2) {
  let $pos = doc3.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc3.resolve(from2), $to = doc3.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
var Fitter = class {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment12.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment12.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap3, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment12.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap3 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap3 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap3 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap3)
      for (let i = 0; i < wrap3.length; i++)
        this.openFrontierNode(wrap3[i]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment12.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan:
      for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        let { match, type } = this.frontier[i];
        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        let fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit)
          continue;
        for (let d = i - 1; d >= 0; d--) {
          let { match: match2, type: type2 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment12.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment12.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
};
function dropFromFragment(fragment, depth, count3) {
  if (depth == 0)
    return fragment.cutByIndex(count3, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count3)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment12.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index3 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index3 == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index3);
  return fit && !invalidMarks(type, node.content, index3) ? fit : null;
}
function invalidMarks(type, fragment, start2) {
  for (let i = start2; i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr2.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice2.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index3 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index3, index3, insert.type, insert.marks))
        return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr2.replace(from2, to, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start2 = match.fillBefore(fragment).append(fragment);
    fragment = start2.append(match.matchFragment(start2).fillBefore(Fragment12.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to, node) {
  if (!node.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr2.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr2.replaceRange(from2, to, new Slice(Fragment12.from(node), 0, 0));
}
function deleteRange(tr2, from2, to) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last3 = i == covered.length - 1;
    if (last3 && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last3 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
      return tr2.delete($from.before(d), to);
  }
  tr2.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start2 = $from.start(d);
    if (start2 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start2 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start2 - 1)
      result.push(d);
  }
  return result;
}
var AttrStep = class _AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment12.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _AttrStep(json.pos, json.attr, json.value);
  }
};
Step.jsonID("attr", AttrStep);
var DocAttrStep = class _DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc3.attrs)
      attrs[name] = doc3.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _DocAttrStep(json.attr, json.value);
  }
};
Step.jsonID("docAttr", DocAttrStep);
var TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc3) {
    this.doc = doc3;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc3;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment12.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap2(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs = null) {
    setBlockType(this, from2, to, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    if (!(mark instanceof Mark)) {
      let node = this.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at position " + pos);
      mark = mark.isInSet(node.marks);
      if (!mark)
        return this;
    }
    this.step(new RemoveNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
};

// node_modules/prosemirror-state/dist/index.js
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr2, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr2, node) {
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr2.deleteRange(from2, to);
      } else {
        tr2.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd(tr2, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc3) {
    return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc3) {
    return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc3, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc3, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
};
Selection.prototype.visible = true;
var SelectionRange = class {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
};
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
var TextSelection = class _TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc3, mapping) {
    let $head = doc3.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc3.resolve(mapping.map(this.anchor));
    return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr2, content = Slice.empty) {
    super.replace(tr2, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr2.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc3, anchor, head = anchor) {
    let $anchor = doc3.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new _TextSelection($anchor, $head);
  }
};
Selection.jsonID("text", TextSelection);
var TextBookmark = class _TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc3) {
    return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
  }
};
var NodeSelection = class _NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc3, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc3.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new _NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment12.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof _NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new _NodeSelection(doc3.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc3, from2) {
    return new _NodeSelection(doc3.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
};
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = class _NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
};
var AllSelection = class _AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc3) {
    super(doc3.resolve(0), doc3.resolve(doc3.content.size));
  }
  replace(tr2, content = Slice.empty) {
    if (content == Slice.empty) {
      tr2.delete(0, tr2.doc.content.size);
      let sel = Selection.atStart(tr2.doc);
      if (!sel.eq(tr2.selection))
        tr2.setSelection(sel);
    } else {
      super.replace(tr2, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc3) {
    return new _AllSelection(doc3);
  }
  map(doc3) {
    return new _AllSelection(doc3);
  }
  eq(other) {
    return other instanceof _AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
};
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map() {
    return this;
  },
  resolve(doc3) {
    return new AllSelection(doc3);
  }
};
function findSelectionIn(doc3, node, pos, index3, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc3, pos);
  for (let i = index3 - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  let last3 = tr2.steps.length - 1;
  if (last3 < startLen)
    return;
  let step = tr2.steps[last3];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr2.mapping.maps[last3], end2;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 == null)
      end2 = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
}
var UPDATED_SEL = 1;
var UPDATED_MARKS = 2;
var UPDATED_SCROLL = 4;
var Transaction2 = class extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    super.addStep(step, doc3);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time2) {
    this.time = time2;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
};
function bind2(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
var FieldDesc = class {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind2(desc.init, self2);
    this.apply = bind2(desc.apply, self2);
  }
};
var baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr2) {
      return tr2.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr2) {
      return tr2.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr2, _marks, _old, state) {
      return state.selection.$cursor ? tr2.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr2, prev) {
      return tr2.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = class {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
};
var EditorState = class _EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr2) {
    return this.applyTransaction(tr2).state;
  }
  /**
  @internal
  */
  filterTransaction(tr2, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr2 = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr2 && newState.filterTransaction(tr2, i)) {
            tr2.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr2);
            newState = newState.applyInner(tr2);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr2) {
    if (!tr2.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new _EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction2(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new _EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new _EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new _EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node2.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
};
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
var Plugin = class {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};
var keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
var PluginKey = class {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};

// node_modules/prosemirror-view/dist/index.js
var domIndex = function(node) {
  for (var index3 = 0; ; index3++) {
    node = node.previousSibling;
    if (!node)
      return index3;
  }
};
var parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
var clearReusedRange = function() {
  reusedRange = null;
};
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset5) {
  for (; ; ) {
    if (node.nodeType == 3 && offset5)
      return node;
    if (node.nodeType == 1 && offset5 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset5 - 1];
      offset5 = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset5 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset5) {
  for (; ; ) {
    if (node.nodeType == 3 && offset5 < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset5 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset5];
      offset5 = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset5 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset5, parent) {
  for (let atStart = offset5 == 0, atEnd = offset5 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index3 = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index3 == 0;
    atEnd = atEnd && index3 == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc3) {
  let elt = doc3.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc3, x, y) {
  if (doc3.caretPositionFromPoint) {
    try {
      let pos = doc3.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_) {
    }
  }
  if (doc3.caretRangeFromPoint) {
    let range = doc3.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc2 = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc3) {
  let vp = doc3.defaultView && doc3.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc3.documentElement.clientWidth,
    top: 0,
    bottom: doc3.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc3 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc3.body;
    let bounding = atTop ? windowRect(doc3) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc3.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack2 = [], doc3 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack2.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc3)
      break;
  }
  return stack2;
}
function resetScrollPos({ refDOM, refTop, stack: stack2 }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack2, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack2, dTop) {
  for (let i = 0; i < stack2.length; i++) {
    let { dom, top: top2, left: left2 } = stack2[i];
    if (dom.scrollTop != top2 + dTop)
      dom.scrollTop = top2 + dTop;
    if (dom.scrollLeft != left2)
      dom.scrollLeft = left2;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset5 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset5 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset5 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset5 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset5 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset5, bias);
}
function posFromCaret(view, node, offset5, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset5, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc3 = view.dom.ownerDocument, node, offset5 = 0;
  let caret = caretFromPoint(doc3, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset5 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset5 = Math.min(offset5, node.childNodes.length);
      if (offset5 < node.childNodes.length) {
        let next = node.childNodes[offset5], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset5++;
      }
    }
    let prev;
    if (webkit && offset5 && node.nodeType == 1 && (prev = node.childNodes[offset5 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset5--;
    if (node == view.dom && offset5 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset5 == 0 || node.nodeType != 1 || node.childNodes[offset5 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset5, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset5, atom: atom2 } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset5 : offset5 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset5, offset5), side);
      if (gecko && offset5 && /\s/.test(node.nodeValue[offset5 - 1]) && offset5 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset5 - 1, offset5 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset5, offset5 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset5, to = offset5, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset5) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset5 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom2 || 0));
  if (!$dom.parent.inlineContent) {
    if (atom2 == null && offset5 && (side < 0 || offset5 == nodeSize(node))) {
      let before = node.childNodes[offset5 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom2 == null && offset5 < nodeSize(node)) {
      let after = node.childNodes[offset5];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom2 == null && offset5 && (side < 0 || offset5 == nodeSize(node))) {
    let before = node.childNodes[offset5 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom2 == null && offset5 < nodeSize(node)) {
    let after = node.childNodes[offset5];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0)
    return rect;
  let x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0)
    return rect;
  let y = top2 ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset5 = $head.parentOffset, atStart = !offset5, atEnd = offset5 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;
var ViewDesc = class {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size4 = 0;
    for (let i = 0; i < this.children.length; i++)
      size4 += this.children[i].size;
    return size4;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset5, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset5 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset5];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset5 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset5 == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset5 == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset5, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset5, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset5 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset5 + child.size;
      if (offset5 == pos && end2 != offset5) {
        while (!child.border && child.children.length) {
          for (let i2 = 0; i2 < child.children.length; i2++) {
            let inner = child.children[i2];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end2)
        return child.descAt(pos - offset5 - child.border);
      offset5 = end2;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset5 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = curPos + child.size;
      if (end2 > pos || child instanceof TrailingHackViewDesc) {
        offset5 = pos - curPos;
        break;
      }
      curPos = end2;
    }
    if (offset5)
      return this.children[i].domFromPos(offset5 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset5 = base2, i = 0; ; i++) {
      let child = this.children[i], end2 = offset5 + child.size;
      if (fromOffset == -1 && from2 <= end2) {
        let childBase = offset5 + child.border;
        if (from2 >= childBase && to <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset5;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end2 > to || i == this.children.length - 1)) {
        to = end2;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset5 = end2;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset5 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset5 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset5];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset5 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset5 + child.size;
      if (from2 > offset5 && to < end2)
        return child.setSelection(anchor - offset5 - child.border, head - offset5 - child.border, view, force);
      offset5 = end2;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset5 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset5 && node.nodeValue[offset5 - 1] == "\n");
        if (brKludge && offset5 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset5 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset5 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset5 + child.size;
      if (offset5 == end2 ? from2 <= end2 && to >= offset5 : from2 < end2 && to > offset5) {
        let startInside = offset5 + child.border, endInside = end2 - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset5 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset5 = end2;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  isText(text) {
    return false;
  }
};
var WidgetViewDesc = class extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap3 = document.createElement("span");
        wrap3.appendChild(dom);
        dom = wrap3;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
};
var CompositionViewDesc = class extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset5) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset5 ? this.size : 0);
    return this.posAtStart + offset5;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
};
var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline3, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline3);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline3), null, mark.attrs);
    return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size4 = this.size;
    if (to < size4)
      nodes = replaceNodes(nodes, to, size4, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
};
var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment12.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline3 = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline3, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline3, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline3, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
        ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off))
        ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline3, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
};
function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc3);
  let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset5, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset5, this.node.text.length);
    return super.localPosFromDOM(dom, offset5, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
};
var TrailingHackViewDesc = class extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
};
var CustomNodeViewDesc = class extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
};
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = class {
  constructor(top2, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start2, end2) {
    if (start2 == end2)
      return;
    for (let i = start2; i < end2; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start2, end2 - start2);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline3, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline3, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index3) {
    let found2 = -1, targetDesc;
    if (index3 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index3 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index3, view) {
    let child = this.top.children[index3];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index3);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index3, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index3)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
};
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node = desc.node;
      if (!node)
        continue;
      if (node != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset5 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset5, child), i);
      offset5 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset5) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index3;
    if (restNode) {
      index3 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index3 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset5)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset5 && locals[decoIndex].to > offset5)
      active.push(locals[decoIndex++]);
    let end2 = offset5 + child.nodeSize;
    if (child.isText) {
      let cutAt = end2;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end2) {
        restNode = child.cut(cutAt - offset5);
        child = child.cut(0, cutAt - offset5);
        end2 = cutAt;
        index3 = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end2)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset5, child), index3);
    offset5 = end2;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start2 = off, end2 = off += child.size;
    if (start2 >= to || end2 <= from2) {
      result.push(child);
    } else {
      if (start2 < from2)
        result.push(child.slice(0, from2 - start2, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end2 > to)
        result.push(child.slice(to - start2, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min4 = head, max3 = head;
      for (let i = 0; i < domSel.rangeCount; i++) {
        let range = domSel.getRangeAt(i);
        min4 = Math.min(min4, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max3 = Math.max(max3, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min4 < 0)
        return null;
      [anchor, head] = max3 == view.state.selection.anchor ? [max3, min4] : [min4, max3];
      $head = doc3.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc3.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset5 } = view.docView.domFromPos(pos, 0);
  let after = offset5 < node.childNodes.length ? node.childNodes[offset5] : null;
  let before = offset5 ? node.childNodes[offset5 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset5 = domSel.anchorOffset;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset5) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setStart(node.parentNode, domIndex(node) + 1);
  else
    range.setStart(node, 0);
  range.collapse(true);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset5 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset5 < nodeLen(node) && isIgnorable(node.childNodes[offset5], -1))
    force = true;
  for (; ; ) {
    if (offset5 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset5 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset5;
        } else if (before.nodeType == 3) {
          node = before;
          offset5 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset5 = 0;
      } else {
        node = prev;
        offset5 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset5);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset5 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset5 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset5];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset5;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset5 = len = 0;
      } else {
        node = next;
        offset5 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset5) {
  while (node && offset5 == node.childNodes.length && !hasBlockDesc(node)) {
    offset5 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset5 < node.childNodes.length) {
    let next = node.childNodes[offset5];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset5 = 0;
  }
}
function textNodeBefore(node, offset5) {
  while (node && !offset5 && !hasBlockDesc(node)) {
    offset5 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset5) {
    let next = node.childNodes[offset5 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset5 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset5) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset5)) {
      node = after;
      offset5 = 0;
    } else if (before = textNodeBefore(node, offset5)) {
      node = before;
      offset5 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset5);
    range.setStart(node, offset5);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset5);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed2 = getComputedStyle(view.dom).direction;
  return computed2 == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code2 = event.keyCode, mods = getMods(event);
  if (code2 == 8 || mac && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code2 == 46 && !event.shiftKey || mac && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37 || mac && code2 == 66 && mods == "c") {
    let dir = code2 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 39 || mac && code2 == 70 && mods == "c") {
    let dir = code2 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 38 || mac && code2 == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code2 == 40 || mac && code2 == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap3 = doc3.createElement("div");
  wrap3.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap3.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc3.createElement(needsWrap[i]);
      while (wrap3.firstChild)
        wrapper.appendChild(wrap3.firstChild);
      wrap3.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap3.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap3, text, slice: slice2 };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text)
    return null;
  let asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode)
      return text ? new Slice(Fragment12.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap3 = match.findWrapping(node.type), inLast;
      if (!wrap3)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap3, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap3);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap3;
      }
    });
    if (result)
      return Fragment12.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap3, from2 = 0) {
  for (let i = wrap3.length - 1; i >= from2; i--)
    node = wrap3[i].create(null, Fragment12.from(node));
  return node;
}
function addToSibling(wrap3, lastWrap, node, sibling, depth) {
  if (depth < wrap3.length && depth < lastWrap.length && wrap3[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap3, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap3.length - 1 ? node.type : wrap3[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment12.from(withWrappers(node, wrap3, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment12.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment12.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
var _policy = null;
function maybeWrapTrusted(html) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html;
  if (!_policy)
    _policy = trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
  return _policy.createHTML(html);
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap3;
  if (wrap3 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap3.map((n) => "<" + n + ">").join("") + html + wrap3.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html);
  if (wrap3)
    for (let i = 0; i < wrap3.length; i++)
      elt = elt.querySelector(wrap3[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == " " && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array2;
  try {
    array2 = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array2.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array2[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment12.from(type.create(array2[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };
var InputState = class {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
};
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text)))
      view.dispatch(view.state.tr.insertText(text).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr2 = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = class {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
};
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset5 = sel.focusOffset; node && node.nodeType == 1 && offset5 != 0; ) {
          let before = offset5 < 0 ? node.lastChild : node.childNodes[offset5 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset5 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !view.state.selection.empty)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap3 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap3.appendChild(dom);
  wrap3.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap3.parentNode)
      wrap3.parentNode.removeChild(wrap3);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
var Dragging = class {
  constructor(slice2, move, node) {
    this.slice = slice2;
    this.move = move;
    this.node = node;
  }
};
var dragCopyModifier = mac ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice2, !event[dragCopyModifier], node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr2 = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr2);
    else
      tr2.deleteSelection();
  }
  let pos = tr2.mapping.map(insertPos);
  let isNode3 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr2.doc;
  if (isNode3)
    tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr2.replaceRange(pos, pos, slice2);
  if (tr2.doc.eq(beforeInsert))
    return;
  let $pos = tr2.doc.resolve(pos);
  if (isNode3 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr2.setSelection(new NodeSelection($pos));
  } else {
    let end2 = tr2.mapping.map(insertPos);
    tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
    tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end2)));
  }
  view.focus();
  view.dispatch(tr2.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
var WidgetType = class _WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset5, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset5, pos - offset5, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
};
var InlineType = class _InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset5, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset5;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset5;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof _InlineType;
  }
  destroy() {
  }
};
var NodeType2 = class _NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset5, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset5, to.pos - offset5, this);
  }
  valid(node, span) {
    let { index: index3, offset: offset5 } = node.content.findIndex(span.from), child;
    return offset5 == span.from && !(child = node.child(index3)).isText && offset5 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
};
var Decoration = class _Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new _Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset5 = 0) {
    return this.type.eq(other.type) && this.from + offset5 == other.from && this.to + offset5 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset5, oldOffset) {
    return this.type.map(mapping, this, offset5, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
};
var none = [];
var noSpec = {};
var DecorationSet = class _DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc3, decorations) {
    return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start2, end2, predicate) {
    let result = [];
    this.findInner(start2 == null ? 0 : start2, end2 == null ? 1e9 : end2, result, 0, predicate);
    return result;
  }
  findInner(start2, end2, result, offset5, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end2 && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset5, span.to + offset5));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end2 && this.children[i + 1] > start2) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start2 - childOff, end2 - childOff, result, offset5 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc3, options2) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc3, 0, 0, options2 || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset5, oldOffset, options2) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset5, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options2.onRemove)
        options2.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset5, oldOffset, options2);
    else
      return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc3, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return _DecorationSet.create(doc3, decorations);
    return this.addInner(doc3, decorations, 0);
  }
  addInner(doc3, decorations, offset5) {
    let children, childIndex = 0;
    doc3.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset5, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset5);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc3, local[i]))
        local.splice(i--, 1);
    return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset5) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from2 = children[i] + offset5, to = children[i + 1] + offset5;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset5)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new _DecorationSet(local, children) : empty;
  }
  forChild(offset5, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return _DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset5) {
        if (this.children[i] == offset5)
          child = this.children[i + 2];
        break;
      }
    let start2 = offset5 + 1, end2 = start2 + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end2 && dec.to > start2 && dec.type instanceof InlineType) {
        let from2 = Math.max(start2, dec.from) - start2, to = Math.min(end2, dec.to) - start2;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new _DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
  forEachSet(f) {
    f(this);
  }
};
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;
var DecorationGroup = class _DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc3) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
    return _DecorationGroup.from(mappedDecos);
  }
  forChild(offset5, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset5, child);
      if (result == empty)
        continue;
      if (result instanceof _DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return _DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
  forEachSet(f) {
    for (let i = 0; i < this.members.length; i++)
      this.members[i].forEachSet(f);
  }
};
function mapChildren(oldChildren, newLocal, mapping, node, offset5, oldOffset, options2) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end2 = children[i2 + 1];
        if (end2 < 0 || oldStart > end2 + baseOffset - moved)
          continue;
        let start2 = children[i2] + baseOffset - moved;
        if (oldEnd >= start2) {
          children[i2 + 1] = oldStart <= start2 ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset5;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset5;
      let { index: index3, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index3);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options2);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset5, oldOffset, options2);
    let built = buildTree(decorations, node, 0, options2);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j < children.length && children[j] < from2)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset5) {
  if (!offset5 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset5, span.to + offset5, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset5, oldOffset, options2) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset5, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options2.onRemove)
        options2.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset5) {
  if (node.isLeaf)
    return null;
  let end2 = offset5 + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset5 && span.to < end2) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array2) {
  let result = [];
  for (let i = 0; i < array2.length; i++)
    if (array2[i] != null)
      result.push(array2[i]);
  return result;
}
function buildTree(spans, node, offset5, options2) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset5);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset5 + localStart + 1, options2);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset5).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options2.onRemove)
        options2.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array2, i, deco) {
  while (i < array2.length && byPos(deco, array2[i]) > 0)
    i++;
  array2.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;
var SelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
};
var DOMObserver = class {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let [a, b] = brs;
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++) {
        let node = mut.addedNodes[i];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
};
var cssChecked = /* @__PURE__ */ new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read2, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
    let desc = view.docView.nearestDesc(p, true);
    if (desc && desc.node.isBlock)
      return p;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc3 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc3, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr3 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr3.setMeta("pointer", true);
      else if (origin == "key")
        tr3.scrollIntoView();
      if (compositionID)
        tr3.setMeta("composition", compositionID);
      view.dispatch(tr3);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse3 = parseBetween(view, from2, to);
  let doc3 = view.state.doc, compare = doc3.slice(parse3.from, parse3.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse3.doc.content, parse3.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse3.sel && parse3.sel.anchor != parse3.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse3.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse3.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr3 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr3.setMeta("composition", compositionID);
          view.dispatch(tr3);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse3.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse3.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse3.from && parse3.doc.textBetween(change.start - parse3.from - 1, change.start - parse3.from + 1) == "  ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse3.doc.resolveNoCache(change.start - parse3.from);
  let $to = parse3.doc.resolveNoCache(change.endB - parse3.from);
  let $fromA = doc3.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse3.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse3.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse3.sel && parse3.sel.anchor == parse3.sel.head && parse3.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse3.doc.resolveNoCache(change.endB - parse3.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr2, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr2 = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      tr2 = view.state.tr;
      if (markChange.type == "add")
        tr2.addMark(chFrom, chTo, markChange.mark);
      else
        tr2.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text)))
        return;
      tr2 = view.state.tr.insertText(text, chFrom, chTo);
    }
  }
  if (!tr2)
    tr2 = view.state.tr.replace(chFrom, chTo, parse3.doc.slice(change.start - parse3.from, change.endB - parse3.from));
  if (parse3.sel) {
    let sel2 = resolveSelection(view, tr2.doc, parse3.sel);
    if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
      tr2.setSelection(sel2);
  }
  if (storedMarks)
    tr2.ensureMarks(storedMarks);
  if (compositionID)
    tr2.setMeta("composition", compositionID);
  view.dispatch(tr2.scrollIntoView());
}
function resolveSelection(view, doc3, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
    return null;
  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update(prev.child(i)));
  if (Fragment12.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start2, end2, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end2 - start2 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start2);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end2 == start2 + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end2++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end2++;
    }
  }
  return end2;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start2 = a.findDiffStart(b, pos);
  if (start2 == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a.size < b.size) {
    let move = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move;
    if (start2 && start2 < b.size && isSurrogatePair(b.textBetween(start2 - 1, start2 + 1)))
      start2 += move ? 1 : -1;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    let move = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move;
    if (start2 && start2 < a.size && isSurrogatePair(a.textBetween(start2 - 1, start2 + 1)))
      start2 += move ? 1 : -1;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
var EditorView = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a5;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a5 = this.dragging) === null || _a5 === void 0 ? void 0 : _a5.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode))
      ;
    else if (this.someProp("handleScrollToSelection", (f) => f(this)))
      ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset5, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset5, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(slice2) {
    return serializeForClipboard(this, slice2);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(tr2) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr2);
    else
      this.updateState(this.state.apply(tr2));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code2 in base)
  if (!shift.hasOwnProperty(code2))
    shift[code2] = base[code2];
var code2;
function keyName(event) {
  var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}

// node_modules/prosemirror-keymap/dist/index.js
var mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift5, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift5 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac3)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift5)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName(prop)] = map2[prop];
  return copy2;
}
function modifiers(name, event, shift5 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift5 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}

// node_modules/prosemirror-commands/dist/index.js
var deleteSelection = (state, dispatch2) => {
  if (state.selection.empty)
    return false;
  if (dispatch2)
    dispatch2(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward = (state, dispatch2, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch2)
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch2, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch2) {
          let tr2 = state.tr.step(delStep);
          tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
          dispatch2(tr2.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2)
      dispatch2(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
var joinTextblockBackward = (state, dispatch2, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
};
var joinTextblockForward = (state, dispatch2, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
};
function joinTextblocksAround(state, $cut, dispatch2) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch2) {
    let tr2 = state.tr.step(step);
    tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward = (state, dispatch2, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward = (state, dispatch2, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch2, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
        dispatch2(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2)
      dispatch2(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward = (state, dispatch2, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp = (state, dispatch2) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch2) {
    let tr2 = state.tr.join(point);
    if (nodeSel)
      tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
var joinDown = (state, dispatch2) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch2)
    dispatch2(state.tr.join(point).scrollIntoView());
  return true;
};
var lift2 = (state, dispatch2) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch2)
    dispatch2(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var newlineInCode = (state, dispatch2) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch2)
    dispatch2(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode = (state, dispatch2) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch2) {
    let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
var createParagraphNear = (state, dispatch2) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch2) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr2 = state.tr.insert(side, type.createAndFill());
    tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock = (state, dispatch2) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch2)
        dispatch2(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch2)
    dispatch2(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch2) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch2)
        dispatch2(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d = $from.depth; ; d--) {
      let node = $from.node(d);
      if (node.isBlock) {
        atEnd = $from.end(d) == $from.pos + ($from.depth - d);
        atStart = $from.start(d) == $from.pos - ($from.depth - d);
        deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
        let splitType = splitNode && splitNode($to.parent, atEnd, $from);
        types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));
        splitDepth = d;
        break;
      } else {
        if (d == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr2 = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
      tr2.deleteSelection();
    let splitPos = tr2.mapping.map($from.pos);
    let can = canSplit(tr2.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr2.doc, splitPos, types.length, types);
    }
    tr2.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first2 = tr2.mapping.map($from.before(splitDepth)), $first = tr2.doc.resolve(first2);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr2.setNodeMarkup(tr2.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch2)
      dispatch2(tr2.scrollIntoView());
    return true;
  };
}
var splitBlock = splitBlockAs();
var selectParentNode = (state, dispatch2) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
var selectAll = (state, dispatch2) => {
  if (dispatch2)
    dispatch2(state.tr.setSelection(new AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch2) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index3 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index3 - 1, index3)) {
    if (dispatch2)
      dispatch2(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index3, index3 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch2)
    dispatch2(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch2, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch2))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch2) {
      let end2 = $cut.pos + after.nodeSize, wrap3 = Fragment12.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap3 = Fragment12.from(conn[i].create(null, wrap3));
      wrap3 = Fragment12.from(before.copy(wrap3));
      let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap3, 1, 0), conn.length, true));
      let $joinAt = tr2.doc.resolve(end2 + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr2.doc, $joinAt.pos))
        tr2.join($joinAt.pos);
      dispatch2(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch2)
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at2 = before, wrap3 = [];
    for (; ; ) {
      wrap3.push(at2);
      if (at2.isTextblock)
        break;
      at2 = at2.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at2.canReplace(at2.childCount, at2.childCount, afterText.content)) {
      if (dispatch2) {
        let end2 = Fragment12.empty;
        for (let i = wrap3.length - 1; i >= 0; i--)
          end2 = Fragment12.from(wrap3[i].copy(end2));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap3.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end2, wrap3.length, 0), 0, true));
        dispatch2(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch2) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch2)
      dispatch2(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function wrapIn(nodeType, attrs = null) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch2)
      dispatch2(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state, dispatch2) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index3 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index3, index3 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch2) {
      let tr2 = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        tr2.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch2(tr2.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state, dispatch2, view) {
    for (let i = 0; i < commands2.length; i++)
      if (commands2[i](state, dispatch2, view))
        return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let key in pcBaseKeymap)
  macBaseKeymap[key] = pcBaseKeymap[key];
var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

// node_modules/prosemirror-schema-list/dist/index.js
function wrapInList(listType, attrs = null) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to);
    if (!range)
      return false;
    let tr2 = dispatch2 ? state.tr : null;
    if (!wrapRangeInList(tr2, range, listType, attrs))
      return false;
    if (dispatch2)
      dispatch2(tr2.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr2, range, listType, attrs = null) {
  let doJoin = false, outerRange = range, doc3 = range.$from.doc;
  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
    if (range.$from.index(range.depth - 1) == 0)
      return false;
    let $insert = doc3.resolve(range.start - 2);
    outerRange = new NodeRange($insert, $insert, range.depth);
    if (range.endIndex < range.parent.childCount)
      range = new NodeRange(range.$from, doc3.resolve(range.$to.end(range.depth)), range.depth);
    doJoin = true;
  }
  let wrap3 = findWrapping(outerRange, listType, attrs, range);
  if (!wrap3)
    return false;
  if (tr2)
    doWrapInList(tr2, range, wrap3, doJoin, listType);
  return true;
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content = Fragment12.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment12.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr2;
}
function liftListItem(itemType) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch2)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch2, itemType, range);
    else
      return liftOutOfList(state, dispatch2, range);
  };
}
function liftToOuterList(state, dispatch2, itemType, range) {
  let tr2 = state.tr, end2 = range.end, endOfList = range.$to.end(range.depth);
  if (end2 < endOfList) {
    tr2.step(new ReplaceAroundStep(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment12.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr2.lift(range, target);
  let $after = tr2.doc.resolve(tr2.mapping.map(end2, -1) - 1);
  if (canJoin(tr2.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr2.join($after.pos);
  dispatch2(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch2, range) {
  let tr2 = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment12.empty : Fragment12.from(list))))
    return false;
  let start2 = $start.pos, end2 = start2 + item.nodeSize;
  tr2.step(new ReplaceAroundStep(start2 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start2 + 1, end2 - 1, new Slice((atStart ? Fragment12.empty : Fragment12.from(list.copy(Fragment12.empty))).append(atEnd ? Fragment12.empty : Fragment12.from(list.copy(Fragment12.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch2(tr2.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch2) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment12.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment12.from(itemType.create(null, Fragment12.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch2(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}

// node_modules/@tiptap/core/dist/index.js
function createChainableState(config) {
  const { state, transaction: transaction2 } = config;
  let { selection } = transaction2;
  let { doc: doc3 } = transaction2;
  let { storedMarks } = transaction2;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc3;
    },
    get tr() {
      selection = transaction2.selection;
      doc3 = transaction2.doc;
      storedMarks = transaction2.storedMarks;
      return transaction2;
    }
  };
}
var CommandManager = class {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props);
        if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr2);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run3 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain2 = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr2, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain2;
        };
        return [name, chainedCommand];
      })),
      run: run3
    };
    return chain2;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch2 = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch2);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch2)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
};
var EventEmitter2 = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn2) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn2);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn2) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn2) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn2);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  once(event, fn2) {
    const onceFn = (...args) => {
      this.off(event, onceFn);
      fn2.apply(this, args);
    };
    return this.on(event, onceFn);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        newStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a5;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const topNode = (_a5 = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a5 === void 0 ? void 0 : _a5.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraNodeFields = extensions.reduce((fields, e) => {
      const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
      linebreakReplacement: callOrReturn(getExtensionField(extension, "linebreakReplacement", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a6;
        return [extensionAttribute.name, { default: (_a6 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a6 === void 0 ? void 0 : _a6.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node) => renderHTML({
        node,
        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraMarkFields = extensions.reduce((fields, e) => {
      const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a6;
        return [extensionAttribute.name, { default: (_a6 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a6 === void 0 ? void 0 : _a6.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index3) => {
    var _a5, _b;
    const chunk = ((_b = (_a5 = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a5, {
      node,
      pos,
      parent,
      index: index3
    })) || node.textContent || "%leaf%";
    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
var InputRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var inputRuleMatcherHandler = (text, find2) => {
  if (isRegExp(find2)) {
    return find2.exec(text);
  }
  const inputRuleMatch = find2(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1(config) {
  var _a5;
  const { editor, from: from2, to, text, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || !!((_a5 = $from.nodeBefore || $from.nodeAfter) === null || _a5 === void 0 ? void 0 : _a5.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr2 = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr2
    });
    const range = {
      from: from2 - (match[0].length - text.length),
      to
    };
    const { commands: commands2, chain: chain2, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands: commands2,
      chain: chain2,
      can
    });
    if (handler === null || !tr2.steps.length) {
      return;
    }
    tr2.setMeta(plugin, {
      transform: tr2,
      from: from2,
      to,
      text
    });
    view.dispatch(tr2);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr2, prev, state) {
        const stored = tr2.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr2.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text === "string") {
              text = text;
            } else {
              text = getHTMLFromFragment(Fragment12.from(text), state.schema);
            }
            const { from: from2 } = simulatedInputMeta;
            const to = from2 + text.length;
            run$1({
              editor,
              from: from2,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr2.selectionSet || tr2.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text) {
        return run$1({
          editor,
          from: from2,
          to,
          text,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject2(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject2(target) && isPlainObject2(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject2(source[key]) && isPlainObject2(target[key])) {
        output[key] = mergeDeep(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var Mark2 = class _Mark {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Mark(config);
  }
  configure(options2 = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options2);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Mark(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr: tr2 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr2.removeStoredMark(removeMark2);
      }
      tr2.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr2);
      return true;
    }
    return false;
  }
};
function isNumber(value) {
  return typeof value === "number";
}
var PasteRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var pasteRuleMatcherHandler = (text, find2, event) => {
  if (isRegExp(find2)) {
    return [...text.matchAll(find2)];
  }
  const matches2 = find2(text, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run(config) {
  const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
  const { commands: commands2, chain: chain2, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "￼");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start2 = resolvedFrom + match.index + 1;
      const end2 = start2 + match[0].length;
      const range = {
        from: state.tr.mapping.map(start2),
        to: state.tr.mapping.map(end2)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain: chain2,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
var tiptapDragFromOtherEditor = null;
var createClipboardPasteEvent = (text) => {
  var _a5;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  (_a5 = event.clipboardData) === null || _a5 === void 0 ? void 0 : _a5.setData("text/html", text);
  return event;
};
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent;
  try {
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  } catch {
    dropEvent = null;
  }
  const processEvent = ({ state, from: from2, to, rule, pasteEvt }) => {
    const tr2 = state.tr;
    const chainableState = createChainableState({
      state,
      transaction: tr2
    });
    const handler = run({
      editor,
      state: chainableState,
      from: Math.max(from2 - 1, 0),
      to: to.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr2.steps.length) {
      return;
    }
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch {
      dropEvent = null;
    }
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr2;
  };
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a5;
          dragSourceElement = ((_a5 = view.dom.parentElement) === null || _a5 === void 0 ? void 0 : _a5.contains(event.target)) ? view.dom.parentElement : null;
          if (dragSourceElement) {
            tiptapDragFromOtherEditor = editor;
          }
        };
        const handleDragend = () => {
          if (tiptapDragFromOtherEditor) {
            tiptapDragFromOtherEditor = null;
          }
        };
        window.addEventListener("dragstart", handleDragstart);
        window.addEventListener("dragend", handleDragend);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
            window.removeEventListener("dragend", handleDragend);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            if (!isDroppedFromProseMirror) {
              const dragFromOtherEditor = tiptapDragFromOtherEditor;
              if (dragFromOtherEditor) {
                setTimeout(() => {
                  const selection = dragFromOtherEditor.state.selection;
                  if (selection) {
                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                  }
                }, 10);
              }
            }
            return false;
          },
          paste: (_view, event) => {
            var _a5;
            const html = (_a5 = event.clipboardData) === null || _a5 === void 0 ? void 0 : _a5.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction2 = transactions[0];
        const isPaste = transaction2.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction2.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction2.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          let { text } = simulatedPasteMeta;
          if (typeof text === "string") {
            text = text;
          } else {
            text = getHTMLFromFragment(Fragment12.from(text), state.schema);
          }
          const { from: from3 } = simulatedPasteMeta;
          const to2 = from3 + text.length;
          const pasteEvt = createClipboardPasteEvent(text);
          return processEvent({
            rule,
            state,
            from: from3,
            to: { b: to2 },
            pasteEvt
          });
        }
        const from2 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from: from2,
          to,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
function findDuplicates(items) {
  const filtered = items.filter((el, index3) => items.indexOf(el) !== index3);
  return Array.from(new Set(filtered));
}
var ExtensionManager = class _ExtensionManager {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = _ExtensionManager.resolve(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(extensions) {
    const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(extensions) {
    return extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [extension, ...this.flatten(addExtensions())];
      }
      return extension;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(extensions) {
    const defaultPriority = 100;
    return extensions.sort((a, b) => {
      const priorityA = getExtensionField(a, "priority") || defaultPriority;
      const priorityB = getExtensionField(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((commands2, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands2;
      }
      return {
        ...commands2,
        ...addCommands()
      };
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor } = this;
    const extensions = _ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      let defaultBindings = {};
      if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node, view, getPos, decorations, innerDecorations) => {
        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView()({
          // pass-through
          node,
          view,
          getPos,
          decorations,
          innerDecorations,
          // tiptap-specific
          editor,
          extension,
          HTMLAttributes
        });
      };
      return [extension.name, nodeview];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((extension) => {
      var _a5;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a5 = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a5 !== void 0 ? _a5 : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      const onCreate2 = getExtensionField(extension, "onCreate", context);
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      const onFocus = getExtensionField(extension, "onFocus", context);
      const onBlur = getExtensionField(extension, "onBlur", context);
      const onDestroy2 = getExtensionField(extension, "onDestroy", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate2) {
        this.editor.on("create", onCreate2);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy2) {
        this.editor.on("destroy", onDestroy2);
      }
    });
  }
};
var Extension = class _Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Extension(config);
  }
  configure(options2 = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options2);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Extension({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function getTextBetween(startNode, range, options2) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
  let text = "";
  startNode.nodesBetween(from2, to, (node, pos, parent, index3) => {
    var _a5;
    if (node.isBlock && pos > from2) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index: index3,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a5 = node === null || node === void 0 ? void 0 : node.text) === null || _a5 === void 0 ? void 0 : _a5.slice(Math.max(from2, pos) - pos, to - pos);
    }
  });
  return text;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc3, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from: from2, to };
            return getTextBetween(doc3, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a5;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a5 = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a5 === void 0 ? void 0 : _a5.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
var clearNodes = () => ({ state, tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc3, mapping } = tr2;
      const $mappedFrom = doc3.resolve(mapping.map(pos));
      const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn2) => (props) => {
  return fn2(props);
};
var createParagraphNear2 = () => ({ state, dispatch: dispatch2 }) => {
  return createParagraphNear(state, dispatch2);
};
var cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
  return true;
};
var deleteCurrentNode = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange2 = (range) => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { from: from2, to } = range;
  if (dispatch2) {
    tr2.delete(from2, to);
  }
  return true;
};
var deleteSelection2 = () => ({ state, dispatch: dispatch2 }) => {
  return deleteSelection(state, dispatch2);
};
var enter = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
var exitCode2 = () => ({ state, dispatch: dispatch2 }) => {
  return exitCode(state, dispatch2);
};
function objectIncludes(object1, object2, options2 = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options2.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
      attributes
    );
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  var _a5;
  if (!$pos || !type) {
    return;
  }
  let start2 = $pos.parent.childAfter($pos.parentOffset);
  if (!start2.node || !start2.node.marks.some((mark2) => mark2.type === type)) {
    start2 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start2.node || !start2.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a5 = start2.node.marks[0]) === null || _a5 === void 0 ? void 0 : _a5.attrs);
  const mark = findMarkInSet([...start2.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start2.index;
  let startPos = $pos.start() + start2.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start2.node.nodeSize;
  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc3, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch2) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc3, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands2) => (props) => {
  const items = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min4 = 0, max3 = 0) {
  return Math.min(Math.max(value, min4), max3);
}
function resolveFocusPosition(doc3, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc3);
  const selectionAtEnd = Selection.atEnd(doc3);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus = (position = null, options2 = {}) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  options2 = {
    scrollIntoView: true,
    ...options2
  };
  const delayedFocus = () => {
    if (isiOS() || isAndroid()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options2 === null || options2 === void 0 ? void 0 : options2.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch2 && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr2.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch2) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn2) => (props) => {
  return items.every((item, index3) => fn2(item, { ...props, index: index3 }));
};
var insertContent = (value, options2) => ({ tr: tr2, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options2);
};
var removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options2) {
  if (content instanceof Node2 || content instanceof Fragment12) {
    return content;
  }
  options2 = {
    slice: true,
    parseOptions: {},
    ...options2
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment12.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options2.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options2.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options2);
    }
  }
  if (isTextContent) {
    if (options2.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options2.slice) {
        DOMParser2.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options2.parseOptions);
      } else {
        DOMParser2.fromSchema(contentCheckSchema).parse(elementFromString(content), options2.parseOptions);
      }
      if (options2.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${invalidContent}`) });
      }
    }
    const parser = DOMParser2.fromSchema(schema);
    if (options2.slice) {
      return parser.parseSlice(elementFromString(content), options2.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options2.parseOptions);
  }
  return createNodeFromContent("", schema, options2);
}
function selectionToInsertionEnd2(tr2, startLen, bias) {
  const last3 = tr2.steps.length - 1;
  if (last3 < startLen) {
    return;
  }
  const step = tr2.steps[last3];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr2.mapping.maps[last3];
  let end2 = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 === 0) {
      end2 = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
}
var isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
var insertContentAt = (position, value, options2) => ({ tr: tr2, dispatch: dispatch2, editor }) => {
  var _a5;
  if (dispatch2) {
    options2 = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options2
    };
    let content;
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...options2.parseOptions
        },
        errorOnInvalidContent: (_a5 = options2.errorOnInvalidContent) !== null && _a5 !== void 0 ? _a5 : editor.options.enableContentCheck
      });
    } catch (e) {
      editor.emit("contentError", {
        editor,
        error: e,
        disableCollaboration: () => {
          if (editor.storage.collaboration) {
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
      return false;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment12) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr2.insertText(newContent, from2, to);
    } else {
      newContent = content;
      tr2.replaceWith(from2, to, newContent);
    }
    if (options2.updateSelection) {
      selectionToInsertionEnd2(tr2, tr2.steps.length - 1, -1);
    }
    if (options2.applyInputRules) {
      tr2.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options2.applyPasteRules) {
      tr2.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
var joinUp2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinUp(state, dispatch2);
};
var joinDown2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinDown(state, dispatch2);
};
var joinBackward2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinBackward(state, dispatch2);
};
var joinForward2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinForward(state, dispatch2);
};
var joinItemBackward = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinTextblockBackward2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockBackward(state, dispatch2);
};
var joinTextblockForward2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockForward(state, dispatch2);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName2(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift5;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift5 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift5) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch2) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift2(state, dispatch2);
};
var liftEmptyBlock2 = () => ({ state, dispatch: dispatch2 }) => {
  return liftEmptyBlock(state, dispatch2);
};
var liftListItem2 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem(type)(state, dispatch2);
};
var newlineInCode2 = () => ({ state, dispatch: dispatch2 }) => {
  return newlineInCode(state, dispatch2);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr2.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    tr2.scrollIntoView();
  }
  return true;
};
var selectAll2 = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const selection = new AllSelection(tr2.doc);
    tr2.setSelection(selection);
  }
  return true;
};
var selectNodeBackward2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeBackward(state, dispatch2);
};
var selectNodeForward2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeForward(state, dispatch2);
};
var selectParentNode2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectParentNode(state, dispatch2);
};
var selectTextblockEnd2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockEnd(state, dispatch2);
};
var selectTextblockStart2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockStart(state, dispatch2);
};
function createDocument(content, schema, parseOptions = {}, options2 = {}) {
  return createNodeFromContent(content, schema, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options2.errorOnInvalidContent
  });
}
var setContent = (content, emitUpdate = false, parseOptions = {}, options2 = {}) => ({ editor, tr: tr2, dispatch: dispatch2, commands: commands2 }) => {
  var _a5, _b;
  const { doc: doc3 } = tr2;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument(content, editor.schema, parseOptions, {
      errorOnInvalidContent: (_a5 = options2.errorOnInvalidContent) !== null && _a5 !== void 0 ? _a5 : editor.options.enableContentCheck
    });
    if (dispatch2) {
      tr2.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch2) {
    tr2.setMeta("preventUpdate", !emitUpdate);
  }
  return commands2.insertContentAt({ from: 0, to: doc3.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: (_b = options2.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck
  });
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction2) => {
    transaction2.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt2(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildrenInRange(node, range, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getSchema(extensions, editor) {
  const resolvedExtensions = ExtensionManager.resolve(extensions);
  return getSchemaByResolvedExtensions(resolvedExtensions, editor);
}
function generateHTML(doc3, extensions) {
  const schema = getSchema(extensions);
  const contentNode = Node2.fromJSON(schema, doc3);
  return getHTMLFromFragment(contentNode.content, schema);
}
function generateJSON(html, extensions) {
  const schema = getSchema(extensions);
  const dom = elementFromString(html);
  return DOMParser2.fromSchema(schema).parse(dom).toJSON();
}
function getText2(node, options2) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options2);
}
function generateText(doc3, extensions, options2) {
  const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
  const schema = getSchema(extensions);
  const contentNode = Node2.fromJSON(schema, doc3);
  return getText2(contentNode, {
    blockSeparator,
    textSerializers: {
      ...getTextSerializersFromSchema(schema),
      ...textSerializers
    }
  });
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array2, by = JSON.stringify) {
  const seen = {};
  return array2.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index3) => {
    const rest = uniqueChanges.filter((_, i) => i !== index3);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index3) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index3];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index3).map(from2, -1);
      const newEnd = mapping.slice(index3).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from2, to, doc3) {
  const marks = [];
  if (from2 === to) {
    doc3.resolve(from2).marks().forEach((mark) => {
      const $pos = doc3.resolve(from2);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc3.nodesBetween(from2, to, (node, pos) => {
      if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {
  var _a5;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a5 = node.text) !== null && _a5 !== void 0 ? _a5 : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function posToDOMRect(view, from2, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from2, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start2 = view.coordsAtPos(resolvedFrom);
  const end2 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start2.top, end2.top);
  const bottom2 = Math.max(start2.bottom, end2.bottom);
  const left2 = Math.min(start2.left, end2.left);
  const right2 = Math.max(start2.right, end2.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x = left2;
  const y = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x,
    y
  };
  return {
    ...data,
    toJSON: () => data
  };
}
function canSetMark(state, tr2, newMarkType) {
  var _a5;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a5 = state.storedMarks) !== null && _a5 !== void 0 ? _a5 : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch2) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr2.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr2, type);
};
var setMeta = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2, chain: chain2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain2().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType2(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType2(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch2);
  }).run();
};
var setNodeSelection = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc3 } = tr2;
    const from2 = minMax(position, 0, doc3.content.size);
    const selection = NodeSelection.create(doc3, from2);
    tr2.setSelection(selection);
  }
  return true;
};
var setTextSelection = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc3 } = tr2;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc3).from;
    const maxPos = TextSelection.atEnd(doc3).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
var sinkListItem2 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem(type)(state, dispatch2);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  const { selection, doc: doc3 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch2) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr2.deleteSelection();
      }
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return can;
};
var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  var _a5;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch2) {
      let wrap3 = Fragment12.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap3 = Fragment12.from($from.node(d).copy(wrap3));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a5 = type.contentMatch.defaultType) === null || _a5 === void 0 ? void 0 : _a5.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap3 = wrap3.append(Fragment12.from(type.createAndFill(null, nextType2) || void 0));
      const start2 = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start2, $from.after(-depthAfter), new Slice(wrap3, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start2, tr2.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch2) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch2) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
var joinListForwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch: dispatch2, chain: chain2, commands: commands2, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch2) {
      return chain2().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch2) {
    return chain2().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
  }
  return chain2().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options2 = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options2;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands2.setNode(toggleType, attributesToCopy);
  }
  return commands2.setNode(type, { ...attributesToCopy, ...attributes });
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch: dispatch2 }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch2) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch2) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options2 = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  var _a5;
  const { extendEmptyMarkRange = false } = options2;
  const { selection } = tr2;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a5 = $from.marks().find((mark) => mark.type === type)) === null || _a5 === void 0 ? void 0 : _a5.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr2.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr2.selection.empty) {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
        });
      } else {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (pos < from2 && nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
          if (pos >= from2 && pos <= to) {
            if (nodeType && nodeType === node.type) {
              tr2.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom2 = Math.max(pos, from2);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr2.addMark(trimmedFrom2, trimmedTo2, markType.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== void 0) {
          tr2.setNodeMarkup(lastPos, void 0, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      }
    });
  }
  return true;
};
var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn(type, attributes)(state, dispatch2);
};
var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList(type, attributes)(state, dispatch2);
};
var commands = Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear: createParagraphNear2,
  cut,
  deleteCurrentNode,
  deleteNode,
  deleteRange: deleteRange2,
  deleteSelection: deleteSelection2,
  enter,
  exitCode: exitCode2,
  extendMarkRange,
  first,
  focus,
  forEach,
  insertContent,
  insertContentAt,
  joinBackward: joinBackward2,
  joinDown: joinDown2,
  joinForward: joinForward2,
  joinItemBackward,
  joinItemForward,
  joinTextblockBackward: joinTextblockBackward2,
  joinTextblockForward: joinTextblockForward2,
  joinUp: joinUp2,
  keyboardShortcut,
  lift: lift3,
  liftEmptyBlock: liftEmptyBlock2,
  liftListItem: liftListItem2,
  newlineInCode: newlineInCode2,
  resetAttributes,
  scrollIntoView,
  selectAll: selectAll2,
  selectNodeBackward: selectNodeBackward2,
  selectNodeForward: selectNodeForward2,
  selectParentNode: selectParentNode2,
  selectTextblockEnd: selectTextblockEnd2,
  selectTextblockStart: selectTextblockStart2,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem: sinkListItem2,
  splitBlock: splitBlock2,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn: wrapIn2,
  wrapInList: wrapInList2
});
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands
    };
  }
});
var Drop = Extension.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e, slice2, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: slice2,
              moved
            });
          }
        }
      })
    ];
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction2 = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction2 = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands2.command(({ tr: tr2 }) => {
        const { selection, doc: doc3 } = tr2;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr3) => tr3.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction2) => transaction2.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction2) => transaction2.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty = isNodeEmpty(newState.doc);
          if (!isEmpty) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr2
          });
          const { commands: commands2 } = new CommandManager({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
var Paste = Extension.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e, slice2) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: slice2
            });
          }
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var index = Object.freeze({
  __proto__: null,
  ClipboardTextSerializer,
  Commands,
  Drop,
  Editable,
  FocusEvents,
  Keymap,
  Paste,
  Tabindex
});
var NodePos = class _NodePos {
  get name() {
    return this.node.type.name;
  }
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a5;
    return (_a5 = this.actualDepth) !== null && _a5 !== void 0 ? _a5 : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from2 = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from2 = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from2, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new _NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node, offset5) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const isNonTextAtom = node.isAtom && !node.isText;
      const targetPos = this.pos + offset5 + (isNonTextAtom ? 0 : 1);
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index3 = 0; index3 < attrKeys.length; index3 += 1) {
            const key = attrKeys[index3];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (!this.children || this.children.length === 0) {
      return nodes;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
        if (doesAllAttributesMatch) {
          nodes.push(childPos);
        }
      }
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const { tr: tr2 } = this.editor.state;
    tr2.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...attributes
    });
    this.editor.view.dispatch(tr2);
  }
};
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor2 = class extends EventEmitter2 {
  constructor(options2 = {}) {
    super();
    this.isFocused = false;
    this.isInitialized = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onPaste: () => null,
      onDrop: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options2);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("contentError", this.options.onContentError);
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("drop", ({ event, slice: slice2, moved }) => this.options.onDrop(event, slice2, moved));
    this.on("paste", ({ event, slice: slice2 }) => this.options.onPaste(event, slice2));
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
      this.isInitialized = true;
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options2 = {}) {
    this.options = {
      ...this.options,
      ...options2
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
    return state;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(nameOrPluginKeyToRemove) {
    if (this.isDestroyed) {
      return void 0;
    }
    const prevPlugins = this.state.plugins;
    let plugins = prevPlugins;
    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      plugins = prevPlugins.filter((plugin) => !plugin.key.startsWith(name));
    });
    if (prevPlugins.length === plugins.length) {
      return void 0;
    }
    const state = this.state.reconfigure({
      plugins
    });
    this.view.updateState(state);
    return state;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var _a5, _b;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b = (_a5 = this.options.coreExtensionOptions) === null || _a5 === void 0 ? void 0 : _a5.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex,
      Drop,
      Paste
    ].filter((ext) => {
      if (typeof this.options.enableCoreExtensions === "object") {
        return this.options.enableCoreExtensions[ext.name] !== false;
      }
      return true;
    }) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var _a5;
    let doc3;
    try {
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
        throw e;
      }
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          if (this.storage.collaboration) {
            this.storage.collaboration.isDisabled = true;
          }
          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
          this.createExtensionManager();
        }
      });
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
    }
    const selection = resolveFocusPosition(doc3, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(_a5 = this.options.editorProps) === null || _a5 === void 0 ? void 0 : _a5.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc3,
        selection: selection || void 0
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    if (this.view.isDestroyed) {
      return;
    }
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn2) {
    this.isCapturingTransaction = true;
    fn2();
    this.isCapturingTransaction = false;
    const tr2 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr2;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction2) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction2;
        return;
      }
      transaction2.steps.forEach((step) => {
        var _a5;
        return (_a5 = this.capturedTransaction) === null || _a5 === void 0 ? void 0 : _a5.step(step);
      });
      return;
    }
    const state = this.state.apply(transaction2);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: transaction2,
      nextState: state
    });
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction: transaction2
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction: transaction2
      });
    }
    const focus3 = transaction2.getMeta("focus");
    const blur2 = transaction2.getMeta("blur");
    if (focus3) {
      this.emit("focus", {
        editor: this,
        event: focus3.event,
        transaction: transaction2
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction: transaction2
      });
    }
    if (!transaction2.docChanged || transaction2.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction: transaction2
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options2) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
    return getText2(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    if (this.view) {
      const dom = this.view.dom;
      if (dom && dom.editor) {
        delete dom.editor;
      }
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a5;
    return !((_a5 = this.view) === null || _a5 === void 0 ? void 0 : _a5.docView);
  }
  $node(selector, attributes) {
    var _a5;
    return ((_a5 = this.$doc) === null || _a5 === void 0 ? void 0 : _a5.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a5;
    return ((_a5 = this.$doc) === null || _a5 === void 0 ? void 0 : _a5.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr: tr2 } = state;
      const start2 = range.from;
      let end2 = range.to;
      const newNode = config.type.create(attributes);
      if (match[1]) {
        const offset5 = match[0].lastIndexOf(match[1]);
        let matchStart = start2 + offset5;
        if (matchStart > end2) {
          matchStart = end2;
        } else {
          end2 = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr2.insertText(lastChar, start2 + match[0].length - 1);
        tr2.replaceWith(matchStart, end2, newNode);
      } else if (match[0]) {
        const insertionStart = config.type.isInline ? start2 : start2 - 1;
        tr2.insert(insertionStart, config.type.create(attributes)).delete(tr2.mapping.map(start2), tr2.mapping.map(end2));
      }
      tr2.scrollIntoView();
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match, chain: chain2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const tr2 = state.tr.delete(range.from, range.to);
      const $start = tr2.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr2.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain2().updateAttributes(nodeType, attributes).run();
      }
      const before = tr2.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
        tr2.join(range.from - 1);
      }
    }
  });
}
var Node3 = class _Node {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Node(config);
  }
  configure(options2 = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options2);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Node(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/richText.mjs
function getFontsFromRichText(editor, richText, initialState2) {
  const { tipTapConfig, addFontsFromNode } = editor.getTextOptions();
  assert(tipTapConfig, "textOptions.tipTapConfig must be set to use rich text");
  assert(addFontsFromNode, "textOptions.addFontsFromNode must be set to use rich text");
  const schema = getSchema(tipTapConfig.extensions ?? []);
  const rootNode = Node2.fromJSON(schema, richText);
  const fonts = /* @__PURE__ */ new Set();
  function addFont(font) {
    fonts.add(font);
  }
  function visit(node, state) {
    state = addFontsFromNode(node, state, addFont);
    for (const child of node.children) {
      visit(child, state);
    }
  }
  visit(rootNode, initialState2);
  return Array.from(fonts);
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/sync/hardReset.mjs
async function hardReset({ shouldReload = true } = {}) {
  clearSessionStorage();
  for (const instance of LocalIndexedDb.connectedInstances) {
    await instance.close();
  }
  await Promise.all(getAllIndexDbNames().map((db) => deleteDB(db)));
  clearLocalStorage();
  if (shouldReload) {
    window.location.reload();
  }
}
if (typeof window !== "undefined") {
  if (true) {
    ;
    window.hardReset = hardReset;
  }
  ;
  window.__tldraw__hardReset = hardReset;
}

// node_modules/@tldraw/editor/dist-esm/lib/utils/window-open.mjs
function openWindow(url, target = "_blank") {
  runtime.openWindow(url, target);
}

// node_modules/@tldraw/editor/dist-esm/index.mjs
function debugEnableLicensing() {
  return;
}
registerTldrawLibraryVersion(
  "@tldraw/editor",
  "3.13.1",
  "esm"
);

// node_modules/tldraw/dist-esm/lib/shapes/shared/usePrefersReducedMotion.mjs
var import_react51 = __toESM(require_react(), 1);
function usePrefersReducedMotion() {
  const [prefersReducedMotion, setPrefersReducedMotion] = (0, import_react51.useState)(false);
  (0, import_react51.useEffect)(() => {
    if (typeof window === "undefined" || !("matchMedia" in window))
      return;
    const mql = window.matchMedia("(prefers-reduced-motion: reduce)");
    const handler = () => {
      setPrefersReducedMotion(mql.matches);
    };
    handler();
    mql.addEventListener("change", handler);
    return () => mql.removeEventListener("change", handler);
  }, []);
  return prefersReducedMotion;
}

// node_modules/tldraw/dist-esm/lib/ui/components/A11y.mjs
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react54 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/context/a11y.mjs
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react52 = __toESM(require_react(), 1);
var A11yContext = (0, import_react52.createContext)(null);
function TldrawUiA11yProvider({ children }) {
  const currentMsg = useAtom("a11y", { msg: "", priority: "assertive" });
  const ctx = (0, import_react52.useContext)(A11yContext);
  const current = (0, import_react52.useMemo)(
    () => ({
      currentMsg,
      announce(msg2) {
        if (!msg2)
          return;
        currentMsg.set(msg2);
      }
    }),
    [currentMsg]
  );
  if (ctx) {
    return (0, import_jsx_runtime38.jsx)(import_jsx_runtime38.Fragment, { children });
  }
  return (0, import_jsx_runtime38.jsx)(A11yContext.Provider, { value: current, children });
}
function useA11y() {
  const ctx = (0, import_react52.useContext)(A11yContext);
  if (!ctx) {
    throw new Error("useA11y must be used within a A11yContext.Provider");
  }
  return ctx;
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useTranslation/useTranslation.mjs
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var React12 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/context/asset-urls.mjs
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var AssetUrlsContext = (0, import_react53.createContext)(null);
function AssetUrlsProvider({
  assetUrls,
  children
}) {
  (0, import_react53.useEffect)(() => {
    for (const src of Object.values(assetUrls.icons)) {
      if (!src)
        continue;
      const image = Image();
      image.src = src;
      image.decode();
    }
    for (const src of Object.values(assetUrls.embedIcons)) {
      if (!src)
        continue;
      const image = Image();
      image.src = src;
      image.decode();
    }
  }, [assetUrls]);
  return (0, import_jsx_runtime39.jsx)(AssetUrlsContext.Provider, { value: assetUrls, children });
}
function useAssetUrls() {
  const assetUrls = (0, import_react53.useContext)(AssetUrlsContext);
  if (!assetUrls) {
    throw new Error("useAssetUrls must be used within an AssetUrlsProvider");
  }
  return assetUrls;
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useTranslation/defaultTranslation.mjs
var DEFAULT_TRANSLATION = {
  "action.convert-to-bookmark": "Convert to Bookmark",
  "action.convert-to-embed": "Convert to Embed",
  "action.open-embed-link": "Open link",
  "action.align-bottom": "Align bottom",
  "action.align-center-horizontal": "Align horizontally",
  "action.align-center-vertical": "Align vertically",
  "action.align-center-horizontal.short": "Align H",
  "action.align-center-vertical.short": "Align V",
  "action.align-left": "Align left",
  "action.align-right": "Align right",
  "action.align-top": "Align top",
  "action.back-to-content": "Back to content",
  "action.bring-forward": "Bring forward",
  "action.bring-to-front": "Bring to front",
  "action.copy-as-png.short": "PNG",
  "action.copy-as-png": "Copy as PNG",
  "action.copy-as-svg.short": "SVG",
  "action.copy-as-svg": "Copy as SVG",
  "action.copy": "Copy",
  "action.cut": "Cut",
  "action.delete": "Delete",
  "action.unlock-all": "Unlock all",
  "action.distribute-horizontal": "Distribute horizontally",
  "action.distribute-vertical": "Distribute vertically",
  "action.distribute-horizontal.short": "Distribute H",
  "action.distribute-vertical.short": "Distribute V",
  "action.duplicate": "Duplicate",
  "action.edit-link": "Edit link",
  "action.exit-pen-mode": "Exit pen mode",
  "action.export-as-png.short": "PNG",
  "action.export-as-png": "Export as PNG",
  "action.export-as-svg.short": "SVG",
  "action.export-as-svg": "Export as SVG",
  "action.export-all-as-png.short": "PNG",
  "action.export-all-as-png": "Export as PNG",
  "action.export-all-as-svg.short": "SVG",
  "action.export-all-as-svg": "Export as SVG",
  "action.fit-frame-to-content": "Fit to content",
  "action.flip-horizontal": "Flip horizontally",
  "action.flip-vertical": "Flip vertically",
  "action.flip-horizontal.short": "Flip H",
  "action.flip-vertical.short": "Flip V",
  "action.fork-project": "Fork this project",
  "action.fork-project-on-tldraw": "Fork project on tldraw",
  "action.group": "Group",
  "action.insert-embed": "Insert embed",
  "action.insert-media": "Upload media",
  "action.leave-shared-project": "Leave shared project",
  "action.new-project": "New project",
  "action.new-shared-project": "New shared project",
  "action.open-cursor-chat": "Cursor chat",
  "action.open-file": "Open file",
  "action.pack": "Pack",
  "action.paste": "Paste",
  "action.paste-error-title": "Pasting failed",
  "action.paste-error-description": "Could not paste due to missing clipboard permissions. Please enable the permissions and try again.",
  "action.print": "Print",
  "action.redo": "Redo",
  "action.remove-frame": "Remove frame",
  "action.rename": "Rename",
  "action.rotate-ccw": "Rotate counterclockwise",
  "action.rotate-cw": "Rotate clockwise",
  "action.save-copy": "Save a copy",
  "action.select-all": "Select all",
  "action.select-none": "Select none",
  "action.send-backward": "Send backward",
  "action.send-to-back": "Send to back",
  "action.share-project": "Share this project",
  "action.stack-horizontal": "Stack horizontally",
  "action.stack-vertical": "Stack vertically",
  "action.stack-horizontal.short": "Stack H",
  "action.stack-vertical.short": "Stack V",
  "action.stop-following": "Stop following",
  "action.stretch-horizontal": "Stretch horizontally",
  "action.stretch-vertical": "Stretch vertically",
  "action.stretch-horizontal.short": "Stretch H",
  "action.stretch-vertical.short": "Stretch V",
  "action.toggle-auto-size": "Toggle auto size",
  "action.toggle-dark-mode.menu": "Dark mode",
  "action.toggle-dark-mode": "Toggle dark mode",
  "action.toggle-paste-at-cursor.menu": "Paste at cursor",
  "action.toggle-paste-at-cursor": "Toggle paste at cursor",
  "action.toggle-wrap-mode.menu": "Select on wrap",
  "action.toggle-wrap-mode": "Toggle Select on wrap",
  "action.toggle-reduce-motion.menu": "Reduce motion",
  "action.toggle-reduce-motion": "Toggle reduce motion",
  "action.toggle-edge-scrolling.menu": "Edge scrolling",
  "action.toggle-edge-scrolling": "Toggle edge scrolling",
  "action.toggle-debug-mode.menu": "Debug mode",
  "action.toggle-debug-mode": "Toggle debug mode",
  "action.toggle-focus-mode.menu": "Focus mode",
  "action.toggle-focus-mode": "Toggle focus mode",
  "action.toggle-dynamic-size-mode.menu": "Dynamic size",
  "action.toggle-dynamic-size-mode": "Toggle dynamic size",
  "action.toggle-grid.menu": "Show grid",
  "action.toggle-grid": "Toggle grid",
  "action.toggle-lock": "Toggle locked",
  "action.flatten-to-image": "Flatten",
  "action.toggle-snap-mode.menu": "Always snap",
  "action.toggle-snap-mode": "Toggle always snap",
  "action.toggle-tool-lock.menu": "Tool lock",
  "action.toggle-tool-lock": "Toggle tool lock",
  "action.toggle-transparent.context-menu": "Transparent",
  "action.toggle-transparent.menu": "Transparent",
  "action.toggle-transparent": "Toggle transparent background",
  "action.undo": "Undo",
  "action.ungroup": "Ungroup",
  "action.zoom-in": "Zoom in",
  "action.zoom-out": "Zoom out",
  "action.zoom-to-100": "Zoom to 100%",
  "action.zoom-to-fit": "Zoom to fit",
  "action.zoom-to-selection": "Zoom to selection",
  "assets.files.size-too-big": "File size is too big",
  "assets.files.type-not-allowed": "File type is not allowed",
  "assets.files.upload-failed": "Upload failed",
  "assets.files.amount-too-many": "Too many files",
  "assets.url.failed": "Couldn’t load URL preview",
  "theme.dark": "Dark",
  "theme.light": "Light",
  "theme.system": "System",
  "color-style.white": "White",
  "color-style.black": "Black",
  "color-style.blue": "Blue",
  "color-style.green": "Green",
  "color-style.grey": "Grey",
  "color-style.light-blue": "Light blue",
  "color-style.light-green": "Light green",
  "color-style.light-red": "Light red",
  "color-style.light-violet": "Light violet",
  "color-style.orange": "Orange",
  "color-style.red": "Red",
  "color-style.violet": "Violet",
  "color-style.yellow": "Yellow",
  "fill-style.none": "None",
  "document.default-name": "Untitled",
  "fill-style.semi": "Semi",
  "fill-style.solid": "Solid",
  "fill-style.pattern": "Pattern",
  "fill-style.fill": "Fill",
  "dash-style.dashed": "Dashed",
  "dash-style.dotted": "Dotted",
  "dash-style.draw": "Draw",
  "dash-style.solid": "Solid",
  "size-style.s": "Small",
  "size-style.m": "Medium",
  "size-style.l": "Large",
  "size-style.xl": "Extra large",
  "opacity-style.0.1": "10%",
  "opacity-style.0.25": "25%",
  "opacity-style.0.5": "50%",
  "opacity-style.0.75": "75%",
  "opacity-style.1": "100%",
  "font-style.draw": "Draw",
  "font-style.sans": "Sans",
  "font-style.serif": "Serif",
  "font-style.mono": "Mono",
  "align-style.start": "Start",
  "align-style.middle": "Middle",
  "align-style.end": "End",
  "align-style.justify": "Justify",
  "verticalAlign-style.start": "Top",
  "verticalAlign-style.middle": "Middle",
  "verticalAlign-style.end": "Bottom",
  "geo-style.arrow-down": "Arrow down",
  "geo-style.arrow-left": "Arrow left",
  "geo-style.arrow-right": "Arrow right",
  "geo-style.arrow-up": "Arrow up",
  "geo-style.cloud": "Cloud",
  "geo-style.diamond": "Diamond",
  "geo-style.ellipse": "Ellipse",
  "geo-style.heart": "Heart",
  "geo-style.hexagon": "Hexagon",
  "geo-style.octagon": "Octagon",
  "geo-style.oval": "Oval",
  "geo-style.pentagon": "Pentagon",
  "geo-style.rectangle": "Rectangle",
  "geo-style.rhombus": "Rhombus",
  "geo-style.star": "Star",
  "geo-style.trapezoid": "Trapezoid",
  "geo-style.triangle": "Triangle",
  "geo-style.x-box": "X box",
  "geo-style.check-box": "Check box",
  "arrowheadStart-style.none": "None",
  "arrowheadStart-style.arrow": "Arrow",
  "arrowheadStart-style.bar": "Bar",
  "arrowheadStart-style.diamond": "Diamond",
  "arrowheadStart-style.dot": "Dot",
  "arrowheadStart-style.inverted": "Inverted",
  "arrowheadStart-style.pipe": "Pipe",
  "arrowheadStart-style.square": "Square",
  "arrowheadStart-style.triangle": "Triangle",
  "arrowheadEnd-style.none": "None",
  "arrowheadEnd-style.arrow": "Arrow",
  "arrowheadEnd-style.bar": "Bar",
  "arrowheadEnd-style.diamond": "Diamond",
  "arrowheadEnd-style.dot": "Dot",
  "arrowheadEnd-style.inverted": "Inverted",
  "arrowheadEnd-style.pipe": "Pipe",
  "arrowheadEnd-style.square": "Square",
  "arrowheadEnd-style.triangle": "Triangle",
  "spline-style.line": "Line",
  "spline-style.cubic": "Cubic",
  "arrow-kind-style.arc": "Arc",
  "arrow-kind-style.elbow": "Elbow",
  "tool.select": "Select",
  "tool.hand": "Hand",
  "tool.draw": "Draw",
  "tool.eraser": "Eraser",
  "tool.arrow-down": "Arrow down",
  "tool.arrow-left": "Arrow left",
  "tool.arrow-right": "Arrow right",
  "tool.arrow-up": "Arrow up",
  "tool.arrow": "Arrow",
  "tool.cloud": "Cloud",
  "tool.diamond": "Diamond",
  "tool.ellipse": "Ellipse",
  "tool.heart": "Heart",
  "tool.hexagon": "Hexagon",
  "tool.highlight": "Highlight",
  "tool.line": "Line",
  "tool.octagon": "Octagon",
  "tool.oval": "Oval",
  "tool.pentagon": "Pentagon",
  "tool.rectangle": "Rectangle",
  "tool.rhombus": "Rhombus",
  "tool.star": "Star",
  "tool.trapezoid": "Trapezoid",
  "tool.triangle": "Triangle",
  "tool.x-box": "X box",
  "tool.check-box": "Check box",
  "tool.media": "Media",
  "tool.frame": "Frame",
  "tool.note": "Note",
  "tool.laser": "Laser",
  "tool.embed": "Embed",
  "tool.text": "Text",
  "tool.pointer-down": "Pointer down",
  "tool.rich-text-bold": "Bold",
  "tool.rich-text-italic": "Italic",
  "tool.rich-text-code": "Code",
  "tool.rich-text-highlight": "Highlight",
  "tool.rich-text-strikethrough": "Strikethrough",
  "tool.rich-text-link": "Link",
  "tool.rich-text-link-visit": "Visit link",
  "tool.rich-text-link-remove": "Remove link",
  "tool.rich-text-header": "Header",
  "tool.rich-text-bulletList": "Bulleted list",
  "tool.rich-text-toolbar-title": "Text formatting",
  "tool.rich-text-orderedList": "Ordered list",
  "tool.bookmark": "Bookmark",
  "a11y.status": "Status",
  "a11y.skip-to-main-content": "Move focus to canvas",
  "a11y.shape-index": "{num} of {total}",
  "a11y.shape-image": "Image",
  "a11y.shape-video": "Video",
  "a11y.multiple-shapes": "{num} shapes selected",
  "a11y.select-shape": "Select next shape",
  "a11y.select-shape-direction": "Select shape in direction",
  "a11y.enter-leave-container": "Enter/leave container",
  "a11y.repeat-shape": "Repeat shape",
  "a11y.move-shape": "Move shape",
  "a11y.move-shape-faster": "Move shape faster",
  "a11y.enlarge-shape": "Enlarge shape",
  "a11y.shrink-shape": "Shrink shape",
  "a11y.pan-camera": "Pan camera",
  "a11y.adjust-shape-styles": "Adjust shape styles",
  "menu.title": "Menu",
  "menu.theme": "Theme",
  "menu.copy-as": "Copy as",
  "menu.edit": "Edit",
  "menu.export-as": "Export as",
  "menu.file": "File",
  "menu.language": "Language",
  "menu.preferences": "Preferences",
  "menu.view": "View",
  "context-menu.title": "Context menu",
  "context-menu.edit": "Edit",
  "context-menu.arrange": "Arrange",
  "context-menu.copy-as": "Copy as",
  "context-menu.export-as": "Export as",
  "context-menu.export-all-as": "Export",
  "context-menu.move-to-page": "Move to page",
  "context-menu.reorder": "Reorder",
  "page-menu.title": "Pages",
  "page-menu.create-new-page": "Create new page",
  "page-menu.max-page-count-reached": "Max pages reached",
  "page-menu.new-page-initial-name": "Page 1",
  "page-menu.edit-start": "Edit",
  "page-menu.edit-done": "Done",
  "page-menu.go-to-page": "Go to page",
  "page-menu.submenu.rename": "Rename",
  "page-menu.submenu.duplicate-page": "Duplicate",
  "page-menu.submenu.title": "Menu",
  "page-menu.submenu.move-down": "Move down",
  "page-menu.submenu.move-up": "Move up",
  "page-menu.submenu.delete": "Delete",
  "share-menu.title": "Share",
  "share-menu.save-note": "Download this project to your computer as a .tldr file.",
  "share-menu.fork-note": "Create a new shared project based on this snapshot.",
  "share-menu.share-project": "Share this project",
  "share-menu.copy-link": "Copy editor link",
  "share-menu.create-snapshot-link": "Copy snapshot link",
  "share-menu.snapshot-link-note": "Capture and share this project as a read-only snapshot link.",
  "share-menu.copy-readonly-link": "Copy viewer link",
  "share-menu.offline-note": "Create a new shared project based on your current project.",
  "share-menu.copy-link-note": "Anyone with the link will be able to view and edit this project.",
  "share-menu.copy-readonly-link-note": "Anyone with the link will be able to access this project.",
  "share-menu.project-too-large": "Sorry, this project can’t be shared because it’s too large. We’re working on it!",
  "share-menu.upload-failed": "Sorry, we couldn’t upload your project at the moment. Please try again or let us know if the problem persists.",
  "share-menu.creating-project": "Creating the new project…",
  "share-menu.copied": "Copied link",
  "document-name-menu.copy-link": "Copy link",
  "status.offline": "Offline",
  "people-menu.title": "People",
  "people-menu.change-name": "Change name",
  "people-menu.avatar-color": "Avatar color",
  "people-menu.change-color": "Change color",
  "people-menu.follow": "Following",
  "people-menu.following": "Following",
  "people-menu.leading": "Following You",
  "people-menu.user": "(You)",
  "people-menu.invite": "Invite others",
  "people-menu.anonymous-user": "New user",
  "help-menu.import-tldr-file": "Import file…",
  "help-menu.title": "Help and resources",
  "help-menu.about": "About tldraw",
  "help-menu.discord": "Discord",
  "help-menu.github": "GitHub",
  "help-menu.keyboard-shortcuts": "Keyboard shortcuts",
  "help-menu.twitter": "Twitter",
  "help-menu.terms": "Terms of service",
  "help-menu.privacy": "Privacy policy",
  "actions-menu.title": "Actions",
  "edit-link-dialog.title": "Edit link",
  "edit-link-dialog.invalid-url": "A link must be a valid URL.",
  "edit-link-dialog.detail": "Links will open in a new tab.",
  "edit-link-dialog.url": "URL",
  "edit-link-dialog.clear": "Clear",
  "edit-link-dialog.save": "Continue",
  "edit-link-dialog.cancel": "Cancel",
  "edit-link-dialog.external-link": "External link",
  "embed-dialog.title": "Insert embed",
  "embed-dialog.back": "Back",
  "embed-dialog.create": "Create",
  "embed-dialog.cancel": "Cancel",
  "embed-dialog.url": "URL",
  "embed-dialog.instruction": "Paste in the site’s URL to create the embed.",
  "embed-dialog.invalid-url": "We could not create an embed from that URL.",
  "shortcuts-dialog.title": "Keyboard shortcuts",
  "shortcuts-dialog.edit": "Edit",
  "shortcuts-dialog.file": "File",
  "shortcuts-dialog.preferences": "Preferences",
  "shortcuts-dialog.tools": "Tools",
  "shortcuts-dialog.transform": "Transform",
  "shortcuts-dialog.view": "View",
  "shortcuts-dialog.collaboration": "Collaboration",
  "shortcuts-dialog.a11y": "Accessibility",
  "shortcuts-dialog.text-formatting": "Text formatting",
  "style-panel.title": "Styles",
  "style-panel.align": "Align",
  "style-panel.label-align": "Label align",
  "style-panel.vertical-align": "Vertical align",
  "style-panel.position": "Position",
  "style-panel.arrowheads": "Arrows",
  "style-panel.arrowhead-start": "Start",
  "style-panel.arrowhead-end": "End",
  "style-panel.arrow-kind": "Line",
  "style-panel.color": "Color",
  "style-panel.dash": "Dash",
  "style-panel.fill": "Fill",
  "style-panel.font": "Font",
  "style-panel.geo": "Shape",
  "style-panel.mixed": "Mixed",
  "style-panel.opacity": "Opacity",
  "style-panel.size": "Size",
  "style-panel.spline": "Spline",
  "tool-panel.title": "Tools",
  "tool-panel.more": "More",
  "navigation-zone.title": "Navigation",
  "navigation-zone.minimap": "Minimap",
  "navigation-zone.toggle-minimap": "Toggle minimap",
  "navigation-zone.zoom": "Zoom",
  "focus-mode.toggle-focus-mode": "Toggle focus mode",
  "toast.close": "Close",
  "toast.success": "Success",
  "toast.error": "Error",
  "toast.info": "Info",
  "toast.warning": "Warning",
  "file-system.file-open-error.title": "Could not open file",
  "file-system.file-open-error.not-a-tldraw-file": "The file you tried to open doesn’t look like a tldraw file.",
  "file-system.file-open-error.file-format-version-too-new": "The file you tried to open is from a newer version of tldraw. Please reload the page and try again.",
  "file-system.file-open-error.generic-corrupted-file": "The file you tried to open is corrupted.",
  "file-system.confirm-open.title": "Overwrite current project?",
  "file-system.confirm-open.description": "Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-open.cancel": "Cancel",
  "file-system.confirm-open.open": "Open file",
  "file-system.confirm-open.dont-show-again": "Don’t ask again",
  "file-system.confirm-clear.title": "Clear current project?",
  "file-system.confirm-clear.description": "Creating a new project will clear your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-clear.cancel": "Cancel",
  "file-system.confirm-clear.continue": "Continue",
  "file-system.confirm-clear.dont-show-again": "Don’t ask again",
  "file-system.shared-document-file-open-error.title": "Could not open file",
  "file-system.shared-document-file-open-error.description": "Opening files from shared projects is not supported.",
  "sharing.confirm-leave.title": "Leave current project?",
  "sharing.confirm-leave.description": "Are you sure you want to leave this shared project? You can return to it by navigating to its URL.",
  "sharing.confirm-leave.cancel": "Cancel",
  "sharing.confirm-leave.leave": "Leave",
  "sharing.confirm-leave.dont-show-again": "Don’t ask again",
  "toast.error.export-fail.title": "Failed export",
  "toast.error.export-fail.desc": "Failed to export image",
  "toast.error.copy-fail.title": "Failed copy",
  "toast.error.copy-fail.desc": "Failed to copy image",
  "context.pages.new-page": "New page",
  "vscode.file-open.desc": "We’ve updated this document to work with the current version of tldraw. If you’d like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
  "vscode.file-open.open": "Continue",
  "vscode.file-open.backup": "Backup",
  "vscode.file-open.backup-saved": "Backup saved",
  "vscode.file-open.backup-failed": "Backup failed: this is not a .tldr file.",
  "vscode.file-open.dont-show-again": "Don’t ask again",
  "cursor-chat.type-to-chat": "Type to chat…",
  "app.loading": "Loading tldraw…",
  "handle.resize-top": "Resize top",
  "handle.resize-bottom": "Resize bottom",
  "handle.resize-left": "Resize left",
  "handle.resize-right": "Resize right",
  "handle.resize-top-left": "Resize top left",
  "handle.resize-top-right": "Resize top right",
  "handle.resize-bottom-left": "Resize bottom left",
  "handle.resize-bottom-right": "Resize bottom right",
  "handle.rotate.top_left_rotate": "Rotate top left",
  "handle.rotate.top_right_rotate": "Rotate top right",
  "handle.rotate.bottom_left_rotate": "Rotate bottom left",
  "handle.rotate.bottom_right_rotate": "Rotate bottom right",
  "handle.rotate.mobile_rotate": "Rotate",
  "handle.crop.top": "Crop top",
  "handle.crop.bottom": "Crop bottom",
  "handle.crop.left": "Crop left",
  "handle.crop.right": "Crop right",
  "handle.crop.top-left": "Crop top left",
  "handle.crop.top-right": "Crop top right",
  "handle.crop.bottom-left": "Crop bottom left",
  "handle.crop.bottom-right": "Crop bottom right",
  "ui.close": "Close",
  "ui.checked": "Checked",
  "ui.unchecked": "Unchecked"
};

// node_modules/tldraw/dist-esm/lib/ui/hooks/useTranslation/translations.mjs
var RTL_LANGUAGES = /* @__PURE__ */ new Set(["ar", "fa", "he", "ur", "ku"]);
var EN_TRANSLATION = {
  locale: "en",
  label: "English",
  messages: DEFAULT_TRANSLATION,
  dir: "ltr"
};
async function fetchTranslation(locale, assetUrls) {
  const mainRes = await fetch(assetUrls.translations.en);
  if (!mainRes.ok) {
    console.warn(`No main translations found.`);
    return EN_TRANSLATION;
  }
  if (locale === "en") {
    return EN_TRANSLATION;
  }
  const language = LANGUAGES.find((t2) => t2.locale === locale);
  if (!language) {
    console.warn(`No translation found for locale ${locale}`);
    return EN_TRANSLATION;
  }
  const res = await fetch(assetUrls.translations[language.locale]);
  const messages = await res.json();
  if (!messages) {
    console.warn(`No messages found for locale ${locale}`);
    return EN_TRANSLATION;
  }
  const missing = [];
  for (const key in EN_TRANSLATION.messages) {
    if (!messages[key]) {
      missing.push(key);
    }
  }
  if (missing.length > 0 && true) {
    console.warn(`Language ${locale}: missing messages for keys:
${missing.join("\n")}`);
  }
  return {
    locale,
    label: language.label,
    dir: RTL_LANGUAGES.has(language.locale) ? "rtl" : "ltr",
    messages: { ...EN_TRANSLATION.messages, ...messages }
  };
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useTranslation/useTranslation.mjs
var TranslationsContext = React12.createContext(null);
function useCurrentTranslation() {
  const translations = React12.useContext(TranslationsContext);
  if (!translations) {
    throw new Error("useCurrentTranslation must be used inside of <TldrawUiContextProvider />");
  }
  return translations;
}
function TldrawUiTranslationProvider({
  overrides,
  locale,
  children
}) {
  const getAssetUrl = useAssetUrls();
  const [currentTranslation, setCurrentTranslation] = React12.useState(() => {
    if (overrides && overrides["en"]) {
      return {
        locale: "en",
        label: "English",
        dir: "ltr",
        messages: { ...DEFAULT_TRANSLATION, ...overrides["en"] }
      };
    }
    return {
      locale: "en",
      label: "English",
      dir: "ltr",
      messages: DEFAULT_TRANSLATION
    };
  });
  React12.useEffect(() => {
    let isCancelled = false;
    async function loadTranslation() {
      const translation = await fetchTranslation(locale, getAssetUrl);
      if (translation && !isCancelled) {
        if (overrides && overrides[locale]) {
          setCurrentTranslation({
            ...translation,
            messages: { ...translation.messages, ...overrides[locale] }
          });
        } else {
          setCurrentTranslation(translation);
        }
      }
    }
    loadTranslation();
    return () => {
      isCancelled = true;
    };
  }, [getAssetUrl, locale, overrides]);
  return (0, import_jsx_runtime40.jsx)(TranslationsContext.Provider, { value: currentTranslation, children });
}
function useTranslation() {
  const translation = useCurrentTranslation();
  return React12.useCallback(
    function msg2(id) {
      return translation.messages[id] ?? id;
    },
    [translation]
  );
}
function untranslated(string2) {
  return string2;
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/Button/TldrawUiButton.mjs
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_classnames13 = __toESM(require_classnames(), 1);
var React13 = __toESM(require_react(), 1);
var TldrawUiButton = React13.forwardRef(
  function TldrawUiButton2({ children, type, isActive: isActive2, ...props }, ref) {
    return (0, import_jsx_runtime41.jsx)(
      "button",
      {
        ref,
        type: "button",
        draggable: false,
        "data-isactive": isActive2,
        ...props,
        className: (0, import_classnames13.default)("tlui-button", `tlui-button__${type}`, props.className),
        children
      }
    );
  }
);

// node_modules/tldraw/dist-esm/lib/ui/components/A11y.mjs
function SkipToMainContent() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const button = (0, import_react54.useRef)(null);
  const handleNavigateToFirstShape = (0, import_react54.useCallback)(
    (e) => {
      var _a5;
      stopEventPropagation(e);
      (_a5 = button.current) == null ? void 0 : _a5.blur();
      const shapes = editor.getCurrentPageShapesInReadingOrder();
      if (!shapes.length)
        return;
      editor.setSelectedShapes([shapes[0].id]);
      editor.zoomToSelectionIfOffscreen(256, {
        animation: {
          duration: editor.options.animationMediumMs
        },
        inset: 0
      });
      editor.timers.setTimeout(() => editor.getContainer().focus(), 100);
    },
    [editor]
  );
  return (0, import_jsx_runtime42.jsx)(
    TldrawUiButton,
    {
      ref: button,
      type: "low",
      tabIndex: 0,
      className: "tl-skip-to-main-content",
      onClick: handleNavigateToFirstShape,
      children: msg2("a11y.skip-to-main-content")
    }
  );
}
var DefaultA11yAnnouncer = (0, import_react54.memo)(function TldrawUiA11yAnnouncer() {
  const a11y = useA11y();
  const translation = useTranslation();
  const msg2 = useValue("a11y-msg", () => a11y.currentMsg.get(), []);
  useA11yDebug(msg2.msg);
  useSelectedShapesAnnouncer();
  return msg2.msg && (0, import_jsx_runtime42.jsx)(
    "div",
    {
      "aria-label": translation("a11y.status"),
      "aria-live": msg2.priority || "assertive",
      role: "status",
      "aria-hidden": "false",
      style: {
        position: "absolute",
        top: "-10000px",
        left: "-10000px"
      },
      children: msg2.msg
    }
  );
});
function generateShapeAnnouncementMessage(args) {
  const { editor, selectedShapeIds, msg: msg2 } = args;
  let a11yLive = "";
  const numShapes = selectedShapeIds.length;
  if (numShapes > 1) {
    a11yLive = msg2("a11y.multiple-shapes").replace("{num}", numShapes.toString());
  } else if (numShapes === 1) {
    const shapeId = selectedShapeIds[0];
    const shape = editor.getShape(shapeId);
    if (!shape)
      return "";
    const shapeUtil = editor.getShapeUtil(shape.type);
    const isMedia = ["image", "video"].includes(shape.type);
    let shapeType = "";
    if (shape.type === "geo") {
      shapeType = msg2(`geo-style.${shape.props.geo}`);
    } else if (isMedia) {
      shapeType = msg2(`a11y.shape-${shape.type}`);
    } else {
      shapeType = msg2(`tool.${shape.type}`);
    }
    const readingOrderShapes = editor.getCurrentPageShapesInReadingOrder();
    const currentShapeIndex = (readingOrderShapes.findIndex((s) => s.id === shapeId) + 1).toString();
    const totalShapes = readingOrderShapes.length.toString();
    const shapeIndex = msg2("a11y.shape-index").replace("{num}", currentShapeIndex).replace("{total}", totalShapes);
    const describingText = shapeUtil.getAriaDescriptor(shape) || shapeUtil.getText(shape) || "";
    a11yLive = (describingText ? `${describingText}, ` : "") + `${shapeType}. ${shapeIndex}`;
  }
  return a11yLive;
}
var useSelectedShapesAnnouncer = () => {
  const editor = useMaybeEditor();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const rPrevSelectedShapeIds = (0, import_react54.useRef)([]);
  useReactor(
    "announce selection",
    () => {
      if (!editor)
        return;
      const isInSelecting = editor.isIn("select.idle");
      const selectedShapeIds = editor.getSelectedShapeIds();
      if (isInSelecting && selectedShapeIds !== rPrevSelectedShapeIds.current) {
        rPrevSelectedShapeIds.current = selectedShapeIds;
        unsafe__withoutCapture(() => {
          const a11yLive = generateShapeAnnouncementMessage({
            editor,
            selectedShapeIds,
            msg: msg2
          });
          if (a11yLive) {
            a11y.announce({ msg: a11yLive });
          }
        });
      }
    },
    [editor, a11y, msg2]
  );
};
var useA11yDebug = (msg2) => {
  const container = useContainer();
  (0, import_react54.useEffect)(() => {
    if (debugFlags.a11y.get()) {
      const log = (msg22) => {
        console.debug(
          `%ca11y%c: ${msg22}`,
          `color: white; background: #40C057; padding: 2px;border-radius: 3px;`,
          "font-weight: normal"
        );
      };
      const handleKeyUp = (e) => {
        const el = document.activeElement;
        if (e.key === "Tab" && el && el !== document.body && !el.classList.contains("tl-container")) {
          const label = el.getAttribute("aria-label") || el.getAttribute("title") || el.textContent;
          if (label) {
            log(label);
          }
        }
      };
      if (msg2) {
        log(msg2);
      }
      document.addEventListener("keyup", handleKeyUp);
      return () => document.removeEventListener("keyup", handleKeyUp);
    }
  }, [container, msg2]);
};

// node_modules/tldraw/dist-esm/lib/ui/components/ColorSchemeMenu.mjs
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/context/events.mjs
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var React14 = __toESM(require_react(), 1);
var defaultEventHandler = () => void 0;
var EventsContext = React14.createContext(null);
function TldrawUiEventsProvider({ onEvent, children }) {
  return (0, import_jsx_runtime43.jsx)(EventsContext.Provider, { value: onEvent ?? defaultEventHandler, children });
}
function useUiEvents() {
  const eventHandler2 = React14.useContext(EventsContext);
  return eventHandler2 ?? defaultEventHandler;
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuCheckboxItem.mjs
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-accessible-icon/dist/index.mjs
var React19 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var React18 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var React17 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React16 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React15 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React15.useCallback(composeRefs(...refs), refs);
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot22 = React16.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React16.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React16.Children.count(newElement) > 1)
            return React16.Children.only(null);
          return React16.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime44.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React16.isValidElement(newElement) ? React16.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime44.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React16.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React16.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React16.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React16.cloneElement(children, props2);
    }
    return React16.Children.count(children) > 1 ? React16.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable22 = ({ children }) => {
    return (0, import_jsx_runtime44.jsx)(import_jsx_runtime44.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable22;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React16.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a5, _b;
  let getter = (_a5 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a5.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot6 = createSlot(`Primitive.${node}`);
  const Node4 = React17.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot6 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime45.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node4.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node4 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target)
    ReactDOM.flushSync(() => target.dispatchEvent(event));
}
var Root = Primitive;

// node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME = "VisuallyHidden";
var VisuallyHidden = React18.forwardRef(
  (props, forwardedRef) => {
    return (0, import_jsx_runtime46.jsx)(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME;
var Root2 = VisuallyHidden;

// node_modules/@radix-ui/react-accessible-icon/dist/index.mjs
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var NAME2 = "AccessibleIcon";
var AccessibleIcon = ({ children, label }) => {
  const child = React19.Children.only(children);
  return (0, import_jsx_runtime47.jsxs)(import_jsx_runtime47.Fragment, { children: [
    React19.cloneElement(child, {
      // accessibility
      "aria-hidden": "true",
      focusable: "false"
      // See: https://allyjs.io/tutorials/focusing-in-svg.html#making-svg-elements-focusable
    }),
    (0, import_jsx_runtime47.jsx)(Root2, { children: label })
  ] });
};
AccessibleIcon.displayName = NAME2;

// node_modules/@radix-ui/react-accordion/dist/index.mjs
var import_react57 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-context/dist/index.mjs
var React20 = __toESM(require_react(), 1);
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
function createContext22(rootComponentName, defaultContext) {
  const Context2 = React20.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value = React20.useMemo(() => context, Object.values(context));
    return (0, import_jsx_runtime48.jsx)(Context2.Provider, { value, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React20.useContext(Context2);
    if (context)
      return context;
    if (defaultContext !== void 0)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React20.createContext(defaultContext);
    const index3 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      var _a5;
      const { scope, children, ...context } = props;
      const Context2 = ((_a5 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a5[index3]) || BaseContext;
      const value = React20.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime48.jsx)(Context2.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      var _a5;
      const Context2 = ((_a5 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a5[index3]) || BaseContext;
      const context = React20.useContext(Context2);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React20.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React20.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React20.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// node_modules/@radix-ui/react-collection/dist/index.mjs
var import_react55 = __toESM(require_react(), 1);
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react56 = __toESM(require_react(), 1);
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
function createCollection(name) {
  const PROVIDER_NAME3 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope10] = createContextScope(PROVIDER_NAME3);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME3,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = import_react55.default.useRef(null);
    const itemMap = import_react55.default.useRef(/* @__PURE__ */ new Map()).current;
    return (0, import_jsx_runtime49.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME3;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = import_react55.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return (0, import_jsx_runtime49.jsx)(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = import_react55.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = import_react55.default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      import_react55.default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return (0, import_jsx_runtime49.jsx)(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection10(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react55.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection10,
    createCollectionScope10
  ];
}
var __instanciated = /* @__PURE__ */ new WeakMap();
var _keys, _a3;
var OrderedDict = (_a3 = class extends Map {
  constructor(entries) {
    super(entries);
    __privateAdd(this, _keys, void 0);
    __privateSet(this, _keys, [...super.keys()]);
    __instanciated.set(this, true);
  }
  set(key, value) {
    if (__instanciated.get(this)) {
      if (this.has(key)) {
        __privateGet(this, _keys)[__privateGet(this, _keys).indexOf(key)] = key;
      } else {
        __privateGet(this, _keys).push(key);
      }
    }
    super.set(key, value);
    return this;
  }
  insert(index3, key, value) {
    const has = this.has(key);
    const length = __privateGet(this, _keys).length;
    const relativeIndex = toSafeInteger(index3);
    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
    if (safeIndex === this.size || has && safeIndex === this.size - 1 || safeIndex === -1) {
      this.set(key, value);
      return this;
    }
    const size4 = this.size + (has ? 0 : 1);
    if (relativeIndex < 0) {
      actualIndex++;
    }
    const keys2 = [...__privateGet(this, _keys)];
    let nextValue;
    let shouldSkip = false;
    for (let i = actualIndex; i < size4; i++) {
      if (actualIndex === i) {
        let nextKey = keys2[i];
        if (keys2[i] === key) {
          nextKey = keys2[i + 1];
        }
        if (has) {
          this.delete(key);
        }
        nextValue = this.get(nextKey);
        this.set(key, value);
      } else {
        if (!shouldSkip && keys2[i - 1] === key) {
          shouldSkip = true;
        }
        const currentKey = keys2[shouldSkip ? i : i - 1];
        const currentValue = nextValue;
        nextValue = this.get(currentKey);
        this.delete(currentKey);
        this.set(currentKey, currentValue);
      }
    }
    return this;
  }
  with(index3, key, value) {
    const copy2 = new _a3(this);
    copy2.insert(index3, key, value);
    return copy2;
  }
  before(key) {
    const index3 = __privateGet(this, _keys).indexOf(key) - 1;
    if (index3 < 0) {
      return void 0;
    }
    return this.entryAt(index3);
  }
  /**
   * Sets a new key-value pair at the position before the given key.
   */
  setBefore(key, newKey, value) {
    const index3 = __privateGet(this, _keys).indexOf(key);
    if (index3 === -1) {
      return this;
    }
    return this.insert(index3, newKey, value);
  }
  after(key) {
    let index3 = __privateGet(this, _keys).indexOf(key);
    index3 = index3 === -1 || index3 === this.size - 1 ? -1 : index3 + 1;
    if (index3 === -1) {
      return void 0;
    }
    return this.entryAt(index3);
  }
  /**
   * Sets a new key-value pair at the position after the given key.
   */
  setAfter(key, newKey, value) {
    const index3 = __privateGet(this, _keys).indexOf(key);
    if (index3 === -1) {
      return this;
    }
    return this.insert(index3 + 1, newKey, value);
  }
  first() {
    return this.entryAt(0);
  }
  last() {
    return this.entryAt(-1);
  }
  clear() {
    __privateSet(this, _keys, []);
    return super.clear();
  }
  delete(key) {
    const deleted = super.delete(key);
    if (deleted) {
      __privateGet(this, _keys).splice(__privateGet(this, _keys).indexOf(key), 1);
    }
    return deleted;
  }
  deleteAt(index3) {
    const key = this.keyAt(index3);
    if (key !== void 0) {
      return this.delete(key);
    }
    return false;
  }
  at(index3) {
    const key = at(__privateGet(this, _keys), index3);
    if (key !== void 0) {
      return this.get(key);
    }
  }
  entryAt(index3) {
    const key = at(__privateGet(this, _keys), index3);
    if (key !== void 0) {
      return [key, this.get(key)];
    }
  }
  indexOf(key) {
    return __privateGet(this, _keys).indexOf(key);
  }
  keyAt(index3) {
    return at(__privateGet(this, _keys), index3);
  }
  from(key, offset5) {
    const index3 = this.indexOf(key);
    if (index3 === -1) {
      return void 0;
    }
    let dest = index3 + offset5;
    if (dest < 0)
      dest = 0;
    if (dest >= this.size)
      dest = this.size - 1;
    return this.at(dest);
  }
  keyFrom(key, offset5) {
    const index3 = this.indexOf(key);
    if (index3 === -1) {
      return void 0;
    }
    let dest = index3 + offset5;
    if (dest < 0)
      dest = 0;
    if (dest >= this.size)
      dest = this.size - 1;
    return this.keyAt(dest);
  }
  find(predicate, thisArg) {
    let index3 = 0;
    for (const entry2 of this) {
      if (Reflect.apply(predicate, thisArg, [entry2, index3, this])) {
        return entry2;
      }
      index3++;
    }
    return void 0;
  }
  findIndex(predicate, thisArg) {
    let index3 = 0;
    for (const entry2 of this) {
      if (Reflect.apply(predicate, thisArg, [entry2, index3, this])) {
        return index3;
      }
      index3++;
    }
    return -1;
  }
  filter(predicate, thisArg) {
    const entries = [];
    let index3 = 0;
    for (const entry2 of this) {
      if (Reflect.apply(predicate, thisArg, [entry2, index3, this])) {
        entries.push(entry2);
      }
      index3++;
    }
    return new _a3(entries);
  }
  map(callbackfn, thisArg) {
    const entries = [];
    let index3 = 0;
    for (const entry2 of this) {
      entries.push([entry2[0], Reflect.apply(callbackfn, thisArg, [entry2, index3, this])]);
      index3++;
    }
    return new _a3(entries);
  }
  reduce(...args) {
    const [callbackfn, initialValue] = args;
    let index3 = 0;
    let accumulator = initialValue ?? this.at(0);
    for (const entry2 of this) {
      if (index3 === 0 && args.length === 1) {
        accumulator = entry2;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry2, index3, this]);
      }
      index3++;
    }
    return accumulator;
  }
  reduceRight(...args) {
    const [callbackfn, initialValue] = args;
    let accumulator = initialValue ?? this.at(-1);
    for (let index3 = this.size - 1; index3 >= 0; index3--) {
      const entry2 = this.at(index3);
      if (index3 === this.size - 1 && args.length === 1) {
        accumulator = entry2;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry2, index3, this]);
      }
    }
    return accumulator;
  }
  toSorted(compareFn) {
    const entries = [...this.entries()].sort(compareFn);
    return new _a3(entries);
  }
  toReversed() {
    const reversed = new _a3();
    for (let index3 = this.size - 1; index3 >= 0; index3--) {
      const key = this.keyAt(index3);
      const element = this.get(key);
      reversed.set(key, element);
    }
    return reversed;
  }
  toSpliced(...args) {
    const entries = [...this.entries()];
    entries.splice(...args);
    return new _a3(entries);
  }
  slice(start2, end2) {
    const result = new _a3();
    let stop = this.size - 1;
    if (start2 === void 0) {
      return result;
    }
    if (start2 < 0) {
      start2 = start2 + this.size;
    }
    if (end2 !== void 0 && end2 > 0) {
      stop = end2 - 1;
    }
    for (let index3 = start2; index3 <= stop; index3++) {
      const key = this.keyAt(index3);
      const element = this.get(key);
      result.set(key, element);
    }
    return result;
  }
  every(predicate, thisArg) {
    let index3 = 0;
    for (const entry2 of this) {
      if (!Reflect.apply(predicate, thisArg, [entry2, index3, this])) {
        return false;
      }
      index3++;
    }
    return true;
  }
  some(predicate, thisArg) {
    let index3 = 0;
    for (const entry2 of this) {
      if (Reflect.apply(predicate, thisArg, [entry2, index3, this])) {
        return true;
      }
      index3++;
    }
    return false;
  }
}, _keys = new WeakMap(), _a3);
function at(array2, index3) {
  if ("at" in Array.prototype) {
    return Array.prototype.at.call(array2, index3);
  }
  const actualIndex = toSafeIndex(array2, index3);
  return actualIndex === -1 ? void 0 : array2[actualIndex];
}
function toSafeIndex(array2, index3) {
  const length = array2.length;
  const relativeIndex = toSafeInteger(index3);
  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
}
function toSafeInteger(number2) {
  return number2 !== number2 || number2 === 0 ? 0 : Math.trunc(number2);
}
function createCollection2(name) {
  const PROVIDER_NAME3 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope10] = createContextScope(PROVIDER_NAME3);
  const [CollectionContextProvider, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME3,
    {
      collectionElement: null,
      collectionRef: { current: null },
      collectionRefObject: { current: null },
      itemMap: new OrderedDict(),
      setItemMap: () => void 0
    }
  );
  const CollectionProvider = ({ state, ...props }) => {
    return state ? (0, import_jsx_runtime50.jsx)(CollectionProviderImpl, { ...props, state }) : (0, import_jsx_runtime50.jsx)(CollectionInit, { ...props });
  };
  CollectionProvider.displayName = PROVIDER_NAME3;
  const CollectionInit = (props) => {
    const state = useInitCollection2();
    return (0, import_jsx_runtime50.jsx)(CollectionProviderImpl, { ...props, state });
  };
  CollectionInit.displayName = PROVIDER_NAME3 + "Init";
  const CollectionProviderImpl = (props) => {
    const { scope, children, state } = props;
    const ref = import_react56.default.useRef(null);
    const [collectionElement, setCollectionElement] = import_react56.default.useState(
      null
    );
    const composeRefs2 = useComposedRefs(ref, setCollectionElement);
    const [itemMap, setItemMap] = state;
    import_react56.default.useEffect(() => {
      if (!collectionElement)
        return;
      const observer = getChildListObserver(() => {
      });
      observer.observe(collectionElement, {
        childList: true,
        subtree: true
      });
      return () => {
        observer.disconnect();
      };
    }, [collectionElement]);
    return (0, import_jsx_runtime50.jsx)(
      CollectionContextProvider,
      {
        scope,
        itemMap,
        setItemMap,
        collectionRef: composeRefs2,
        collectionRefObject: ref,
        collectionElement,
        children
      }
    );
  };
  CollectionProviderImpl.displayName = PROVIDER_NAME3 + "Impl";
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = import_react56.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return (0, import_jsx_runtime50.jsx)(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = import_react56.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = import_react56.default.useRef(null);
      const [element, setElement] = import_react56.default.useState(null);
      const composedRefs = useComposedRefs(forwardedRef, ref, setElement);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      const { setItemMap } = context;
      const itemDataRef = import_react56.default.useRef(itemData);
      if (!shallowEqual(itemDataRef.current, itemData)) {
        itemDataRef.current = itemData;
      }
      const memoizedItemData = itemDataRef.current;
      import_react56.default.useEffect(() => {
        const itemData2 = memoizedItemData;
        setItemMap((map2) => {
          if (!element) {
            return map2;
          }
          if (!map2.has(element)) {
            map2.set(element, { ...itemData2, element });
            return map2.toSorted(sortByDocumentPosition);
          }
          return map2.set(element, { ...itemData2, element }).toSorted(sortByDocumentPosition);
        });
        return () => {
          setItemMap((map2) => {
            if (!element || !map2.has(element)) {
              return map2;
            }
            map2.delete(element);
            return new OrderedDict(map2);
          });
        };
      }, [element, memoizedItemData, setItemMap]);
      return (0, import_jsx_runtime50.jsx)(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useInitCollection2() {
    return import_react56.default.useState(new OrderedDict());
  }
  function useCollection10(scope) {
    const { itemMap } = useCollectionContext(name + "CollectionConsumer", scope);
    return itemMap;
  }
  const functions = {
    createCollectionScope: createCollectionScope10,
    useCollection: useCollection10,
    useInitCollection: useInitCollection2
  };
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    functions
  ];
}
function shallowEqual(a, b) {
  if (a === b)
    return true;
  if (typeof a !== "object" || typeof b !== "object")
    return false;
  if (a == null || b == null)
    return false;
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length)
    return false;
  for (const key of keysA) {
    if (!Object.prototype.hasOwnProperty.call(b, key))
      return false;
    if (a[key] !== b[key])
      return false;
  }
  return true;
}
function isElementPreceding(a, b) {
  return !!(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function sortByDocumentPosition(a, b) {
  return !a[1].element || !b[1].element ? 0 : isElementPreceding(a[1].element, b[1].element) ? -1 : 1;
}
function getChildListObserver(callback) {
  const observer = new MutationObserver((mutationsList) => {
    for (const mutation of mutationsList) {
      if (mutation.type === "childList") {
        callback();
        return;
      }
    }
  });
  return observer;
}

// node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React25 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React23 = __toESM(require_react(), 1);
var useLayoutEffect22 = (globalThis == null ? void 0 : globalThis.document) ? React23.useLayoutEffect : () => {
};

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React26 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-effect-event/dist/index.mjs
var React24 = __toESM(require_react(), 1);
var useReactEffectEvent = React24[" useEffectEvent ".trim().toString()];
var useReactInsertionEffect = React24[" useInsertionEffect ".trim().toString()];
function useEffectEvent(callback) {
  if (typeof useReactEffectEvent === "function") {
    return useReactEffectEvent(callback);
  }
  const ref = React24.useRef(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  if (typeof useReactInsertionEffect === "function") {
    useReactInsertionEffect(() => {
      ref.current = callback;
    });
  } else {
    useLayoutEffect22(() => {
      ref.current = callback;
    });
  }
  return React24.useMemo(() => (...args) => {
    var _a5;
    return (_a5 = ref.current) == null ? void 0 : _a5.call(ref, ...args);
  }, []);
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var useInsertionEffect = React25[" useInsertionEffect ".trim().toString()] || useLayoutEffect22;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React25.useRef(prop !== void 0);
    React25.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from2 = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from2} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React25.useCallback(
    (nextValue) => {
      var _a5;
      if (isControlled) {
        const value2 = isFunction2(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          (_a5 = onChangeRef.current) == null ? void 0 : _a5.call(onChangeRef, value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React25.useState(defaultProp);
  const prevValueRef = React25.useRef(value);
  const onChangeRef = React25.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React25.useEffect(() => {
    var _a5;
    if (prevValueRef.current !== value) {
      (_a5 = onChangeRef.current) == null ? void 0 : _a5.call(onChangeRef, value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction2(value) {
  return typeof value === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");

// node_modules/@radix-ui/react-collapsible/dist/index.mjs
var React30 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-presence/dist/index.mjs
var React27 = __toESM(require_react(), 1);
var React28 = __toESM(require_react(), 1);
function useStateMachine(initialState2, machine) {
  return React28.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence2(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React27.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React27.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence2(present) {
  const [node, setNode2] = React27.useState();
  const stylesRef = React27.useRef(null);
  const prevPresentRef = React27.useRef(present);
  const prevAnimationNameRef = React27.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React27.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React27.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode2(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef2(element) {
  var _a5, _b;
  let getter = (_a5 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a5.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-id/dist/index.mjs
var React29 = __toESM(require_react(), 1);
var useReactId = React29[" useId ".trim().toString()] || (() => void 0);
var count = 0;
function useId2(deterministicId) {
  const [id, setId] = React29.useState(useReactId());
  useLayoutEffect22(() => {
    if (!deterministicId)
      setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// node_modules/@radix-ui/react-collapsible/dist/index.mjs
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var COLLAPSIBLE_NAME = "Collapsible";
var [createCollapsibleContext, createCollapsibleScope] = createContextScope(COLLAPSIBLE_NAME);
var [CollapsibleProvider, useCollapsibleContext] = createCollapsibleContext(COLLAPSIBLE_NAME);
var Collapsible = React30.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCollapsible,
      open: openProp,
      defaultOpen,
      disabled,
      onOpenChange,
      ...collapsibleProps
    } = props;
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? false,
      onChange: onOpenChange,
      caller: COLLAPSIBLE_NAME
    });
    return (0, import_jsx_runtime51.jsx)(
      CollapsibleProvider,
      {
        scope: __scopeCollapsible,
        disabled,
        contentId: useId2(),
        open,
        onOpenToggle: React30.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        children: (0, import_jsx_runtime51.jsx)(
          Primitive.div,
          {
            "data-state": getState(open),
            "data-disabled": disabled ? "" : void 0,
            ...collapsibleProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Collapsible.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME = "CollapsibleTrigger";
var CollapsibleTrigger = React30.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCollapsible, ...triggerProps } = props;
    const context = useCollapsibleContext(TRIGGER_NAME, __scopeCollapsible);
    return (0, import_jsx_runtime51.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-controls": context.contentId,
        "aria-expanded": context.open || false,
        "data-state": getState(context.open),
        "data-disabled": context.disabled ? "" : void 0,
        disabled: context.disabled,
        ...triggerProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
CollapsibleTrigger.displayName = TRIGGER_NAME;
var CONTENT_NAME = "CollapsibleContent";
var CollapsibleContent = React30.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...contentProps } = props;
    const context = useCollapsibleContext(CONTENT_NAME, props.__scopeCollapsible);
    return (0, import_jsx_runtime51.jsx)(Presence, { present: forceMount || context.open, children: ({ present }) => (0, import_jsx_runtime51.jsx)(CollapsibleContentImpl, { ...contentProps, ref: forwardedRef, present }) });
  }
);
CollapsibleContent.displayName = CONTENT_NAME;
var CollapsibleContentImpl = React30.forwardRef((props, forwardedRef) => {
  const { __scopeCollapsible, present, children, ...contentProps } = props;
  const context = useCollapsibleContext(CONTENT_NAME, __scopeCollapsible);
  const [isPresent, setIsPresent] = React30.useState(present);
  const ref = React30.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const heightRef = React30.useRef(0);
  const height = heightRef.current;
  const widthRef = React30.useRef(0);
  const width = widthRef.current;
  const isOpen = context.open || isPresent;
  const isMountAnimationPreventedRef = React30.useRef(isOpen);
  const originalStylesRef = React30.useRef(void 0);
  React30.useEffect(() => {
    const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
    return () => cancelAnimationFrame(rAF);
  }, []);
  useLayoutEffect22(() => {
    const node = ref.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [context.open, present]);
  return (0, import_jsx_runtime51.jsx)(
    Primitive.div,
    {
      "data-state": getState(context.open),
      "data-disabled": context.disabled ? "" : void 0,
      id: context.contentId,
      hidden: !isOpen,
      ...contentProps,
      ref: composedRefs,
      style: {
        [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
        [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
        ...props.style
      },
      children: isOpen && children
    }
  );
});
function getState(open) {
  return open ? "open" : "closed";
}
var Root3 = Collapsible;
var Trigger = CollapsibleTrigger;
var Content = CollapsibleContent;

// node_modules/@radix-ui/react-direction/dist/index.mjs
var React31 = __toESM(require_react(), 1);
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var DirectionContext = React31.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React31.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}

// node_modules/@radix-ui/react-accordion/dist/index.mjs
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var ACCORDION_NAME = "Accordion";
var ACCORDION_KEYS = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"];
var [Collection, useCollection, createCollectionScope] = createCollection(ACCORDION_NAME);
var [createAccordionContext, createAccordionScope] = createContextScope(ACCORDION_NAME, [
  createCollectionScope,
  createCollapsibleScope
]);
var useCollapsibleScope = createCollapsibleScope();
var Accordion = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { type, ...accordionProps } = props;
    const singleProps = accordionProps;
    const multipleProps = accordionProps;
    return (0, import_jsx_runtime53.jsx)(Collection.Provider, { scope: props.__scopeAccordion, children: type === "multiple" ? (0, import_jsx_runtime53.jsx)(AccordionImplMultiple, { ...multipleProps, ref: forwardedRef }) : (0, import_jsx_runtime53.jsx)(AccordionImplSingle, { ...singleProps, ref: forwardedRef }) });
  }
);
Accordion.displayName = ACCORDION_NAME;
var [AccordionValueProvider, useAccordionValueContext] = createAccordionContext(ACCORDION_NAME);
var [AccordionCollapsibleProvider, useAccordionCollapsibleContext] = createAccordionContext(
  ACCORDION_NAME,
  { collapsible: false }
);
var AccordionImplSingle = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const {
      value: valueProp,
      defaultValue,
      onValueChange = () => {
      },
      collapsible = false,
      ...accordionSingleProps
    } = props;
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue ?? "",
      onChange: onValueChange,
      caller: ACCORDION_NAME
    });
    return (0, import_jsx_runtime53.jsx)(
      AccordionValueProvider,
      {
        scope: props.__scopeAccordion,
        value: import_react57.default.useMemo(() => value ? [value] : [], [value]),
        onItemOpen: setValue,
        onItemClose: import_react57.default.useCallback(() => collapsible && setValue(""), [collapsible, setValue]),
        children: (0, import_jsx_runtime53.jsx)(AccordionCollapsibleProvider, { scope: props.__scopeAccordion, collapsible, children: (0, import_jsx_runtime53.jsx)(AccordionImpl, { ...accordionSingleProps, ref: forwardedRef }) })
      }
    );
  }
);
var AccordionImplMultiple = import_react57.default.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...accordionMultipleProps
  } = props;
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? [],
    onChange: onValueChange,
    caller: ACCORDION_NAME
  });
  const handleItemOpen = import_react57.default.useCallback(
    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
    [setValue]
  );
  const handleItemClose = import_react57.default.useCallback(
    (itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)),
    [setValue]
  );
  return (0, import_jsx_runtime53.jsx)(
    AccordionValueProvider,
    {
      scope: props.__scopeAccordion,
      value,
      onItemOpen: handleItemOpen,
      onItemClose: handleItemClose,
      children: (0, import_jsx_runtime53.jsx)(AccordionCollapsibleProvider, { scope: props.__scopeAccordion, collapsible: true, children: (0, import_jsx_runtime53.jsx)(AccordionImpl, { ...accordionMultipleProps, ref: forwardedRef }) })
    }
  );
});
var [AccordionImplProvider, useAccordionContext] = createAccordionContext(ACCORDION_NAME);
var AccordionImpl = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, disabled, dir, orientation = "vertical", ...accordionProps } = props;
    const accordionRef = import_react57.default.useRef(null);
    const composedRefs = useComposedRefs(accordionRef, forwardedRef);
    const getItems = useCollection(__scopeAccordion);
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const handleKeyDown2 = composeEventHandlers(props.onKeyDown, (event) => {
      var _a5;
      if (!ACCORDION_KEYS.includes(event.key))
        return;
      const target = event.target;
      const triggerCollection = getItems().filter((item) => {
        var _a6;
        return !((_a6 = item.ref.current) == null ? void 0 : _a6.disabled);
      });
      const triggerIndex = triggerCollection.findIndex((item) => item.ref.current === target);
      const triggerCount = triggerCollection.length;
      if (triggerIndex === -1)
        return;
      event.preventDefault();
      let nextIndex = triggerIndex;
      const homeIndex = 0;
      const endIndex = triggerCount - 1;
      const moveNext = () => {
        nextIndex = triggerIndex + 1;
        if (nextIndex > endIndex) {
          nextIndex = homeIndex;
        }
      };
      const movePrev = () => {
        nextIndex = triggerIndex - 1;
        if (nextIndex < homeIndex) {
          nextIndex = endIndex;
        }
      };
      switch (event.key) {
        case "Home":
          nextIndex = homeIndex;
          break;
        case "End":
          nextIndex = endIndex;
          break;
        case "ArrowRight":
          if (orientation === "horizontal") {
            if (isDirectionLTR) {
              moveNext();
            } else {
              movePrev();
            }
          }
          break;
        case "ArrowDown":
          if (orientation === "vertical") {
            moveNext();
          }
          break;
        case "ArrowLeft":
          if (orientation === "horizontal") {
            if (isDirectionLTR) {
              movePrev();
            } else {
              moveNext();
            }
          }
          break;
        case "ArrowUp":
          if (orientation === "vertical") {
            movePrev();
          }
          break;
      }
      const clampedIndex = nextIndex % triggerCount;
      (_a5 = triggerCollection[clampedIndex].ref.current) == null ? void 0 : _a5.focus();
    });
    return (0, import_jsx_runtime53.jsx)(
      AccordionImplProvider,
      {
        scope: __scopeAccordion,
        disabled,
        direction: dir,
        orientation,
        children: (0, import_jsx_runtime53.jsx)(Collection.Slot, { scope: __scopeAccordion, children: (0, import_jsx_runtime53.jsx)(
          Primitive.div,
          {
            ...accordionProps,
            "data-orientation": orientation,
            ref: composedRefs,
            onKeyDown: disabled ? void 0 : handleKeyDown2
          }
        ) })
      }
    );
  }
);
var ITEM_NAME = "AccordionItem";
var [AccordionItemProvider, useAccordionItemContext] = createAccordionContext(ITEM_NAME);
var AccordionItem = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, value, ...accordionItemProps } = props;
    const accordionContext = useAccordionContext(ITEM_NAME, __scopeAccordion);
    const valueContext = useAccordionValueContext(ITEM_NAME, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    const triggerId = useId2();
    const open = value && valueContext.value.includes(value) || false;
    const disabled = accordionContext.disabled || props.disabled;
    return (0, import_jsx_runtime53.jsx)(
      AccordionItemProvider,
      {
        scope: __scopeAccordion,
        open,
        disabled,
        triggerId,
        children: (0, import_jsx_runtime53.jsx)(
          Root3,
          {
            "data-orientation": accordionContext.orientation,
            "data-state": getState2(open),
            ...collapsibleScope,
            ...accordionItemProps,
            ref: forwardedRef,
            disabled,
            open,
            onOpenChange: (open2) => {
              if (open2) {
                valueContext.onItemOpen(value);
              } else {
                valueContext.onItemClose(value);
              }
            }
          }
        )
      }
    );
  }
);
AccordionItem.displayName = ITEM_NAME;
var HEADER_NAME = "AccordionHeader";
var AccordionHeader = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, ...headerProps } = props;
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(HEADER_NAME, __scopeAccordion);
    return (0, import_jsx_runtime53.jsx)(
      Primitive.h3,
      {
        "data-orientation": accordionContext.orientation,
        "data-state": getState2(itemContext.open),
        "data-disabled": itemContext.disabled ? "" : void 0,
        ...headerProps,
        ref: forwardedRef
      }
    );
  }
);
AccordionHeader.displayName = HEADER_NAME;
var TRIGGER_NAME2 = "AccordionTrigger";
var AccordionTrigger = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, ...triggerProps } = props;
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(TRIGGER_NAME2, __scopeAccordion);
    const collapsibleContext = useAccordionCollapsibleContext(TRIGGER_NAME2, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    return (0, import_jsx_runtime53.jsx)(Collection.ItemSlot, { scope: __scopeAccordion, children: (0, import_jsx_runtime53.jsx)(
      Trigger,
      {
        "aria-disabled": itemContext.open && !collapsibleContext.collapsible || void 0,
        "data-orientation": accordionContext.orientation,
        id: itemContext.triggerId,
        ...collapsibleScope,
        ...triggerProps,
        ref: forwardedRef
      }
    ) });
  }
);
AccordionTrigger.displayName = TRIGGER_NAME2;
var CONTENT_NAME2 = "AccordionContent";
var AccordionContent = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, ...contentProps } = props;
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(CONTENT_NAME2, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    return (0, import_jsx_runtime53.jsx)(
      Content,
      {
        role: "region",
        "aria-labelledby": itemContext.triggerId,
        "data-orientation": accordionContext.orientation,
        ...collapsibleScope,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ["--radix-accordion-content-height"]: "var(--radix-collapsible-content-height)",
          ["--radix-accordion-content-width"]: "var(--radix-collapsible-content-width)",
          ...props.style
        }
      }
    );
  }
);
AccordionContent.displayName = CONTENT_NAME2;
function getState2(open) {
  return open ? "open" : "closed";
}

// node_modules/@radix-ui/react-alert-dialog/dist/index.mjs
var React49 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var dist_exports3 = {};
__export(dist_exports3, {
  Close: () => Close,
  Content: () => Content2,
  Description: () => Description,
  Dialog: () => Dialog,
  DialogClose: () => DialogClose,
  DialogContent: () => DialogContent,
  DialogDescription: () => DialogDescription,
  DialogOverlay: () => DialogOverlay,
  DialogPortal: () => DialogPortal,
  DialogTitle: () => DialogTitle,
  DialogTrigger: () => DialogTrigger,
  Overlay: () => Overlay,
  Portal: () => Portal2,
  Root: () => Root5,
  Title: () => Title,
  Trigger: () => Trigger2,
  WarningProvider: () => WarningProvider,
  createDialogScope: () => createDialogScope
});
var React48 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React35 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React33 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React33.useRef(callback);
  React33.useEffect(() => {
    callbackRef.current = callback;
  });
  return React33.useMemo(() => (...args) => {
    var _a5;
    return (_a5 = callbackRef.current) == null ? void 0 : _a5.call(callbackRef, ...args);
  }, []);
}

// node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React34 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React34.useEffect(() => {
    const handleKeyDown2 = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown2, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React35.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React35.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React35.useContext(DismissableLayerContext);
    const [node, setNode2] = React35.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React35.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode2(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index3 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index3 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch)
        return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch)
        return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index3 === context.layers.size - 1;
      if (!isHighestLayer)
        return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React35.useEffect(() => {
      if (!node)
        return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React35.useEffect(() => {
      return () => {
        if (!node)
          return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React35.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return (0, import_jsx_runtime54.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React35.forwardRef((props, forwardedRef) => {
  const context = React35.useContext(DismissableLayerContext);
  const ref = React35.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React35.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return (0, import_jsx_runtime54.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React35.useRef(false);
  const handleClickRef = React35.useRef(() => {
  });
  React35.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React35.useRef(false);
  React35.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var Root4 = DismissableLayer;
var Branch = DismissableLayerBranch;

// node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React36 = __toESM(require_react(), 1);
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React36.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React36.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React36.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React36.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React36.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus2(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget)) {
          focus2(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0)
            focus2(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React36.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus2(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus2(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown2 = React36.useCallback(
    (event) => {
      if (!loop && !trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first2, last3] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first2 && last3;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last3) {
            event.preventDefault();
            if (loop)
              focus2(first2, { select: true });
          } else if (event.shiftKey && focusedElement === first2) {
            event.preventDefault();
            if (loop)
              focus2(last3, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime55.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown2 });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus2(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first2 = findVisible(candidates, container);
  const last3 = findVisible(candidates.reverse(), container);
  return [first2, last3];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus2(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack2 = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack2[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack2 = arrayRemove(stack2, focusScope);
      stack2.unshift(focusScope);
    },
    remove(focusScope) {
      var _a5;
      stack2 = arrayRemove(stack2, focusScope);
      (_a5 = stack2[0]) == null ? void 0 : _a5.resume();
    }
  };
}
function arrayRemove(array2, item) {
  const updatedArray = [...array2];
  const index3 = updatedArray.indexOf(item);
  if (index3 !== -1) {
    updatedArray.splice(index3, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// node_modules/@radix-ui/react-portal/dist/index.mjs
var React37 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var PORTAL_NAME = "Portal";
var Portal = React37.forwardRef((props, forwardedRef) => {
  var _a5;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React37.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a5 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a5.body);
  return container ? import_react_dom3.default.createPortal((0, import_jsx_runtime56.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React38 = __toESM(require_react(), 1);
var count2 = 0;
function useFocusGuards() {
  React38.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React47 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
var React43 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react58 = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react58.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last3 = ref.value;
          if (last3 !== value) {
            ref.value = value;
            ref.callback(value, last3);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React39 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React39.useLayoutEffect : React39.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-sidecar/dist/es2015/hoc.js
var React40 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react59 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options2);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
var React41 = __toESM(require_react());
var import_react60 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
var React42 = __toESM(require_react());
var SideCar = function(_a5) {
  var sideCar = _a5.sideCar, rest = __rest(_a5, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React42.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React43.forwardRef(function(props, parentRef) {
  var ref = React43.useRef(null);
  var _a5 = React43.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a5[0], setCallbacks = _a5[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React43.createElement(
    React43.Fragment,
    null,
    enabled && React43.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React43.cloneElement(React43.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React43.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React46 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React45 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/hook.js
var React44 = __toESM(require_react());

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React44.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a5) {
    var styles = _a5.styles, dynamic = _a5.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left2 = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right2 = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left2), parse2(top2), parse2(right2)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a5, allowRelative, gapMode, important) {
  var left2 = _a5.left, top2 = _a5.top, right2 = _a5.right, gap = _a5.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left2, "px;\n    padding-top: ").concat(top2, "px;\n    padding-right: ").concat(right2, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React45.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a5) {
  var noRelative = _a5.noRelative, noImportant = _a5.noImportant, _b = _a5.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React45.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React45.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options2 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options2, options2);
    window.removeEventListener("test", options2, options2);
  } catch (err) {
    passiveSupported = false;
  }
}
var options2;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a5 = getScrollVariables(axis, current), scrollHeight = _a5[1], clientHeight = _a5[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a5) {
  var scrollTop = _a5.scrollTop, scrollHeight = _a5.scrollHeight, clientHeight = _a5.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a5) {
  var scrollLeft = _a5.scrollLeft, scrollWidth = _a5.scrollWidth, clientWidth = _a5.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a5 = getScrollVariables(axis, target), position = _a5[0], scroll_1 = _a5[1], capacity = _a5[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter2 = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React46.useRef([]);
  var touchStartRef = React46.useRef([0, 0]);
  var activeAxis = React46.useRef();
  var id = React46.useState(idCounter2++)[0];
  var Style2 = React46.useState(styleSingleton)[0];
  var lastProps = React46.useRef(props);
  React46.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React46.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React46.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React46.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React46.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React46.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React46.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React46.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React46.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst3) {
        return inst3 !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React46.createElement(
    React46.Fragment,
    null,
    inert ? React46.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React46.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React47.forwardRef(function(props, ref) {
  return React47.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode2, markerName, controlAttribute) {
  var targets = correctTargets(parentNode2, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode2);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode2, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode2 || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React48.useRef(null);
  const contentRef = React48.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return (0, import_jsx_runtime57.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId2(),
      titleId: useId2(),
      descriptionId: useId2(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React48.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME3 = "DialogTrigger";
var DialogTrigger = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME3, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return (0, import_jsx_runtime57.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState3(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME3;
var PORTAL_NAME2 = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME2, __scopeDialog);
  return (0, import_jsx_runtime57.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React48.Children.map(children, (child) => (0, import_jsx_runtime57.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime57.jsx)(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME2;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React48.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? (0, import_jsx_runtime57.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime57.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var Slot2 = createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      (0, import_jsx_runtime57.jsx)(Combination_default, { as: Slot2, allowPinchZoom: true, shards: [context.contentRef], children: (0, import_jsx_runtime57.jsx)(
        Primitive.div,
        {
          "data-state": getState3(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME3 = "DialogContent";
var DialogContent = React48.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    return (0, import_jsx_runtime57.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime57.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime57.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME3;
var DialogContentModal = React48.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const contentRef = React48.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React48.useEffect(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime57.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a5;
          event.preventDefault();
          (_a5 = context.triggerRef.current) == null ? void 0 : _a5.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick)
            event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React48.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const hasInteractedOutsideRef = React48.useRef(false);
    const hasPointerDownOutsideRef = React48.useRef(false);
    return (0, import_jsx_runtime57.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a5, _b;
          (_a5 = props.onCloseAutoFocus) == null ? void 0 : _a5.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current)
              (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a5, _b;
          (_a5 = props.onInteractOutside) == null ? void 0 : _a5.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger)
            event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, __scopeDialog);
    const contentRef = React48.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return (0, import_jsx_runtime57.jsxs)(import_jsx_runtime57.Fragment, { children: [
      (0, import_jsx_runtime57.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: (0, import_jsx_runtime57.jsx)(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState3(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      (0, import_jsx_runtime57.jsxs)(import_jsx_runtime57.Fragment, { children: [
        (0, import_jsx_runtime57.jsx)(TitleWarning, { titleId: context.titleId }),
        (0, import_jsx_runtime57.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return (0, import_jsx_runtime57.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return (0, import_jsx_runtime57.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return (0, import_jsx_runtime57.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState3(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME3,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React48.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle)
        console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React48.useEffect(() => {
    var _a5;
    const describedById = (_a5 = contentRef.current) == null ? void 0 : _a5.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root5 = Dialog;
var Trigger2 = DialogTrigger;
var Portal2 = DialogPortal;
var Overlay = DialogOverlay;
var Content2 = DialogContent;
var Title = DialogTitle;
var Description = DialogDescription;
var Close = DialogClose;

// node_modules/@radix-ui/react-alert-dialog/dist/index.mjs
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var ROOT_NAME = "AlertDialog";
var [createAlertDialogContext, createAlertDialogScope] = createContextScope(ROOT_NAME, [
  createDialogScope
]);
var useDialogScope = createDialogScope();
var AlertDialog = (props) => {
  const { __scopeAlertDialog, ...alertDialogProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return (0, import_jsx_runtime58.jsx)(Root5, { ...dialogScope, ...alertDialogProps, modal: true });
};
AlertDialog.displayName = ROOT_NAME;
var TRIGGER_NAME4 = "AlertDialogTrigger";
var AlertDialogTrigger = React49.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...triggerProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return (0, import_jsx_runtime58.jsx)(Trigger2, { ...dialogScope, ...triggerProps, ref: forwardedRef });
  }
);
AlertDialogTrigger.displayName = TRIGGER_NAME4;
var PORTAL_NAME3 = "AlertDialogPortal";
var AlertDialogPortal = (props) => {
  const { __scopeAlertDialog, ...portalProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return (0, import_jsx_runtime58.jsx)(Portal2, { ...dialogScope, ...portalProps });
};
AlertDialogPortal.displayName = PORTAL_NAME3;
var OVERLAY_NAME2 = "AlertDialogOverlay";
var AlertDialogOverlay = React49.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...overlayProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return (0, import_jsx_runtime58.jsx)(Overlay, { ...dialogScope, ...overlayProps, ref: forwardedRef });
  }
);
AlertDialogOverlay.displayName = OVERLAY_NAME2;
var CONTENT_NAME4 = "AlertDialogContent";
var [AlertDialogContentProvider, useAlertDialogContentContext] = createAlertDialogContext(CONTENT_NAME4);
var Slottable2 = createSlottable("AlertDialogContent");
var AlertDialogContent = React49.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, children, ...contentProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const contentRef = React49.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const cancelRef = React49.useRef(null);
    return (0, import_jsx_runtime58.jsx)(
      WarningProvider,
      {
        contentName: CONTENT_NAME4,
        titleName: TITLE_NAME2,
        docsSlug: "alert-dialog",
        children: (0, import_jsx_runtime58.jsx)(AlertDialogContentProvider, { scope: __scopeAlertDialog, cancelRef, children: (0, import_jsx_runtime58.jsxs)(
          Content2,
          {
            role: "alertdialog",
            ...dialogScope,
            ...contentProps,
            ref: composedRefs,
            onOpenAutoFocus: composeEventHandlers(contentProps.onOpenAutoFocus, (event) => {
              var _a5;
              event.preventDefault();
              (_a5 = cancelRef.current) == null ? void 0 : _a5.focus({ preventScroll: true });
            }),
            onPointerDownOutside: (event) => event.preventDefault(),
            onInteractOutside: (event) => event.preventDefault(),
            children: [
              (0, import_jsx_runtime58.jsx)(Slottable2, { children }),
              (0, import_jsx_runtime58.jsx)(DescriptionWarning2, { contentRef })
            ]
          }
        ) })
      }
    );
  }
);
AlertDialogContent.displayName = CONTENT_NAME4;
var TITLE_NAME2 = "AlertDialogTitle";
var AlertDialogTitle = React49.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...titleProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return (0, import_jsx_runtime58.jsx)(Title, { ...dialogScope, ...titleProps, ref: forwardedRef });
  }
);
AlertDialogTitle.displayName = TITLE_NAME2;
var DESCRIPTION_NAME2 = "AlertDialogDescription";
var AlertDialogDescription = React49.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...descriptionProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return (0, import_jsx_runtime58.jsx)(Description, { ...dialogScope, ...descriptionProps, ref: forwardedRef });
});
AlertDialogDescription.displayName = DESCRIPTION_NAME2;
var ACTION_NAME = "AlertDialogAction";
var AlertDialogAction = React49.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...actionProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return (0, import_jsx_runtime58.jsx)(Close, { ...dialogScope, ...actionProps, ref: forwardedRef });
  }
);
AlertDialogAction.displayName = ACTION_NAME;
var CANCEL_NAME = "AlertDialogCancel";
var AlertDialogCancel = React49.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...cancelProps } = props;
    const { cancelRef } = useAlertDialogContentContext(CANCEL_NAME, __scopeAlertDialog);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const ref = useComposedRefs(forwardedRef, cancelRef);
    return (0, import_jsx_runtime58.jsx)(Close, { ...dialogScope, ...cancelProps, ref });
  }
);
AlertDialogCancel.displayName = CANCEL_NAME;
var DescriptionWarning2 = ({ contentRef }) => {
  const MESSAGE = `\`${CONTENT_NAME4}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${CONTENT_NAME4}\` by passing a \`${DESCRIPTION_NAME2}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${CONTENT_NAME4}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
  React49.useEffect(() => {
    var _a5;
    const hasDescription = document.getElementById(
      (_a5 = contentRef.current) == null ? void 0 : _a5.getAttribute("aria-describedby")
    );
    if (!hasDescription)
      console.warn(MESSAGE);
  }, [MESSAGE, contentRef]);
  return null;
};

// node_modules/@radix-ui/react-aspect-ratio/dist/index.mjs
var React50 = __toESM(require_react(), 1);
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var NAME3 = "AspectRatio";
var AspectRatio = React50.forwardRef(
  (props, forwardedRef) => {
    const { ratio = 1 / 1, style: style2, ...aspectRatioProps } = props;
    return (0, import_jsx_runtime59.jsx)(
      "div",
      {
        style: {
          // ensures inner element is contained
          position: "relative",
          // ensures padding bottom trick maths works
          width: "100%",
          paddingBottom: `${100 / ratio}%`
        },
        "data-radix-aspect-ratio-wrapper": "",
        children: (0, import_jsx_runtime59.jsx)(
          Primitive.div,
          {
            ...aspectRatioProps,
            ref: forwardedRef,
            style: {
              ...style2,
              // ensures children expand in ratio
              position: "absolute",
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            }
          }
        )
      }
    );
  }
);
AspectRatio.displayName = NAME3;

// node_modules/@radix-ui/react-avatar/dist/index.mjs
var React51 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-is-hydrated/dist/index.mjs
var import_shim = __toESM(require_shim(), 1);
function useIsHydrated() {
  return (0, import_shim.useSyncExternalStore)(
    subscribe,
    () => true,
    () => false
  );
}
function subscribe() {
  return () => {
  };
}

// node_modules/@radix-ui/react-avatar/dist/index.mjs
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var AVATAR_NAME = "Avatar";
var [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME);
var [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);
var Avatar = React51.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, ...avatarProps } = props;
    const [imageLoadingStatus, setImageLoadingStatus] = React51.useState("idle");
    return (0, import_jsx_runtime60.jsx)(
      AvatarProvider,
      {
        scope: __scopeAvatar,
        imageLoadingStatus,
        onImageLoadingStatusChange: setImageLoadingStatus,
        children: (0, import_jsx_runtime60.jsx)(Primitive.span, { ...avatarProps, ref: forwardedRef })
      }
    );
  }
);
Avatar.displayName = AVATAR_NAME;
var IMAGE_NAME = "AvatarImage";
var AvatarImage = React51.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, src, onLoadingStatusChange = () => {
    }, ...imageProps } = props;
    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);
    const imageLoadingStatus = useImageLoadingStatus(src, imageProps);
    const handleLoadingStatusChange = useCallbackRef((status) => {
      onLoadingStatusChange(status);
      context.onImageLoadingStatusChange(status);
    });
    useLayoutEffect22(() => {
      if (imageLoadingStatus !== "idle") {
        handleLoadingStatusChange(imageLoadingStatus);
      }
    }, [imageLoadingStatus, handleLoadingStatusChange]);
    return imageLoadingStatus === "loaded" ? (0, import_jsx_runtime60.jsx)(Primitive.img, { ...imageProps, ref: forwardedRef, src }) : null;
  }
);
AvatarImage.displayName = IMAGE_NAME;
var FALLBACK_NAME = "AvatarFallback";
var AvatarFallback = React51.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, delayMs, ...fallbackProps } = props;
    const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);
    const [canRender, setCanRender] = React51.useState(delayMs === void 0);
    React51.useEffect(() => {
      if (delayMs !== void 0) {
        const timerId = window.setTimeout(() => setCanRender(true), delayMs);
        return () => window.clearTimeout(timerId);
      }
    }, [delayMs]);
    return canRender && context.imageLoadingStatus !== "loaded" ? (0, import_jsx_runtime60.jsx)(Primitive.span, { ...fallbackProps, ref: forwardedRef }) : null;
  }
);
AvatarFallback.displayName = FALLBACK_NAME;
function resolveLoadingStatus(image, src) {
  if (!image) {
    return "idle";
  }
  if (!src) {
    return "error";
  }
  if (image.src !== src) {
    image.src = src;
  }
  return image.complete && image.naturalWidth > 0 ? "loaded" : "loading";
}
function useImageLoadingStatus(src, { referrerPolicy, crossOrigin }) {
  const isHydrated = useIsHydrated();
  const imageRef = React51.useRef(null);
  const image = (() => {
    if (!isHydrated)
      return null;
    if (!imageRef.current) {
      imageRef.current = new window.Image();
    }
    return imageRef.current;
  })();
  const [loadingStatus, setLoadingStatus] = React51.useState(
    () => resolveLoadingStatus(image, src)
  );
  useLayoutEffect22(() => {
    setLoadingStatus(resolveLoadingStatus(image, src));
  }, [image, src]);
  useLayoutEffect22(() => {
    const updateStatus = (status) => () => {
      setLoadingStatus(status);
    };
    if (!image)
      return;
    const handleLoad = updateStatus("loaded");
    const handleError = updateStatus("error");
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (referrerPolicy) {
      image.referrerPolicy = referrerPolicy;
    }
    if (typeof crossOrigin === "string") {
      image.crossOrigin = crossOrigin;
    }
    return () => {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    };
  }, [image, crossOrigin, referrerPolicy]);
  return loadingStatus;
}

// node_modules/@radix-ui/react-checkbox/dist/index.mjs
var React54 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-previous/dist/index.mjs
var React52 = __toESM(require_react(), 1);
function usePrevious(value) {
  const ref = React52.useRef({ value, previous: value });
  return React52.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}

// node_modules/@radix-ui/react-use-size/dist/index.mjs
var React53 = __toESM(require_react(), 1);
function useSize(element) {
  const [size4, setSize] = React53.useState(void 0);
  useLayoutEffect22(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry2 = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry2) {
          const borderSizeEntry = entry2["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}

// node_modules/@radix-ui/react-checkbox/dist/index.mjs
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
var [CheckboxProviderImpl, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
function CheckboxProvider(props) {
  const {
    __scopeCheckbox,
    checked: checkedProp,
    children,
    defaultChecked,
    disabled,
    form,
    name,
    onCheckedChange,
    required,
    value = "on",
    // @ts-expect-error
    internal_do_not_use_render
  } = props;
  const [checked, setChecked] = useControllableState({
    prop: checkedProp,
    defaultProp: defaultChecked ?? false,
    onChange: onCheckedChange,
    caller: CHECKBOX_NAME
  });
  const [control, setControl] = React54.useState(null);
  const [bubbleInput, setBubbleInput] = React54.useState(null);
  const hasConsumerStoppedPropagationRef = React54.useRef(false);
  const isFormControl2 = control ? !!form || !!control.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    true
  );
  const context = {
    checked,
    disabled,
    setChecked,
    control,
    setControl,
    name,
    form,
    value,
    hasConsumerStoppedPropagationRef,
    required,
    defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked,
    isFormControl: isFormControl2,
    bubbleInput,
    setBubbleInput
  };
  return (0, import_jsx_runtime61.jsx)(
    CheckboxProviderImpl,
    {
      scope: __scopeCheckbox,
      ...context,
      children: isFunction3(internal_do_not_use_render) ? internal_do_not_use_render(context) : children
    }
  );
}
var TRIGGER_NAME5 = "CheckboxTrigger";
var CheckboxTrigger = React54.forwardRef(
  ({ __scopeCheckbox, onKeyDown, onClick, ...checkboxProps }, forwardedRef) => {
    const {
      control,
      value,
      disabled,
      checked,
      required,
      setControl,
      setChecked,
      hasConsumerStoppedPropagationRef,
      isFormControl: isFormControl2,
      bubbleInput
    } = useCheckboxContext(TRIGGER_NAME5, __scopeCheckbox);
    const composedRefs = useComposedRefs(forwardedRef, setControl);
    const initialCheckedStateRef = React54.useRef(checked);
    React54.useEffect(() => {
      const form = control == null ? void 0 : control.form;
      if (form) {
        const reset2 = () => setChecked(initialCheckedStateRef.current);
        form.addEventListener("reset", reset2);
        return () => form.removeEventListener("reset", reset2);
      }
    }, [control, setChecked]);
    return (0, import_jsx_runtime61.jsx)(
      Primitive.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        "aria-required": required,
        "data-state": getState4(checked),
        "data-disabled": disabled ? "" : void 0,
        disabled,
        value,
        ...checkboxProps,
        ref: composedRefs,
        onKeyDown: composeEventHandlers(onKeyDown, (event) => {
          if (event.key === "Enter")
            event.preventDefault();
        }),
        onClick: composeEventHandlers(onClick, (event) => {
          setChecked((prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked);
          if (bubbleInput && isFormControl2) {
            hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
            if (!hasConsumerStoppedPropagationRef.current)
              event.stopPropagation();
          }
        })
      }
    );
  }
);
CheckboxTrigger.displayName = TRIGGER_NAME5;
var Checkbox = React54.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCheckbox,
      name,
      checked,
      defaultChecked,
      required,
      disabled,
      value,
      onCheckedChange,
      form,
      ...checkboxProps
    } = props;
    return (0, import_jsx_runtime61.jsx)(
      CheckboxProvider,
      {
        __scopeCheckbox,
        checked,
        defaultChecked,
        disabled,
        required,
        onCheckedChange,
        name,
        form,
        value,
        internal_do_not_use_render: ({ isFormControl: isFormControl2 }) => (0, import_jsx_runtime61.jsxs)(import_jsx_runtime61.Fragment, { children: [
          (0, import_jsx_runtime61.jsx)(
            CheckboxTrigger,
            {
              ...checkboxProps,
              ref: forwardedRef,
              __scopeCheckbox
            }
          ),
          isFormControl2 && (0, import_jsx_runtime61.jsx)(
            CheckboxBubbleInput,
            {
              __scopeCheckbox
            }
          )
        ] })
      }
    );
  }
);
Checkbox.displayName = CHECKBOX_NAME;
var INDICATOR_NAME = "CheckboxIndicator";
var CheckboxIndicator = React54.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);
    return (0, import_jsx_runtime61.jsx)(
      Presence,
      {
        present: forceMount || isIndeterminate(context.checked) || context.checked === true,
        children: (0, import_jsx_runtime61.jsx)(
          Primitive.span,
          {
            "data-state": getState4(context.checked),
            "data-disabled": context.disabled ? "" : void 0,
            ...indicatorProps,
            ref: forwardedRef,
            style: { pointerEvents: "none", ...props.style }
          }
        )
      }
    );
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME;
var BUBBLE_INPUT_NAME = "CheckboxBubbleInput";
var CheckboxBubbleInput = React54.forwardRef(
  ({ __scopeCheckbox, ...props }, forwardedRef) => {
    const {
      control,
      hasConsumerStoppedPropagationRef,
      checked,
      defaultChecked,
      required,
      disabled,
      name,
      value,
      form,
      bubbleInput,
      setBubbleInput
    } = useCheckboxContext(BUBBLE_INPUT_NAME, __scopeCheckbox);
    const composedRefs = useComposedRefs(forwardedRef, setBubbleInput);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    React54.useEffect(() => {
      const input = bubbleInput;
      if (!input)
        return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      const bubbles = !hasConsumerStoppedPropagationRef.current;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        input.indeterminate = isIndeterminate(checked);
        setChecked.call(input, isIndeterminate(checked) ? false : checked);
        input.dispatchEvent(event);
      }
    }, [bubbleInput, prevChecked, checked, hasConsumerStoppedPropagationRef]);
    const defaultCheckedRef = React54.useRef(isIndeterminate(checked) ? false : checked);
    return (0, import_jsx_runtime61.jsx)(
      Primitive.input,
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: defaultChecked ?? defaultCheckedRef.current,
        required,
        disabled,
        name,
        value,
        form,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
CheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME;
function isFunction3(value) {
  return typeof value === "function";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getState4(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}

// node_modules/@radix-ui/react-context-menu/dist/index.mjs
var dist_exports7 = {};
__export(dist_exports7, {
  Arrow: () => Arrow23,
  CheckboxItem: () => CheckboxItem2,
  Content: () => Content23,
  ContextMenu: () => ContextMenu,
  ContextMenuArrow: () => ContextMenuArrow,
  ContextMenuCheckboxItem: () => ContextMenuCheckboxItem,
  ContextMenuContent: () => ContextMenuContent,
  ContextMenuGroup: () => ContextMenuGroup,
  ContextMenuItem: () => ContextMenuItem,
  ContextMenuItemIndicator: () => ContextMenuItemIndicator,
  ContextMenuLabel: () => ContextMenuLabel,
  ContextMenuPortal: () => ContextMenuPortal,
  ContextMenuRadioGroup: () => ContextMenuRadioGroup,
  ContextMenuRadioItem: () => ContextMenuRadioItem,
  ContextMenuSeparator: () => ContextMenuSeparator,
  ContextMenuSub: () => ContextMenuSub,
  ContextMenuSubContent: () => ContextMenuSubContent,
  ContextMenuSubTrigger: () => ContextMenuSubTrigger,
  ContextMenuTrigger: () => ContextMenuTrigger,
  Group: () => Group2,
  Item: () => Item22,
  ItemIndicator: () => ItemIndicator2,
  Label: () => Label2,
  Portal: () => Portal22,
  RadioGroup: () => RadioGroup2,
  RadioItem: () => RadioItem2,
  Root: () => Root23,
  Separator: () => Separator2,
  Sub: () => Sub2,
  SubContent: () => SubContent2,
  SubTrigger: () => SubTrigger2,
  Trigger: () => Trigger3,
  createContextMenuScope: () => createContextMenuScope
});
var React60 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-menu/dist/index.mjs
var React59 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-popper/dist/index.mjs
var React57 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round2 = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp3(start2, value, end2) {
  return max(start2, min(value, end2));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide2(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide2(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide2(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference: reference2,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide2(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
  const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
  const commonAlign = reference2[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference2.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case "right":
      coords = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference2.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference2.x,
        y: reference2.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference2, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference: reference2,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn2({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference: reference2,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference: reference2,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options2) {
  var _await$platform$isEle;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options2, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options2) => ({
  name: "arrow",
  options: options2,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options2, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max3 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset5 = clamp3(min$1, center, max3);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset5 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset5,
        centerOffset: center - offset5 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "flip",
    options: options2,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options2, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide2(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide2(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements3 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements3[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "hide",
    options: options2,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options2, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options2) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide2(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options2, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options2) {
  if (options2 === void 0) {
    options2 = 0;
  }
  return {
    name: "offset",
    options: options2,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options2);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift2 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "shift",
    options: options2,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options2, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide2(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min4 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp3(min4, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min4 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp3(min4, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    options: options2,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset5 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options2, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset5, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide2(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "size",
    options: options2,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options2, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide2(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle3(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit2 = isWebKit();
  const css = isElement2(elementOrCss) ? getComputedStyle3(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit2 && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit2 && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle3(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot2(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode2 = getParentNode(node);
  if (isLastTraversableNode(parentNode2)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode2) && isOverflowElement(parentNode2)) {
    return parentNode2;
  }
  return getNearestOverflowAncestor(parentNode2);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle3(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round2(rect.width) : rect.width) / width;
  let y = ($ ? round2(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow2(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect2 = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect2.left + visualOffsets.x) / scale.x;
  let y = (clientRect2.top + visualOffsets.y) / scale.y;
  let width = clientRect2.width / scale.x;
  let height = clientRect2.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle3(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left2;
      y += top2;
      currentWin = getWindow2(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle3(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect2 = getBoundingClientRect(element, true, strategy === "fixed");
  const top2 = clientRect2.top + element.clientTop;
  const left2 = clientRect2.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left2 * scale.x;
  const y = top2 * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode2 = getParentNode(element);
  if (parentNode2 === stopNode || !isElement2(parentNode2) || isLastTraversableNode(parentNode2)) {
    return false;
  }
  return getComputedStyle3(parentNode2).position === "fixed" || hasFixedPositionAncestor(parentNode2, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult2 = cache.get(element);
  if (cachedResult2) {
    return cachedResult2;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement2(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle3(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle3(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle3(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle3(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow2(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle3(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement2,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left: left2,
      top: top2,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top2);
    const insetRight = floor(root.clientWidth - (left2 + width));
    const insetBottom = floor(root.clientHeight - (top2 + height));
    const insetLeft = floor(left2);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference2, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference2);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference2) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference2);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift3 = shift2;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference2, floating, options2) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options2
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference2, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React55 = __toESM(require_react(), 1);
var import_react61 = __toESM(require_react(), 1);
var ReactDOM3 = __toESM(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop3 = function noop4() {
};
var index2 = isClient ? import_react61.useLayoutEffect : noop3;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys2;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a);
    length = keys2.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys2[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys2[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React55.useRef(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options2;
  const [data, setData] = React55.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React55.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React55.useState(null);
  const [_floating, _setFloating] = React55.useState(null);
  const setReference = React55.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React55.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React55.useRef(null);
  const floatingRef = React55.useRef(null);
  const dataRef = React55.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React55.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM3.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index2(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React55.useRef(false);
  index2(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index2(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React55.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React55.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React55.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React55.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options2) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options: options2,
    fn(state) {
      const {
        element,
        padding
      } = typeof options2 === "function" ? options2(state) : options2;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options2, deps) => ({
  ...offset2(options2),
  options: [options2, deps]
});
var shift4 = (options2, deps) => ({
  ...shift3(options2),
  options: [options2, deps]
});
var limitShift3 = (options2, deps) => ({
  ...limitShift2(options2),
  options: [options2, deps]
});
var flip3 = (options2, deps) => ({
  ...flip2(options2),
  options: [options2, deps]
});
var size3 = (options2, deps) => ({
  ...size2(options2),
  options: [options2, deps]
});
var hide3 = (options2, deps) => ({
  ...hide2(options2),
  options: [options2, deps]
});
var arrow3 = (options2, deps) => ({
  ...arrow$1(options2),
  options: [options2, deps]
});

// node_modules/@radix-ui/react-arrow/dist/index.mjs
var React56 = __toESM(require_react(), 1);
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var NAME4 = "Arrow";
var Arrow = React56.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return (0, import_jsx_runtime62.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : (0, import_jsx_runtime62.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME4;
var Root6 = Arrow;

// node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React57.useState(null);
  return (0, import_jsx_runtime63.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React57.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React57.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React57.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : (0, import_jsx_runtime63.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME5 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME5);
var PopperContent = React57.forwardRef(
  (props, forwardedRef) => {
    var _a5, _b, _c, _d, _e, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME5, __scopePopper);
    const [content, setContent3] = React57.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent3(node));
    const [arrow6, setArrow] = React57.useState(null);
    const arrowSize = useSize(arrow6);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift4({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow6 && arrow3({ element: arrow6, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect22(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a5 = middlewareData.arrow) == null ? void 0 : _a5.x;
    const arrowY = (_b = middlewareData.arrow) == null ? void 0 : _b.y;
    const cannotCenterArrow = ((_c = middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React57.useState();
    useLayoutEffect22(() => {
      if (content)
        setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return (0, import_jsx_runtime63.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e = middlewareData.transformOrigin) == null ? void 0 : _e.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: (0, import_jsx_runtime63.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: (0, import_jsx_runtime63.jsx)(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME5;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React57.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    (0, import_jsx_runtime63.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: (0, import_jsx_runtime63.jsx)(
          Root6,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options2) => ({
  name: "transformOrigin",
  options: options2,
  fn(data) {
    var _a5, _b, _c;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a5 = middlewareData.arrow) == null ? void 0 : _a5.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options2.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options2.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root22 = Popper;
var Anchor = PopperAnchor;
var Content3 = PopperContent;
var Arrow2 = PopperArrow;

// node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var React58 = __toESM(require_react(), 1);
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var GROUP_NAME = "RovingFocusGroup";
var [Collection2, useCollection2, createCollectionScope2] = createCollection(GROUP_NAME);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME,
  [createCollectionScope2]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
var RovingFocusGroup = React58.forwardRef(
  (props, forwardedRef) => {
    return (0, import_jsx_runtime64.jsx)(Collection2.Provider, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime64.jsx)(Collection2.Slot, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime64.jsx)(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME;
var RovingFocusGroupImpl = React58.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React58.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React58.useState(false);
  const handleEntryFocus = useCallbackRef(onEntryFocus);
  const getItems = useCollection2(__scopeRovingFocusGroup);
  const isClickFocusRef = React58.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React58.useState(0);
  React58.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return (0, import_jsx_runtime64.jsx)(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React58.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React58.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React58.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React58.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: (0, import_jsx_runtime64.jsx)(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME2 = "RovingFocusGroupItem";
var RovingFocusGroupItem = React58.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props;
    const autoId = useId2();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME2, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection2(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    React58.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return (0, import_jsx_runtime64.jsx)(
      Collection2.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: (0, import_jsx_runtime64.jsx)(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable)
                event.preventDefault();
              else
                context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget)
                return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)
                  return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last")
                  candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev")
                    candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst2(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME2;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key))
    return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray(array2, startIndex) {
  return array2.map((_, index3) => array2[(startIndex + index3) % array2.length]);
}
var Root7 = RovingFocusGroup;
var Item = RovingFocusGroupItem;

// node_modules/@radix-ui/react-menu/dist/index.mjs
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection3, useCollection3, createCollectionScope3] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope3,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope = createPopperScope();
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope(__scopeMenu);
  const [content, setContent3] = React59.useState(null);
  const isUsingKeyboardRef = React59.useRef(false);
  const handleOpenChange = useCallbackRef(onOpenChange);
  const direction = useDirection(dir);
  React59.useEffect(() => {
    const handleKeyDown2 = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown2, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return (0, import_jsx_runtime65.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime65.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent3,
      children: (0, import_jsx_runtime65.jsx)(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: React59.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME2 = "MenuAnchor";
var MenuAnchor = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope(__scopeMenu);
    return (0, import_jsx_runtime65.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME2;
var PORTAL_NAME4 = "MenuPortal";
var [PortalProvider2, usePortalContext2] = createMenuContext(PORTAL_NAME4, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME4, __scopeMenu);
  return (0, import_jsx_runtime65.jsx)(PortalProvider2, { scope: __scopeMenu, forceMount, children: (0, import_jsx_runtime65.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime65.jsx)(Portal, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME4;
var CONTENT_NAME6 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME6);
var MenuContent = React59.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME6, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useMenuContext(CONTENT_NAME6, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME6, props.__scopeMenu);
    return (0, import_jsx_runtime65.jsx)(Collection3.Provider, { scope: props.__scopeMenu, children: (0, import_jsx_runtime65.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime65.jsx)(Collection3.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? (0, import_jsx_runtime65.jsx)(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime65.jsx)(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = React59.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME6, props.__scopeMenu);
    const ref = React59.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React59.useEffect(() => {
      const content = ref.current;
      if (content)
        return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime65.jsx)(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = React59.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME6, props.__scopeMenu);
  return (0, import_jsx_runtime65.jsx)(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var Slot3 = createSlot("MenuContent.ScrollLock");
var MenuContentImpl = React59.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context = useMenuContext(CONTENT_NAME6, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME6, __scopeMenu);
    const popperScope = usePopperScope(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const getItems = useCollection3(__scopeMenu);
    const [currentItemId, setCurrentItemId] = React59.useState(null);
    const contentRef = React59.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = React59.useRef(0);
    const searchRef = React59.useRef("");
    const pointerGraceTimerRef = React59.useRef(0);
    const pointerGraceIntentRef = React59.useRef(null);
    const pointerDirRef = React59.useRef("right");
    const lastPointerXRef = React59.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? Combination_default : React59.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot3, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      var _a5, _b;
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = (_a5 = items.find((item) => item.ref.current === currentItem)) == null ? void 0 : _a5.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = (_b = items.find((item) => item.textValue === nextMatch)) == null ? void 0 : _b.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "")
          timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    React59.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = React59.useCallback((event) => {
      var _a5, _b;
      const isMovingTowards = pointerDirRef.current === ((_a5 = pointerGraceIntentRef.current) == null ? void 0 : _a5.side);
      return isMovingTowards && isPointerInGraceArea(event, (_b = pointerGraceIntentRef.current) == null ? void 0 : _b.area);
    }, []);
    return (0, import_jsx_runtime65.jsx)(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: React59.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event))
              event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: React59.useCallback(
          (event) => {
            var _a5;
            if (isPointerMovingToSubmenu(event))
              return;
            (_a5 = contentRef.current) == null ? void 0 : _a5.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: React59.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event))
              event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: React59.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: (0, import_jsx_runtime65.jsx)(ScrollLockWrapper, { ...scrollLockWrapperProps, children: (0, import_jsx_runtime65.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              var _a5;
              event.preventDefault();
              (_a5 = contentRef.current) == null ? void 0 : _a5.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: (0, import_jsx_runtime65.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: (0, import_jsx_runtime65.jsx)(
                  Root7,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current)
                        event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: (0, import_jsx_runtime65.jsx)(
                      Content3,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab")
                              event.preventDefault();
                            if (!isModifierKey && isCharacterKey)
                              handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content)
                            return;
                          if (!FIRST_LAST_KEYS.includes(event.key))
                            return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key))
                            candidateNodes.reverse();
                          focusFirst3(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME6;
var GROUP_NAME2 = "MenuGroup";
var MenuGroup = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return (0, import_jsx_runtime65.jsx)(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME2;
var LABEL_NAME = "MenuLabel";
var MenuLabel = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return (0, import_jsx_runtime65.jsx)(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME;
var ITEM_NAME3 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React59.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = React59.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME3, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME3, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = React59.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect == null ? void 0 : onSelect(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return (0, import_jsx_runtime65.jsx)(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          var _a5;
          (_a5 = props.onPointerDown) == null ? void 0 : _a5.call(props, event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          var _a5;
          if (!isPointerDownRef.current)
            (_a5 = event.currentTarget) == null ? void 0 : _a5.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ")
            return;
          if (SELECTION_KEYS.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME3;
var MenuItemImpl = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME3, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const ref = React59.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = React59.useState(false);
    const [textContent, setTextContent] = React59.useState("");
    React59.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return (0, import_jsx_runtime65.jsx)(
      Collection3.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: (0, import_jsx_runtime65.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: (0, import_jsx_runtime65.jsx)(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME = "MenuCheckboxItem";
var MenuCheckboxItem = React59.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return (0, import_jsx_runtime65.jsx)(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: (0, import_jsx_runtime65.jsx)(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate2(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange == null ? void 0 : onCheckedChange(isIndeterminate2(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
  RADIO_GROUP_NAME,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = React59.forwardRef(
  (props, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef(onValueChange);
    return (0, import_jsx_runtime65.jsx)(RadioGroupProvider, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: (0, import_jsx_runtime65.jsx)(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "MenuRadioItem";
var MenuRadioItem = React59.forwardRef(
  (props, forwardedRef) => {
    const { value, ...radioItemProps } = props;
    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);
    const checked = value === context.value;
    return (0, import_jsx_runtime65.jsx)(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: (0, import_jsx_runtime65.jsx)(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => {
            var _a5;
            return (_a5 = context.onValueChange) == null ? void 0 : _a5.call(context, value);
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME;
var ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME,
  { checked: false }
);
var MenuItemIndicator = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);
    return (0, import_jsx_runtime65.jsx)(
      Presence,
      {
        present: forceMount || isIndeterminate2(indicatorContext.checked) || indicatorContext.checked === true,
        children: (0, import_jsx_runtime65.jsx)(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME = "MenuSeparator";
var MenuSeparator = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return (0, import_jsx_runtime65.jsx)(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME2 = "MenuArrow";
var MenuArrow = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeMenu);
    return (0, import_jsx_runtime65.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME2;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var MenuSub = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);
  const popperScope = usePopperScope(__scopeMenu);
  const [trigger2, setTrigger] = React59.useState(null);
  const [content, setContent3] = React59.useState(null);
  const handleOpenChange = useCallbackRef(onOpenChange);
  React59.useEffect(() => {
    if (parentMenuContext.open === false)
      handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return (0, import_jsx_runtime65.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime65.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent3,
      children: (0, import_jsx_runtime65.jsx)(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId2(),
          triggerId: useId2(),
          trigger: trigger2,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) });
};
MenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME = "MenuSubTrigger";
var MenuSubTrigger = React59.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const openTimerRef = React59.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = React59.useCallback(() => {
      if (openTimerRef.current)
        window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    React59.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    React59.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return (0, import_jsx_runtime65.jsx)(MenuAnchor, { asChild: true, ...scope, children: (0, import_jsx_runtime65.jsx)(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          var _a5;
          (_a5 = props.onClick) == null ? void 0 : _a5.call(props, event);
          if (props.disabled || event.defaultPrevented)
            return;
          event.currentTarget.focus();
          if (!context.open)
            context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented)
              return;
            if (!props.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse((event) => {
            var _a5, _b;
            clearOpenTimer();
            const contentRect = (_a5 = context.content) == null ? void 0 : _a5.getBoundingClientRect();
            if (contentRect) {
              const side = (_b = context.content) == null ? void 0 : _b.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented)
                return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a5;
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ")
            return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            (_a5 = context.content) == null ? void 0 : _a5.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "MenuSubContent";
var MenuSubContent = React59.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME6, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context = useMenuContext(CONTENT_NAME6, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME6, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);
    const ref = React59.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return (0, import_jsx_runtime65.jsx)(Collection3.Provider, { scope: props.__scopeMenu, children: (0, import_jsx_runtime65.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime65.jsx)(Collection3.Slot, { scope: props.__scopeMenu, children: (0, import_jsx_runtime65.jsx)(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          var _a5;
          if (rootContext.isUsingKeyboardRef.current)
            (_a5 = ref.current) == null ? void 0 : _a5.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger)
            context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a5;
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            (_a5 = subContext.trigger) == null ? void 0 : _a5.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate2(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate2(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst3(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray2(array2, startIndex) {
  return array2.map((_, index3) => array2[(startIndex + index3) % array2.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray2(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root32 = Menu;
var Anchor2 = MenuAnchor;
var Portal3 = MenuPortal;
var Content22 = MenuContent;
var Group = MenuGroup;
var Label = MenuLabel;
var Item2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow22 = MenuArrow;
var Sub = MenuSub;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;

// node_modules/@radix-ui/react-context-menu/dist/index.mjs
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var CONTEXT_MENU_NAME = "ContextMenu";
var [createContextMenuContext, createContextMenuScope] = createContextScope(CONTEXT_MENU_NAME, [
  createMenuScope
]);
var useMenuScope = createMenuScope();
var [ContextMenuProvider, useContextMenuContext] = createContextMenuContext(CONTEXT_MENU_NAME);
var ContextMenu = (props) => {
  const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props;
  const [open, setOpen] = React60.useState(false);
  const menuScope = useMenuScope(__scopeContextMenu);
  const handleOpenChangeProp = useCallbackRef(onOpenChange);
  const handleOpenChange = React60.useCallback(
    (open2) => {
      setOpen(open2);
      handleOpenChangeProp(open2);
    },
    [handleOpenChangeProp]
  );
  return (0, import_jsx_runtime66.jsx)(
    ContextMenuProvider,
    {
      scope: __scopeContextMenu,
      open,
      onOpenChange: handleOpenChange,
      modal,
      children: (0, import_jsx_runtime66.jsx)(
        Root32,
        {
          ...menuScope,
          dir,
          open,
          onOpenChange: handleOpenChange,
          modal,
          children
        }
      )
    }
  );
};
ContextMenu.displayName = CONTEXT_MENU_NAME;
var TRIGGER_NAME6 = "ContextMenuTrigger";
var ContextMenuTrigger = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, disabled = false, ...triggerProps } = props;
    const context = useContextMenuContext(TRIGGER_NAME6, __scopeContextMenu);
    const menuScope = useMenuScope(__scopeContextMenu);
    const pointRef = React60.useRef({ x: 0, y: 0 });
    const virtualRef = React60.useRef({
      getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...pointRef.current })
    });
    const longPressTimerRef = React60.useRef(0);
    const clearLongPress = React60.useCallback(
      () => window.clearTimeout(longPressTimerRef.current),
      []
    );
    const handleOpen = (event) => {
      pointRef.current = { x: event.clientX, y: event.clientY };
      context.onOpenChange(true);
    };
    React60.useEffect(() => clearLongPress, [clearLongPress]);
    React60.useEffect(() => void (disabled && clearLongPress()), [disabled, clearLongPress]);
    return (0, import_jsx_runtime66.jsxs)(import_jsx_runtime66.Fragment, { children: [
      (0, import_jsx_runtime66.jsx)(Anchor2, { ...menuScope, virtualRef }),
      (0, import_jsx_runtime66.jsx)(
        Primitive.span,
        {
          "data-state": context.open ? "open" : "closed",
          "data-disabled": disabled ? "" : void 0,
          ...triggerProps,
          ref: forwardedRef,
          style: { WebkitTouchCallout: "none", ...props.style },
          onContextMenu: disabled ? props.onContextMenu : composeEventHandlers(props.onContextMenu, (event) => {
            clearLongPress();
            handleOpen(event);
            event.preventDefault();
          }),
          onPointerDown: disabled ? props.onPointerDown : composeEventHandlers(
            props.onPointerDown,
            whenTouchOrPen((event) => {
              clearLongPress();
              longPressTimerRef.current = window.setTimeout(() => handleOpen(event), 700);
            })
          ),
          onPointerMove: disabled ? props.onPointerMove : composeEventHandlers(props.onPointerMove, whenTouchOrPen(clearLongPress)),
          onPointerCancel: disabled ? props.onPointerCancel : composeEventHandlers(props.onPointerCancel, whenTouchOrPen(clearLongPress)),
          onPointerUp: disabled ? props.onPointerUp : composeEventHandlers(props.onPointerUp, whenTouchOrPen(clearLongPress))
        }
      )
    ] });
  }
);
ContextMenuTrigger.displayName = TRIGGER_NAME6;
var PORTAL_NAME5 = "ContextMenuPortal";
var ContextMenuPortal = (props) => {
  const { __scopeContextMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime66.jsx)(Portal3, { ...menuScope, ...portalProps });
};
ContextMenuPortal.displayName = PORTAL_NAME5;
var CONTENT_NAME7 = "ContextMenuContent";
var ContextMenuContent = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...contentProps } = props;
    const context = useContextMenuContext(CONTENT_NAME7, __scopeContextMenu);
    const menuScope = useMenuScope(__scopeContextMenu);
    const hasInteractedOutsideRef = React60.useRef(false);
    return (0, import_jsx_runtime66.jsx)(
      Content22,
      {
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: (event) => {
          var _a5;
          (_a5 = props.onCloseAutoFocus) == null ? void 0 : _a5.call(props, event);
          if (!event.defaultPrevented && hasInteractedOutsideRef.current) {
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a5;
          (_a5 = props.onInteractOutside) == null ? void 0 : _a5.call(props, event);
          if (!event.defaultPrevented && !context.modal)
            hasInteractedOutsideRef.current = true;
        },
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
ContextMenuContent.displayName = CONTENT_NAME7;
var GROUP_NAME3 = "ContextMenuGroup";
var ContextMenuGroup = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeContextMenu);
    return (0, import_jsx_runtime66.jsx)(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
ContextMenuGroup.displayName = GROUP_NAME3;
var LABEL_NAME2 = "ContextMenuLabel";
var ContextMenuLabel = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeContextMenu);
    return (0, import_jsx_runtime66.jsx)(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
ContextMenuLabel.displayName = LABEL_NAME2;
var ITEM_NAME4 = "ContextMenuItem";
var ContextMenuItem = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeContextMenu);
    return (0, import_jsx_runtime66.jsx)(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
ContextMenuItem.displayName = ITEM_NAME4;
var CHECKBOX_ITEM_NAME2 = "ContextMenuCheckboxItem";
var ContextMenuCheckboxItem = React60.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime66.jsx)(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
ContextMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME2;
var RADIO_GROUP_NAME2 = "ContextMenuRadioGroup";
var ContextMenuRadioGroup = React60.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime66.jsx)(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
ContextMenuRadioGroup.displayName = RADIO_GROUP_NAME2;
var RADIO_ITEM_NAME2 = "ContextMenuRadioItem";
var ContextMenuRadioItem = React60.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime66.jsx)(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
ContextMenuRadioItem.displayName = RADIO_ITEM_NAME2;
var INDICATOR_NAME2 = "ContextMenuItemIndicator";
var ContextMenuItemIndicator = React60.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime66.jsx)(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
ContextMenuItemIndicator.displayName = INDICATOR_NAME2;
var SEPARATOR_NAME2 = "ContextMenuSeparator";
var ContextMenuSeparator = React60.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime66.jsx)(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
ContextMenuSeparator.displayName = SEPARATOR_NAME2;
var ARROW_NAME3 = "ContextMenuArrow";
var ContextMenuArrow = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeContextMenu);
    return (0, import_jsx_runtime66.jsx)(Arrow22, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
ContextMenuArrow.displayName = ARROW_NAME3;
var SUB_NAME2 = "ContextMenuSub";
var ContextMenuSub = (props) => {
  const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SUB_NAME2
  });
  return (0, import_jsx_runtime66.jsx)(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
ContextMenuSub.displayName = SUB_NAME2;
var SUB_TRIGGER_NAME2 = "ContextMenuSubTrigger";
var ContextMenuSubTrigger = React60.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...triggerItemProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime66.jsx)(SubTrigger, { ...menuScope, ...triggerItemProps, ref: forwardedRef });
});
ContextMenuSubTrigger.displayName = SUB_TRIGGER_NAME2;
var SUB_CONTENT_NAME2 = "ContextMenuSubContent";
var ContextMenuSubContent = React60.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime66.jsx)(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
ContextMenuSubContent.displayName = SUB_CONTENT_NAME2;
function whenTouchOrPen(handler) {
  return (event) => event.pointerType !== "mouse" ? handler(event) : void 0;
}
var Root23 = ContextMenu;
var Trigger3 = ContextMenuTrigger;
var Portal22 = ContextMenuPortal;
var Content23 = ContextMenuContent;
var Group2 = ContextMenuGroup;
var Label2 = ContextMenuLabel;
var Item22 = ContextMenuItem;
var CheckboxItem2 = ContextMenuCheckboxItem;
var RadioGroup2 = ContextMenuRadioGroup;
var RadioItem2 = ContextMenuRadioItem;
var ItemIndicator2 = ContextMenuItemIndicator;
var Separator2 = ContextMenuSeparator;
var Arrow23 = ContextMenuArrow;
var Sub2 = ContextMenuSub;
var SubTrigger2 = ContextMenuSubTrigger;
var SubContent2 = ContextMenuSubContent;

// node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var dist_exports9 = {};
__export(dist_exports9, {
  Arrow: () => Arrow24,
  CheckboxItem: () => CheckboxItem22,
  Content: () => Content24,
  DropdownMenu: () => DropdownMenu,
  DropdownMenuArrow: () => DropdownMenuArrow,
  DropdownMenuCheckboxItem: () => DropdownMenuCheckboxItem,
  DropdownMenuContent: () => DropdownMenuContent,
  DropdownMenuGroup: () => DropdownMenuGroup,
  DropdownMenuItem: () => DropdownMenuItem,
  DropdownMenuItemIndicator: () => DropdownMenuItemIndicator,
  DropdownMenuLabel: () => DropdownMenuLabel,
  DropdownMenuPortal: () => DropdownMenuPortal,
  DropdownMenuRadioGroup: () => DropdownMenuRadioGroup,
  DropdownMenuRadioItem: () => DropdownMenuRadioItem,
  DropdownMenuSeparator: () => DropdownMenuSeparator,
  DropdownMenuSub: () => DropdownMenuSub,
  DropdownMenuSubContent: () => DropdownMenuSubContent,
  DropdownMenuSubTrigger: () => DropdownMenuSubTrigger,
  DropdownMenuTrigger: () => DropdownMenuTrigger,
  Group: () => Group22,
  Item: () => Item23,
  ItemIndicator: () => ItemIndicator22,
  Label: () => Label22,
  Portal: () => Portal23,
  RadioGroup: () => RadioGroup22,
  RadioItem: () => RadioItem22,
  Root: () => Root24,
  Separator: () => Separator22,
  Sub: () => Sub22,
  SubContent: () => SubContent22,
  SubTrigger: () => SubTrigger22,
  Trigger: () => Trigger4,
  createDropdownMenuScope: () => createDropdownMenuScope
});
var React61 = __toESM(require_react(), 1);
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope2 = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  const triggerRef = React61.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return (0, import_jsx_runtime67.jsx)(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId2(),
      triggerRef,
      contentId: useId2(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React61.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: (0, import_jsx_runtime67.jsx)(Root32, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME7 = "DropdownMenuTrigger";
var DropdownMenuTrigger = React61.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context = useDropdownMenuContext(TRIGGER_NAME7, __scopeDropdownMenu);
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return (0, import_jsx_runtime67.jsx)(Anchor2, { asChild: true, ...menuScope, children: (0, import_jsx_runtime67.jsx)(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open)
              event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled)
            return;
          if (["Enter", " "].includes(event.key))
            context.onOpenToggle();
          if (event.key === "ArrowDown")
            context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key))
            event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger.displayName = TRIGGER_NAME7;
var PORTAL_NAME6 = "DropdownMenuPortal";
var DropdownMenuPortal = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime67.jsx)(Portal3, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME6;
var CONTENT_NAME8 = "DropdownMenuContent";
var DropdownMenuContent = React61.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context = useDropdownMenuContext(CONTENT_NAME8, __scopeDropdownMenu);
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    const hasInteractedOutsideRef = React61.useRef(false);
    return (0, import_jsx_runtime67.jsx)(
      Content22,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a5;
          if (!hasInteractedOutsideRef.current)
            (_a5 = context.triggerRef.current) == null ? void 0 : _a5.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick)
            hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent.displayName = CONTENT_NAME8;
var GROUP_NAME4 = "DropdownMenuGroup";
var DropdownMenuGroup = React61.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return (0, import_jsx_runtime67.jsx)(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME4;
var LABEL_NAME3 = "DropdownMenuLabel";
var DropdownMenuLabel = React61.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return (0, import_jsx_runtime67.jsx)(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME3;
var ITEM_NAME5 = "DropdownMenuItem";
var DropdownMenuItem = React61.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return (0, import_jsx_runtime67.jsx)(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem.displayName = ITEM_NAME5;
var CHECKBOX_ITEM_NAME3 = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = React61.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime67.jsx)(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME3;
var RADIO_GROUP_NAME3 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = React61.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime67.jsx)(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME3;
var RADIO_ITEM_NAME3 = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = React61.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime67.jsx)(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME3;
var INDICATOR_NAME3 = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React61.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime67.jsx)(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME3;
var SEPARATOR_NAME3 = "DropdownMenuSeparator";
var DropdownMenuSeparator = React61.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime67.jsx)(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME3;
var ARROW_NAME4 = "DropdownMenuArrow";
var DropdownMenuArrow = React61.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return (0, import_jsx_runtime67.jsx)(Arrow22, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME4;
var DropdownMenuSub = (props) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: "DropdownMenuSub"
  });
  return (0, import_jsx_runtime67.jsx)(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
var SUB_TRIGGER_NAME3 = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = React61.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime67.jsx)(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME3;
var SUB_CONTENT_NAME3 = "DropdownMenuSubContent";
var DropdownMenuSubContent = React61.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime67.jsx)(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME3;
var Root24 = DropdownMenu;
var Trigger4 = DropdownMenuTrigger;
var Portal23 = DropdownMenuPortal;
var Content24 = DropdownMenuContent;
var Group22 = DropdownMenuGroup;
var Label22 = DropdownMenuLabel;
var Item23 = DropdownMenuItem;
var CheckboxItem22 = DropdownMenuCheckboxItem;
var RadioGroup22 = DropdownMenuRadioGroup;
var RadioItem22 = DropdownMenuRadioItem;
var ItemIndicator22 = DropdownMenuItemIndicator;
var Separator22 = DropdownMenuSeparator;
var Arrow24 = DropdownMenuArrow;
var Sub22 = DropdownMenuSub;
var SubTrigger22 = DropdownMenuSubTrigger;
var SubContent22 = DropdownMenuSubContent;

// node_modules/@radix-ui/react-form/dist/index.mjs
var React63 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-label/dist/index.mjs
var React62 = __toESM(require_react(), 1);
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var NAME5 = "Label";
var Label3 = React62.forwardRef((props, forwardedRef) => {
  return (0, import_jsx_runtime68.jsx)(
    Primitive.label,
    {
      ...props,
      ref: forwardedRef,
      onMouseDown: (event) => {
        var _a5;
        const target = event.target;
        if (target.closest("button, input, select, textarea"))
          return;
        (_a5 = props.onMouseDown) == null ? void 0 : _a5.call(props, event);
        if (!event.defaultPrevented && event.detail > 1)
          event.preventDefault();
      }
    }
  );
});
Label3.displayName = NAME5;

// node_modules/@radix-ui/react-form/dist/index.mjs
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var [createFormContext, createFormScope] = createContextScope("Form");
var FORM_NAME = "Form";
var [ValidationProvider, useValidationContext] = createFormContext(FORM_NAME);
var [AriaDescriptionProvider, useAriaDescriptionContext] = createFormContext(FORM_NAME);
var Form = React63.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, onClearServerErrors = () => {
    }, ...rootProps } = props;
    const formRef = React63.useRef(null);
    const composedFormRef = useComposedRefs(forwardedRef, formRef);
    const [validityMap, setValidityMap] = React63.useState({});
    const getFieldValidity = React63.useCallback(
      (fieldName) => validityMap[fieldName],
      [validityMap]
    );
    const handleFieldValidityChange = React63.useCallback(
      (fieldName, validity) => setValidityMap((prevValidityMap) => ({
        ...prevValidityMap,
        [fieldName]: { ...prevValidityMap[fieldName] ?? {}, ...validity }
      })),
      []
    );
    const handleFieldValiditionClear = React63.useCallback((fieldName) => {
      setValidityMap((prevValidityMap) => ({ ...prevValidityMap, [fieldName]: void 0 }));
      setCustomErrorsMap((prevCustomErrorsMap) => ({ ...prevCustomErrorsMap, [fieldName]: {} }));
    }, []);
    const [customMatcherEntriesMap, setCustomMatcherEntriesMap] = React63.useState({});
    const getFieldCustomMatcherEntries = React63.useCallback(
      (fieldName) => customMatcherEntriesMap[fieldName] ?? [],
      [customMatcherEntriesMap]
    );
    const handleFieldCustomMatcherAdd = React63.useCallback((fieldName, matcherEntry) => {
      setCustomMatcherEntriesMap((prevCustomMatcherEntriesMap) => ({
        ...prevCustomMatcherEntriesMap,
        [fieldName]: [...prevCustomMatcherEntriesMap[fieldName] ?? [], matcherEntry]
      }));
    }, []);
    const handleFieldCustomMatcherRemove = React63.useCallback((fieldName, matcherEntryId) => {
      setCustomMatcherEntriesMap((prevCustomMatcherEntriesMap) => ({
        ...prevCustomMatcherEntriesMap,
        [fieldName]: (prevCustomMatcherEntriesMap[fieldName] ?? []).filter(
          (matcherEntry) => matcherEntry.id !== matcherEntryId
        )
      }));
    }, []);
    const [customErrorsMap, setCustomErrorsMap] = React63.useState({});
    const getFieldCustomErrors = React63.useCallback(
      (fieldName) => customErrorsMap[fieldName] ?? {},
      [customErrorsMap]
    );
    const handleFieldCustomErrorsChange = React63.useCallback((fieldName, customErrors) => {
      setCustomErrorsMap((prevCustomErrorsMap) => ({
        ...prevCustomErrorsMap,
        [fieldName]: { ...prevCustomErrorsMap[fieldName] ?? {}, ...customErrors }
      }));
    }, []);
    const [messageIdsMap, setMessageIdsMap] = React63.useState({});
    const handleFieldMessageIdAdd = React63.useCallback((fieldName, id) => {
      setMessageIdsMap((prevMessageIdsMap) => {
        const fieldDescriptionIds = new Set(prevMessageIdsMap[fieldName]).add(id);
        return { ...prevMessageIdsMap, [fieldName]: fieldDescriptionIds };
      });
    }, []);
    const handleFieldMessageIdRemove = React63.useCallback((fieldName, id) => {
      setMessageIdsMap((prevMessageIdsMap) => {
        const fieldDescriptionIds = new Set(prevMessageIdsMap[fieldName]);
        fieldDescriptionIds.delete(id);
        return { ...prevMessageIdsMap, [fieldName]: fieldDescriptionIds };
      });
    }, []);
    const getFieldDescription = React63.useCallback(
      (fieldName) => Array.from(messageIdsMap[fieldName] ?? []).join(" ") || void 0,
      [messageIdsMap]
    );
    return (0, import_jsx_runtime69.jsx)(
      ValidationProvider,
      {
        scope: __scopeForm,
        getFieldValidity,
        onFieldValidityChange: handleFieldValidityChange,
        getFieldCustomMatcherEntries,
        onFieldCustomMatcherEntryAdd: handleFieldCustomMatcherAdd,
        onFieldCustomMatcherEntryRemove: handleFieldCustomMatcherRemove,
        getFieldCustomErrors,
        onFieldCustomErrorsChange: handleFieldCustomErrorsChange,
        onFieldValiditionClear: handleFieldValiditionClear,
        children: (0, import_jsx_runtime69.jsx)(
          AriaDescriptionProvider,
          {
            scope: __scopeForm,
            onFieldMessageIdAdd: handleFieldMessageIdAdd,
            onFieldMessageIdRemove: handleFieldMessageIdRemove,
            getFieldDescription,
            children: (0, import_jsx_runtime69.jsx)(
              Primitive.form,
              {
                ...rootProps,
                ref: composedFormRef,
                onInvalid: composeEventHandlers(props.onInvalid, (event) => {
                  const firstInvalidControl = getFirstInvalidControl(event.currentTarget);
                  if (firstInvalidControl === event.target)
                    firstInvalidControl.focus();
                  event.preventDefault();
                }),
                onSubmit: composeEventHandlers(props.onSubmit, onClearServerErrors, {
                  checkForDefaultPrevented: false
                }),
                onReset: composeEventHandlers(props.onReset, onClearServerErrors)
              }
            )
          }
        )
      }
    );
  }
);
Form.displayName = FORM_NAME;
var FIELD_NAME = "FormField";
var [FormFieldProvider, useFormFieldContext] = createFormContext(FIELD_NAME);
var FormField = React63.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, name, serverInvalid = false, ...fieldProps } = props;
    const validationContext = useValidationContext(FIELD_NAME, __scopeForm);
    const validity = validationContext.getFieldValidity(name);
    const id = useId2();
    return (0, import_jsx_runtime69.jsx)(FormFieldProvider, { scope: __scopeForm, id, name, serverInvalid, children: (0, import_jsx_runtime69.jsx)(
      Primitive.div,
      {
        "data-valid": getValidAttribute(validity, serverInvalid),
        "data-invalid": getInvalidAttribute(validity, serverInvalid),
        ...fieldProps,
        ref: forwardedRef
      }
    ) });
  }
);
FormField.displayName = FIELD_NAME;
var LABEL_NAME4 = "FormLabel";
var FormLabel = React63.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, ...labelProps } = props;
    const validationContext = useValidationContext(LABEL_NAME4, __scopeForm);
    const fieldContext = useFormFieldContext(LABEL_NAME4, __scopeForm);
    const htmlFor = labelProps.htmlFor || fieldContext.id;
    const validity = validationContext.getFieldValidity(fieldContext.name);
    return (0, import_jsx_runtime69.jsx)(
      Label3,
      {
        "data-valid": getValidAttribute(validity, fieldContext.serverInvalid),
        "data-invalid": getInvalidAttribute(validity, fieldContext.serverInvalid),
        ...labelProps,
        ref: forwardedRef,
        htmlFor
      }
    );
  }
);
FormLabel.displayName = LABEL_NAME4;
var CONTROL_NAME = "FormControl";
var FormControl = React63.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, ...controlProps } = props;
    const validationContext = useValidationContext(CONTROL_NAME, __scopeForm);
    const fieldContext = useFormFieldContext(CONTROL_NAME, __scopeForm);
    const ariaDescriptionContext = useAriaDescriptionContext(CONTROL_NAME, __scopeForm);
    const ref = React63.useRef(null);
    const composedRef = useComposedRefs(forwardedRef, ref);
    const name = controlProps.name || fieldContext.name;
    const id = controlProps.id || fieldContext.id;
    const customMatcherEntries = validationContext.getFieldCustomMatcherEntries(name);
    const { onFieldValidityChange, onFieldCustomErrorsChange, onFieldValiditionClear } = validationContext;
    const updateControlValidity = React63.useCallback(
      async (control) => {
        if (hasBuiltInError(control.validity)) {
          const controlValidity2 = validityStateToObject(control.validity);
          onFieldValidityChange(name, controlValidity2);
          return;
        }
        const formData = control.form ? new FormData(control.form) : new FormData();
        const matcherArgs = [control.value, formData];
        const syncCustomMatcherEntries = [];
        const ayncCustomMatcherEntries = [];
        customMatcherEntries.forEach((customMatcherEntry) => {
          if (isAsyncCustomMatcherEntry(customMatcherEntry, matcherArgs)) {
            ayncCustomMatcherEntries.push(customMatcherEntry);
          } else if (isSyncCustomMatcherEntry(customMatcherEntry)) {
            syncCustomMatcherEntries.push(customMatcherEntry);
          }
        });
        const syncCustomErrors = syncCustomMatcherEntries.map(({ id: id2, match }) => {
          return [id2, match(...matcherArgs)];
        });
        const syncCustomErrorsById = Object.fromEntries(syncCustomErrors);
        const hasSyncCustomErrors = Object.values(syncCustomErrorsById).some(Boolean);
        const hasCustomError = hasSyncCustomErrors;
        control.setCustomValidity(hasCustomError ? DEFAULT_INVALID_MESSAGE : "");
        const controlValidity = validityStateToObject(control.validity);
        onFieldValidityChange(name, controlValidity);
        onFieldCustomErrorsChange(name, syncCustomErrorsById);
        if (!hasSyncCustomErrors && ayncCustomMatcherEntries.length > 0) {
          const promisedCustomErrors = ayncCustomMatcherEntries.map(
            ({ id: id2, match }) => match(...matcherArgs).then((matches2) => [id2, matches2])
          );
          const asyncCustomErrors = await Promise.all(promisedCustomErrors);
          const asyncCustomErrorsById = Object.fromEntries(asyncCustomErrors);
          const hasAsyncCustomErrors = Object.values(asyncCustomErrorsById).some(Boolean);
          const hasCustomError2 = hasAsyncCustomErrors;
          control.setCustomValidity(hasCustomError2 ? DEFAULT_INVALID_MESSAGE : "");
          const controlValidity2 = validityStateToObject(control.validity);
          onFieldValidityChange(name, controlValidity2);
          onFieldCustomErrorsChange(name, asyncCustomErrorsById);
        }
      },
      [customMatcherEntries, name, onFieldCustomErrorsChange, onFieldValidityChange]
    );
    React63.useEffect(() => {
      const control = ref.current;
      if (control) {
        const handleChange = () => updateControlValidity(control);
        control.addEventListener("change", handleChange);
        return () => control.removeEventListener("change", handleChange);
      }
    }, [updateControlValidity]);
    const resetControlValidity = React63.useCallback(() => {
      const control = ref.current;
      if (control) {
        control.setCustomValidity("");
        onFieldValiditionClear(name);
      }
    }, [name, onFieldValiditionClear]);
    React63.useEffect(() => {
      var _a5;
      const form = (_a5 = ref.current) == null ? void 0 : _a5.form;
      if (form) {
        form.addEventListener("reset", resetControlValidity);
        return () => form.removeEventListener("reset", resetControlValidity);
      }
    }, [resetControlValidity]);
    React63.useEffect(() => {
      const control = ref.current;
      const form = control == null ? void 0 : control.closest("form");
      if (form && fieldContext.serverInvalid) {
        const firstInvalidControl = getFirstInvalidControl(form);
        if (firstInvalidControl === control)
          firstInvalidControl.focus();
      }
    }, [fieldContext.serverInvalid]);
    const validity = validationContext.getFieldValidity(name);
    return (0, import_jsx_runtime69.jsx)(
      Primitive.input,
      {
        "data-valid": getValidAttribute(validity, fieldContext.serverInvalid),
        "data-invalid": getInvalidAttribute(validity, fieldContext.serverInvalid),
        "aria-invalid": fieldContext.serverInvalid ? true : void 0,
        "aria-describedby": ariaDescriptionContext.getFieldDescription(name),
        title: "",
        ...controlProps,
        ref: composedRef,
        id,
        name,
        onInvalid: composeEventHandlers(props.onInvalid, (event) => {
          const control = event.currentTarget;
          updateControlValidity(control);
        }),
        onChange: composeEventHandlers(props.onChange, (_event) => {
          resetControlValidity();
        })
      }
    );
  }
);
FormControl.displayName = CONTROL_NAME;
var DEFAULT_INVALID_MESSAGE = "This value is not valid";
var DEFAULT_BUILT_IN_MESSAGES = {
  badInput: DEFAULT_INVALID_MESSAGE,
  patternMismatch: "This value does not match the required pattern",
  rangeOverflow: "This value is too large",
  rangeUnderflow: "This value is too small",
  stepMismatch: "This value does not match the required step",
  tooLong: "This value is too long",
  tooShort: "This value is too short",
  typeMismatch: "This value does not match the required type",
  valid: void 0,
  valueMissing: "This value is missing"
};
var MESSAGE_NAME = "FormMessage";
var FormMessage = React63.forwardRef(
  (props, forwardedRef) => {
    const { match, name: nameProp, ...messageProps } = props;
    const fieldContext = useFormFieldContext(MESSAGE_NAME, props.__scopeForm);
    const name = nameProp ?? fieldContext.name;
    if (match === void 0) {
      return (0, import_jsx_runtime69.jsx)(FormMessageImpl, { ...messageProps, ref: forwardedRef, name, children: props.children || DEFAULT_INVALID_MESSAGE });
    } else if (typeof match === "function") {
      return (0, import_jsx_runtime69.jsx)(FormCustomMessage, { match, ...messageProps, ref: forwardedRef, name });
    } else {
      return (0, import_jsx_runtime69.jsx)(FormBuiltInMessage, { match, ...messageProps, ref: forwardedRef, name });
    }
  }
);
FormMessage.displayName = MESSAGE_NAME;
var FormBuiltInMessage = React63.forwardRef(
  (props, forwardedRef) => {
    const { match, forceMatch = false, name, children, ...messageProps } = props;
    const validationContext = useValidationContext(MESSAGE_NAME, messageProps.__scopeForm);
    const validity = validationContext.getFieldValidity(name);
    const matches2 = forceMatch || (validity == null ? void 0 : validity[match]);
    if (matches2) {
      return (0, import_jsx_runtime69.jsx)(FormMessageImpl, { ref: forwardedRef, ...messageProps, name, children: children ?? DEFAULT_BUILT_IN_MESSAGES[match] });
    }
    return null;
  }
);
var FormCustomMessage = React63.forwardRef(
  (props, forwardedRef) => {
    const { match, forceMatch = false, name, id: idProp, children, ...messageProps } = props;
    const validationContext = useValidationContext(MESSAGE_NAME, messageProps.__scopeForm);
    const ref = React63.useRef(null);
    const composedRef = useComposedRefs(forwardedRef, ref);
    const _id = useId2();
    const id = idProp ?? _id;
    const customMatcherEntry = React63.useMemo(() => ({ id, match }), [id, match]);
    const { onFieldCustomMatcherEntryAdd, onFieldCustomMatcherEntryRemove } = validationContext;
    React63.useEffect(() => {
      onFieldCustomMatcherEntryAdd(name, customMatcherEntry);
      return () => onFieldCustomMatcherEntryRemove(name, customMatcherEntry.id);
    }, [customMatcherEntry, name, onFieldCustomMatcherEntryAdd, onFieldCustomMatcherEntryRemove]);
    const validity = validationContext.getFieldValidity(name);
    const customErrors = validationContext.getFieldCustomErrors(name);
    const hasMatchingCustomError = customErrors[id];
    const matches2 = forceMatch || validity && !hasBuiltInError(validity) && hasMatchingCustomError;
    if (matches2) {
      return (0, import_jsx_runtime69.jsx)(FormMessageImpl, { id, ref: composedRef, ...messageProps, name, children: children ?? DEFAULT_INVALID_MESSAGE });
    }
    return null;
  }
);
var FormMessageImpl = React63.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, id: idProp, name, ...messageProps } = props;
    const ariaDescriptionContext = useAriaDescriptionContext(MESSAGE_NAME, __scopeForm);
    const _id = useId2();
    const id = idProp ?? _id;
    const { onFieldMessageIdAdd, onFieldMessageIdRemove } = ariaDescriptionContext;
    React63.useEffect(() => {
      onFieldMessageIdAdd(name, id);
      return () => onFieldMessageIdRemove(name, id);
    }, [name, id, onFieldMessageIdAdd, onFieldMessageIdRemove]);
    return (0, import_jsx_runtime69.jsx)(Primitive.span, { id, ...messageProps, ref: forwardedRef });
  }
);
var VALIDITY_STATE_NAME = "FormValidityState";
var FormValidityState = (props) => {
  const { __scopeForm, name: nameProp, children } = props;
  const validationContext = useValidationContext(VALIDITY_STATE_NAME, __scopeForm);
  const fieldContext = useFormFieldContext(VALIDITY_STATE_NAME, __scopeForm);
  const name = nameProp ?? fieldContext.name;
  const validity = validationContext.getFieldValidity(name);
  return (0, import_jsx_runtime69.jsx)(import_jsx_runtime69.Fragment, { children: children(validity) });
};
FormValidityState.displayName = VALIDITY_STATE_NAME;
var SUBMIT_NAME = "FormSubmit";
var FormSubmit = React63.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, ...submitProps } = props;
    return (0, import_jsx_runtime69.jsx)(Primitive.button, { type: "submit", ...submitProps, ref: forwardedRef });
  }
);
FormSubmit.displayName = SUBMIT_NAME;
function validityStateToObject(validity) {
  const object2 = {};
  for (const key in validity) {
    object2[key] = validity[key];
  }
  return object2;
}
function isHTMLElement2(element) {
  return element instanceof HTMLElement;
}
function isFormControl(element) {
  return "validity" in element;
}
function isInvalid(control) {
  return isFormControl(control) && (control.validity.valid === false || control.getAttribute("aria-invalid") === "true");
}
function getFirstInvalidControl(form) {
  const elements = form.elements;
  const [firstInvalidControl] = Array.from(elements).filter(isHTMLElement2).filter(isInvalid);
  return firstInvalidControl;
}
function isAsyncCustomMatcherEntry(entry2, args) {
  return entry2.match.constructor.name === "AsyncFunction" || returnsPromise(entry2.match, args);
}
function isSyncCustomMatcherEntry(entry2) {
  return entry2.match.constructor.name === "Function";
}
function returnsPromise(func, args) {
  return func(...args) instanceof Promise;
}
function hasBuiltInError(validity) {
  let error = false;
  for (const validityKey in validity) {
    const key = validityKey;
    if (key !== "valid" && key !== "customError" && validity[key]) {
      error = true;
      break;
    }
  }
  return error;
}
function getValidAttribute(validity, serverInvalid) {
  if ((validity == null ? void 0 : validity.valid) === true && !serverInvalid)
    return true;
  return void 0;
}
function getInvalidAttribute(validity, serverInvalid) {
  if ((validity == null ? void 0 : validity.valid) === false || serverInvalid)
    return true;
  return void 0;
}

// node_modules/@radix-ui/react-hover-card/dist/index.mjs
var React64 = __toESM(require_react(), 1);
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var originalBodyUserSelect;
var HOVERCARD_NAME = "HoverCard";
var [createHoverCardContext, createHoverCardScope] = createContextScope(HOVERCARD_NAME, [
  createPopperScope
]);
var usePopperScope2 = createPopperScope();
var [HoverCardProvider, useHoverCardContext] = createHoverCardContext(HOVERCARD_NAME);
var HoverCard = (props) => {
  const {
    __scopeHoverCard,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    openDelay = 700,
    closeDelay = 300
  } = props;
  const popperScope = usePopperScope2(__scopeHoverCard);
  const openTimerRef = React64.useRef(0);
  const closeTimerRef = React64.useRef(0);
  const hasSelectionRef = React64.useRef(false);
  const isPointerDownOnContentRef = React64.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: HOVERCARD_NAME
  });
  const handleOpen = React64.useCallback(() => {
    clearTimeout(closeTimerRef.current);
    openTimerRef.current = window.setTimeout(() => setOpen(true), openDelay);
  }, [openDelay, setOpen]);
  const handleClose = React64.useCallback(() => {
    clearTimeout(openTimerRef.current);
    if (!hasSelectionRef.current && !isPointerDownOnContentRef.current) {
      closeTimerRef.current = window.setTimeout(() => setOpen(false), closeDelay);
    }
  }, [closeDelay, setOpen]);
  const handleDismiss = React64.useCallback(() => setOpen(false), [setOpen]);
  React64.useEffect(() => {
    return () => {
      clearTimeout(openTimerRef.current);
      clearTimeout(closeTimerRef.current);
    };
  }, []);
  return (0, import_jsx_runtime70.jsx)(
    HoverCardProvider,
    {
      scope: __scopeHoverCard,
      open,
      onOpenChange: setOpen,
      onOpen: handleOpen,
      onClose: handleClose,
      onDismiss: handleDismiss,
      hasSelectionRef,
      isPointerDownOnContentRef,
      children: (0, import_jsx_runtime70.jsx)(Root22, { ...popperScope, children })
    }
  );
};
HoverCard.displayName = HOVERCARD_NAME;
var TRIGGER_NAME8 = "HoverCardTrigger";
var HoverCardTrigger = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeHoverCard, ...triggerProps } = props;
    const context = useHoverCardContext(TRIGGER_NAME8, __scopeHoverCard);
    const popperScope = usePopperScope2(__scopeHoverCard);
    return (0, import_jsx_runtime70.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime70.jsx)(
      Primitive.a,
      {
        "data-state": context.open ? "open" : "closed",
        ...triggerProps,
        ref: forwardedRef,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, excludeTouch(context.onOpen)),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, excludeTouch(context.onClose)),
        onFocus: composeEventHandlers(props.onFocus, context.onOpen),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onTouchStart: composeEventHandlers(props.onTouchStart, (event) => event.preventDefault())
      }
    ) });
  }
);
HoverCardTrigger.displayName = TRIGGER_NAME8;
var PORTAL_NAME7 = "HoverCardPortal";
var [PortalProvider3, usePortalContext3] = createHoverCardContext(PORTAL_NAME7, {
  forceMount: void 0
});
var HoverCardPortal = (props) => {
  const { __scopeHoverCard, forceMount, children, container } = props;
  const context = useHoverCardContext(PORTAL_NAME7, __scopeHoverCard);
  return (0, import_jsx_runtime70.jsx)(PortalProvider3, { scope: __scopeHoverCard, forceMount, children: (0, import_jsx_runtime70.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime70.jsx)(Portal, { asChild: true, container, children }) }) });
};
HoverCardPortal.displayName = PORTAL_NAME7;
var CONTENT_NAME9 = "HoverCardContent";
var HoverCardContent = React64.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext3(CONTENT_NAME9, props.__scopeHoverCard);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useHoverCardContext(CONTENT_NAME9, props.__scopeHoverCard);
    return (0, import_jsx_runtime70.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime70.jsx)(
      HoverCardContentImpl,
      {
        "data-state": context.open ? "open" : "closed",
        ...contentProps,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, excludeTouch(context.onOpen)),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, excludeTouch(context.onClose)),
        ref: forwardedRef
      }
    ) });
  }
);
HoverCardContent.displayName = CONTENT_NAME9;
var HoverCardContentImpl = React64.forwardRef((props, forwardedRef) => {
  const {
    __scopeHoverCard,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    ...contentProps
  } = props;
  const context = useHoverCardContext(CONTENT_NAME9, __scopeHoverCard);
  const popperScope = usePopperScope2(__scopeHoverCard);
  const ref = React64.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [containSelection, setContainSelection] = React64.useState(false);
  React64.useEffect(() => {
    if (containSelection) {
      const body = document.body;
      originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
      body.style.userSelect = "none";
      body.style.webkitUserSelect = "none";
      return () => {
        body.style.userSelect = originalBodyUserSelect;
        body.style.webkitUserSelect = originalBodyUserSelect;
      };
    }
  }, [containSelection]);
  React64.useEffect(() => {
    if (ref.current) {
      const handlePointerUp = () => {
        setContainSelection(false);
        context.isPointerDownOnContentRef.current = false;
        setTimeout(() => {
          var _a5;
          const hasSelection2 = ((_a5 = document.getSelection()) == null ? void 0 : _a5.toString()) !== "";
          if (hasSelection2)
            context.hasSelectionRef.current = true;
        });
      };
      document.addEventListener("pointerup", handlePointerUp);
      return () => {
        document.removeEventListener("pointerup", handlePointerUp);
        context.hasSelectionRef.current = false;
        context.isPointerDownOnContentRef.current = false;
      };
    }
  }, [context.isPointerDownOnContentRef, context.hasSelectionRef]);
  React64.useEffect(() => {
    if (ref.current) {
      const tabbables = getTabbableNodes(ref.current);
      tabbables.forEach((tabbable) => tabbable.setAttribute("tabindex", "-1"));
    }
  });
  return (0, import_jsx_runtime70.jsx)(
    DismissableLayer,
    {
      asChild: true,
      disableOutsidePointerEvents: false,
      onInteractOutside,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside: composeEventHandlers(onFocusOutside, (event) => {
        event.preventDefault();
      }),
      onDismiss: context.onDismiss,
      children: (0, import_jsx_runtime70.jsx)(
        Content3,
        {
          ...popperScope,
          ...contentProps,
          onPointerDown: composeEventHandlers(contentProps.onPointerDown, (event) => {
            if (event.currentTarget.contains(event.target)) {
              setContainSelection(true);
            }
            context.hasSelectionRef.current = false;
            context.isPointerDownOnContentRef.current = true;
          }),
          ref: composedRefs,
          style: {
            ...contentProps.style,
            userSelect: containSelection ? "text" : void 0,
            // Safari requires prefix
            WebkitUserSelect: containSelection ? "text" : void 0,
            // re-namespace exposed content custom properties
            ...{
              "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
              "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
              "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
            }
          }
        }
      )
    }
  );
});
var ARROW_NAME5 = "HoverCardArrow";
var HoverCardArrow = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeHoverCard, ...arrowProps } = props;
    const popperScope = usePopperScope2(__scopeHoverCard);
    return (0, import_jsx_runtime70.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
HoverCardArrow.displayName = ARROW_NAME5;
function excludeTouch(eventHandler2) {
  return (event) => event.pointerType === "touch" ? void 0 : eventHandler2();
}
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}

// node_modules/@radix-ui/react-menubar/dist/index.mjs
var React65 = __toESM(require_react(), 1);
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var MENUBAR_NAME = "Menubar";
var [Collection4, useCollection4, createCollectionScope4] = createCollection(MENUBAR_NAME);
var [createMenubarContext, createMenubarScope] = createContextScope(MENUBAR_NAME, [
  createCollectionScope4,
  createRovingFocusGroupScope
]);
var useMenuScope3 = createMenuScope();
var useRovingFocusGroupScope2 = createRovingFocusGroupScope();
var [MenubarContextProvider, useMenubarContext] = createMenubarContext(MENUBAR_NAME);
var Menubar = React65.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenubar,
      value: valueProp,
      onValueChange,
      defaultValue,
      loop = true,
      dir,
      ...menubarProps
    } = props;
    const direction = useDirection(dir);
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeMenubar);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue ?? "",
      caller: MENUBAR_NAME
    });
    const [currentTabStopId, setCurrentTabStopId] = React65.useState(null);
    return (0, import_jsx_runtime71.jsx)(
      MenubarContextProvider,
      {
        scope: __scopeMenubar,
        value,
        onMenuOpen: React65.useCallback(
          (value2) => {
            setValue(value2);
            setCurrentTabStopId(value2);
          },
          [setValue]
        ),
        onMenuClose: React65.useCallback(() => setValue(""), [setValue]),
        onMenuToggle: React65.useCallback(
          (value2) => {
            setValue((prevValue) => prevValue ? "" : value2);
            setCurrentTabStopId(value2);
          },
          [setValue]
        ),
        dir: direction,
        loop,
        children: (0, import_jsx_runtime71.jsx)(Collection4.Provider, { scope: __scopeMenubar, children: (0, import_jsx_runtime71.jsx)(Collection4.Slot, { scope: __scopeMenubar, children: (0, import_jsx_runtime71.jsx)(
          Root7,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation: "horizontal",
            loop,
            dir: direction,
            currentTabStopId,
            onCurrentTabStopIdChange: setCurrentTabStopId,
            children: (0, import_jsx_runtime71.jsx)(Primitive.div, { role: "menubar", ...menubarProps, ref: forwardedRef })
          }
        ) }) })
      }
    );
  }
);
Menubar.displayName = MENUBAR_NAME;
var MENU_NAME2 = "MenubarMenu";
var [MenubarMenuProvider, useMenubarMenuContext] = createMenubarContext(MENU_NAME2);
var MenubarMenu = (props) => {
  const { __scopeMenubar, value: valueProp, ...menuProps } = props;
  const autoValue = useId2();
  const value = valueProp || autoValue || "LEGACY_REACT_AUTO_VALUE";
  const context = useMenubarContext(MENU_NAME2, __scopeMenubar);
  const menuScope = useMenuScope3(__scopeMenubar);
  const triggerRef = React65.useRef(null);
  const wasKeyboardTriggerOpenRef = React65.useRef(false);
  const open = context.value === value;
  React65.useEffect(() => {
    if (!open)
      wasKeyboardTriggerOpenRef.current = false;
  }, [open]);
  return (0, import_jsx_runtime71.jsx)(
    MenubarMenuProvider,
    {
      scope: __scopeMenubar,
      value,
      triggerId: useId2(),
      triggerRef,
      contentId: useId2(),
      wasKeyboardTriggerOpenRef,
      children: (0, import_jsx_runtime71.jsx)(
        Root32,
        {
          ...menuScope,
          open,
          onOpenChange: (open2) => {
            if (!open2)
              context.onMenuClose();
          },
          modal: false,
          dir: context.dir,
          ...menuProps
        }
      )
    }
  );
};
MenubarMenu.displayName = MENU_NAME2;
var TRIGGER_NAME9 = "MenubarTrigger";
var MenubarTrigger = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, disabled = false, ...triggerProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeMenubar);
    const menuScope = useMenuScope3(__scopeMenubar);
    const context = useMenubarContext(TRIGGER_NAME9, __scopeMenubar);
    const menuContext2 = useMenubarMenuContext(TRIGGER_NAME9, __scopeMenubar);
    const ref = React65.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, menuContext2.triggerRef);
    const [isFocused, setIsFocused] = React65.useState(false);
    const open = context.value === menuContext2.value;
    return (0, import_jsx_runtime71.jsx)(Collection4.ItemSlot, { scope: __scopeMenubar, value: menuContext2.value, disabled, children: (0, import_jsx_runtime71.jsx)(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        tabStopId: menuContext2.value,
        children: (0, import_jsx_runtime71.jsx)(Anchor2, { asChild: true, ...menuScope, children: (0, import_jsx_runtime71.jsx)(
          Primitive.button,
          {
            type: "button",
            role: "menuitem",
            id: menuContext2.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": open,
            "aria-controls": open ? menuContext2.contentId : void 0,
            "data-highlighted": isFocused ? "" : void 0,
            "data-state": open ? "open" : "closed",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            ...triggerProps,
            ref: composedRefs,
            onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onMenuOpen(menuContext2.value);
                if (!open)
                  event.preventDefault();
              }
            }),
            onPointerEnter: composeEventHandlers(props.onPointerEnter, () => {
              var _a5;
              const menubarOpen = Boolean(context.value);
              if (menubarOpen && !open) {
                context.onMenuOpen(menuContext2.value);
                (_a5 = ref.current) == null ? void 0 : _a5.focus();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (disabled)
                return;
              if (["Enter", " "].includes(event.key))
                context.onMenuToggle(menuContext2.value);
              if (event.key === "ArrowDown")
                context.onMenuOpen(menuContext2.value);
              if (["Enter", " ", "ArrowDown"].includes(event.key)) {
                menuContext2.wasKeyboardTriggerOpenRef.current = true;
                event.preventDefault();
              }
            }),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    ) });
  }
);
MenubarTrigger.displayName = TRIGGER_NAME9;
var PORTAL_NAME8 = "MenubarPortal";
var MenubarPortal = (props) => {
  const { __scopeMenubar, ...portalProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return (0, import_jsx_runtime71.jsx)(Portal3, { ...menuScope, ...portalProps });
};
MenubarPortal.displayName = PORTAL_NAME8;
var CONTENT_NAME10 = "MenubarContent";
var MenubarContent = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, align = "start", ...contentProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    const context = useMenubarContext(CONTENT_NAME10, __scopeMenubar);
    const menuContext2 = useMenubarMenuContext(CONTENT_NAME10, __scopeMenubar);
    const getItems = useCollection4(__scopeMenubar);
    const hasInteractedOutsideRef = React65.useRef(false);
    return (0, import_jsx_runtime71.jsx)(
      Content22,
      {
        id: menuContext2.contentId,
        "aria-labelledby": menuContext2.triggerId,
        "data-radix-menubar-content": "",
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        align,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a5;
          const menubarOpen = Boolean(context.value);
          if (!menubarOpen && !hasInteractedOutsideRef.current) {
            (_a5 = menuContext2.triggerRef.current) == null ? void 0 : _a5.focus();
          }
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          const target = event.target;
          const isMenubarTrigger = getItems().some((item) => {
            var _a5;
            return (_a5 = item.ref.current) == null ? void 0 : _a5.contains(target);
          });
          if (isMenubarTrigger)
            event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, () => {
          hasInteractedOutsideRef.current = true;
        }),
        onEntryFocus: (event) => {
          if (!menuContext2.wasKeyboardTriggerOpenRef.current)
            event.preventDefault();
        },
        onKeyDown: composeEventHandlers(
          props.onKeyDown,
          (event) => {
            if (["ArrowRight", "ArrowLeft"].includes(event.key)) {
              const target = event.target;
              const targetIsSubTrigger = target.hasAttribute("data-radix-menubar-subtrigger");
              const isKeyDownInsideSubMenu = target.closest("[data-radix-menubar-content]") !== event.currentTarget;
              const prevMenuKey = context.dir === "rtl" ? "ArrowRight" : "ArrowLeft";
              const isPrevKey = prevMenuKey === event.key;
              const isNextKey = !isPrevKey;
              if (isNextKey && targetIsSubTrigger)
                return;
              if (isKeyDownInsideSubMenu && isPrevKey)
                return;
              const items = getItems().filter((item) => !item.disabled);
              let candidateValues = items.map((item) => item.value);
              if (isPrevKey)
                candidateValues.reverse();
              const currentIndex = candidateValues.indexOf(menuContext2.value);
              candidateValues = context.loop ? wrapArray3(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
              const [nextValue] = candidateValues;
              if (nextValue)
                context.onMenuOpen(nextValue);
            }
          },
          { checkForDefaultPrevented: false }
        ),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
            "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
            "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
MenubarContent.displayName = CONTENT_NAME10;
var GROUP_NAME5 = "MenubarGroup";
var MenubarGroup = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...groupProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime71.jsx)(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
MenubarGroup.displayName = GROUP_NAME5;
var LABEL_NAME5 = "MenubarLabel";
var MenubarLabel = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...labelProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime71.jsx)(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
MenubarLabel.displayName = LABEL_NAME5;
var ITEM_NAME6 = "MenubarItem";
var MenubarItem = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...itemProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime71.jsx)(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
MenubarItem.displayName = ITEM_NAME6;
var CHECKBOX_ITEM_NAME4 = "MenubarCheckboxItem";
var MenubarCheckboxItem = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...checkboxItemProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime71.jsx)(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
  }
);
MenubarCheckboxItem.displayName = CHECKBOX_ITEM_NAME4;
var RADIO_GROUP_NAME4 = "MenubarRadioGroup";
var MenubarRadioGroup = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...radioGroupProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime71.jsx)(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
  }
);
MenubarRadioGroup.displayName = RADIO_GROUP_NAME4;
var RADIO_ITEM_NAME4 = "MenubarRadioItem";
var MenubarRadioItem = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...radioItemProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime71.jsx)(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
  }
);
MenubarRadioItem.displayName = RADIO_ITEM_NAME4;
var INDICATOR_NAME4 = "MenubarItemIndicator";
var MenubarItemIndicator = React65.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return (0, import_jsx_runtime71.jsx)(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
MenubarItemIndicator.displayName = INDICATOR_NAME4;
var SEPARATOR_NAME4 = "MenubarSeparator";
var MenubarSeparator = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...separatorProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime71.jsx)(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
  }
);
MenubarSeparator.displayName = SEPARATOR_NAME4;
var ARROW_NAME6 = "MenubarArrow";
var MenubarArrow = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...arrowProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime71.jsx)(Arrow22, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
MenubarArrow.displayName = ARROW_NAME6;
var SUB_NAME3 = "MenubarSub";
var MenubarSub = (props) => {
  const { __scopeMenubar, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SUB_NAME3
  });
  return (0, import_jsx_runtime71.jsx)(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
MenubarSub.displayName = SUB_NAME3;
var SUB_TRIGGER_NAME4 = "MenubarSubTrigger";
var MenubarSubTrigger = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...subTriggerProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime71.jsx)(
      SubTrigger,
      {
        "data-radix-menubar-subtrigger": "",
        ...menuScope,
        ...subTriggerProps,
        ref: forwardedRef
      }
    );
  }
);
MenubarSubTrigger.displayName = SUB_TRIGGER_NAME4;
var SUB_CONTENT_NAME4 = "MenubarSubContent";
var MenubarSubContent = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...subContentProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime71.jsx)(
      SubContent,
      {
        ...menuScope,
        "data-radix-menubar-content": "",
        ...subContentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
            "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
            "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
MenubarSubContent.displayName = SUB_CONTENT_NAME4;
function wrapArray3(array2, startIndex) {
  return array2.map((_, index3) => array2[(startIndex + index3) % array2.length]);
}

// node_modules/@radix-ui/react-navigation-menu/dist/index.mjs
var React66 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var NAVIGATION_MENU_NAME = "NavigationMenu";
var [Collection5, useCollection5, createCollectionScope5] = createCollection(NAVIGATION_MENU_NAME);
var [FocusGroupCollection, useFocusGroupCollection, createFocusGroupCollectionScope] = createCollection(NAVIGATION_MENU_NAME);
var [createNavigationMenuContext, createNavigationMenuScope] = createContextScope(
  NAVIGATION_MENU_NAME,
  [createCollectionScope5, createFocusGroupCollectionScope]
);
var [NavigationMenuProviderImpl, useNavigationMenuContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);
var [ViewportContentProvider, useViewportContentContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);
var NavigationMenu = React66.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeNavigationMenu,
      value: valueProp,
      onValueChange,
      defaultValue,
      delayDuration = 200,
      skipDelayDuration = 300,
      orientation = "horizontal",
      dir,
      ...NavigationMenuProps
    } = props;
    const [navigationMenu, setNavigationMenu] = React66.useState(null);
    const composedRef = useComposedRefs(forwardedRef, (node) => setNavigationMenu(node));
    const direction = useDirection(dir);
    const openTimerRef = React66.useRef(0);
    const closeTimerRef = React66.useRef(0);
    const skipDelayTimerRef = React66.useRef(0);
    const [isOpenDelayed, setIsOpenDelayed] = React66.useState(true);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: (value2) => {
        const isOpen = value2 !== "";
        const hasSkipDelayDuration = skipDelayDuration > 0;
        if (isOpen) {
          window.clearTimeout(skipDelayTimerRef.current);
          if (hasSkipDelayDuration)
            setIsOpenDelayed(false);
        } else {
          window.clearTimeout(skipDelayTimerRef.current);
          skipDelayTimerRef.current = window.setTimeout(
            () => setIsOpenDelayed(true),
            skipDelayDuration
          );
        }
        onValueChange == null ? void 0 : onValueChange(value2);
      },
      defaultProp: defaultValue ?? "",
      caller: NAVIGATION_MENU_NAME
    });
    const startCloseTimer = React66.useCallback(() => {
      window.clearTimeout(closeTimerRef.current);
      closeTimerRef.current = window.setTimeout(() => setValue(""), 150);
    }, [setValue]);
    const handleOpen = React66.useCallback(
      (itemValue) => {
        window.clearTimeout(closeTimerRef.current);
        setValue(itemValue);
      },
      [setValue]
    );
    const handleDelayedOpen = React66.useCallback(
      (itemValue) => {
        const isOpenItem = value === itemValue;
        if (isOpenItem) {
          window.clearTimeout(closeTimerRef.current);
        } else {
          openTimerRef.current = window.setTimeout(() => {
            window.clearTimeout(closeTimerRef.current);
            setValue(itemValue);
          }, delayDuration);
        }
      },
      [value, setValue, delayDuration]
    );
    React66.useEffect(() => {
      return () => {
        window.clearTimeout(openTimerRef.current);
        window.clearTimeout(closeTimerRef.current);
        window.clearTimeout(skipDelayTimerRef.current);
      };
    }, []);
    return (0, import_jsx_runtime72.jsx)(
      NavigationMenuProvider,
      {
        scope: __scopeNavigationMenu,
        isRootMenu: true,
        value,
        dir: direction,
        orientation,
        rootNavigationMenu: navigationMenu,
        onTriggerEnter: (itemValue) => {
          window.clearTimeout(openTimerRef.current);
          if (isOpenDelayed)
            handleDelayedOpen(itemValue);
          else
            handleOpen(itemValue);
        },
        onTriggerLeave: () => {
          window.clearTimeout(openTimerRef.current);
          startCloseTimer();
        },
        onContentEnter: () => window.clearTimeout(closeTimerRef.current),
        onContentLeave: startCloseTimer,
        onItemSelect: (itemValue) => {
          setValue((prevValue) => prevValue === itemValue ? "" : itemValue);
        },
        onItemDismiss: () => setValue(""),
        children: (0, import_jsx_runtime72.jsx)(
          Primitive.nav,
          {
            "aria-label": "Main",
            "data-orientation": orientation,
            dir: direction,
            ...NavigationMenuProps,
            ref: composedRef
          }
        )
      }
    );
  }
);
NavigationMenu.displayName = NAVIGATION_MENU_NAME;
var SUB_NAME4 = "NavigationMenuSub";
var NavigationMenuSub = React66.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeNavigationMenu,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      ...subProps
    } = props;
    const context = useNavigationMenuContext(SUB_NAME4, __scopeNavigationMenu);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue ?? "",
      caller: SUB_NAME4
    });
    return (0, import_jsx_runtime72.jsx)(
      NavigationMenuProvider,
      {
        scope: __scopeNavigationMenu,
        isRootMenu: false,
        value,
        dir: context.dir,
        orientation,
        rootNavigationMenu: context.rootNavigationMenu,
        onTriggerEnter: (itemValue) => setValue(itemValue),
        onItemSelect: (itemValue) => setValue(itemValue),
        onItemDismiss: () => setValue(""),
        children: (0, import_jsx_runtime72.jsx)(Primitive.div, { "data-orientation": orientation, ...subProps, ref: forwardedRef })
      }
    );
  }
);
NavigationMenuSub.displayName = SUB_NAME4;
var NavigationMenuProvider = (props) => {
  const {
    scope,
    isRootMenu,
    rootNavigationMenu,
    dir,
    orientation,
    children,
    value,
    onItemSelect,
    onItemDismiss,
    onTriggerEnter,
    onTriggerLeave,
    onContentEnter,
    onContentLeave
  } = props;
  const [viewport2, setViewport] = React66.useState(null);
  const [viewportContent, setViewportContent] = React66.useState(/* @__PURE__ */ new Map());
  const [indicatorTrack, setIndicatorTrack] = React66.useState(null);
  return (0, import_jsx_runtime72.jsx)(
    NavigationMenuProviderImpl,
    {
      scope,
      isRootMenu,
      rootNavigationMenu,
      value,
      previousValue: usePrevious(value),
      baseId: useId2(),
      dir,
      orientation,
      viewport: viewport2,
      onViewportChange: setViewport,
      indicatorTrack,
      onIndicatorTrackChange: setIndicatorTrack,
      onTriggerEnter: useCallbackRef(onTriggerEnter),
      onTriggerLeave: useCallbackRef(onTriggerLeave),
      onContentEnter: useCallbackRef(onContentEnter),
      onContentLeave: useCallbackRef(onContentLeave),
      onItemSelect: useCallbackRef(onItemSelect),
      onItemDismiss: useCallbackRef(onItemDismiss),
      onViewportContentChange: React66.useCallback((contentValue, contentData) => {
        setViewportContent((prevContent) => {
          prevContent.set(contentValue, contentData);
          return new Map(prevContent);
        });
      }, []),
      onViewportContentRemove: React66.useCallback((contentValue) => {
        setViewportContent((prevContent) => {
          if (!prevContent.has(contentValue))
            return prevContent;
          prevContent.delete(contentValue);
          return new Map(prevContent);
        });
      }, []),
      children: (0, import_jsx_runtime72.jsx)(Collection5.Provider, { scope, children: (0, import_jsx_runtime72.jsx)(ViewportContentProvider, { scope, items: viewportContent, children }) })
    }
  );
};
var LIST_NAME = "NavigationMenuList";
var NavigationMenuList = React66.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, ...listProps } = props;
    const context = useNavigationMenuContext(LIST_NAME, __scopeNavigationMenu);
    const list = (0, import_jsx_runtime72.jsx)(Primitive.ul, { "data-orientation": context.orientation, ...listProps, ref: forwardedRef });
    return (0, import_jsx_runtime72.jsx)(Primitive.div, { style: { position: "relative" }, ref: context.onIndicatorTrackChange, children: (0, import_jsx_runtime72.jsx)(Collection5.Slot, { scope: __scopeNavigationMenu, children: context.isRootMenu ? (0, import_jsx_runtime72.jsx)(FocusGroup, { asChild: true, children: list }) : list }) });
  }
);
NavigationMenuList.displayName = LIST_NAME;
var ITEM_NAME7 = "NavigationMenuItem";
var [NavigationMenuItemContextProvider, useNavigationMenuItemContext] = createNavigationMenuContext(ITEM_NAME7);
var NavigationMenuItem = React66.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, value: valueProp, ...itemProps } = props;
    const autoValue = useId2();
    const value = valueProp || autoValue || "LEGACY_REACT_AUTO_VALUE";
    const contentRef = React66.useRef(null);
    const triggerRef = React66.useRef(null);
    const focusProxyRef = React66.useRef(null);
    const restoreContentTabOrderRef = React66.useRef(() => {
    });
    const wasEscapeCloseRef = React66.useRef(false);
    const handleContentEntry = React66.useCallback((side = "start") => {
      if (contentRef.current) {
        restoreContentTabOrderRef.current();
        const candidates = getTabbableCandidates2(contentRef.current);
        if (candidates.length)
          focusFirst4(side === "start" ? candidates : candidates.reverse());
      }
    }, []);
    const handleContentExit = React66.useCallback(() => {
      if (contentRef.current) {
        const candidates = getTabbableCandidates2(contentRef.current);
        if (candidates.length)
          restoreContentTabOrderRef.current = removeFromTabOrder(candidates);
      }
    }, []);
    return (0, import_jsx_runtime72.jsx)(
      NavigationMenuItemContextProvider,
      {
        scope: __scopeNavigationMenu,
        value,
        triggerRef,
        contentRef,
        focusProxyRef,
        wasEscapeCloseRef,
        onEntryKeyDown: handleContentEntry,
        onFocusProxyEnter: handleContentEntry,
        onRootContentClose: handleContentExit,
        onContentFocusOutside: handleContentExit,
        children: (0, import_jsx_runtime72.jsx)(Primitive.li, { ...itemProps, ref: forwardedRef })
      }
    );
  }
);
NavigationMenuItem.displayName = ITEM_NAME7;
var TRIGGER_NAME10 = "NavigationMenuTrigger";
var NavigationMenuTrigger = React66.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, disabled, ...triggerProps } = props;
  const context = useNavigationMenuContext(TRIGGER_NAME10, props.__scopeNavigationMenu);
  const itemContext = useNavigationMenuItemContext(TRIGGER_NAME10, props.__scopeNavigationMenu);
  const ref = React66.useRef(null);
  const composedRefs = useComposedRefs(ref, itemContext.triggerRef, forwardedRef);
  const triggerId = makeTriggerId(context.baseId, itemContext.value);
  const contentId = makeContentId(context.baseId, itemContext.value);
  const hasPointerMoveOpenedRef = React66.useRef(false);
  const wasClickCloseRef = React66.useRef(false);
  const open = itemContext.value === context.value;
  return (0, import_jsx_runtime72.jsxs)(import_jsx_runtime72.Fragment, { children: [
    (0, import_jsx_runtime72.jsx)(Collection5.ItemSlot, { scope: __scopeNavigationMenu, value: itemContext.value, children: (0, import_jsx_runtime72.jsx)(FocusGroupItem, { asChild: true, children: (0, import_jsx_runtime72.jsx)(
      Primitive.button,
      {
        id: triggerId,
        disabled,
        "data-disabled": disabled ? "" : void 0,
        "data-state": getOpenState2(open),
        "aria-expanded": open,
        "aria-controls": contentId,
        ...triggerProps,
        ref: composedRefs,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, () => {
          wasClickCloseRef.current = false;
          itemContext.wasEscapeCloseRef.current = false;
        }),
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse2(() => {
            if (disabled || wasClickCloseRef.current || itemContext.wasEscapeCloseRef.current || hasPointerMoveOpenedRef.current)
              return;
            context.onTriggerEnter(itemContext.value);
            hasPointerMoveOpenedRef.current = true;
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse2(() => {
            if (disabled)
              return;
            context.onTriggerLeave();
            hasPointerMoveOpenedRef.current = false;
          })
        ),
        onClick: composeEventHandlers(props.onClick, () => {
          context.onItemSelect(itemContext.value);
          wasClickCloseRef.current = open;
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const verticalEntryKey = context.dir === "rtl" ? "ArrowLeft" : "ArrowRight";
          const entryKey = { horizontal: "ArrowDown", vertical: verticalEntryKey }[context.orientation];
          if (open && event.key === entryKey) {
            itemContext.onEntryKeyDown();
            event.preventDefault();
          }
        })
      }
    ) }) }),
    open && (0, import_jsx_runtime72.jsxs)(import_jsx_runtime72.Fragment, { children: [
      (0, import_jsx_runtime72.jsx)(
        Root2,
        {
          "aria-hidden": true,
          tabIndex: 0,
          ref: itemContext.focusProxyRef,
          onFocus: (event) => {
            const content = itemContext.contentRef.current;
            const prevFocusedElement = event.relatedTarget;
            const wasTriggerFocused = prevFocusedElement === ref.current;
            const wasFocusFromContent = content == null ? void 0 : content.contains(prevFocusedElement);
            if (wasTriggerFocused || !wasFocusFromContent) {
              itemContext.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
            }
          }
        }
      ),
      context.viewport && (0, import_jsx_runtime72.jsx)("span", { "aria-owns": contentId })
    ] })
  ] });
});
NavigationMenuTrigger.displayName = TRIGGER_NAME10;
var LINK_NAME = "NavigationMenuLink";
var LINK_SELECT = "navigationMenu.linkSelect";
var NavigationMenuLink = React66.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, active, onSelect, ...linkProps } = props;
    return (0, import_jsx_runtime72.jsx)(FocusGroupItem, { asChild: true, children: (0, import_jsx_runtime72.jsx)(
      Primitive.a,
      {
        "data-active": active ? "" : void 0,
        "aria-current": active ? "page" : void 0,
        ...linkProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(
          props.onClick,
          (event) => {
            const target = event.target;
            const linkSelectEvent = new CustomEvent(LINK_SELECT, {
              bubbles: true,
              cancelable: true
            });
            target.addEventListener(LINK_SELECT, (event2) => onSelect == null ? void 0 : onSelect(event2), { once: true });
            dispatchDiscreteCustomEvent(target, linkSelectEvent);
            if (!linkSelectEvent.defaultPrevented && !event.metaKey) {
              const rootContentDismissEvent = new CustomEvent(ROOT_CONTENT_DISMISS, {
                bubbles: true,
                cancelable: true
              });
              dispatchDiscreteCustomEvent(target, rootContentDismissEvent);
            }
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
NavigationMenuLink.displayName = LINK_NAME;
var INDICATOR_NAME5 = "NavigationMenuIndicator";
var NavigationMenuIndicator = React66.forwardRef((props, forwardedRef) => {
  const { forceMount, ...indicatorProps } = props;
  const context = useNavigationMenuContext(INDICATOR_NAME5, props.__scopeNavigationMenu);
  const isVisible = Boolean(context.value);
  return context.indicatorTrack ? import_react_dom5.default.createPortal(
    (0, import_jsx_runtime72.jsx)(Presence, { present: forceMount || isVisible, children: (0, import_jsx_runtime72.jsx)(NavigationMenuIndicatorImpl, { ...indicatorProps, ref: forwardedRef }) }),
    context.indicatorTrack
  ) : null;
});
NavigationMenuIndicator.displayName = INDICATOR_NAME5;
var NavigationMenuIndicatorImpl = React66.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, ...indicatorProps } = props;
  const context = useNavigationMenuContext(INDICATOR_NAME5, __scopeNavigationMenu);
  const getItems = useCollection5(__scopeNavigationMenu);
  const [activeTrigger, setActiveTrigger] = React66.useState(
    null
  );
  const [position, setPosition] = React66.useState(null);
  const isHorizontal = context.orientation === "horizontal";
  const isVisible = Boolean(context.value);
  React66.useEffect(() => {
    var _a5;
    const items = getItems();
    const triggerNode = (_a5 = items.find((item) => item.value === context.value)) == null ? void 0 : _a5.ref.current;
    if (triggerNode)
      setActiveTrigger(triggerNode);
  }, [getItems, context.value]);
  const handlePositionChange = () => {
    if (activeTrigger) {
      setPosition({
        size: isHorizontal ? activeTrigger.offsetWidth : activeTrigger.offsetHeight,
        offset: isHorizontal ? activeTrigger.offsetLeft : activeTrigger.offsetTop
      });
    }
  };
  useResizeObserver(activeTrigger, handlePositionChange);
  useResizeObserver(context.indicatorTrack, handlePositionChange);
  return position ? (0, import_jsx_runtime72.jsx)(
    Primitive.div,
    {
      "aria-hidden": true,
      "data-state": isVisible ? "visible" : "hidden",
      "data-orientation": context.orientation,
      ...indicatorProps,
      ref: forwardedRef,
      style: {
        position: "absolute",
        ...isHorizontal ? {
          left: 0,
          width: position.size + "px",
          transform: `translateX(${position.offset}px)`
        } : {
          top: 0,
          height: position.size + "px",
          transform: `translateY(${position.offset}px)`
        },
        ...indicatorProps.style
      }
    }
  ) : null;
});
var CONTENT_NAME11 = "NavigationMenuContent";
var NavigationMenuContent = React66.forwardRef((props, forwardedRef) => {
  const { forceMount, ...contentProps } = props;
  const context = useNavigationMenuContext(CONTENT_NAME11, props.__scopeNavigationMenu);
  const itemContext = useNavigationMenuItemContext(CONTENT_NAME11, props.__scopeNavigationMenu);
  const composedRefs = useComposedRefs(itemContext.contentRef, forwardedRef);
  const open = itemContext.value === context.value;
  const commonProps = {
    value: itemContext.value,
    triggerRef: itemContext.triggerRef,
    focusProxyRef: itemContext.focusProxyRef,
    wasEscapeCloseRef: itemContext.wasEscapeCloseRef,
    onContentFocusOutside: itemContext.onContentFocusOutside,
    onRootContentClose: itemContext.onRootContentClose,
    ...contentProps
  };
  return !context.viewport ? (0, import_jsx_runtime72.jsx)(Presence, { present: forceMount || open, children: (0, import_jsx_runtime72.jsx)(
    NavigationMenuContentImpl,
    {
      "data-state": getOpenState2(open),
      ...commonProps,
      ref: composedRefs,
      onPointerEnter: composeEventHandlers(props.onPointerEnter, context.onContentEnter),
      onPointerLeave: composeEventHandlers(
        props.onPointerLeave,
        whenMouse2(context.onContentLeave)
      ),
      style: {
        // Prevent interaction when animating out
        pointerEvents: !open && context.isRootMenu ? "none" : void 0,
        ...commonProps.style
      }
    }
  ) }) : (0, import_jsx_runtime72.jsx)(ViewportContentMounter, { forceMount, ...commonProps, ref: composedRefs });
});
NavigationMenuContent.displayName = CONTENT_NAME11;
var ViewportContentMounter = React66.forwardRef((props, forwardedRef) => {
  const context = useNavigationMenuContext(CONTENT_NAME11, props.__scopeNavigationMenu);
  const { onViewportContentChange, onViewportContentRemove } = context;
  useLayoutEffect22(() => {
    onViewportContentChange(props.value, {
      ref: forwardedRef,
      ...props
    });
  }, [props, forwardedRef, onViewportContentChange]);
  useLayoutEffect22(() => {
    return () => onViewportContentRemove(props.value);
  }, [props.value, onViewportContentRemove]);
  return null;
});
var ROOT_CONTENT_DISMISS = "navigationMenu.rootContentDismiss";
var NavigationMenuContentImpl = React66.forwardRef((props, forwardedRef) => {
  const {
    __scopeNavigationMenu,
    value,
    triggerRef,
    focusProxyRef,
    wasEscapeCloseRef,
    onRootContentClose,
    onContentFocusOutside,
    ...contentProps
  } = props;
  const context = useNavigationMenuContext(CONTENT_NAME11, __scopeNavigationMenu);
  const ref = React66.useRef(null);
  const composedRefs = useComposedRefs(ref, forwardedRef);
  const triggerId = makeTriggerId(context.baseId, value);
  const contentId = makeContentId(context.baseId, value);
  const getItems = useCollection5(__scopeNavigationMenu);
  const prevMotionAttributeRef = React66.useRef(null);
  const { onItemDismiss } = context;
  React66.useEffect(() => {
    const content = ref.current;
    if (context.isRootMenu && content) {
      const handleClose = () => {
        var _a5;
        onItemDismiss();
        onRootContentClose();
        if (content.contains(document.activeElement))
          (_a5 = triggerRef.current) == null ? void 0 : _a5.focus();
      };
      content.addEventListener(ROOT_CONTENT_DISMISS, handleClose);
      return () => content.removeEventListener(ROOT_CONTENT_DISMISS, handleClose);
    }
  }, [context.isRootMenu, props.value, triggerRef, onItemDismiss, onRootContentClose]);
  const motionAttribute = React66.useMemo(() => {
    const items = getItems();
    const values = items.map((item) => item.value);
    if (context.dir === "rtl")
      values.reverse();
    const index3 = values.indexOf(context.value);
    const prevIndex = values.indexOf(context.previousValue);
    const isSelected = value === context.value;
    const wasSelected = prevIndex === values.indexOf(value);
    if (!isSelected && !wasSelected)
      return prevMotionAttributeRef.current;
    const attribute = (() => {
      if (index3 !== prevIndex) {
        if (isSelected && prevIndex !== -1)
          return index3 > prevIndex ? "from-end" : "from-start";
        if (wasSelected && index3 !== -1)
          return index3 > prevIndex ? "to-start" : "to-end";
      }
      return null;
    })();
    prevMotionAttributeRef.current = attribute;
    return attribute;
  }, [context.previousValue, context.value, context.dir, getItems, value]);
  return (0, import_jsx_runtime72.jsx)(FocusGroup, { asChild: true, children: (0, import_jsx_runtime72.jsx)(
    DismissableLayer,
    {
      id: contentId,
      "aria-labelledby": triggerId,
      "data-motion": motionAttribute,
      "data-orientation": context.orientation,
      ...contentProps,
      ref: composedRefs,
      disableOutsidePointerEvents: false,
      onDismiss: () => {
        var _a5;
        const rootContentDismissEvent = new Event(ROOT_CONTENT_DISMISS, {
          bubbles: true,
          cancelable: true
        });
        (_a5 = ref.current) == null ? void 0 : _a5.dispatchEvent(rootContentDismissEvent);
      },
      onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
        var _a5;
        onContentFocusOutside();
        const target = event.target;
        if ((_a5 = context.rootNavigationMenu) == null ? void 0 : _a5.contains(target))
          event.preventDefault();
      }),
      onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
        var _a5;
        const target = event.target;
        const isTrigger = getItems().some((item) => {
          var _a6;
          return (_a6 = item.ref.current) == null ? void 0 : _a6.contains(target);
        });
        const isRootViewport = context.isRootMenu && ((_a5 = context.viewport) == null ? void 0 : _a5.contains(target));
        if (isTrigger || isRootViewport || !context.isRootMenu)
          event.preventDefault();
      }),
      onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
        var _a5;
        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
        const isTabKey = event.key === "Tab" && !isMetaKey;
        if (isTabKey) {
          const candidates = getTabbableCandidates2(event.currentTarget);
          const focusedElement = document.activeElement;
          const index3 = candidates.findIndex((candidate) => candidate === focusedElement);
          const isMovingBackwards = event.shiftKey;
          const nextCandidates = isMovingBackwards ? candidates.slice(0, index3).reverse() : candidates.slice(index3 + 1, candidates.length);
          if (focusFirst4(nextCandidates)) {
            event.preventDefault();
          } else {
            (_a5 = focusProxyRef.current) == null ? void 0 : _a5.focus();
          }
        }
      }),
      onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (_event) => {
        wasEscapeCloseRef.current = true;
      })
    }
  ) });
});
var VIEWPORT_NAME = "NavigationMenuViewport";
var NavigationMenuViewport = React66.forwardRef((props, forwardedRef) => {
  const { forceMount, ...viewportProps } = props;
  const context = useNavigationMenuContext(VIEWPORT_NAME, props.__scopeNavigationMenu);
  const open = Boolean(context.value);
  return (0, import_jsx_runtime72.jsx)(Presence, { present: forceMount || open, children: (0, import_jsx_runtime72.jsx)(NavigationMenuViewportImpl, { ...viewportProps, ref: forwardedRef }) });
});
NavigationMenuViewport.displayName = VIEWPORT_NAME;
var NavigationMenuViewportImpl = React66.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, children, ...viewportImplProps } = props;
  const context = useNavigationMenuContext(VIEWPORT_NAME, __scopeNavigationMenu);
  const composedRefs = useComposedRefs(forwardedRef, context.onViewportChange);
  const viewportContentContext = useViewportContentContext(
    CONTENT_NAME11,
    props.__scopeNavigationMenu
  );
  const [size4, setSize] = React66.useState(null);
  const [content, setContent3] = React66.useState(null);
  const viewportWidth = size4 ? (size4 == null ? void 0 : size4.width) + "px" : void 0;
  const viewportHeight = size4 ? (size4 == null ? void 0 : size4.height) + "px" : void 0;
  const open = Boolean(context.value);
  const activeContentValue = open ? context.value : context.previousValue;
  const handleSizeChange = () => {
    if (content)
      setSize({ width: content.offsetWidth, height: content.offsetHeight });
  };
  useResizeObserver(content, handleSizeChange);
  return (0, import_jsx_runtime72.jsx)(
    Primitive.div,
    {
      "data-state": getOpenState2(open),
      "data-orientation": context.orientation,
      ...viewportImplProps,
      ref: composedRefs,
      style: {
        // Prevent interaction when animating out
        pointerEvents: !open && context.isRootMenu ? "none" : void 0,
        ["--radix-navigation-menu-viewport-width"]: viewportWidth,
        ["--radix-navigation-menu-viewport-height"]: viewportHeight,
        ...viewportImplProps.style
      },
      onPointerEnter: composeEventHandlers(props.onPointerEnter, context.onContentEnter),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse2(context.onContentLeave)),
      children: Array.from(viewportContentContext.items).map(([value, { ref, forceMount, ...props2 }]) => {
        const isActive2 = activeContentValue === value;
        return (0, import_jsx_runtime72.jsx)(Presence, { present: forceMount || isActive2, children: (0, import_jsx_runtime72.jsx)(
          NavigationMenuContentImpl,
          {
            ...props2,
            ref: composeRefs(ref, (node) => {
              if (isActive2 && node)
                setContent3(node);
            })
          }
        ) }, value);
      })
    }
  );
});
var FOCUS_GROUP_NAME = "FocusGroup";
var FocusGroup = React66.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, ...groupProps } = props;
    const context = useNavigationMenuContext(FOCUS_GROUP_NAME, __scopeNavigationMenu);
    return (0, import_jsx_runtime72.jsx)(FocusGroupCollection.Provider, { scope: __scopeNavigationMenu, children: (0, import_jsx_runtime72.jsx)(FocusGroupCollection.Slot, { scope: __scopeNavigationMenu, children: (0, import_jsx_runtime72.jsx)(Primitive.div, { dir: context.dir, ...groupProps, ref: forwardedRef }) }) });
  }
);
var ARROW_KEYS = ["ArrowRight", "ArrowLeft", "ArrowUp", "ArrowDown"];
var FOCUS_GROUP_ITEM_NAME = "FocusGroupItem";
var FocusGroupItem = React66.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, ...groupProps } = props;
    const getItems = useFocusGroupCollection(__scopeNavigationMenu);
    const context = useNavigationMenuContext(FOCUS_GROUP_ITEM_NAME, __scopeNavigationMenu);
    return (0, import_jsx_runtime72.jsx)(FocusGroupCollection.ItemSlot, { scope: __scopeNavigationMenu, children: (0, import_jsx_runtime72.jsx)(
      Primitive.button,
      {
        ...groupProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isFocusNavigationKey = ["Home", "End", ...ARROW_KEYS].includes(event.key);
          if (isFocusNavigationKey) {
            let candidateNodes = getItems().map((item) => item.ref.current);
            const prevItemKey = context.dir === "rtl" ? "ArrowRight" : "ArrowLeft";
            const prevKeys = [prevItemKey, "ArrowUp", "End"];
            if (prevKeys.includes(event.key))
              candidateNodes.reverse();
            if (ARROW_KEYS.includes(event.key)) {
              const currentIndex = candidateNodes.indexOf(event.currentTarget);
              candidateNodes = candidateNodes.slice(currentIndex + 1);
            }
            setTimeout(() => focusFirst4(candidateNodes));
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
function getTabbableCandidates2(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst4(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement)
      return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
function removeFromTabOrder(candidates) {
  candidates.forEach((candidate) => {
    candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
    candidate.setAttribute("tabindex", "-1");
  });
  return () => {
    candidates.forEach((candidate) => {
      const prevTabIndex = candidate.dataset.tabindex;
      candidate.setAttribute("tabindex", prevTabIndex);
    });
  };
}
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef(onResize);
  useLayoutEffect22(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
function getOpenState2(open) {
  return open ? "open" : "closed";
}
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
function whenMouse2(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}

// node_modules/@radix-ui/react-one-time-password-field/dist/index.mjs
var React67 = __toESM(require_react(), 1);
var import_react_dom6 = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/number/dist/index.mjs
function clamp4(value, [min4, max3]) {
  return Math.min(max3, Math.max(min4, value));
}

// node_modules/@radix-ui/react-one-time-password-field/dist/index.mjs
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var INPUT_VALIDATION_MAP = {
  numeric: {
    type: "numeric",
    regexp: /[^\d]/g,
    pattern: "\\d{1}",
    inputMode: "numeric"
  },
  alpha: {
    type: "alpha",
    regexp: /[^a-zA-Z]/g,
    pattern: "[a-zA-Z]{1}",
    inputMode: "text"
  },
  alphanumeric: {
    type: "alphanumeric",
    regexp: /[^a-zA-Z0-9]/g,
    pattern: "[a-zA-Z0-9]{1}",
    inputMode: "text"
  },
  none: null
};
var ONE_TIME_PASSWORD_FIELD_NAME = "OneTimePasswordField";
var [Collection6, { useCollection: useCollection6, createCollectionScope: createCollectionScope6, useInitCollection }] = createCollection2(ONE_TIME_PASSWORD_FIELD_NAME);
var [createOneTimePasswordFieldContext] = createContextScope(ONE_TIME_PASSWORD_FIELD_NAME, [
  createCollectionScope6,
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope3 = createRovingFocusGroupScope();
var [OneTimePasswordFieldContext, useOneTimePasswordFieldContext] = createOneTimePasswordFieldContext(ONE_TIME_PASSWORD_FIELD_NAME);
var OneTimePasswordField = React67.forwardRef(
  function OneTimePasswordFieldImpl({
    __scopeOneTimePasswordField,
    defaultValue,
    value: valueProp,
    onValueChange,
    autoSubmit = false,
    children,
    onPaste,
    onAutoSubmit,
    disabled = false,
    readOnly = false,
    autoComplete = "one-time-code",
    autoFocus = false,
    form,
    name,
    placeholder,
    type = "text",
    // TODO: Change default to vertical when inputs use vertical writing mode
    orientation = "horizontal",
    dir,
    validationType = "numeric",
    sanitizeValue: sanitizeValueProp,
    ...domProps
  }, forwardedRef) {
    var _a5;
    const rovingFocusGroupScope = useRovingFocusGroupScope3(__scopeOneTimePasswordField);
    const direction = useDirection(dir);
    const collectionState = useInitCollection();
    const [collection] = collectionState;
    const validation = INPUT_VALIDATION_MAP[validationType] ? INPUT_VALIDATION_MAP[validationType] : null;
    const sanitizeValue = React67.useCallback(
      (value2) => {
        if (Array.isArray(value2)) {
          value2 = value2.map(removeWhitespace).join("");
        } else {
          value2 = removeWhitespace(value2);
        }
        if (validation) {
          const regexp2 = new RegExp(validation.regexp);
          value2 = value2.replace(regexp2, "");
        } else if (sanitizeValueProp) {
          value2 = sanitizeValueProp(value2);
        }
        return value2.split("");
      },
      [validation, sanitizeValueProp]
    );
    const controlledValue = React67.useMemo(() => {
      return valueProp != null ? sanitizeValue(valueProp) : void 0;
    }, [valueProp, sanitizeValue]);
    const [value, setValue] = useControllableState({
      caller: "OneTimePasswordField",
      prop: controlledValue,
      defaultProp: defaultValue != null ? sanitizeValue(defaultValue) : [],
      onChange: React67.useCallback(
        (value2) => onValueChange == null ? void 0 : onValueChange(value2.join("")),
        [onValueChange]
      )
    });
    const dispatch2 = useEffectEvent((action) => {
      var _a6, _b, _c, _d, _e, _f, _g, _h, _i;
      switch (action.type) {
        case "SET_CHAR": {
          const { index: index3, char } = action;
          const currentTarget = (_a6 = collection.at(index3)) == null ? void 0 : _a6.element;
          if (value[index3] === char) {
            const next = currentTarget && ((_b = collection.from(currentTarget, 1)) == null ? void 0 : _b.element);
            focusInput(next);
            return;
          }
          if (char === "") {
            return;
          }
          if (validation) {
            const regexp2 = new RegExp(validation.regexp);
            const clean2 = char.replace(regexp2, "");
            if (clean2 !== char) {
              return;
            }
          }
          if (value.length >= collection.size) {
            const newValue2 = [...value];
            newValue2[index3] = char;
            (0, import_react_dom6.flushSync)(() => setValue(newValue2));
            const next = currentTarget && ((_c = collection.from(currentTarget, 1)) == null ? void 0 : _c.element);
            focusInput(next);
            return;
          }
          const newValue = [...value];
          newValue[index3] = char;
          const lastElement = (_d = collection.at(-1)) == null ? void 0 : _d.element;
          (0, import_react_dom6.flushSync)(() => setValue(newValue));
          if (currentTarget !== lastElement) {
            const next = currentTarget && ((_e = collection.from(currentTarget, 1)) == null ? void 0 : _e.element);
            focusInput(next);
          } else {
            currentTarget == null ? void 0 : currentTarget.select();
          }
          return;
        }
        case "CLEAR_CHAR": {
          const { index: index3, reason } = action;
          if (!value[index3]) {
            return;
          }
          const newValue = value.filter((_, i) => i !== index3);
          const currentTarget = (_f = collection.at(index3)) == null ? void 0 : _f.element;
          const previous = currentTarget && ((_g = collection.from(currentTarget, -1)) == null ? void 0 : _g.element);
          (0, import_react_dom6.flushSync)(() => setValue(newValue));
          if (reason === "Backspace") {
            focusInput(previous);
          } else if (reason === "Delete" || reason === "Cut") {
            focusInput(currentTarget);
          }
          return;
        }
        case "CLEAR": {
          if (value.length === 0) {
            return;
          }
          if (action.reason === "Backspace" || action.reason === "Delete") {
            (0, import_react_dom6.flushSync)(() => setValue([]));
            focusInput((_h = collection.at(0)) == null ? void 0 : _h.element);
          } else {
            setValue([]);
          }
          return;
        }
        case "PASTE": {
          const { value: pastedValue } = action;
          const value2 = sanitizeValue(pastedValue);
          if (!value2) {
            return;
          }
          (0, import_react_dom6.flushSync)(() => setValue(value2));
          focusInput((_i = collection.at(value2.length - 1)) == null ? void 0 : _i.element);
          return;
        }
      }
    });
    const validationTypeRef = React67.useRef(validation);
    React67.useEffect(() => {
      var _a6;
      if (!validation) {
        return;
      }
      if (((_a6 = validationTypeRef.current) == null ? void 0 : _a6.type) !== validation.type) {
        validationTypeRef.current = validation;
        setValue(sanitizeValue(value.join("")));
      }
    }, [sanitizeValue, setValue, validation, value]);
    const hiddenInputRef = React67.useRef(null);
    const userActionRef = React67.useRef(null);
    const rootRef = React67.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, rootRef);
    const firstInput = (_a5 = collection.at(0)) == null ? void 0 : _a5.element;
    const locateForm = React67.useCallback(() => {
      var _a6;
      let formElement;
      if (form) {
        const associatedElement = (((_a6 = rootRef.current) == null ? void 0 : _a6.ownerDocument) ?? document).getElementById(form);
        if (isFormElement(associatedElement)) {
          formElement = associatedElement;
        }
      } else if (hiddenInputRef.current) {
        formElement = hiddenInputRef.current.form;
      } else if (firstInput) {
        formElement = firstInput.form;
      }
      return formElement ?? null;
    }, [form, firstInput]);
    const attemptSubmit = React67.useCallback(() => {
      const formElement = locateForm();
      formElement == null ? void 0 : formElement.requestSubmit();
    }, [locateForm]);
    React67.useEffect(() => {
      const form2 = locateForm();
      if (form2) {
        const reset2 = () => dispatch2({ type: "CLEAR", reason: "Reset" });
        form2.addEventListener("reset", reset2);
        return () => form2.removeEventListener("reset", reset2);
      }
    }, [dispatch2, locateForm]);
    const currentValue = value.join("");
    const valueRef = React67.useRef(currentValue);
    const length = collection.size;
    React67.useEffect(() => {
      const previousValue = valueRef.current;
      valueRef.current = currentValue;
      if (previousValue === currentValue) {
        return;
      }
      if (autoSubmit && value.every((char) => char !== "") && value.length === length) {
        onAutoSubmit == null ? void 0 : onAutoSubmit(value.join(""));
        attemptSubmit();
      }
    }, [attemptSubmit, autoSubmit, currentValue, length, onAutoSubmit, value]);
    const isHydrated = useIsHydrated();
    return (0, import_jsx_runtime73.jsx)(
      OneTimePasswordFieldContext,
      {
        scope: __scopeOneTimePasswordField,
        value,
        attemptSubmit,
        disabled,
        readOnly,
        autoComplete,
        autoFocus,
        form,
        name,
        placeholder,
        type,
        hiddenInputRef,
        userActionRef,
        dispatch: dispatch2,
        validationType,
        orientation,
        isHydrated,
        sanitizeValue,
        children: (0, import_jsx_runtime73.jsx)(Collection6.Provider, { scope: __scopeOneTimePasswordField, state: collectionState, children: (0, import_jsx_runtime73.jsx)(Collection6.Slot, { scope: __scopeOneTimePasswordField, children: (0, import_jsx_runtime73.jsx)(
          Root7,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation,
            dir: direction,
            children: (0, import_jsx_runtime73.jsx)(
              Root.div,
              {
                ...domProps,
                role: "group",
                ref: composedRefs,
                onPaste: composeEventHandlers(
                  onPaste,
                  (event) => {
                    event.preventDefault();
                    const pastedValue = event.clipboardData.getData("Text");
                    dispatch2({ type: "PASTE", value: pastedValue });
                  }
                ),
                children
              }
            )
          }
        ) }) })
      }
    );
  }
);
var OneTimePasswordFieldHiddenInput = React67.forwardRef(function OneTimePasswordFieldHiddenInput2({ __scopeOneTimePasswordField, ...props }, forwardedRef) {
  const { value, hiddenInputRef, name } = useOneTimePasswordFieldContext(
    "OneTimePasswordFieldHiddenInput",
    __scopeOneTimePasswordField
  );
  const ref = useComposedRefs(hiddenInputRef, forwardedRef);
  return (0, import_jsx_runtime73.jsx)(
    "input",
    {
      ref,
      name,
      value: value.join("").trim(),
      autoComplete: "off",
      autoFocus: false,
      autoCapitalize: "off",
      autoCorrect: "off",
      autoSave: "off",
      spellCheck: false,
      ...props,
      type: "hidden",
      readOnly: true
    }
  );
});
var OneTimePasswordFieldInput = React67.forwardRef(function OneTimePasswordFieldInput2({
  __scopeOneTimePasswordField,
  onInvalidChange,
  index: indexProp,
  ...props
}, forwardedRef) {
  const {
    value: _value,
    defaultValue: _defaultValue,
    disabled: _disabled,
    readOnly: _readOnly,
    autoComplete: _autoComplete,
    autoFocus: _autoFocus,
    form: _form,
    name: _name,
    placeholder: _placeholder,
    type: _type,
    ...domProps
  } = props;
  const context = useOneTimePasswordFieldContext(
    "OneTimePasswordFieldInput",
    __scopeOneTimePasswordField
  );
  const { dispatch: dispatch2, userActionRef, validationType, isHydrated } = context;
  const collection = useCollection6(__scopeOneTimePasswordField);
  const rovingFocusGroupScope = useRovingFocusGroupScope3(__scopeOneTimePasswordField);
  const inputRef = React67.useRef(null);
  const [element, setElement] = React67.useState(null);
  const index3 = indexProp ?? (element ? collection.indexOf(element) : -1);
  const canSetPlaceholder = indexProp != null || isHydrated;
  let placeholder;
  if (canSetPlaceholder && context.placeholder && context.value.length === 0) {
    placeholder = context.placeholder[index3];
  }
  const composedInputRef = useComposedRefs(forwardedRef, inputRef, setElement);
  const char = context.value[index3] ?? "";
  const keyboardActionTimeoutRef = React67.useRef(null);
  React67.useEffect(() => {
    return () => {
      window.clearTimeout(keyboardActionTimeoutRef.current);
    };
  }, []);
  const totalValue = context.value.join("").trim();
  const lastSelectableIndex = clamp4(totalValue.length, [0, collection.size - 1]);
  const isFocusable = index3 <= lastSelectableIndex;
  const validation = validationType in INPUT_VALIDATION_MAP ? INPUT_VALIDATION_MAP[validationType] : void 0;
  return (0, import_jsx_runtime73.jsx)(Collection6.ItemSlot, { scope: __scopeOneTimePasswordField, children: (0, import_jsx_runtime73.jsx)(
    Item,
    {
      ...rovingFocusGroupScope,
      asChild: true,
      focusable: !context.disabled && isFocusable,
      active: index3 === lastSelectableIndex,
      children: ({ hasTabStop, isCurrentTabStop }) => {
        const supportsAutoComplete = hasTabStop ? isCurrentTabStop : index3 === 0;
        return (0, import_jsx_runtime73.jsx)(
          Root.input,
          {
            ref: composedInputRef,
            type: context.type,
            "aria-label": `Character ${index3 + 1} of ${collection.size}`,
            autoComplete: supportsAutoComplete ? context.autoComplete : "off",
            "data-1p-ignore": supportsAutoComplete ? void 0 : "true",
            "data-lpignore": supportsAutoComplete ? void 0 : "true",
            "data-protonpass-ignore": supportsAutoComplete ? void 0 : "true",
            "data-bwignore": supportsAutoComplete ? void 0 : "true",
            inputMode: validation == null ? void 0 : validation.inputMode,
            maxLength: 1,
            pattern: validation == null ? void 0 : validation.pattern,
            readOnly: context.readOnly,
            value: char,
            placeholder,
            "data-radix-otp-input": "",
            "data-radix-index": index3,
            ...domProps,
            onFocus: composeEventHandlers(props.onFocus, (event) => {
              event.currentTarget.select();
            }),
            onCut: composeEventHandlers(props.onCut, (event) => {
              const currentValue = event.currentTarget.value;
              if (currentValue !== "") {
                userActionRef.current = {
                  type: "cut"
                };
                keyboardActionTimeoutRef.current = window.setTimeout(() => {
                  userActionRef.current = null;
                }, 10);
              }
            }),
            onInput: composeEventHandlers(props.onInput, (event) => {
              const value = event.currentTarget.value;
              if (value.length > 1) {
                event.preventDefault();
                dispatch2({ type: "PASTE", value });
              }
            }),
            onChange: composeEventHandlers(props.onChange, (event) => {
              const value = event.target.value;
              event.preventDefault();
              const action = userActionRef.current;
              userActionRef.current = null;
              if (action) {
                switch (action.type) {
                  case "cut":
                    dispatch2({ type: "CLEAR_CHAR", index: index3, reason: "Cut" });
                    return;
                  case "keydown": {
                    if (action.key === "Char") {
                      return;
                    }
                    const isClearing = action.key === "Backspace" && (action.metaKey || action.ctrlKey);
                    if (action.key === "Clear" || isClearing) {
                      dispatch2({ type: "CLEAR", reason: "Backspace" });
                    } else {
                      dispatch2({ type: "CLEAR_CHAR", index: index3, reason: action.key });
                    }
                    return;
                  }
                  default:
                    return;
                }
              }
              if (event.target.validity.valid) {
                if (value === "") {
                  let reason = "Backspace";
                  if (isInputEvent(event.nativeEvent)) {
                    const inputType = event.nativeEvent.inputType;
                    if (inputType === "deleteContentBackward") {
                      reason = "Backspace";
                    } else if (inputType === "deleteByCut") {
                      reason = "Cut";
                    }
                  }
                  dispatch2({ type: "CLEAR_CHAR", index: index3, reason });
                } else {
                  dispatch2({ type: "SET_CHAR", char: value, index: index3, event });
                }
              } else {
                const element2 = event.target;
                onInvalidChange == null ? void 0 : onInvalidChange(element2.value);
                requestAnimationFrame(() => {
                  if (element2.ownerDocument.activeElement === element2) {
                    element2.select();
                  }
                });
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              var _a5, _b, _c;
              switch (event.key) {
                case "Clear":
                case "Delete":
                case "Backspace": {
                  const currentValue = event.currentTarget.value;
                  if (currentValue === "") {
                    if (event.key === "Delete")
                      return;
                    const isClearing = event.key === "Clear" || event.metaKey || event.ctrlKey;
                    if (isClearing) {
                      dispatch2({ type: "CLEAR", reason: "Backspace" });
                    } else {
                      const element2 = event.currentTarget;
                      requestAnimationFrame(() => {
                        var _a6;
                        focusInput((_a6 = collection.from(element2, -1)) == null ? void 0 : _a6.element);
                      });
                    }
                  } else {
                    userActionRef.current = {
                      type: "keydown",
                      key: event.key,
                      metaKey: event.metaKey,
                      ctrlKey: event.ctrlKey
                    };
                    keyboardActionTimeoutRef.current = window.setTimeout(() => {
                      userActionRef.current = null;
                    }, 10);
                  }
                  return;
                }
                case "Enter": {
                  event.preventDefault();
                  context.attemptSubmit();
                  return;
                }
                case "ArrowDown":
                case "ArrowUp": {
                  if (context.orientation === "horizontal") {
                    event.preventDefault();
                  }
                  return;
                }
                default: {
                  if (event.currentTarget.value === event.key) {
                    const element2 = event.currentTarget;
                    event.preventDefault();
                    focusInput((_a5 = collection.from(element2, 1)) == null ? void 0 : _a5.element);
                    return;
                  } else if (
                    // input already has a value, but...
                    event.currentTarget.value && // the value is not selected
                    !(event.currentTarget.selectionStart === 0 && event.currentTarget.selectionEnd != null && event.currentTarget.selectionEnd > 0)
                  ) {
                    const attemptedValue = event.key;
                    if (event.key.length > 1 || event.key === " ") {
                      return;
                    } else {
                      const nextInput = (_b = collection.from(event.currentTarget, 1)) == null ? void 0 : _b.element;
                      const lastInput = (_c = collection.at(-1)) == null ? void 0 : _c.element;
                      if (nextInput !== lastInput && event.currentTarget !== lastInput) {
                        if (event.currentTarget.selectionStart === 0) {
                          dispatch2({ type: "SET_CHAR", char: attemptedValue, index: index3, event });
                        } else {
                          dispatch2({
                            type: "SET_CHAR",
                            char: attemptedValue,
                            index: index3 + 1,
                            event
                          });
                        }
                        userActionRef.current = {
                          type: "keydown",
                          key: "Char",
                          metaKey: event.metaKey,
                          ctrlKey: event.ctrlKey
                        };
                        keyboardActionTimeoutRef.current = window.setTimeout(() => {
                          userActionRef.current = null;
                        }, 10);
                      }
                    }
                  }
                }
              }
            }),
            onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
              var _a5;
              event.preventDefault();
              const indexToFocus = Math.min(index3, lastSelectableIndex);
              const element2 = (_a5 = collection.at(indexToFocus)) == null ? void 0 : _a5.element;
              focusInput(element2);
            })
          }
        );
      }
    }
  ) });
});
function isFormElement(element) {
  return (element == null ? void 0 : element.tagName) === "FORM";
}
function removeWhitespace(value) {
  return value.replace(/\s/g, "");
}
function focusInput(element) {
  if (!element)
    return;
  if (element.ownerDocument.activeElement === element) {
    window.requestAnimationFrame(() => {
      var _a5;
      (_a5 = element.select) == null ? void 0 : _a5.call(element);
    });
  } else {
    element.focus();
  }
}
function isInputEvent(event) {
  return event.type === "input";
}

// node_modules/@radix-ui/react-password-toggle-field/dist/index.mjs
var React68 = __toESM(require_react(), 1);
var import_react_dom7 = __toESM(require_react_dom(), 1);
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var PASSWORD_TOGGLE_FIELD_NAME = "PasswordToggleField";
var [createPasswordToggleFieldContext] = createContextScope(PASSWORD_TOGGLE_FIELD_NAME);
var [PasswordToggleFieldProvider, usePasswordToggleFieldContext] = createPasswordToggleFieldContext(PASSWORD_TOGGLE_FIELD_NAME);
var INITIAL_FOCUS_STATE = {
  clickTriggered: false,
  selectionStart: null,
  selectionEnd: null
};
var PasswordToggleField = ({
  __scopePasswordToggleField,
  ...props
}) => {
  const baseId = useId2(props.id);
  const defaultInputId = `${baseId}-input`;
  const [inputIdState, setInputIdState] = React68.useState(defaultInputId);
  const inputId = inputIdState ?? defaultInputId;
  const syncInputId = React68.useCallback(
    (providedId) => setInputIdState(providedId != null ? String(providedId) : null),
    []
  );
  const { visible: visibleProp, defaultVisible, onVisiblityChange, children } = props;
  const [visible = false, setVisible] = useControllableState({
    caller: PASSWORD_TOGGLE_FIELD_NAME,
    prop: visibleProp,
    defaultProp: defaultVisible ?? false,
    onChange: onVisiblityChange
  });
  const inputRef = React68.useRef(null);
  const focusState = React68.useRef(INITIAL_FOCUS_STATE);
  return (0, import_jsx_runtime74.jsx)(
    PasswordToggleFieldProvider,
    {
      scope: __scopePasswordToggleField,
      inputId,
      inputRef,
      setVisible,
      syncInputId,
      visible,
      focusState,
      children
    }
  );
};
PasswordToggleField.displayName = PASSWORD_TOGGLE_FIELD_NAME;
var PASSWORD_TOGGLE_FIELD_INPUT_NAME = PASSWORD_TOGGLE_FIELD_NAME + "Input";
var PasswordToggleFieldInput = React68.forwardRef(
  ({
    __scopePasswordToggleField,
    autoComplete = "current-password",
    autoCapitalize = "off",
    spellCheck = false,
    id: idProp,
    ...props
  }, forwardedRef) => {
    const { visible, inputRef, inputId, syncInputId, setVisible, focusState } = usePasswordToggleFieldContext(PASSWORD_TOGGLE_FIELD_INPUT_NAME, __scopePasswordToggleField);
    React68.useEffect(() => {
      syncInputId(idProp);
    }, [idProp, syncInputId]);
    const _setVisible = useEffectEvent(setVisible);
    React68.useEffect(() => {
      const inputElement = inputRef.current;
      const form = inputElement == null ? void 0 : inputElement.form;
      if (!form) {
        return;
      }
      const controller = new AbortController();
      form.addEventListener(
        "reset",
        (event) => {
          if (!event.defaultPrevented) {
            _setVisible(false);
          }
        },
        { signal: controller.signal }
      );
      form.addEventListener(
        "submit",
        () => {
          _setVisible(false);
        },
        { signal: controller.signal }
      );
      return () => {
        controller.abort();
      };
    }, [inputRef, _setVisible]);
    return (0, import_jsx_runtime74.jsx)(
      Primitive.input,
      {
        ...props,
        id: idProp ?? inputId,
        autoCapitalize,
        autoComplete,
        ref: useComposedRefs(forwardedRef, inputRef),
        spellCheck,
        type: visible ? "text" : "password",
        onBlur: composeEventHandlers(props.onBlur, (event) => {
          const { selectionStart, selectionEnd } = event.currentTarget;
          focusState.current.selectionStart = selectionStart;
          focusState.current.selectionEnd = selectionEnd;
        })
      }
    );
  }
);
PasswordToggleFieldInput.displayName = PASSWORD_TOGGLE_FIELD_INPUT_NAME;
var PASSWORD_TOGGLE_FIELD_TOGGLE_NAME = PASSWORD_TOGGLE_FIELD_NAME + "Toggle";
var PasswordToggleFieldToggle = React68.forwardRef(
  ({
    __scopePasswordToggleField,
    onClick,
    onPointerDown,
    onPointerCancel,
    onPointerUp,
    onFocus,
    children,
    "aria-label": ariaLabelProp,
    "aria-controls": ariaControls,
    "aria-hidden": ariaHidden,
    tabIndex,
    ...props
  }, forwardedRef) => {
    const { setVisible, visible, inputRef, inputId, focusState } = usePasswordToggleFieldContext(
      PASSWORD_TOGGLE_FIELD_TOGGLE_NAME,
      __scopePasswordToggleField
    );
    const [internalAriaLabel, setInternalAriaLabel] = React68.useState(void 0);
    const elementRef = React68.useRef(null);
    const ref = useComposedRefs(forwardedRef, elementRef);
    const isHydrated = useIsHydrated();
    React68.useEffect(() => {
      const element = elementRef.current;
      if (!element || ariaLabelProp) {
        setInternalAriaLabel(void 0);
        return;
      }
      const DEFAULT_ARIA_LABEL = visible ? "Hide password" : "Show password";
      function checkForInnerTextLabel(textContent) {
        const text = textContent ? textContent : void 0;
        setInternalAriaLabel(text ? void 0 : DEFAULT_ARIA_LABEL);
      }
      checkForInnerTextLabel(element.textContent);
      const observer = new MutationObserver((entries) => {
        let textContent;
        for (const entry2 of entries) {
          if (entry2.type === "characterData") {
            if (element.textContent) {
              textContent = element.textContent;
            }
          }
        }
        checkForInnerTextLabel(textContent);
      });
      observer.observe(element, { characterData: true, subtree: true });
      return () => {
        observer.disconnect();
      };
    }, [visible, ariaLabelProp]);
    const ariaLabel = ariaLabelProp || internalAriaLabel;
    if (!isHydrated) {
      ariaHidden ?? (ariaHidden = true);
      tabIndex ?? (tabIndex = -1);
    } else {
      ariaControls ?? (ariaControls = inputId);
    }
    React68.useEffect(() => {
      var _a5, _b;
      let cleanup = () => {
      };
      const ownerWindow = ((_b = (_a5 = elementRef.current) == null ? void 0 : _a5.ownerDocument) == null ? void 0 : _b.defaultView) || window;
      const reset2 = () => focusState.current.clickTriggered = false;
      const handlePointerUp = () => cleanup = requestIdleCallback(ownerWindow, reset2);
      ownerWindow.addEventListener("pointerup", handlePointerUp);
      return () => {
        cleanup();
        ownerWindow.removeEventListener("pointerup", handlePointerUp);
      };
    }, [focusState]);
    return (0, import_jsx_runtime74.jsx)(
      Primitive.button,
      {
        "aria-controls": ariaControls,
        "aria-hidden": ariaHidden,
        "aria-label": ariaLabel,
        ref,
        id: inputId,
        ...props,
        onPointerDown: composeEventHandlers(onPointerDown, () => {
          focusState.current.clickTriggered = true;
        }),
        onPointerCancel: (event) => {
          onPointerCancel == null ? void 0 : onPointerCancel(event);
          focusState.current = INITIAL_FOCUS_STATE;
        },
        onClick: (event) => {
          onClick == null ? void 0 : onClick(event);
          if (event.defaultPrevented) {
            focusState.current = INITIAL_FOCUS_STATE;
            return;
          }
          (0, import_react_dom7.flushSync)(() => {
            setVisible((s) => !s);
          });
          if (focusState.current.clickTriggered) {
            const input = inputRef.current;
            if (input) {
              const { selectionStart, selectionEnd } = focusState.current;
              input.focus();
              if (selectionStart !== null || selectionEnd !== null) {
                requestAnimationFrame(() => {
                  if (input.ownerDocument.activeElement === input) {
                    input.selectionStart = selectionStart;
                    input.selectionEnd = selectionEnd;
                  }
                });
              }
            }
          }
          focusState.current = INITIAL_FOCUS_STATE;
        },
        onPointerUp: (event) => {
          onPointerUp == null ? void 0 : onPointerUp(event);
          setTimeout(() => {
            focusState.current = INITIAL_FOCUS_STATE;
          }, 50);
        },
        type: "button",
        children
      }
    );
  }
);
PasswordToggleFieldToggle.displayName = PASSWORD_TOGGLE_FIELD_TOGGLE_NAME;
var PASSWORD_TOGGLE_FIELD_SLOT_NAME = PASSWORD_TOGGLE_FIELD_NAME + "Slot";
var PasswordToggleFieldSlot = ({
  __scopePasswordToggleField,
  ...props
}) => {
  const { visible } = usePasswordToggleFieldContext(
    PASSWORD_TOGGLE_FIELD_SLOT_NAME,
    __scopePasswordToggleField
  );
  return "render" in props ? (
    //
    props.render({ visible })
  ) : visible ? props.visible : props.hidden;
};
PasswordToggleFieldSlot.displayName = PASSWORD_TOGGLE_FIELD_SLOT_NAME;
var PASSWORD_TOGGLE_FIELD_ICON_NAME = PASSWORD_TOGGLE_FIELD_NAME + "Icon";
var PasswordToggleFieldIcon = React68.forwardRef(
  ({
    __scopePasswordToggleField,
    // @ts-expect-error
    children,
    ...props
  }, forwardedRef) => {
    const { visible } = usePasswordToggleFieldContext(
      PASSWORD_TOGGLE_FIELD_ICON_NAME,
      __scopePasswordToggleField
    );
    const { visible: visibleIcon, hidden: hiddenIcon, ...domProps } = props;
    return (0, import_jsx_runtime74.jsx)(Primitive.svg, { ...domProps, ref: forwardedRef, "aria-hidden": true, asChild: true, children: visible ? visibleIcon : hiddenIcon });
  }
);
PasswordToggleFieldIcon.displayName = PASSWORD_TOGGLE_FIELD_ICON_NAME;
function requestIdleCallback(window22, callback, options2) {
  if (window22.requestIdleCallback) {
    const id2 = window22.requestIdleCallback(callback, options2);
    return () => {
      window22.cancelIdleCallback(id2);
    };
  }
  const start2 = Date.now();
  const id = window22.setTimeout(() => {
    const timeRemaining = () => Math.max(0, 50 - (Date.now() - start2));
    callback({ didTimeout: false, timeRemaining });
  }, 1);
  return () => {
    window22.clearTimeout(id);
  };
}

// node_modules/@radix-ui/react-popover/dist/index.mjs
var dist_exports11 = {};
__export(dist_exports11, {
  Anchor: () => Anchor22,
  Arrow: () => Arrow25,
  Close: () => Close2,
  Content: () => Content25,
  Popover: () => Popover,
  PopoverAnchor: () => PopoverAnchor,
  PopoverArrow: () => PopoverArrow,
  PopoverClose: () => PopoverClose,
  PopoverContent: () => PopoverContent,
  PopoverPortal: () => PopoverPortal,
  PopoverTrigger: () => PopoverTrigger,
  Portal: () => Portal4,
  Root: () => Root25,
  Trigger: () => Trigger5,
  createPopoverScope: () => createPopoverScope
});
var React69 = __toESM(require_react(), 1);
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope3 = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope3(__scopePopover);
  const triggerRef = React69.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = React69.useState(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: POPOVER_NAME
  });
  return (0, import_jsx_runtime75.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime75.jsx)(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId2(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: React69.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: React69.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: React69.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME3 = "PopoverAnchor";
var PopoverAnchor = React69.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME3, __scopePopover);
    const popperScope = usePopperScope3(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    React69.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return (0, import_jsx_runtime75.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME3;
var TRIGGER_NAME11 = "PopoverTrigger";
var PopoverTrigger = React69.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME11, __scopePopover);
    const popperScope = usePopperScope3(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger2 = (0, import_jsx_runtime75.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState5(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger2 : (0, import_jsx_runtime75.jsx)(Anchor, { asChild: true, ...popperScope, children: trigger2 });
  }
);
PopoverTrigger.displayName = TRIGGER_NAME11;
var PORTAL_NAME9 = "PopoverPortal";
var [PortalProvider4, usePortalContext4] = createPopoverContext(PORTAL_NAME9, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME9, __scopePopover);
  return (0, import_jsx_runtime75.jsx)(PortalProvider4, { scope: __scopePopover, forceMount, children: (0, import_jsx_runtime75.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime75.jsx)(Portal, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME9;
var CONTENT_NAME12 = "PopoverContent";
var PopoverContent = React69.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext4(CONTENT_NAME12, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME12, props.__scopePopover);
    return (0, import_jsx_runtime75.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime75.jsx)(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime75.jsx)(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent.displayName = CONTENT_NAME12;
var Slot4 = createSlot("PopoverContent.RemoveScroll");
var PopoverContentModal = React69.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME12, props.__scopePopover);
    const contentRef = React69.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = React69.useRef(false);
    React69.useEffect(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime75.jsx)(Combination_default, { as: Slot4, allowPinchZoom: true, children: (0, import_jsx_runtime75.jsx)(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a5;
          event.preventDefault();
          if (!isRightClickOutsideRef.current)
            (_a5 = context.triggerRef.current) == null ? void 0 : _a5.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = React69.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME12, props.__scopePopover);
    const hasInteractedOutsideRef = React69.useRef(false);
    const hasPointerDownOutsideRef = React69.useRef(false);
    return (0, import_jsx_runtime75.jsx)(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a5, _b;
          (_a5 = props.onCloseAutoFocus) == null ? void 0 : _a5.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current)
              (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a5, _b;
          (_a5 = props.onInteractOutside) == null ? void 0 : _a5.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger)
            event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = React69.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME12, __scopePopover);
    const popperScope = usePopperScope3(__scopePopover);
    useFocusGuards();
    return (0, import_jsx_runtime75.jsx)(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: (0, import_jsx_runtime75.jsx)(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: (0, import_jsx_runtime75.jsx)(
              Content3,
              {
                "data-state": getState5(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME2 = "PopoverClose";
var PopoverClose = React69.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME2, __scopePopover);
    return (0, import_jsx_runtime75.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME2;
var ARROW_NAME7 = "PopoverArrow";
var PopoverArrow = React69.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope3(__scopePopover);
    return (0, import_jsx_runtime75.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME7;
function getState5(open) {
  return open ? "open" : "closed";
}
var Root25 = Popover;
var Anchor22 = PopoverAnchor;
var Trigger5 = PopoverTrigger;
var Portal4 = PopoverPortal;
var Content25 = PopoverContent;
var Close2 = PopoverClose;
var Arrow25 = PopoverArrow;

// node_modules/@radix-ui/react-progress/dist/index.mjs
var React70 = __toESM(require_react(), 1);
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var PROGRESS_NAME = "Progress";
var DEFAULT_MAX = 100;
var [createProgressContext, createProgressScope] = createContextScope(PROGRESS_NAME);
var [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME);
var Progress = React70.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeProgress,
      value: valueProp = null,
      max: maxProp,
      getValueLabel = defaultGetValueLabel,
      ...progressProps
    } = props;
    if ((maxProp || maxProp === 0) && !isValidMaxNumber(maxProp)) {
      console.error(getInvalidMaxError(`${maxProp}`, "Progress"));
    }
    const max3 = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;
    if (valueProp !== null && !isValidValueNumber(valueProp, max3)) {
      console.error(getInvalidValueError(`${valueProp}`, "Progress"));
    }
    const value = isValidValueNumber(valueProp, max3) ? valueProp : null;
    const valueLabel = isNumber2(value) ? getValueLabel(value, max3) : void 0;
    return (0, import_jsx_runtime76.jsx)(ProgressProvider, { scope: __scopeProgress, value, max: max3, children: (0, import_jsx_runtime76.jsx)(
      Primitive.div,
      {
        "aria-valuemax": max3,
        "aria-valuemin": 0,
        "aria-valuenow": isNumber2(value) ? value : void 0,
        "aria-valuetext": valueLabel,
        role: "progressbar",
        "data-state": getProgressState(value, max3),
        "data-value": value ?? void 0,
        "data-max": max3,
        ...progressProps,
        ref: forwardedRef
      }
    ) });
  }
);
Progress.displayName = PROGRESS_NAME;
var INDICATOR_NAME6 = "ProgressIndicator";
var ProgressIndicator = React70.forwardRef(
  (props, forwardedRef) => {
    const { __scopeProgress, ...indicatorProps } = props;
    const context = useProgressContext(INDICATOR_NAME6, __scopeProgress);
    return (0, import_jsx_runtime76.jsx)(
      Primitive.div,
      {
        "data-state": getProgressState(context.value, context.max),
        "data-value": context.value ?? void 0,
        "data-max": context.max,
        ...indicatorProps,
        ref: forwardedRef
      }
    );
  }
);
ProgressIndicator.displayName = INDICATOR_NAME6;
function defaultGetValueLabel(value, max3) {
  return `${Math.round(value / max3 * 100)}%`;
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function isNumber2(value) {
  return typeof value === "number";
}
function isValidMaxNumber(max3) {
  return isNumber2(max3) && !isNaN(max3) && max3 > 0;
}
function isValidValueNumber(value, max3) {
  return isNumber2(value) && !isNaN(value) && value <= max3 && value >= 0;
}
function getInvalidMaxError(propValue, componentName) {
  return `Invalid prop \`max\` of value \`${propValue}\` supplied to \`${componentName}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`;
}
function getInvalidValueError(propValue, componentName) {
  return `Invalid prop \`value\` of value \`${propValue}\` supplied to \`${componentName}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}

// node_modules/@radix-ui/react-radio-group/dist/index.mjs
var React210 = __toESM(require_react(), 1);
var React71 = __toESM(require_react(), 1);
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var RADIO_NAME = "Radio";
var [createRadioContext, createRadioScope] = createContextScope(RADIO_NAME);
var [RadioProvider, useRadioContext] = createRadioContext(RADIO_NAME);
var Radio = React71.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadio,
      name,
      checked = false,
      required,
      disabled,
      value = "on",
      onCheck,
      form,
      ...radioProps
    } = props;
    const [button, setButton] = React71.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React71.useRef(false);
    const isFormControl2 = button ? form || !!button.closest("form") : true;
    return (0, import_jsx_runtime77.jsxs)(RadioProvider, { scope: __scopeRadio, checked, disabled, children: [
      (0, import_jsx_runtime77.jsx)(
        Primitive.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": checked,
          "data-state": getState6(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...radioProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            if (!checked)
              onCheck == null ? void 0 : onCheck();
            if (isFormControl2) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current)
                event.stopPropagation();
            }
          })
        }
      ),
      isFormControl2 && (0, import_jsx_runtime77.jsx)(
        RadioBubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Radio.displayName = RADIO_NAME;
var INDICATOR_NAME7 = "RadioIndicator";
var RadioIndicator = React71.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadio, forceMount, ...indicatorProps } = props;
    const context = useRadioContext(INDICATOR_NAME7, __scopeRadio);
    return (0, import_jsx_runtime77.jsx)(Presence, { present: forceMount || context.checked, children: (0, import_jsx_runtime77.jsx)(
      Primitive.span,
      {
        "data-state": getState6(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef
      }
    ) });
  }
);
RadioIndicator.displayName = INDICATOR_NAME7;
var BUBBLE_INPUT_NAME2 = "RadioBubbleInput";
var RadioBubbleInput = React71.forwardRef(
  ({
    __scopeRadio,
    control,
    checked,
    bubbles = true,
    ...props
  }, forwardedRef) => {
    const ref = React71.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    React71.useEffect(() => {
      const input = ref.current;
      if (!input)
        return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    return (0, import_jsx_runtime77.jsx)(
      Primitive.input,
      {
        type: "radio",
        "aria-hidden": true,
        defaultChecked: checked,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
RadioBubbleInput.displayName = BUBBLE_INPUT_NAME2;
function getState6(checked) {
  return checked ? "checked" : "unchecked";
}
var ARROW_KEYS2 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var RADIO_GROUP_NAME5 = "RadioGroup";
var [createRadioGroupContext, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME5, [
  createRovingFocusGroupScope,
  createRadioScope
]);
var useRovingFocusGroupScope4 = createRovingFocusGroupScope();
var useRadioScope = createRadioScope();
var [RadioGroupProvider2, useRadioGroupContext2] = createRadioGroupContext(RADIO_GROUP_NAME5);
var RadioGroup3 = React210.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadioGroup,
      name,
      defaultValue,
      value: valueProp,
      required = false,
      disabled = false,
      orientation,
      dir,
      loop = true,
      onValueChange,
      ...groupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope4(__scopeRadioGroup);
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue ?? null,
      onChange: onValueChange,
      caller: RADIO_GROUP_NAME5
    });
    return (0, import_jsx_runtime78.jsx)(
      RadioGroupProvider2,
      {
        scope: __scopeRadioGroup,
        name,
        required,
        disabled,
        value,
        onValueChange: setValue,
        children: (0, import_jsx_runtime78.jsx)(
          Root7,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation,
            dir: direction,
            loop,
            children: (0, import_jsx_runtime78.jsx)(
              Primitive.div,
              {
                role: "radiogroup",
                "aria-required": required,
                "aria-orientation": orientation,
                "data-disabled": disabled ? "" : void 0,
                dir: direction,
                ...groupProps,
                ref: forwardedRef
              }
            )
          }
        )
      }
    );
  }
);
RadioGroup3.displayName = RADIO_GROUP_NAME5;
var ITEM_NAME8 = "RadioGroupItem";
var RadioGroupItem = React210.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, disabled, ...itemProps } = props;
    const context = useRadioGroupContext2(ITEM_NAME8, __scopeRadioGroup);
    const isDisabled = context.disabled || disabled;
    const rovingFocusGroupScope = useRovingFocusGroupScope4(__scopeRadioGroup);
    const radioScope = useRadioScope(__scopeRadioGroup);
    const ref = React210.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const checked = context.value === itemProps.value;
    const isArrowKeyPressedRef = React210.useRef(false);
    React210.useEffect(() => {
      const handleKeyDown2 = (event) => {
        if (ARROW_KEYS2.includes(event.key)) {
          isArrowKeyPressedRef.current = true;
        }
      };
      const handleKeyUp = () => isArrowKeyPressedRef.current = false;
      document.addEventListener("keydown", handleKeyDown2);
      document.addEventListener("keyup", handleKeyUp);
      return () => {
        document.removeEventListener("keydown", handleKeyDown2);
        document.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    return (0, import_jsx_runtime78.jsx)(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !isDisabled,
        active: checked,
        children: (0, import_jsx_runtime78.jsx)(
          Radio,
          {
            disabled: isDisabled,
            required: context.required,
            checked,
            ...radioScope,
            ...itemProps,
            name: context.name,
            ref: composedRefs,
            onCheck: () => context.onValueChange(itemProps.value),
            onKeyDown: composeEventHandlers((event) => {
              if (event.key === "Enter")
                event.preventDefault();
            }),
            onFocus: composeEventHandlers(itemProps.onFocus, () => {
              var _a5;
              if (isArrowKeyPressedRef.current)
                (_a5 = ref.current) == null ? void 0 : _a5.click();
            })
          }
        )
      }
    );
  }
);
RadioGroupItem.displayName = ITEM_NAME8;
var INDICATOR_NAME22 = "RadioGroupIndicator";
var RadioGroupIndicator = React210.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, ...indicatorProps } = props;
    const radioScope = useRadioScope(__scopeRadioGroup);
    return (0, import_jsx_runtime78.jsx)(RadioIndicator, { ...radioScope, ...indicatorProps, ref: forwardedRef });
  }
);
RadioGroupIndicator.displayName = INDICATOR_NAME22;

// node_modules/@radix-ui/react-scroll-area/dist/index.mjs
var React211 = __toESM(require_react(), 1);
var React72 = __toESM(require_react(), 1);
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
function useStateMachine2(initialState2, machine) {
  return React72.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var SCROLL_AREA_NAME = "ScrollArea";
var [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME);
var [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME);
var ScrollArea = React211.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeScrollArea,
      type = "hover",
      dir,
      scrollHideDelay = 600,
      ...scrollAreaProps
    } = props;
    const [scrollArea, setScrollArea] = React211.useState(null);
    const [viewport2, setViewport] = React211.useState(null);
    const [content, setContent3] = React211.useState(null);
    const [scrollbarX, setScrollbarX] = React211.useState(null);
    const [scrollbarY, setScrollbarY] = React211.useState(null);
    const [cornerWidth, setCornerWidth] = React211.useState(0);
    const [cornerHeight, setCornerHeight] = React211.useState(0);
    const [scrollbarXEnabled, setScrollbarXEnabled] = React211.useState(false);
    const [scrollbarYEnabled, setScrollbarYEnabled] = React211.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setScrollArea(node));
    const direction = useDirection(dir);
    return (0, import_jsx_runtime79.jsx)(
      ScrollAreaProvider,
      {
        scope: __scopeScrollArea,
        type,
        dir: direction,
        scrollHideDelay,
        scrollArea,
        viewport: viewport2,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent3,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight,
        children: (0, import_jsx_runtime79.jsx)(
          Primitive.div,
          {
            dir: direction,
            ...scrollAreaProps,
            ref: composedRefs,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              ["--radix-scroll-area-corner-width"]: cornerWidth + "px",
              ["--radix-scroll-area-corner-height"]: cornerHeight + "px",
              ...props.style
            }
          }
        )
      }
    );
  }
);
ScrollArea.displayName = SCROLL_AREA_NAME;
var VIEWPORT_NAME2 = "ScrollAreaViewport";
var ScrollAreaViewport = React211.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, children, nonce, ...viewportProps } = props;
    const context = useScrollAreaContext(VIEWPORT_NAME2, __scopeScrollArea);
    const ref = React211.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    return (0, import_jsx_runtime79.jsxs)(import_jsx_runtime79.Fragment, { children: [
      (0, import_jsx_runtime79.jsx)(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      (0, import_jsx_runtime79.jsx)(
        Primitive.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...viewportProps,
          ref: composedRefs,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: context.scrollbarYEnabled ? "scroll" : "hidden",
            ...props.style
          },
          children: (0, import_jsx_runtime79.jsx)("div", { ref: context.onContentChange, style: { minWidth: "100%", display: "table" }, children })
        }
      )
    ] });
  }
);
ScrollAreaViewport.displayName = VIEWPORT_NAME2;
var SCROLLBAR_NAME = "ScrollAreaScrollbar";
var ScrollAreaScrollbar = React211.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
    const isHorizontal = props.orientation === "horizontal";
    React211.useEffect(() => {
      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
      return () => {
        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
      };
    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);
    return context.type === "hover" ? (0, import_jsx_runtime79.jsx)(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? (0, import_jsx_runtime79.jsx)(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? (0, import_jsx_runtime79.jsx)(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? (0, import_jsx_runtime79.jsx)(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
var ScrollAreaScrollbarHover = React211.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [visible, setVisible] = React211.useState(false);
  React211.useEffect(() => {
    const scrollArea = context.scrollArea;
    let hideTimer = 0;
    if (scrollArea) {
      const handlePointerEnter = () => {
        window.clearTimeout(hideTimer);
        setVisible(true);
      };
      const handlePointerLeave = () => {
        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
      };
      scrollArea.addEventListener("pointerenter", handlePointerEnter);
      scrollArea.addEventListener("pointerleave", handlePointerLeave);
      return () => {
        window.clearTimeout(hideTimer);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      };
    }
  }, [context.scrollArea, context.scrollHideDelay]);
  return (0, import_jsx_runtime79.jsx)(Presence, { present: forceMount || visible, children: (0, import_jsx_runtime79.jsx)(
    ScrollAreaScrollbarAuto,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarScroll = React211.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const isHorizontal = props.orientation === "horizontal";
  const debounceScrollEnd = useDebounceCallback(() => send("SCROLL_END"), 100);
  const [state, send] = useStateMachine2("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  React211.useEffect(() => {
    if (state === "idle") {
      const hideTimer = window.setTimeout(() => send("HIDE"), context.scrollHideDelay);
      return () => window.clearTimeout(hideTimer);
    }
  }, [state, context.scrollHideDelay, send]);
  React211.useEffect(() => {
    const viewport2 = context.viewport;
    const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
    if (viewport2) {
      let prevScrollPos = viewport2[scrollDirection];
      const handleScroll2 = () => {
        const scrollPos = viewport2[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          send("SCROLL");
          debounceScrollEnd();
        }
        prevScrollPos = scrollPos;
      };
      viewport2.addEventListener("scroll", handleScroll2);
      return () => viewport2.removeEventListener("scroll", handleScroll2);
    }
  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);
  return (0, import_jsx_runtime79.jsx)(Presence, { present: forceMount || state !== "hidden", children: (0, import_jsx_runtime79.jsx)(
    ScrollAreaScrollbarVisible,
    {
      "data-state": state === "hidden" ? "hidden" : "visible",
      ...scrollbarProps,
      ref: forwardedRef,
      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => send("POINTER_ENTER")),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => send("POINTER_LEAVE"))
    }
  ) });
});
var ScrollAreaScrollbarAuto = React211.forwardRef((props, forwardedRef) => {
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const { forceMount, ...scrollbarProps } = props;
  const [visible, setVisible] = React211.useState(false);
  const isHorizontal = props.orientation === "horizontal";
  const handleResize = useDebounceCallback(() => {
    if (context.viewport) {
      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
      setVisible(isHorizontal ? isOverflowX : isOverflowY);
    }
  }, 10);
  useResizeObserver2(context.viewport, handleResize);
  useResizeObserver2(context.content, handleResize);
  return (0, import_jsx_runtime79.jsx)(Presence, { present: forceMount || visible, children: (0, import_jsx_runtime79.jsx)(
    ScrollAreaScrollbarVisible,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarVisible = React211.forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const thumbRef = React211.useRef(null);
  const pointerOffsetRef = React211.useRef(0);
  const [sizes, setSizes] = React211.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  });
  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
  const commonProps = {
    ...scrollbarProps,
    sizes,
    onSizesChange: setSizes,
    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
    onThumbChange: (thumb) => thumbRef.current = thumb,
    onThumbPointerUp: () => pointerOffsetRef.current = 0,
    onThumbPointerDown: (pointerPos) => pointerOffsetRef.current = pointerPos
  };
  function getScrollPosition(pointerPos, dir) {
    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);
  }
  if (orientation === "horizontal") {
    return (0, import_jsx_runtime79.jsx)(
      ScrollAreaScrollbarX,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollLeft;
            const offset5 = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);
            thumbRef.current.style.transform = `translate3d(${offset5}px, 0, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport)
            context.viewport.scrollLeft = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) {
            context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);
          }
        }
      }
    );
  }
  if (orientation === "vertical") {
    return (0, import_jsx_runtime79.jsx)(
      ScrollAreaScrollbarY,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollTop;
            const offset5 = getThumbOffsetFromScroll(scrollPos, sizes);
            thumbRef.current.style.transform = `translate3d(0, ${offset5}px, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport)
            context.viewport.scrollTop = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport)
            context.viewport.scrollTop = getScrollPosition(pointerPos);
        }
      }
    );
  }
  return null;
});
var ScrollAreaScrollbarX = React211.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = React211.useState();
  const ref = React211.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);
  React211.useEffect(() => {
    if (ref.current)
      setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return (0, import_jsx_runtime79.jsx)(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "horizontal",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        bottom: 0,
        left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        ["--radix-scroll-area-thumb-width"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollLeft + event.deltaX;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollWidth,
            viewport: context.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    }
  );
});
var ScrollAreaScrollbarY = React211.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = React211.useState();
  const ref = React211.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);
  React211.useEffect(() => {
    if (ref.current)
      setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return (0, import_jsx_runtime79.jsx)(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "vertical",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        top: 0,
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        ["--radix-scroll-area-thumb-height"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollTop + event.deltaY;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    }
  );
});
var [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME);
var ScrollAreaScrollbarImpl = React211.forwardRef((props, forwardedRef) => {
  const {
    __scopeScrollArea,
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);
  const [scrollbar, setScrollbar] = React211.useState(null);
  const composeRefs2 = useComposedRefs(forwardedRef, (node) => setScrollbar(node));
  const rectRef = React211.useRef(null);
  const prevWebkitUserSelectRef = React211.useRef("");
  const viewport2 = context.viewport;
  const maxScrollPos = sizes.content - sizes.viewport;
  const handleWheelScroll = useCallbackRef(onWheelScroll);
  const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);
  const handleResize = useDebounceCallback(onResize, 10);
  function handleDragScroll(event) {
    if (rectRef.current) {
      const x = event.clientX - rectRef.current.left;
      const y = event.clientY - rectRef.current.top;
      onDragScroll({ x, y });
    }
  }
  React211.useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      const isScrollbarWheel = scrollbar == null ? void 0 : scrollbar.contains(element);
      if (isScrollbarWheel)
        handleWheelScroll(event, maxScrollPos);
    };
    document.addEventListener("wheel", handleWheel, { passive: false });
    return () => document.removeEventListener("wheel", handleWheel, { passive: false });
  }, [viewport2, scrollbar, maxScrollPos, handleWheelScroll]);
  React211.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
  useResizeObserver2(scrollbar, handleResize);
  useResizeObserver2(context.content, handleResize);
  return (0, import_jsx_runtime79.jsx)(
    ScrollbarProvider,
    {
      scope: __scopeScrollArea,
      scrollbar,
      hasThumb,
      onThumbChange: useCallbackRef(onThumbChange),
      onThumbPointerUp: useCallbackRef(onThumbPointerUp),
      onThumbPositionChange: handleThumbPositionChange,
      onThumbPointerDown: useCallbackRef(onThumbPointerDown),
      children: (0, import_jsx_runtime79.jsx)(
        Primitive.div,
        {
          ...scrollbarProps,
          ref: composeRefs2,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            const mainPointer = 0;
            if (event.button === mainPointer) {
              const element = event.target;
              element.setPointerCapture(event.pointerId);
              rectRef.current = scrollbar.getBoundingClientRect();
              prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
              document.body.style.webkitUserSelect = "none";
              if (context.viewport)
                context.viewport.style.scrollBehavior = "auto";
              handleDragScroll(event);
            }
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const element = event.target;
            if (element.hasPointerCapture(event.pointerId)) {
              element.releasePointerCapture(event.pointerId);
            }
            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
            if (context.viewport)
              context.viewport.style.scrollBehavior = "";
            rectRef.current = null;
          })
        }
      )
    }
  );
});
var THUMB_NAME = "ScrollAreaThumb";
var ScrollAreaThumb = React211.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props;
    const scrollbarContext = useScrollbarContext(THUMB_NAME, props.__scopeScrollArea);
    return (0, import_jsx_runtime79.jsx)(Presence, { present: forceMount || scrollbarContext.hasThumb, children: (0, import_jsx_runtime79.jsx)(ScrollAreaThumbImpl, { ref: forwardedRef, ...thumbProps }) });
  }
);
var ScrollAreaThumbImpl = React211.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, style: style2, ...thumbProps } = props;
    const scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea);
    const scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea);
    const { onThumbPositionChange } = scrollbarContext;
    const composedRef = useComposedRefs(
      forwardedRef,
      (node) => scrollbarContext.onThumbChange(node)
    );
    const removeUnlinkedScrollListenerRef = React211.useRef(void 0);
    const debounceScrollEnd = useDebounceCallback(() => {
      if (removeUnlinkedScrollListenerRef.current) {
        removeUnlinkedScrollListenerRef.current();
        removeUnlinkedScrollListenerRef.current = void 0;
      }
    }, 100);
    React211.useEffect(() => {
      const viewport2 = scrollAreaContext.viewport;
      if (viewport2) {
        const handleScroll2 = () => {
          debounceScrollEnd();
          if (!removeUnlinkedScrollListenerRef.current) {
            const listener = addUnlinkedScrollListener(viewport2, onThumbPositionChange);
            removeUnlinkedScrollListenerRef.current = listener;
            onThumbPositionChange();
          }
        };
        onThumbPositionChange();
        viewport2.addEventListener("scroll", handleScroll2);
        return () => viewport2.removeEventListener("scroll", handleScroll2);
      }
    }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);
    return (0, import_jsx_runtime79.jsx)(
      Primitive.div,
      {
        "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
        ...thumbProps,
        ref: composedRef,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...style2
        },
        onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
          const thumb = event.target;
          const thumbRect = thumb.getBoundingClientRect();
          const x = event.clientX - thumbRect.left;
          const y = event.clientY - thumbRect.top;
          scrollbarContext.onThumbPointerDown({ x, y });
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
      }
    );
  }
);
ScrollAreaThumb.displayName = THUMB_NAME;
var CORNER_NAME = "ScrollAreaCorner";
var ScrollAreaCorner = React211.forwardRef(
  (props, forwardedRef) => {
    const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);
    const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);
    const hasCorner = context.type !== "scroll" && hasBothScrollbarsVisible;
    return hasCorner ? (0, import_jsx_runtime79.jsx)(ScrollAreaCornerImpl, { ...props, ref: forwardedRef }) : null;
  }
);
ScrollAreaCorner.displayName = CORNER_NAME;
var ScrollAreaCornerImpl = React211.forwardRef((props, forwardedRef) => {
  const { __scopeScrollArea, ...cornerProps } = props;
  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);
  const [width, setWidth] = React211.useState(0);
  const [height, setHeight] = React211.useState(0);
  const hasSize = Boolean(width && height);
  useResizeObserver2(context.scrollbarX, () => {
    var _a5;
    const height2 = ((_a5 = context.scrollbarX) == null ? void 0 : _a5.offsetHeight) || 0;
    context.onCornerHeightChange(height2);
    setHeight(height2);
  });
  useResizeObserver2(context.scrollbarY, () => {
    var _a5;
    const width2 = ((_a5 = context.scrollbarY) == null ? void 0 : _a5.offsetWidth) || 0;
    context.onCornerWidthChange(width2);
    setWidth(width2);
  });
  return hasSize ? (0, import_jsx_runtime79.jsx)(
    Primitive.div,
    {
      ...cornerProps,
      ref: forwardedRef,
      style: {
        width,
        height,
        position: "absolute",
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...props.style
      }
    }
  ) : null;
});
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset5 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset5;
  const minPointerPos = sizes.scrollbar.paddingStart + offset5;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp4(scrollPos, scrollClampRange);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
var addUnlinkedScrollListener = (node, handler = () => {
}) => {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position.left;
    const isVerticalScroll = prevPosition.top !== position.top;
    if (isHorizontalScroll || isVerticalScroll)
      handler();
    prevPosition = position;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
};
function useDebounceCallback(callback, delay) {
  const handleCallback = useCallbackRef(callback);
  const debounceTimerRef = React211.useRef(0);
  React211.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);
  return React211.useCallback(() => {
    window.clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = window.setTimeout(handleCallback, delay);
  }, [handleCallback, delay]);
}
function useResizeObserver2(element, onResize) {
  const handleResize = useCallbackRef(onResize);
  useLayoutEffect22(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}

// node_modules/@radix-ui/react-select/dist/index.mjs
var React73 = __toESM(require_react(), 1);
var ReactDOM5 = __toESM(require_react_dom(), 1);
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS2 = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection7, useCollection7, createCollectionScope7] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope7,
  createPopperScope
]);
var usePopperScope4 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope4(__scopeSelect);
  const [trigger2, setTrigger] = React73.useState(null);
  const [valueNode, setValueNode] = React73.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React73.useState(false);
  const direction = useDirection(dir);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SELECT_NAME
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange,
    caller: SELECT_NAME
  });
  const triggerPointerDownPosRef = React73.useRef(null);
  const isFormControl2 = trigger2 ? form || !!trigger2.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React73.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return (0, import_jsx_runtime80.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime80.jsxs)(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId2(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        (0, import_jsx_runtime80.jsx)(Collection7.Provider, { scope: __scopeSelect, children: (0, import_jsx_runtime80.jsx)(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: React73.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React73.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl2 ? (0, import_jsx_runtime80.jsxs)(
          SelectBubbleInput,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? (0, import_jsx_runtime80.jsx)("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select.displayName = SELECT_NAME;
var TRIGGER_NAME12 = "SelectTrigger";
var SelectTrigger = React73.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope4(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME12, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection7(__scopeSelect);
    const pointerTypeRef = React73.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return (0, import_jsx_runtime80.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime80.jsx)(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1)
            handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ")
            return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger.displayName = TRIGGER_NAME12;
var VALUE_NAME = "SelectValue";
var SelectValue = React73.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style: style2, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect22(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return (0, import_jsx_runtime80.jsx)(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? (0, import_jsx_runtime80.jsx)(import_jsx_runtime80.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React73.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return (0, import_jsx_runtime80.jsx)(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "▼" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME10 = "SelectPortal";
var SelectPortal = (props) => {
  return (0, import_jsx_runtime80.jsx)(Portal, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME10;
var CONTENT_NAME13 = "SelectContent";
var SelectContent = React73.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME13, props.__scopeSelect);
    const [fragment, setFragment] = React73.useState();
    useLayoutEffect22(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM5.createPortal(
        (0, import_jsx_runtime80.jsx)(SelectContentProvider, { scope: props.__scopeSelect, children: (0, import_jsx_runtime80.jsx)(Collection7.Slot, { scope: props.__scopeSelect, children: (0, import_jsx_runtime80.jsx)("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return (0, import_jsx_runtime80.jsx)(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent.displayName = CONTENT_NAME13;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME13);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var Slot5 = createSlot("SelectContent.RemoveScroll");
var SelectContentImpl = React73.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME13, __scopeSelect);
    const [content, setContent3] = React73.useState(null);
    const [viewport2, setViewport] = React73.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent3(node));
    const [selectedItem, setSelectedItem] = React73.useState(null);
    const [selectedItemText, setSelectedItemText] = React73.useState(
      null
    );
    const getItems = useCollection7(__scopeSelect);
    const [isPositioned, setIsPositioned] = React73.useState(false);
    const firstValidItemFoundRef = React73.useRef(false);
    React73.useEffect(() => {
      if (content)
        return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst6 = React73.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
            return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport2)
            viewport2.scrollTop = 0;
          if (candidate === lastItem && viewport2)
            viewport2.scrollTop = viewport2.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
            return;
        }
      },
      [getItems, viewport2]
    );
    const focusSelectedItem = React73.useCallback(
      () => focusFirst6([selectedItem, content]),
      [focusFirst6, selectedItem, content]
    );
    React73.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React73.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          var _a5, _b;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a5 = triggerPointerDownPosRef.current) == null ? void 0 : _a5.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b = triggerPointerDownPosRef.current) == null ? void 0 : _b.y) ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React73.useEffect(() => {
      const close2 = () => onOpenChange(false);
      window.addEventListener("blur", close2);
      window.addEventListener("resize", close2);
      return () => {
        window.removeEventListener("blur", close2);
        window.removeEventListener("resize", close2);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React73.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem)
            firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React73.useCallback(() => content == null ? void 0 : content.focus(), [content]);
    const itemTextRefCallback = React73.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return (0, import_jsx_runtime80.jsx)(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport: viewport2,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: (0, import_jsx_runtime80.jsx)(Combination_default, { as: Slot5, allowPinchZoom: true, children: (0, import_jsx_runtime80.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a5;
              (_a5 = context.trigger) == null ? void 0 : _a5.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: (0, import_jsx_runtime80.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: (0, import_jsx_runtime80.jsx)(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab")
                        event.preventDefault();
                      if (!isModifierKey && event.key.length === 1)
                        handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst6(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React73.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME13, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME13, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React73.useState(null);
  const [content, setContent3] = React73.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent3(node));
  const getItems = useCollection7(__scopeSelect);
  const shouldExpandOnScrollRef = React73.useRef(false);
  const shouldRepositionRef = React73.useRef(true);
  const { viewport: viewport2, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React73.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport2 && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left2 = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left2;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp4(left2, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right2 = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right2;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp4(right2, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport2.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport2);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport2.offsetTop - viewport2.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport2.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport2.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport2.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport2,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect22(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React73.useState();
  useLayoutEffect22(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React73.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return (0, import_jsx_runtime80.jsx)(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: (0, import_jsx_runtime80.jsx)(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: (0, import_jsx_runtime80.jsx)(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React73.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope4(__scopeSelect);
  return (0, import_jsx_runtime80.jsx)(
    Content3,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME13, {});
var VIEWPORT_NAME3 = "SelectViewport";
var SelectViewport = React73.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME3, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME3, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React73.useRef(0);
    return (0, import_jsx_runtime80.jsxs)(import_jsx_runtime80.Fragment, { children: [
      (0, import_jsx_runtime80.jsx)(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      (0, import_jsx_runtime80.jsx)(Collection7.Slot, { scope: __scopeSelect, children: (0, import_jsx_runtime80.jsx)(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport2 = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport2.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport2.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport2.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME3;
var GROUP_NAME6 = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME6);
var SelectGroup = React73.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId2();
    return (0, import_jsx_runtime80.jsx)(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: (0, import_jsx_runtime80.jsx)(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME6;
var LABEL_NAME6 = "SelectLabel";
var SelectLabel = React73.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME6, __scopeSelect);
    return (0, import_jsx_runtime80.jsx)(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel.displayName = LABEL_NAME6;
var ITEM_NAME9 = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME9);
var SelectItem = React73.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME9, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME9, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React73.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React73.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => {
        var _a5;
        return (_a5 = contentContext.itemRefCallback) == null ? void 0 : _a5.call(contentContext, node, value, disabled);
      }
    );
    const textId = useId2();
    const pointerTypeRef = React73.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return (0, import_jsx_runtime80.jsx)(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React73.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || ((node == null ? void 0 : node.textContent) ?? "").trim());
        }, []),
        children: (0, import_jsx_runtime80.jsx)(
          Collection7.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: (0, import_jsx_runtime80.jsx)(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse")
                    handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse")
                    handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a5;
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    (_a5 = contentContext.onItemLeave) == null ? void 0 : _a5.call(contentContext);
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a5;
                  if (event.currentTarget === document.activeElement) {
                    (_a5 = contentContext.onItemLeave) == null ? void 0 : _a5.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a5;
                  const isTypingAhead = ((_a5 = contentContext.searchRef) == null ? void 0 : _a5.current) !== "";
                  if (isTypingAhead && event.key === " ")
                    return;
                  if (SELECTION_KEYS2.includes(event.key))
                    handleSelect();
                  if (event.key === " ")
                    event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem.displayName = ITEM_NAME9;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React73.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style: style2, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React73.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _a5;
        return (_a5 = contentContext.itemTextRefCallback) == null ? void 0 : _a5.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = React73.useMemo(
      () => (0, import_jsx_runtime80.jsx)("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect22(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return (0, import_jsx_runtime80.jsxs)(import_jsx_runtime80.Fragment, { children: [
      (0, import_jsx_runtime80.jsx)(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM5.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME2 = "SelectItemIndicator";
var SelectItemIndicator = React73.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME2, __scopeSelect);
    return itemContext.isSelected ? (0, import_jsx_runtime80.jsx)(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME2;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = React73.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React73.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const canScrollUp2 = viewport2.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      var handleScroll2 = handleScroll22;
      const viewport2 = contentContext.viewport;
      handleScroll22();
      viewport2.addEventListener("scroll", handleScroll22);
      return () => viewport2.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? (0, import_jsx_runtime80.jsx)(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport: viewport2, selectedItem } = contentContext;
        if (viewport2 && selectedItem) {
          viewport2.scrollTop = viewport2.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = React73.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React73.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const maxScroll = viewport2.scrollHeight - viewport2.clientHeight;
        const canScrollDown2 = Math.ceil(viewport2.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      var handleScroll2 = handleScroll22;
      const viewport2 = contentContext.viewport;
      handleScroll22();
      viewport2.addEventListener("scroll", handleScroll22);
      return () => viewport2.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? (0, import_jsx_runtime80.jsx)(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport: viewport2, selectedItem } = contentContext;
        if (viewport2 && selectedItem) {
          viewport2.scrollTop = viewport2.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React73.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React73.useRef(null);
  const getItems = useCollection7(__scopeSelect);
  const clearAutoScrollTimer = React73.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React73.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect22(() => {
    var _a5;
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    (_a5 = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a5.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return (0, import_jsx_runtime80.jsx)(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a5;
        (_a5 = contentContext.onItemLeave) == null ? void 0 : _a5.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME5 = "SelectSeparator";
var SelectSeparator = React73.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return (0, import_jsx_runtime80.jsx)(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator.displayName = SEPARATOR_NAME5;
var ARROW_NAME8 = "SelectArrow";
var SelectArrow = React73.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope4(__scopeSelect);
    const context = useSelectContext(ARROW_NAME8, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME8, __scopeSelect);
    return context.open && contentContext.position === "popper" ? (0, import_jsx_runtime80.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME8;
var BUBBLE_INPUT_NAME3 = "SelectBubbleInput";
var SelectBubbleInput = React73.forwardRef(
  ({ __scopeSelect, value, ...props }, forwardedRef) => {
    const ref = React73.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    React73.useEffect(() => {
      const select = ref.current;
      if (!select)
        return;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return (0, import_jsx_runtime80.jsx)(
      Primitive.select,
      {
        ...props,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME3;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef(onSearchChange);
  const searchRef = React73.useRef("");
  const timerRef = React73.useRef(0);
  const handleTypeaheadSearch = React73.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "")
          timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React73.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React73.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray4(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem)
    wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray4(array2, startIndex) {
  return array2.map((_, index3) => array2[(startIndex + index3) % array2.length]);
}

// node_modules/@radix-ui/react-separator/dist/index.mjs
var React74 = __toESM(require_react(), 1);
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var NAME6 = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = ["horizontal", "vertical"];
var Separator3 = React74.forwardRef((props, forwardedRef) => {
  const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;
  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
  const ariaOrientation = orientation === "vertical" ? orientation : void 0;
  const semanticProps = decorative ? { role: "none" } : { "aria-orientation": ariaOrientation, role: "separator" };
  return (0, import_jsx_runtime81.jsx)(
    Primitive.div,
    {
      "data-orientation": orientation,
      ...semanticProps,
      ...domProps,
      ref: forwardedRef
    }
  );
});
Separator3.displayName = NAME6;
function isValidOrientation(orientation) {
  return ORIENTATIONS.includes(orientation);
}
var Root8 = Separator3;

// node_modules/@radix-ui/react-slider/dist/index.mjs
var dist_exports12 = {};
__export(dist_exports12, {
  Range: () => Range2,
  Root: () => Root9,
  Slider: () => Slider,
  SliderRange: () => SliderRange,
  SliderThumb: () => SliderThumb,
  SliderTrack: () => SliderTrack,
  Thumb: () => Thumb,
  Track: () => Track,
  createSliderScope: () => createSliderScope
});
var React75 = __toESM(require_react(), 1);
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS3 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var SLIDER_NAME = "Slider";
var [Collection8, useCollection8, createCollectionScope8] = createCollection(SLIDER_NAME);
var [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [
  createCollectionScope8
]);
var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
var Slider = React75.forwardRef(
  (props, forwardedRef) => {
    const {
      name,
      min: min4 = 0,
      max: max3 = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min4],
      value,
      onValueChange = () => {
      },
      onValueCommit = () => {
      },
      inverted = false,
      form,
      ...sliderProps
    } = props;
    const thumbRefs = React75.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = React75.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
    const [values = [], setValues] = useControllableState({
      prop: value,
      defaultProp: defaultValue,
      onChange: (value2) => {
        var _a5;
        const thumbs = [...thumbRefs.current];
        (_a5 = thumbs[valueIndexToChangeRef.current]) == null ? void 0 : _a5.focus();
        onValueChange(value2);
      }
    });
    const valuesBeforeSlideStartRef = React75.useRef(values);
    function handleSlideStart(value2) {
      const closestIndex = getClosestValueIndex(values, value2);
      updateValues(value2, closestIndex);
    }
    function handleSlideMove(value2) {
      updateValues(value2, valueIndexToChangeRef.current);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
      const nextValue = values[valueIndexToChangeRef.current];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged)
        onValueCommit(values);
    }
    function updateValues(value2, atIndex, { commit } = { commit: false }) {
      const decimalCount = getDecimalCount(step);
      const snapToStep = roundValue(Math.round((value2 - min4) / step) * step + min4, decimalCount);
      const nextValue = clamp4(snapToStep, [min4, max3]);
      setValues((prevValues = []) => {
        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          const hasChanged = String(nextValues) !== String(prevValues);
          if (hasChanged && commit)
            onValueCommit(nextValues);
          return hasChanged ? nextValues : prevValues;
        } else {
          return prevValues;
        }
      });
    }
    return (0, import_jsx_runtime82.jsx)(
      SliderProvider,
      {
        scope: props.__scopeSlider,
        name,
        disabled,
        min: min4,
        max: max3,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        form,
        children: (0, import_jsx_runtime82.jsx)(Collection8.Provider, { scope: props.__scopeSlider, children: (0, import_jsx_runtime82.jsx)(Collection8.Slot, { scope: props.__scopeSlider, children: (0, import_jsx_runtime82.jsx)(
          SliderOrientation,
          {
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0,
            ...sliderProps,
            ref: forwardedRef,
            onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {
              if (!disabled)
                valuesBeforeSlideStartRef.current = values;
            }),
            min: min4,
            max: max3,
            inverted,
            onSlideStart: disabled ? void 0 : handleSlideStart,
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onSlideEnd: disabled ? void 0 : handleSlideEnd,
            onHomeKeyDown: () => !disabled && updateValues(min4, 0, { commit: true }),
            onEndKeyDown: () => !disabled && updateValues(max3, values.length - 1, { commit: true }),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const isPageKey = PAGE_KEYS.includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS3.includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex = valueIndexToChangeRef.current;
                const value2 = values[atIndex];
                const stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex, { commit: true });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Slider.displayName = SLIDER_NAME;
var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
});
var SliderHorizontal = React75.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min4,
      max: max3,
      dir,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const [slider, setSlider] = React75.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));
    const rectRef = React75.useRef(void 0);
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || slider.getBoundingClientRect();
      const input = [0, rect.width];
      const output = isSlidingFromLeft ? [min4, max3] : [max3, min4];
      const value = linearScale2(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.left);
    }
    return (0, import_jsx_runtime82.jsx)(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromLeft ? "left" : "right",
        endEdge: isSlidingFromLeft ? "right" : "left",
        direction: isSlidingFromLeft ? 1 : -1,
        size: "width",
        children: (0, import_jsx_runtime82.jsx)(
          SliderImpl,
          {
            dir: direction,
            "data-orientation": "horizontal",
            ...sliderProps,
            ref: composedRefs,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateX(-50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideStart == null ? void 0 : onSlideStart(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideMove == null ? void 0 : onSlideMove(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd == null ? void 0 : onSlideEnd();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderVertical = React75.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min4,
      max: max3,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const sliderRef = React75.useRef(null);
    const ref = useComposedRefs(forwardedRef, sliderRef);
    const rectRef = React75.useRef(void 0);
    const isSlidingFromBottom = !inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
      const input = [0, rect.height];
      const output = isSlidingFromBottom ? [max3, min4] : [min4, max3];
      const value = linearScale2(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.top);
    }
    return (0, import_jsx_runtime82.jsx)(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromBottom ? "bottom" : "top",
        endEdge: isSlidingFromBottom ? "top" : "bottom",
        size: "height",
        direction: isSlidingFromBottom ? 1 : -1,
        children: (0, import_jsx_runtime82.jsx)(
          SliderImpl,
          {
            "data-orientation": "vertical",
            ...sliderProps,
            ref,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateY(50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideStart == null ? void 0 : onSlideStart(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideMove == null ? void 0 : onSlideMove(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd == null ? void 0 : onSlideEnd();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderImpl = React75.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSlider,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onHomeKeyDown,
      onEndKeyDown,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const context = useSliderContext(SLIDER_NAME, __scopeSlider);
    return (0, import_jsx_runtime82.jsx)(
      Primitive.span,
      {
        ...sliderProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === "Home") {
            onHomeKeyDown(event);
            event.preventDefault();
          } else if (event.key === "End") {
            onEndKeyDown(event);
            event.preventDefault();
          } else if (PAGE_KEYS.concat(ARROW_KEYS3).includes(event.key)) {
            onStepKeyDown(event);
            event.preventDefault();
          }
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          const target = event.target;
          target.setPointerCapture(event.pointerId);
          event.preventDefault();
          if (context.thumbs.has(target)) {
            target.focus();
          } else {
            onSlideStart(event);
          }
        }),
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId))
            onSlideMove(event);
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            onSlideEnd(event);
          }
        })
      }
    );
  }
);
var TRACK_NAME = "SliderTrack";
var SliderTrack = React75.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props;
    const context = useSliderContext(TRACK_NAME, __scopeSlider);
    return (0, import_jsx_runtime82.jsx)(
      Primitive.span,
      {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        ...trackProps,
        ref: forwardedRef
      }
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderRange";
var SliderRange = React75.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props;
    const context = useSliderContext(RANGE_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
    const ref = React75.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => convertValueToPercentage(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return (0, import_jsx_runtime82.jsx)(
      Primitive.span,
      {
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        ...rangeProps,
        ref: composedRefs,
        style: {
          ...props.style,
          [orientation.startEdge]: offsetStart + "%",
          [orientation.endEdge]: offsetEnd + "%"
        }
      }
    );
  }
);
SliderRange.displayName = RANGE_NAME;
var THUMB_NAME2 = "SliderThumb";
var SliderThumb = React75.forwardRef(
  (props, forwardedRef) => {
    const getItems = useCollection8(props.__scopeSlider);
    const [thumb, setThumb] = React75.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const index3 = React75.useMemo(
      () => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1,
      [getItems, thumb]
    );
    return (0, import_jsx_runtime82.jsx)(SliderThumbImpl, { ...props, ref: composedRefs, index: index3 });
  }
);
var SliderThumbImpl = React75.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, index: index3, name, ...thumbProps } = props;
    const context = useSliderContext(THUMB_NAME2, __scopeSlider);
    const orientation = useSliderOrientationContext(THUMB_NAME2, __scopeSlider);
    const [thumb, setThumb] = React75.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const isFormControl2 = thumb ? context.form || !!thumb.closest("form") : true;
    const size4 = useSize(thumb);
    const value = context.values[index3];
    const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
    const label = getLabel(index3, context.values.length);
    const orientationSize = size4 == null ? void 0 : size4[orientation.size];
    const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;
    React75.useEffect(() => {
      if (thumb) {
        context.thumbs.add(thumb);
        return () => {
          context.thumbs.delete(thumb);
        };
      }
    }, [thumb, context.thumbs]);
    return (0, import_jsx_runtime82.jsxs)(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`
        },
        children: [
          (0, import_jsx_runtime82.jsx)(Collection8.ItemSlot, { scope: props.__scopeSlider, children: (0, import_jsx_runtime82.jsx)(
            Primitive.span,
            {
              role: "slider",
              "aria-label": props["aria-label"] || label,
              "aria-valuemin": context.min,
              "aria-valuenow": value,
              "aria-valuemax": context.max,
              "aria-orientation": context.orientation,
              "data-orientation": context.orientation,
              "data-disabled": context.disabled ? "" : void 0,
              tabIndex: context.disabled ? void 0 : 0,
              ...thumbProps,
              ref: composedRefs,
              style: value === void 0 ? { display: "none" } : props.style,
              onFocus: composeEventHandlers(props.onFocus, () => {
                context.valueIndexToChangeRef.current = index3;
              })
            }
          ) }),
          isFormControl2 && (0, import_jsx_runtime82.jsx)(
            SliderBubbleInput,
            {
              name: name ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0),
              form: context.form,
              value
            },
            index3
          )
        ]
      }
    );
  }
);
SliderThumb.displayName = THUMB_NAME2;
var BUBBLE_INPUT_NAME4 = "RadioBubbleInput";
var SliderBubbleInput = React75.forwardRef(
  ({ __scopeSlider, value, ...props }, forwardedRef) => {
    const ref = React75.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevValue = usePrevious(value);
    React75.useEffect(() => {
      const input = ref.current;
      if (!input)
        return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("input", { bubbles: true });
        setValue.call(input, value);
        input.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return (0, import_jsx_runtime82.jsx)(
      Primitive.input,
      {
        style: { display: "none" },
        ...props,
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SliderBubbleInput.displayName = BUBBLE_INPUT_NAME4;
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function convertValueToPercentage(value, min4, max3) {
  const maxSteps = max3 - min4;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min4);
  return clamp4(percentage, [0, 100]);
}
function getLabel(index3, totalValues) {
  if (totalValues > 2) {
    return `Value ${index3 + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index3];
  } else {
    return void 0;
  }
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1)
    return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left2, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset5 = linearScale2([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset5(left2) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index3) => values[index3 + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale2(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var Root9 = Slider;
var Track = SliderTrack;
var Range2 = SliderRange;
var Thumb = SliderThumb;

// node_modules/@radix-ui/react-switch/dist/index.mjs
var React76 = __toESM(require_react(), 1);
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var SWITCH_NAME = "Switch";
var [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch = React76.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSwitch,
      name,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      form,
      ...switchProps
    } = props;
    const [button, setButton] = React76.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React76.useRef(false);
    const isFormControl2 = button ? form || !!button.closest("form") : true;
    const [checked, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked ?? false,
      onChange: onCheckedChange,
      caller: SWITCH_NAME
    });
    return (0, import_jsx_runtime83.jsxs)(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
      (0, import_jsx_runtime83.jsx)(
        Primitive.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": checked,
          "aria-required": required,
          "data-state": getState7(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...switchProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isFormControl2) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current)
                event.stopPropagation();
            }
          })
        }
      ),
      isFormControl2 && (0, import_jsx_runtime83.jsx)(
        SwitchBubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Switch.displayName = SWITCH_NAME;
var THUMB_NAME3 = "SwitchThumb";
var SwitchThumb = React76.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSwitch, ...thumbProps } = props;
    const context = useSwitchContext(THUMB_NAME3, __scopeSwitch);
    return (0, import_jsx_runtime83.jsx)(
      Primitive.span,
      {
        "data-state": getState7(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...thumbProps,
        ref: forwardedRef
      }
    );
  }
);
SwitchThumb.displayName = THUMB_NAME3;
var BUBBLE_INPUT_NAME5 = "SwitchBubbleInput";
var SwitchBubbleInput = React76.forwardRef(
  ({
    __scopeSwitch,
    control,
    checked,
    bubbles = true,
    ...props
  }, forwardedRef) => {
    const ref = React76.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    React76.useEffect(() => {
      const input = ref.current;
      if (!input)
        return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    return (0, import_jsx_runtime83.jsx)(
      "input",
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: checked,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
SwitchBubbleInput.displayName = BUBBLE_INPUT_NAME5;
function getState7(checked) {
  return checked ? "checked" : "unchecked";
}

// node_modules/@radix-ui/react-tabs/dist/index.mjs
var React77 = __toESM(require_react(), 1);
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope5 = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs = React77.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue ?? "",
      caller: TABS_NAME
    });
    return (0, import_jsx_runtime84.jsx)(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId2(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: (0, import_jsx_runtime84.jsx)(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList = React77.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope5(__scopeTabs);
    return (0, import_jsx_runtime84.jsx)(
      Root7,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: (0, import_jsx_runtime84.jsx)(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList.displayName = TAB_LIST_NAME;
var TRIGGER_NAME13 = "TabsTrigger";
var TabsTrigger = React77.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context = useTabsContext(TRIGGER_NAME13, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope5(__scopeTabs);
    const triggerId = makeTriggerId2(context.baseId, value);
    const contentId = makeContentId2(context.baseId, value);
    const isSelected = value === context.value;
    return (0, import_jsx_runtime84.jsx)(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: (0, import_jsx_runtime84.jsx)(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key))
                context.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger.displayName = TRIGGER_NAME13;
var CONTENT_NAME14 = "TabsContent";
var TabsContent = React77.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context = useTabsContext(CONTENT_NAME14, __scopeTabs);
    const triggerId = makeTriggerId2(context.baseId, value);
    const contentId = makeContentId2(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = React77.useRef(isSelected);
    React77.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return (0, import_jsx_runtime84.jsx)(Presence, { present: forceMount || isSelected, children: ({ present }) => (0, import_jsx_runtime84.jsx)(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent.displayName = CONTENT_NAME14;
function makeTriggerId2(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId2(baseId, value) {
  return `${baseId}-content-${value}`;
}

// node_modules/@radix-ui/react-toast/dist/index.mjs
var dist_exports13 = {};
__export(dist_exports13, {
  Action: () => Action,
  Close: () => Close3,
  Description: () => Description2,
  Provider: () => Provider,
  Root: () => Root26,
  Title: () => Title2,
  Toast: () => Toast,
  ToastAction: () => ToastAction,
  ToastClose: () => ToastClose,
  ToastDescription: () => ToastDescription,
  ToastProvider: () => ToastProvider,
  ToastTitle: () => ToastTitle,
  ToastViewport: () => ToastViewport,
  Viewport: () => Viewport,
  createToastScope: () => createToastScope
});
var React78 = __toESM(require_react(), 1);
var ReactDOM6 = __toESM(require_react_dom(), 1);
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var PROVIDER_NAME = "ToastProvider";
var [Collection9, useCollection9, createCollectionScope9] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope9]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);
var ToastProvider = (props) => {
  const {
    __scopeToast,
    label = "Notification",
    duration = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50,
    children
  } = props;
  const [viewport2, setViewport] = React78.useState(null);
  const [toastCount, setToastCount] = React78.useState(0);
  const isFocusedToastEscapeKeyDownRef = React78.useRef(false);
  const isClosePausedRef = React78.useRef(false);
  if (!label.trim()) {
    console.error(
      `Invalid prop \`label\` supplied to \`${PROVIDER_NAME}\`. Expected non-empty \`string\`.`
    );
  }
  return (0, import_jsx_runtime85.jsx)(Collection9.Provider, { scope: __scopeToast, children: (0, import_jsx_runtime85.jsx)(
    ToastProviderProvider,
    {
      scope: __scopeToast,
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport: viewport2,
      onViewportChange: setViewport,
      onToastAdd: React78.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
      onToastRemove: React78.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef,
      children
    }
  ) });
};
ToastProvider.displayName = PROVIDER_NAME;
var VIEWPORT_NAME4 = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport = React78.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context = useToastProviderContext(VIEWPORT_NAME4, __scopeToast);
    const getItems = useCollection9(__scopeToast);
    const wrapperRef = React78.useRef(null);
    const headFocusProxyRef = React78.useRef(null);
    const tailFocusProxyRef = React78.useRef(null);
    const ref = React78.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    React78.useEffect(() => {
      const handleKeyDown2 = (event) => {
        var _a5;
        const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed)
          (_a5 = ref.current) == null ? void 0 : _a5.focus();
      };
      document.addEventListener("keydown", handleKeyDown2);
      return () => document.removeEventListener("keydown", handleKeyDown2);
    }, [hotkey]);
    React78.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport2 = ref.current;
      if (hasToasts && wrapper && viewport2) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport2.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport2.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside)
            handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside)
            handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef]);
    const getSortedTabbableCandidates = React78.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates3(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    React78.useEffect(() => {
      const viewport2 = ref.current;
      if (viewport2) {
        const handleKeyDown2 = (event) => {
          var _a5, _b, _c;
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport2;
            if (targetIsViewport && isTabbingBackwards) {
              (_a5 = headFocusProxyRef.current) == null ? void 0 : _a5.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index3 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst5(sortedCandidates.slice(index3 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? (_b = headFocusProxyRef.current) == null ? void 0 : _b.focus() : (_c = tailFocusProxyRef.current) == null ? void 0 : _c.focus();
            }
          }
        };
        viewport2.addEventListener("keydown", handleKeyDown2);
        return () => viewport2.removeEventListener("keydown", handleKeyDown2);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return (0, import_jsx_runtime85.jsxs)(
      Branch,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && (0, import_jsx_runtime85.jsx)(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst5(tabbableCandidates);
              }
            }
          ),
          (0, import_jsx_runtime85.jsx)(Collection9.Slot, { scope: __scopeToast, children: (0, import_jsx_runtime85.jsx)(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && (0, import_jsx_runtime85.jsx)(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst5(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport.displayName = VIEWPORT_NAME4;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = React78.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return (0, import_jsx_runtime85.jsx)(
      VisuallyHidden,
      {
        "aria-hidden": true,
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          var _a5;
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !((_a5 = context.viewport) == null ? void 0 : _a5.contains(prevFocusedElement));
          if (isFocusFromOutsideViewport)
            onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast = React78.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? true,
      onChange: onOpenChange,
      caller: TOAST_NAME
    });
    return (0, import_jsx_runtime85.jsx)(Presence, { present: forceMount || open, children: (0, import_jsx_runtime85.jsx)(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef(props.onPause),
        onResume: useCallbackRef(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = React78.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode2] = React78.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode2(node2));
    const pointerStartRef = React78.useRef(null);
    const swipeDeltaRef = React78.useRef(null);
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = React78.useRef(0);
    const closeTimerRemainingTimeRef = React78.useRef(duration);
    const closeTimerRef = React78.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef(() => {
      var _a5;
      const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
      if (isFocusInToast)
        (_a5 = context.viewport) == null ? void 0 : _a5.focus();
      onClose();
    });
    const startTimer = React78.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity)
          return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    React78.useEffect(() => {
      const viewport2 = context.viewport;
      if (viewport2) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume == null ? void 0 : onResume();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause == null ? void 0 : onPause();
        };
        viewport2.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport2.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport2.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport2.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context.viewport, duration, onPause, onResume, startTimer]);
    React78.useEffect(() => {
      if (open && !context.isClosePausedRef.current)
        startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]);
    React78.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = React78.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context.viewport)
      return null;
    return (0, import_jsx_runtime85.jsxs)(import_jsx_runtime85.Fragment, { children: [
      announceTextContent && (0, import_jsx_runtime85.jsx)(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      (0, import_jsx_runtime85.jsx)(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: ReactDOM6.createPortal(
        (0, import_jsx_runtime85.jsx)(Collection9.ItemSlot, { scope: __scopeToast, children: (0, import_jsx_runtime85.jsx)(
          Root4,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context.isFocusedToastEscapeKeyDownRef.current)
                handleClose();
              context.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: (0, import_jsx_runtime85.jsx)(
              Primitive.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": true,
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape")
                    return;
                  onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0)
                    return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current)
                    return;
                  const x = event.clientX - pointerStartRef.current.x;
                  const y = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                  const clamp5 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp5(0, x) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp5(0, y) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent2(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent2(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent2(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent2(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = React78.useState(false);
  const [isAnnounced, setIsAnnounced] = React78.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  React78.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : (0, import_jsx_runtime85.jsx)(Portal, { asChild: true, children: (0, import_jsx_runtime85.jsx)(VisuallyHidden, { ...announceProps, children: renderAnnounceText && (0, import_jsx_runtime85.jsxs)(import_jsx_runtime85.Fragment, { children: [
    context.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME3 = "ToastTitle";
var ToastTitle = React78.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return (0, import_jsx_runtime85.jsx)(Primitive.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle.displayName = TITLE_NAME3;
var DESCRIPTION_NAME3 = "ToastDescription";
var ToastDescription = React78.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return (0, import_jsx_runtime85.jsx)(Primitive.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription.displayName = DESCRIPTION_NAME3;
var ACTION_NAME2 = "ToastAction";
var ToastAction = React78.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME2}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return (0, import_jsx_runtime85.jsx)(ToastAnnounceExclude, { altText, asChild: true, children: (0, import_jsx_runtime85.jsx)(ToastClose, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction.displayName = ACTION_NAME2;
var CLOSE_NAME3 = "ToastClose";
var ToastClose = React78.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME3, __scopeToast);
    return (0, import_jsx_runtime85.jsx)(ToastAnnounceExclude, { asChild: true, children: (0, import_jsx_runtime85.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose.displayName = CLOSE_NAME3;
var ToastAnnounceExclude = React78.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return (0, import_jsx_runtime85.jsx)(
    Primitive.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent)
      textContent.push(node.textContent);
    if (isHTMLElement3(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText)
            textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent2(name, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
  if (handler)
    currentTarget.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn2 = useCallbackRef(callback);
  useLayoutEffect22(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn2));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn2]);
}
function isHTMLElement3(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates3(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst5(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement)
      return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
var Provider = ToastProvider;
var Viewport = ToastViewport;
var Root26 = Toast;
var Title2 = ToastTitle;
var Description2 = ToastDescription;
var Action = ToastAction;
var Close3 = ToastClose;

// node_modules/@radix-ui/react-toggle/dist/index.mjs
var React79 = __toESM(require_react(), 1);
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var NAME7 = "Toggle";
var Toggle = React79.forwardRef((props, forwardedRef) => {
  const { pressed: pressedProp, defaultPressed, onPressedChange, ...buttonProps } = props;
  const [pressed, setPressed] = useControllableState({
    prop: pressedProp,
    onChange: onPressedChange,
    defaultProp: defaultPressed ?? false,
    caller: NAME7
  });
  return (0, import_jsx_runtime86.jsx)(
    Primitive.button,
    {
      type: "button",
      "aria-pressed": pressed,
      "data-state": pressed ? "on" : "off",
      "data-disabled": props.disabled ? "" : void 0,
      ...buttonProps,
      ref: forwardedRef,
      onClick: composeEventHandlers(props.onClick, () => {
        if (!props.disabled) {
          setPressed(!pressed);
        }
      })
    }
  );
});
Toggle.displayName = NAME7;

// node_modules/@radix-ui/react-toggle-group/dist/index.mjs
var import_react62 = __toESM(require_react(), 1);
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var TOGGLE_GROUP_NAME = "ToggleGroup";
var [createToggleGroupContext, createToggleGroupScope] = createContextScope(TOGGLE_GROUP_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope6 = createRovingFocusGroupScope();
var ToggleGroup = import_react62.default.forwardRef((props, forwardedRef) => {
  const { type, ...toggleGroupProps } = props;
  if (type === "single") {
    const singleProps = toggleGroupProps;
    return (0, import_jsx_runtime87.jsx)(ToggleGroupImplSingle, { ...singleProps, ref: forwardedRef });
  }
  if (type === "multiple") {
    const multipleProps = toggleGroupProps;
    return (0, import_jsx_runtime87.jsx)(ToggleGroupImplMultiple, { ...multipleProps, ref: forwardedRef });
  }
  throw new Error(`Missing prop \`type\` expected on \`${TOGGLE_GROUP_NAME}\``);
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var [ToggleGroupValueProvider, useToggleGroupValueContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
var ToggleGroupImplSingle = import_react62.default.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...toggleGroupSingleProps
  } = props;
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? "",
    onChange: onValueChange,
    caller: TOGGLE_GROUP_NAME
  });
  return (0, import_jsx_runtime87.jsx)(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "single",
      value: import_react62.default.useMemo(() => value ? [value] : [], [value]),
      onItemActivate: setValue,
      onItemDeactivate: import_react62.default.useCallback(() => setValue(""), [setValue]),
      children: (0, import_jsx_runtime87.jsx)(ToggleGroupImpl, { ...toggleGroupSingleProps, ref: forwardedRef })
    }
  );
});
var ToggleGroupImplMultiple = import_react62.default.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...toggleGroupMultipleProps
  } = props;
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? [],
    onChange: onValueChange,
    caller: TOGGLE_GROUP_NAME
  });
  const handleButtonActivate = import_react62.default.useCallback(
    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
    [setValue]
  );
  const handleButtonDeactivate = import_react62.default.useCallback(
    (itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)),
    [setValue]
  );
  return (0, import_jsx_runtime87.jsx)(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "multiple",
      value,
      onItemActivate: handleButtonActivate,
      onItemDeactivate: handleButtonDeactivate,
      children: (0, import_jsx_runtime87.jsx)(ToggleGroupImpl, { ...toggleGroupMultipleProps, ref: forwardedRef })
    }
  );
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var [ToggleGroupContext, useToggleGroupContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
var ToggleGroupImpl = import_react62.default.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToggleGroup,
      disabled = false,
      rovingFocus = true,
      orientation,
      dir,
      loop = true,
      ...toggleGroupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope6(__scopeToggleGroup);
    const direction = useDirection(dir);
    const commonProps = { role: "group", dir: direction, ...toggleGroupProps };
    return (0, import_jsx_runtime87.jsx)(ToggleGroupContext, { scope: __scopeToggleGroup, rovingFocus, disabled, children: rovingFocus ? (0, import_jsx_runtime87.jsx)(
      Root7,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation,
        dir: direction,
        loop,
        children: (0, import_jsx_runtime87.jsx)(Primitive.div, { ...commonProps, ref: forwardedRef })
      }
    ) : (0, import_jsx_runtime87.jsx)(Primitive.div, { ...commonProps, ref: forwardedRef }) });
  }
);
var ITEM_NAME10 = "ToggleGroupItem";
var ToggleGroupItem = import_react62.default.forwardRef(
  (props, forwardedRef) => {
    const valueContext = useToggleGroupValueContext(ITEM_NAME10, props.__scopeToggleGroup);
    const context = useToggleGroupContext(ITEM_NAME10, props.__scopeToggleGroup);
    const rovingFocusGroupScope = useRovingFocusGroupScope6(props.__scopeToggleGroup);
    const pressed = valueContext.value.includes(props.value);
    const disabled = context.disabled || props.disabled;
    const commonProps = { ...props, pressed, disabled };
    const ref = import_react62.default.useRef(null);
    return context.rovingFocus ? (0, import_jsx_runtime87.jsx)(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: pressed,
        ref,
        children: (0, import_jsx_runtime87.jsx)(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef })
      }
    ) : (0, import_jsx_runtime87.jsx)(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef });
  }
);
ToggleGroupItem.displayName = ITEM_NAME10;
var ToggleGroupItemImpl = import_react62.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToggleGroup, value, ...itemProps } = props;
    const valueContext = useToggleGroupValueContext(ITEM_NAME10, __scopeToggleGroup);
    const singleProps = { role: "radio", "aria-checked": props.pressed, "aria-pressed": void 0 };
    const typeProps = valueContext.type === "single" ? singleProps : void 0;
    return (0, import_jsx_runtime87.jsx)(
      Toggle,
      {
        ...typeProps,
        ...itemProps,
        ref: forwardedRef,
        onPressedChange: (pressed) => {
          if (pressed) {
            valueContext.onItemActivate(value);
          } else {
            valueContext.onItemDeactivate(value);
          }
        }
      }
    );
  }
);
var Root27 = ToggleGroup;
var Item24 = ToggleGroupItem;

// node_modules/@radix-ui/react-toolbar/dist/index.mjs
var dist_exports15 = {};
__export(dist_exports15, {
  Button: () => Button,
  Link: () => Link,
  Root: () => Root42,
  Separator: () => Separator4,
  ToggleGroup: () => ToggleGroup2,
  ToggleItem: () => ToggleItem,
  Toolbar: () => Toolbar,
  ToolbarButton: () => ToolbarButton,
  ToolbarLink: () => ToolbarLink,
  ToolbarSeparator: () => ToolbarSeparator,
  ToolbarToggleGroup: () => ToolbarToggleGroup,
  ToolbarToggleItem: () => ToolbarToggleItem,
  createToolbarScope: () => createToolbarScope
});
var React81 = __toESM(require_react(), 1);
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var TOOLBAR_NAME = "Toolbar";
var [createToolbarContext, createToolbarScope] = createContextScope(TOOLBAR_NAME, [
  createRovingFocusGroupScope,
  createToggleGroupScope
]);
var useRovingFocusGroupScope7 = createRovingFocusGroupScope();
var useToggleGroupScope = createToggleGroupScope();
var [ToolbarProvider, useToolbarContext] = createToolbarContext(TOOLBAR_NAME);
var Toolbar = React81.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, orientation = "horizontal", dir, loop = true, ...toolbarProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope7(__scopeToolbar);
    const direction = useDirection(dir);
    return (0, import_jsx_runtime88.jsx)(ToolbarProvider, { scope: __scopeToolbar, orientation, dir: direction, children: (0, import_jsx_runtime88.jsx)(
      Root7,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation,
        dir: direction,
        loop,
        children: (0, import_jsx_runtime88.jsx)(
          Primitive.div,
          {
            role: "toolbar",
            "aria-orientation": orientation,
            dir: direction,
            ...toolbarProps,
            ref: forwardedRef
          }
        )
      }
    ) });
  }
);
Toolbar.displayName = TOOLBAR_NAME;
var SEPARATOR_NAME6 = "ToolbarSeparator";
var ToolbarSeparator = React81.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...separatorProps } = props;
    const context = useToolbarContext(SEPARATOR_NAME6, __scopeToolbar);
    return (0, import_jsx_runtime88.jsx)(
      Root8,
      {
        orientation: context.orientation === "horizontal" ? "vertical" : "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
ToolbarSeparator.displayName = SEPARATOR_NAME6;
var BUTTON_NAME = "ToolbarButton";
var ToolbarButton = React81.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...buttonProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope7(__scopeToolbar);
    return (0, import_jsx_runtime88.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !props.disabled, children: (0, import_jsx_runtime88.jsx)(Primitive.button, { type: "button", ...buttonProps, ref: forwardedRef }) });
  }
);
ToolbarButton.displayName = BUTTON_NAME;
var LINK_NAME2 = "ToolbarLink";
var ToolbarLink = React81.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...linkProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope7(__scopeToolbar);
    return (0, import_jsx_runtime88.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: true, children: (0, import_jsx_runtime88.jsx)(
      Primitive.a,
      {
        ...linkProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === " ")
            event.currentTarget.click();
        })
      }
    ) });
  }
);
ToolbarLink.displayName = LINK_NAME2;
var TOGGLE_GROUP_NAME2 = "ToolbarToggleGroup";
var ToolbarToggleGroup = React81.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...toggleGroupProps } = props;
    const context = useToolbarContext(TOGGLE_GROUP_NAME2, __scopeToolbar);
    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);
    return (0, import_jsx_runtime88.jsx)(
      Root27,
      {
        "data-orientation": context.orientation,
        dir: context.dir,
        ...toggleGroupScope,
        ...toggleGroupProps,
        ref: forwardedRef,
        rovingFocus: false
      }
    );
  }
);
ToolbarToggleGroup.displayName = TOGGLE_GROUP_NAME2;
var TOGGLE_ITEM_NAME = "ToolbarToggleItem";
var ToolbarToggleItem = React81.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...toggleItemProps } = props;
    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);
    const scope = { __scopeToolbar: props.__scopeToolbar };
    return (0, import_jsx_runtime88.jsx)(ToolbarButton, { asChild: true, ...scope, children: (0, import_jsx_runtime88.jsx)(Item24, { ...toggleGroupScope, ...toggleItemProps, ref: forwardedRef }) });
  }
);
ToolbarToggleItem.displayName = TOGGLE_ITEM_NAME;
var Root42 = Toolbar;
var Separator4 = ToolbarSeparator;
var Button = ToolbarButton;
var Link = ToolbarLink;
var ToggleGroup2 = ToolbarToggleGroup;
var ToggleItem = ToolbarToggleItem;

// node_modules/@radix-ui/react-tooltip/dist/index.mjs
var React82 = __toESM(require_react(), 1);
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope5 = createPopperScope();
var PROVIDER_NAME2 = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME2);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = React82.useRef(true);
  const isPointerInTransitRef = React82.useRef(false);
  const skipDelayTimerRef = React82.useRef(0);
  React82.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return (0, import_jsx_runtime89.jsx)(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayedRef,
      delayDuration,
      onOpen: React82.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        isOpenDelayedRef.current = false;
      }, []),
      onClose: React82.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => isOpenDelayedRef.current = true,
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React82.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME2;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope5(__scopeTooltip);
  const [trigger2, setTrigger] = React82.useState(null);
  const contentId = useId2();
  const openTimerRef = React82.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React82.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = React82.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React82.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React82.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React82.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React82.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return (0, import_jsx_runtime89.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime89.jsx)(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      onTriggerEnter: React82.useCallback(() => {
        if (providerContext.isOpenDelayedRef.current)
          handleDelayedOpen();
        else
          handleOpen();
      }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React82.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME14 = "TooltipTrigger";
var TooltipTrigger = React82.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME14, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME14, __scopeTooltip);
    const popperScope = usePopperScope5(__scopeTooltip);
    const ref = React82.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = React82.useRef(false);
    const hasPointerMoveOpenedRef = React82.useRef(false);
    const handlePointerUp = React82.useCallback(() => isPointerDownRef.current = false, []);
    React82.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return (0, import_jsx_runtime89.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime89.jsx)(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch")
            return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          if (context.open) {
            context.onClose();
          }
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current)
            context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME14;
var PORTAL_NAME11 = "TooltipPortal";
var [PortalProvider5, usePortalContext5] = createTooltipContext(PORTAL_NAME11, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME11, __scopeTooltip);
  return (0, import_jsx_runtime89.jsx)(PortalProvider5, { scope: __scopeTooltip, forceMount, children: (0, import_jsx_runtime89.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime89.jsx)(Portal, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME11;
var CONTENT_NAME15 = "TooltipContent";
var TooltipContent = React82.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext5(CONTENT_NAME15, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME15, props.__scopeTooltip);
    return (0, import_jsx_runtime89.jsx)(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? (0, import_jsx_runtime89.jsx)(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime89.jsx)(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React82.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME15, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME15, props.__scopeTooltip);
  const ref = React82.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React82.useState(null);
  const { trigger: trigger2, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React82.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React82.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React82.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React82.useEffect(() => {
    if (trigger2 && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger2);
      trigger2.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger2.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger2, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React82.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger2 == null ? void 0 : trigger2.contains(target)) || (content == null ? void 0 : content.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon2(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger2, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return (0, import_jsx_runtime89.jsx)(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable3 = createSlottable("TooltipContent");
var TooltipContentImpl = React82.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME15, __scopeTooltip);
    const popperScope = usePopperScope5(__scopeTooltip);
    const { onClose } = context;
    React82.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React82.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(context.trigger))
            onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return (0, import_jsx_runtime89.jsx)(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: (0, import_jsx_runtime89.jsxs)(
          Content3,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              (0, import_jsx_runtime89.jsx)(Slottable3, { children }),
              (0, import_jsx_runtime89.jsx)(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: (0, import_jsx_runtime89.jsx)(Root2, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME15;
var ARROW_NAME9 = "TooltipArrow";
var TooltipArrow = React82.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope5(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME9,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : (0, import_jsx_runtime89.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME9;
function getExitSideFromRect(point, rect) {
  const top2 = Math.abs(rect.top - point.y);
  const bottom2 = Math.abs(rect.bottom - point.y);
  const right2 = Math.abs(rect.right - point.x);
  const left2 = Math.abs(rect.left - point.x);
  switch (Math.min(top2, bottom2, right2, left2)) {
    case left2:
      return "left";
    case right2:
      return "right";
    case top2:
      return "top";
    case bottom2:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top: top2, right: right2, bottom: bottom2, left: left2 } = rect;
  return [
    { x: left2, y: top2 },
    { x: right2, y: top2 },
    { x: right2, y: bottom2 },
    { x: left2, y: bottom2 }
  ];
}
function isPointInPolygon2(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x)
      return -1;
    else if (a.x > b.x)
      return 1;
    else if (a.y < b.y)
      return -1;
    else if (a.y > b.y)
      return 1;
    else
      return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}

// node_modules/tldraw/dist-esm/lib/ui/context/actions.mjs
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var React86 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/selectHelpers.mjs
function kickoutOccludedShapes(editor, shapeIds) {
  var _a5;
  const parentsToCheck = /* @__PURE__ */ new Set();
  for (const id of shapeIds) {
    const shape = editor.getShape(id);
    if (!shape)
      continue;
    if (editor.getShapeUtil(shape).onDragShapesOut) {
      parentsToCheck.add(shape);
    }
    const parent = editor.getShape(shape.parentId);
    if (!parent)
      continue;
    if (editor.getShapeUtil(parent).onDragShapesOut) {
      parentsToCheck.add(parent);
    }
  }
  const parentsWithKickedOutChildren = /* @__PURE__ */ new Map();
  for (const parent of parentsToCheck) {
    const occludedChildren = getOccludedChildren(editor, parent);
    if (occludedChildren.length) {
      parentsWithKickedOutChildren.set(parent, occludedChildren);
    }
  }
  for (const [parent, kickedOutChildrenIds] of parentsWithKickedOutChildren) {
    const shapeUtil = editor.getShapeUtil(parent);
    const kickedOutChildren = compact(kickedOutChildrenIds.map((id) => editor.getShape(id)));
    (_a5 = shapeUtil.onDragShapesOut) == null ? void 0 : _a5.call(shapeUtil, parent, kickedOutChildren);
  }
}
function getOccludedChildren(editor, parent) {
  const childIds = editor.getSortedChildIdsForParent(parent.id);
  if (childIds.length === 0)
    return [];
  const parentPageBounds = editor.getShapePageBounds(parent);
  if (!parentPageBounds)
    return [];
  let parentGeometry;
  let parentPageTransform;
  let parentPageCorners;
  const results = [];
  for (const childId of childIds) {
    const shapePageBounds = editor.getShapePageBounds(childId);
    if (!shapePageBounds) {
      continue;
    }
    if (!parentPageBounds.includes(shapePageBounds)) {
      results.push(childId);
      continue;
    }
    parentGeometry ?? (parentGeometry = editor.getShapeGeometry(parent));
    parentPageTransform ?? (parentPageTransform = editor.getShapePageTransform(parent));
    parentPageCorners ?? (parentPageCorners = parentPageTransform.applyToPoints(parentGeometry.vertices));
    const parentCornersInShapeSpace = editor.getShapePageTransform(childId).clone().invert().applyToPoints(parentPageCorners);
    const { vertices, isClosed } = editor.getShapeGeometry(childId);
    if (vertices.some((v) => pointInPolygon(v, parentCornersInShapeSpace))) {
      continue;
    }
    if (isClosed) {
      if (polygonsIntersect(parentCornersInShapeSpace, vertices)) {
        continue;
      }
    } else if (polygonIntersectsPolyline(parentCornersInShapeSpace, vertices)) {
      continue;
    }
    results.push(childId);
  }
  return results;
}
function startEditingShapeWithLabel(editor, shape, selectAll3 = false) {
  editor.select(shape);
  editor.setEditingShape(shape);
  editor.setCurrentTool("select.editing_shape", {
    target: "shape",
    shape
  });
  if (selectAll3) {
    editor.emit("select-all-text", { shapeId: shape.id });
  }
}

// node_modules/tldraw/dist-esm/lib/utils/frames/frames.mjs
function removeFrame(editor, ids) {
  const frames = compact(
    ids.map((id) => editor.getShape(id)).filter((f) => f && editor.isShapeOfType(f, "frame"))
  );
  if (!frames.length)
    return;
  const allChildren = [];
  editor.run(() => {
    frames.map((frame2) => {
      const children = editor.getSortedChildIdsForParent(frame2.id);
      if (children.length) {
        editor.reparentShapes(children, frame2.parentId, frame2.index);
        allChildren.push(...children);
      }
    });
    editor.setSelectedShapes(allChildren);
    editor.deleteShapes(ids);
  });
}
var DEFAULT_FRAME_PADDING = 50;
function getFrameChildrenBounds(children, editor, opts = { padding: DEFAULT_FRAME_PADDING }) {
  const bounds = Box.FromPoints(
    children.flatMap((shape) => {
      if (!shape)
        return [];
      const geometry = editor.getShapeGeometry(shape.id);
      const transform = editor.getShapeLocalTransform(shape);
      return (transform == null ? void 0 : transform.applyToPoints(geometry.vertices)) ?? [];
    })
  );
  const padding = opts.padding ?? DEFAULT_FRAME_PADDING;
  const w = bounds.w + 2 * padding;
  const h = bounds.h + 2 * padding;
  const dx = padding - bounds.minX;
  const dy = padding - bounds.minY;
  return { w, h, dx, dy };
}
function fitFrameToContent(editor, id, opts = {}) {
  const frame2 = editor.getShape(id);
  if (!frame2)
    return;
  const childIds = editor.getSortedChildIdsForParent(frame2.id);
  const children = compact(childIds.map((id2) => editor.getShape(id2)));
  if (!children.length)
    return;
  const { w, h, dx, dy } = getFrameChildrenBounds(children, editor, opts);
  if (dx === 0 && dy === 0 && frame2.props.w === w && frame2.props.h === h)
    return;
  const diff = new Vec(dx, dy).rot(frame2.rotation);
  editor.run(() => {
    const changes = childIds.map((child) => {
      const shape = editor.getShape(child);
      return {
        id: shape.id,
        type: shape.type,
        x: shape.x + dx,
        y: shape.y + dy
      };
    });
    changes.push({
      id: frame2.id,
      type: frame2.type,
      x: frame2.x - diff.x,
      y: frame2.y - diff.y,
      props: {
        w,
        h
      }
    });
    editor.updateShapes(changes);
  });
}

// node_modules/tldraw/dist-esm/lib/ui/components/EditLinkDialog.mjs
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_react64 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/Button/TldrawUiButtonLabel.mjs
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
function TldrawUiButtonLabel({ children }) {
  return (0, import_jsx_runtime90.jsx)("span", { className: "tlui-button__label", children });
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiDialog.mjs
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var import_classnames15 = __toESM(require_classnames(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/Button/TldrawUiButtonIcon.mjs
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiIcon.mjs
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var import_classnames14 = __toESM(require_classnames(), 1);
var import_react63 = __toESM(require_react(), 1);
var TldrawUiIcon = (0, import_react63.memo)(function TldrawUiIcon2({
  label,
  small,
  invertIcon,
  icon,
  color,
  className,
  ...props
}) {
  const assetUrls = useAssetUrls();
  const asset = assetUrls.icons[icon] ?? assetUrls.icons["question-mark-circle"];
  const ref = (0, import_react63.useRef)(null);
  (0, import_react63.useLayoutEffect)(() => {
    if (!asset) {
      console.error(`Icon not found: ${icon}. Add it to the assetUrls.icons object.`);
    }
    if (ref == null ? void 0 : ref.current) {
      ref.current.style.webkitMask = `url(${asset}) center 100% / 100% no-repeat`;
    }
  }, [ref, asset, icon]);
  if (icon === "none") {
    return (0, import_jsx_runtime91.jsx)(
      "div",
      {
        className: (0, import_classnames14.default)(
          "tlui-icon tlui-icon__placeholder",
          { "tlui-icon__small": small },
          className
        )
      }
    );
  }
  return (0, import_jsx_runtime91.jsx)(
    "div",
    {
      ...props,
      ref,
      "aria-label": label,
      role: "img",
      className: (0, import_classnames14.default)("tlui-icon", { "tlui-icon__small": small }, className),
      style: {
        color,
        mask: `url(${asset}) center 100% / 100% no-repeat`,
        transform: invertIcon ? "scale(-1, 1)" : void 0
      }
    }
  );
});

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/Button/TldrawUiButtonIcon.mjs
function TldrawUiButtonIcon({ icon, small, invertIcon }) {
  return (0, import_jsx_runtime92.jsx)(
    TldrawUiIcon,
    {
      "aria-hidden": "true",
      label: "",
      className: "tlui-button__icon",
      icon,
      small,
      invertIcon
    }
  );
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiDialog.mjs
function TldrawUiDialogHeader({ className, children }) {
  return (0, import_jsx_runtime93.jsx)("div", { className: (0, import_classnames15.default)("tlui-dialog__header", className), children });
}
function TldrawUiDialogTitle({ className, children, style: style2 }) {
  return (0, import_jsx_runtime93.jsx)(
    dist_exports3.Title,
    {
      dir: "ltr",
      className: (0, import_classnames15.default)("tlui-dialog__header__title", className),
      style: style2,
      children
    }
  );
}
function TldrawUiDialogCloseButton() {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime93.jsx)("div", { className: "tlui-dialog__header__close", children: (0, import_jsx_runtime93.jsx)(dist_exports3.DialogClose, { "data-testid": "dialog.close", dir: "ltr", asChild: true, children: (0, import_jsx_runtime93.jsx)(
    TldrawUiButton,
    {
      type: "icon",
      "aria-label": msg2("ui.close"),
      onTouchEnd: (e) => e.target.click(),
      children: (0, import_jsx_runtime93.jsx)(TldrawUiButtonIcon, { small: true, icon: "cross-2" })
    }
  ) }) });
}
function TldrawUiDialogBody({ className, children, style: style2 }) {
  return (0, import_jsx_runtime93.jsx)("div", { className: (0, import_classnames15.default)("tlui-dialog__body", className), style: style2, children });
}
function TldrawUiDialogFooter({ className, children }) {
  return (0, import_jsx_runtime93.jsx)("div", { className: (0, import_classnames15.default)("tlui-dialog__footer", className), children });
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiInput.mjs
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var import_classnames16 = __toESM(require_classnames(), 1);
var React83 = __toESM(require_react(), 1);
var TldrawUiInput = React83.forwardRef(
  function TldrawUiInput2({
    className,
    label,
    icon,
    iconLeft,
    iconLabel,
    autoSelect = false,
    autoFocus = false,
    defaultValue,
    placeholder,
    onComplete,
    onValueChange,
    onCancel,
    onFocus,
    onBlur,
    shouldManuallyMaintainScrollPositionWhenFocused = false,
    children,
    value,
    "data-testid": dataTestId
  }, ref) {
    const editor = useMaybeEditor();
    const rInputRef = React83.useRef(null);
    React83.useImperativeHandle(ref, () => rInputRef.current);
    const msg2 = useTranslation();
    const rInitialValue = React83.useRef(defaultValue ?? "");
    const rCurrentValue = React83.useRef(defaultValue ?? "");
    const isComposing = React83.useRef(false);
    const [isFocused, setIsFocused] = React83.useState(false);
    const handleFocus = React83.useCallback(
      (e) => {
        setIsFocused(true);
        const elm = e.currentTarget;
        rCurrentValue.current = elm.value;
        if (editor) {
          editor.timers.requestAnimationFrame(() => {
            if (autoSelect) {
              elm.select();
            }
          });
        } else {
          tltime.requestAnimationFrame("anon", () => {
            if (autoSelect) {
              elm.select();
            }
          });
        }
        onFocus == null ? void 0 : onFocus();
      },
      [autoSelect, editor, onFocus]
    );
    const handleChange = React83.useCallback(
      (e) => {
        const value2 = e.currentTarget.value;
        rCurrentValue.current = value2;
        onValueChange == null ? void 0 : onValueChange(value2);
      },
      [onValueChange]
    );
    const handleKeyDownCapture = React83.useCallback(
      (e) => {
        switch (e.key) {
          case "Enter": {
            if (isComposing.current)
              return;
            e.currentTarget.blur();
            stopEventPropagation(e);
            onComplete == null ? void 0 : onComplete(e.currentTarget.value);
            break;
          }
          case "Escape": {
            e.currentTarget.value = rInitialValue.current;
            onCancel == null ? void 0 : onCancel(e.currentTarget.value);
            e.currentTarget.blur();
            stopEventPropagation(e);
            break;
          }
        }
      },
      [onComplete, onCancel]
    );
    const handleBlur = React83.useCallback(
      (e) => {
        setIsFocused(false);
        const value2 = e.currentTarget.value;
        onBlur == null ? void 0 : onBlur(value2);
      },
      [onBlur]
    );
    const handleCompositionStart = React83.useCallback(() => isComposing.current = true, []);
    const handleCompositionEnd = React83.useCallback(() => isComposing.current = false, []);
    React83.useEffect(() => {
      if (!tlenv.isIos)
        return;
      const visualViewport = window.visualViewport;
      if (isFocused && shouldManuallyMaintainScrollPositionWhenFocused && visualViewport) {
        const onViewportChange = () => {
          var _a5;
          (_a5 = rInputRef.current) == null ? void 0 : _a5.scrollIntoView({ block: "center" });
        };
        visualViewport.addEventListener("resize", onViewportChange);
        visualViewport.addEventListener("scroll", onViewportChange);
        if (editor) {
          editor.timers.requestAnimationFrame(() => {
            var _a5;
            (_a5 = rInputRef.current) == null ? void 0 : _a5.scrollIntoView({ block: "center" });
          });
        } else {
          tltime.requestAnimationFrame("anon", () => {
            var _a5;
            (_a5 = rInputRef.current) == null ? void 0 : _a5.scrollIntoView({ block: "center" });
          });
        }
        return () => {
          visualViewport.removeEventListener("resize", onViewportChange);
          visualViewport.removeEventListener("scroll", onViewportChange);
        };
      }
    }, [isFocused, editor, shouldManuallyMaintainScrollPositionWhenFocused]);
    return (0, import_jsx_runtime94.jsxs)("div", { draggable: false, className: "tlui-input__wrapper", children: [
      children,
      label && (0, import_jsx_runtime94.jsx)("label", { children: msg2(label) }),
      iconLeft && (0, import_jsx_runtime94.jsx)(
        TldrawUiIcon,
        {
          label: iconLabel ? msg2(iconLabel) : "",
          icon: iconLeft,
          className: "tlui-icon-left",
          small: true
        }
      ),
      (0, import_jsx_runtime94.jsx)(
        "input",
        {
          ref: rInputRef,
          className: (0, import_classnames16.default)("tlui-input", className),
          type: "text",
          defaultValue,
          onKeyDownCapture: handleKeyDownCapture,
          onChange: handleChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onCompositionStart: handleCompositionStart,
          onCompositionEnd: handleCompositionEnd,
          autoFocus,
          placeholder,
          value,
          "data-testid": dataTestId
        }
      ),
      icon && (0, import_jsx_runtime94.jsx)(TldrawUiIcon, { label: iconLabel ? msg2(iconLabel) : "", icon, small: !!label })
    ] });
  }
);

// node_modules/tldraw/dist-esm/lib/ui/components/EditLinkDialog.mjs
function validateUrl(url) {
  if (validation_exports.linkUrl.isValid(url)) {
    return { isValid: true, hasProtocol: true };
  }
  if (validation_exports.linkUrl.isValid("https://" + url)) {
    return { isValid: true, hasProtocol: false };
  }
  return { isValid: false, hasProtocol: false };
}
var EditLinkDialog = track(function EditLinkDialog2({ onClose }) {
  const editor = useEditor();
  const selectedShape = editor.getOnlySelectedShape();
  if (!(selectedShape && "url" in selectedShape.props && typeof selectedShape.props.url === "string")) {
    return null;
  }
  return (0, import_jsx_runtime95.jsx)(EditLinkDialogInner, { onClose, selectedShape });
});
var EditLinkDialogInner = track(function EditLinkDialogInner2({
  onClose,
  selectedShape
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const rInput = (0, import_react64.useRef)(null);
  (0, import_react64.useEffect)(() => {
    editor.timers.requestAnimationFrame(() => {
      var _a5;
      return (_a5 = rInput.current) == null ? void 0 : _a5.focus();
    });
  }, [editor]);
  const rInitialValue = (0, import_react64.useRef)(selectedShape.props.url);
  const [urlInputState, setUrlInputState] = (0, import_react64.useState)(() => {
    const urlValidResult = validateUrl(selectedShape.props.url);
    const initialValue = urlValidResult.isValid === true ? urlValidResult.hasProtocol ? selectedShape.props.url : "https://" + selectedShape.props.url : "https://";
    return {
      actual: initialValue,
      safe: initialValue,
      valid: true
    };
  });
  const handleChange = (0, import_react64.useCallback)((rawValue) => {
    const fixedRawValue = rawValue.replace(/https?:\/\/(https?:\/\/)/, (_match, arg1) => {
      return arg1;
    });
    const urlValidResult = validateUrl(fixedRawValue);
    const safeValue = urlValidResult.isValid === true ? urlValidResult.hasProtocol ? fixedRawValue : "https://" + fixedRawValue : "https://";
    setUrlInputState({
      actual: fixedRawValue,
      safe: safeValue,
      valid: urlValidResult.isValid
    });
  }, []);
  const handleClear = (0, import_react64.useCallback)(() => {
    const onlySelectedShape = editor.getOnlySelectedShape();
    if (!onlySelectedShape)
      return;
    editor.updateShapes([
      { id: onlySelectedShape.id, type: onlySelectedShape.type, props: { url: "" } }
    ]);
    onClose();
  }, [editor, onClose]);
  const handleComplete = (0, import_react64.useCallback)(() => {
    const onlySelectedShape = editor.getOnlySelectedShape();
    if (!onlySelectedShape)
      return;
    if (onlySelectedShape && "url" in onlySelectedShape.props) {
      if (onlySelectedShape.props.url !== urlInputState.safe) {
        editor.updateShapes([
          {
            id: onlySelectedShape.id,
            type: onlySelectedShape.type,
            props: { url: urlInputState.safe }
          }
        ]);
      }
    }
    onClose();
  }, [editor, onClose, urlInputState]);
  const handleCancel = (0, import_react64.useCallback)(() => {
    onClose();
  }, [onClose]);
  if (!selectedShape) {
    onClose();
    return null;
  }
  const isRemoving = rInitialValue.current && !urlInputState.valid;
  return (0, import_jsx_runtime95.jsxs)(import_jsx_runtime95.Fragment, { children: [
    (0, import_jsx_runtime95.jsxs)(TldrawUiDialogHeader, { children: [
      (0, import_jsx_runtime95.jsx)(TldrawUiDialogTitle, { children: msg2("edit-link-dialog.title") }),
      (0, import_jsx_runtime95.jsx)(TldrawUiDialogCloseButton, {})
    ] }),
    (0, import_jsx_runtime95.jsx)(TldrawUiDialogBody, { children: (0, import_jsx_runtime95.jsxs)("div", { className: "tlui-edit-link-dialog", children: [
      (0, import_jsx_runtime95.jsx)(
        TldrawUiInput,
        {
          ref: rInput,
          className: "tlui-edit-link-dialog__input",
          label: "edit-link-dialog.url",
          autoFocus: true,
          autoSelect: true,
          placeholder: "https://example.com",
          value: urlInputState.actual,
          onValueChange: handleChange,
          onComplete: handleComplete,
          onCancel: handleCancel
        }
      ),
      (0, import_jsx_runtime95.jsx)("div", { children: urlInputState.valid ? msg2("edit-link-dialog.detail") : msg2("edit-link-dialog.invalid-url") })
    ] }) }),
    (0, import_jsx_runtime95.jsxs)(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
      (0, import_jsx_runtime95.jsx)(TldrawUiButton, { type: "normal", onClick: handleCancel, onTouchEnd: handleCancel, children: (0, import_jsx_runtime95.jsx)(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.cancel") }) }),
      isRemoving ? (0, import_jsx_runtime95.jsx)(TldrawUiButton, { type: "danger", onTouchEnd: handleClear, onClick: handleClear, children: (0, import_jsx_runtime95.jsx)(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.clear") }) }) : (0, import_jsx_runtime95.jsx)(
        TldrawUiButton,
        {
          type: "primary",
          disabled: !urlInputState.valid,
          onTouchEnd: handleComplete,
          onClick: handleComplete,
          children: (0, import_jsx_runtime95.jsx)(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.save") })
        }
      )
    ] })
  ] });
});

// node_modules/tldraw/dist-esm/lib/ui/components/EmbedDialog.mjs
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/defaultEmbedDefinitions.mjs
var TLDRAW_APP_RE2 = /(^\/[f|p|r|ro|s|v]\/[^/]+\/?$)/;
var DEFAULT_EMBED_DEFINITIONS = [
  {
    type: "tldraw",
    title: "tldraw",
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: true,
    overridePermissions: {
      "allow-top-navigation": true
    },
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE2)) {
        urlObj.searchParams.append("embed", "true");
        return url;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE2)) {
        urlObj.searchParams.delete("embed");
        return url;
      }
      return;
    }
  },
  {
    type: "figma",
    title: "Figma",
    hostnames: ["figma.com"],
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      if (!!url.match(
        // eslint-disable-next-line no-useless-escape
        /https:\/\/([\w\.-]+\.)?figma.com\/(file|proto|design)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/
      ) && !url.includes("figma.com/embed")) {
        return `https://www.figma.com/embed?embed_host=share&url=${url}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/?$/)) {
        const outUrl = urlObj.searchParams.get("url");
        if (outUrl) {
          return outUrl;
        }
      }
      return;
    }
  },
  {
    type: "google_maps",
    title: "Google Maps",
    hostnames: ["google.*"],
    width: 720,
    height: 500,
    doesResize: true,
    overridePermissions: {
      "allow-presentation": true
    },
    toEmbedUrl: (url) => {
      if (url.includes("/maps/embed?")) {
        return url;
      } else if (url.includes("/maps/")) {
        const match = url.match(/@(.*?),(.*?),(.*?)(z|m)/);
        let result;
        if (match) {
          const [, lat, lng, zoomOrMeters, mapTypeSymbol] = match;
          const mapType = mapTypeSymbol === "z" ? "roadmap" : "satellite";
          const z = mapType === "roadmap" ? zoomOrMeters : -Math.log2(parseInt(zoomOrMeters) / 14772321) / 0.8;
          const host = new URL(url).host.replace("www.", "");
          result = `https://${host}/maps/embed/v1/view?key=${process.env.NEXT_PUBLIC_GC_API_KEY}&center=${lat},${lng}&zoom=${z}&maptype=${mapType}`;
        } else {
          result = "";
        }
        return result;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj)
        return;
      const matches2 = urlObj.pathname.match(/^\/maps\/embed\/v1\/view\/?$/);
      if (matches2 && urlObj.searchParams.has("center") && urlObj.searchParams.get("zoom")) {
        const zoom = urlObj.searchParams.get("zoom") ?? "12";
        const mapType = urlObj.searchParams.get("maptype") ?? "roadmap";
        const zoomOrMeters = mapType === "roadmap" ? zoom : 14772321 * Math.pow(2, parseInt(zoom) * -0.8);
        const [lat, lon] = urlObj.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${lat},${lon},${zoomOrMeters}${mapType === "roadmap" ? "z" : "m"}`;
      }
      return;
    }
  },
  {
    type: "val_town",
    title: "Val Town",
    hostnames: ["val.town"],
    minWidth: 260,
    minHeight: 100,
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/v\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/embed/${matches2[1]}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/v/${matches2[1]}`;
      }
      return;
    }
  },
  {
    type: "codesandbox",
    title: "CodeSandbox",
    hostnames: ["codesandbox.io"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/s\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/embed/${matches2[1]}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/s/${matches2[1]}`;
      }
      return;
    }
  },
  {
    type: "codepen",
    title: "Codepen",
    hostnames: ["codepen.io"],
    minWidth: 300,
    minHeight: 300,
    width: 520,
    height: 400,
    doesResize: true,
    toEmbedUrl: (url) => {
      const CODEPEN_URL_REGEXP = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/;
      const matches2 = url.match(CODEPEN_URL_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/embed/${id}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const CODEPEN_EMBED_REGEXP = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/;
      const matches2 = url.match(CODEPEN_EMBED_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/pen/${id}`;
      }
      return;
    }
  },
  {
    type: "scratch",
    title: "Scratch",
    hostnames: ["scratch.mit.edu"],
    width: 520,
    height: 400,
    doesResize: false,
    toEmbedUrl: (url) => {
      const SCRATCH_URL_REGEXP = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/;
      const matches2 = url.match(SCRATCH_URL_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/embed/${id}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const SCRATCH_EMBED_REGEXP = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/;
      const matches2 = url.match(SCRATCH_EMBED_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/${id}`;
      }
      return;
    }
  },
  {
    type: "youtube",
    title: "YouTube",
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    width: 800,
    height: 450,
    doesResize: true,
    overridePermissions: {
      "allow-presentation": true,
      "allow-popups-to-escape-sandbox": true
    },
    isAspectRatioLocked: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj)
        return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtu.be") {
        const videoId = urlObj.pathname.split("/").filter(Boolean)[0];
        const searchParams = new URLSearchParams(urlObj.search);
        const timeStart = searchParams.get("t");
        if (timeStart) {
          searchParams.set("start", timeStart);
          searchParams.delete("t");
        }
        const search = searchParams.toString() ? "?" + searchParams.toString() : "";
        return `https://www.youtube.com/embed/${videoId}${search}`;
      } else if ((hostname === "youtube.com" || hostname === "m.youtube.com") && urlObj.pathname.match(/^\/watch/)) {
        const videoId = urlObj.searchParams.get("v");
        const searchParams = new URLSearchParams(urlObj.search);
        searchParams.delete("v");
        const timeStart = searchParams.get("t");
        if (timeStart) {
          searchParams.set("start", timeStart);
          searchParams.delete("t");
        }
        const search = searchParams.toString() ? "?" + searchParams.toString() : "";
        return `https://www.youtube.com/embed/${videoId}${search}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj)
        return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtube.com") {
        const matches2 = urlObj.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (matches2) {
          const params = new URLSearchParams(urlObj.search);
          params.set("v", (matches2 == null ? void 0 : matches2[1]) ?? "");
          const timeStart = params.get("start");
          if (timeStart) {
            params.set("t", timeStart);
            params.delete("start");
          }
          return `https://www.youtube.com/watch?${params.toString()}`;
        }
      }
      return;
    }
  },
  {
    type: "google_calendar",
    title: "Google Calendar",
    hostnames: ["calendar.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: true,
    instructionLink: "https://support.google.com/calendar/answer/41207?hl=en",
    overridePermissions: {
      "allow-popups-to-escape-sandbox": true
    },
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const cidQs = urlObj == null ? void 0 : urlObj.searchParams.get("cid");
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/\/calendar\/u\/0/)) && cidQs) {
        urlObj.pathname = "/calendar/embed";
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("src", cidQs);
        return urlObj.href;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const srcQs = urlObj == null ? void 0 : urlObj.searchParams.get("src");
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/\/calendar\/embed/)) && srcQs) {
        urlObj.pathname = "/calendar/u/0";
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("cid", srcQs);
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "google_slides",
    title: "Google Slides",
    hostnames: ["docs.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: true,
    overridePermissions: {
      "allow-popups-to-escape-sandbox": true
    },
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/^\/presentation/)) && (urlObj == null ? void 0 : urlObj.pathname.match(/\/pub\/?$/))) {
        urlObj.pathname = urlObj.pathname.replace(/\/pub$/, "/embed");
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/^\/presentation/)) && (urlObj == null ? void 0 : urlObj.pathname.match(/\/embed\/?$/))) {
        urlObj.pathname = urlObj.pathname.replace(/\/embed$/, "/pub");
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "github_gist",
    title: "GitHub Gist",
    hostnames: ["gist.github.com"],
    width: 720,
    height: 500,
    doesResize: true,
    // Security warning:
    // Gists allow adding .json extensions to the URL which return JSONP.
    // Furthermore, the JSONP can include callbacks that execute arbitrary JavaScript.
    // It _is_ sandboxed by the iframe but we still want to disable it nonetheless.
    // We restrict the id to only allow hexdecimal characters to prevent this.
    // Read more:
    //   https://github.com/bhaveshk90/Content-Security-Policy-CSP-Bypass-Techniques
    //   https://github.com/renniepak/CSPBypass
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/)) {
        if (!url.split("/").pop())
          return;
        return url;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/)) {
        if (!url.split("/").pop())
          return;
        return url;
      }
      return;
    }
  },
  {
    type: "replit",
    title: "Replit",
    hostnames: ["replit.com"],
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/)) {
        return `${url}?embed=true`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/) && urlObj.searchParams.has("embed")) {
        urlObj.searchParams.delete("embed");
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "felt",
    title: "Felt",
    hostnames: ["felt.com"],
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/map\//)) {
        return urlObj.origin + "/embed" + urlObj.pathname;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/map\//)) {
        urlObj.pathname = urlObj.pathname.replace(/^\/embed/, "");
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "spotify",
    title: "Spotify",
    hostnames: ["open.spotify.com"],
    width: 720,
    height: 500,
    minHeight: 500,
    overrideOutlineRadius: 12,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/(artist|album)\//)) {
        return urlObj.origin + "/embed" + urlObj.pathname;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/(artist|album)\//)) {
        return urlObj.origin + urlObj.pathname.replace(/^\/embed/, "");
      }
      return;
    }
  },
  {
    type: "vimeo",
    title: "Vimeo",
    hostnames: ["vimeo.com", "player.vimeo.com"],
    width: 640,
    height: 360,
    doesResize: true,
    isAspectRatioLocked: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "vimeo.com") {
        if (urlObj.pathname.match(/^\/[0-9]+/)) {
          return "https://player.vimeo.com/video/" + urlObj.pathname.split("/")[1] + "?title=0&byline=0";
        }
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "player.vimeo.com") {
        const matches2 = urlObj.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (matches2) {
          return "https://vimeo.com/" + matches2[1];
        }
      }
      return;
    }
  },
  {
    type: "excalidraw",
    title: "Excalidraw",
    hostnames: ["excalidraw.com"],
    width: 720,
    height: 500,
    doesResize: true,
    isAspectRatioLocked: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hash.match(/#room=/)) {
        return url;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hash.match(/#room=/)) {
        return url;
      }
      return;
    }
  },
  {
    type: "observable",
    title: "Observable",
    hostnames: ["observablehq.com"],
    width: 720,
    height: 500,
    doesResize: true,
    isAspectRatioLocked: false,
    backgroundColor: "#fff",
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}/embed${urlObj.pathname}?cell=*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/d\/([^/]+)\/?$/)) {
        const pathName = urlObj.pathname.replace(/^\/d/, "");
        return `${urlObj.origin}/embed${pathName}?cell=*`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "")}#cell-*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/embed\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "/d")}#cell-*`;
      }
      return;
    }
  },
  {
    type: "desmos",
    title: "Desmos",
    hostnames: ["desmos.com"],
    width: 700,
    height: 450,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "" && urlObj.hash === "") {
        return `${url}?embed`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "?embed" && urlObj.hash === "") {
        return url.replace("?embed", "");
      }
      return;
    }
  }
];
var embedShapePermissionDefaults = {
  // ========================================================================================
  // Disabled permissions
  // ========================================================================================
  // [MDN] Experimental: Allows for downloads to occur without a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads-without-user-activation": false,
  // [MDN] Allows for downloads to occur with a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads": false,
  // [MDN] Lets the resource open modal windows.
  // [REASON] The <iframe/> could 'window.prompt("Enter your tldraw password")'.
  "allow-modals": false,
  // [MDN] Lets the resource lock the screen orientation.
  // [REASON] Would interfere with the tldraw interface.
  "allow-orientation-lock": false,
  // [MDN] Lets the resource use the Pointer Lock API.
  // [REASON] Maybe we should allow this for games embeds (scratch/codepen/codesandbox).
  "allow-pointer-lock": false,
  // [MDN] Allows popups (such as window.open(), target="_blank", or showModalDialog()). If this keyword is not used, the popup will silently fail to open.
  // [REASON] We want to allow embeds to link back to their original sites (e.g. YouTube).
  "allow-popups": true,
  // [MDN] Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.
  // [REASON] We shouldn't allow popups as a embed could pretend to be us by opening a mocked version of tldraw. This is very unobvious when it is performed as an action within our app.
  "allow-popups-to-escape-sandbox": false,
  // [MDN] Lets the resource start a presentation session.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-presentation": false,
  // [MDN] Experimental: Lets the resource request access to the parent's storage capabilities with the Storage Access API.
  // [REASON] We don't want anyone else to access our storage.
  "allow-storage-access-by-user-activation": false,
  // [MDN] Lets the resource navigate the top-level browsing context (the one named _top).
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation": false,
  // [MDN] Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation-by-user-activation": false,
  // ========================================================================================
  // Enabled permissions
  // ========================================================================================
  // [MDN] Lets the resource run scripts (but not create popup windows).
  "allow-scripts": true,
  // [MDN] If this token is not used, the resource is treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs).
  "allow-same-origin": true,
  // [MDN] Allows the resource to submit forms. If this keyword is not used, form submission is blocked.
  "allow-forms": true
};
var DEFAULT_EMBED_DEFINITION_TYPES = DEFAULT_EMBED_DEFINITIONS.map(
  (def) => def.type
);
function isDefaultEmbedDefinitionType(type) {
  return DEFAULT_EMBED_DEFINITION_TYPES.includes(type);
}
function isCustomEmbedDefinition(def) {
  return "icon" in def;
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useGetEmbedDefinition.mjs
function useGetEmbedShapeUtil() {
  const editor = useMaybeEditor();
  if (!editor)
    return void 0;
  if (editor.hasShapeUtil("embed")) {
    return editor.getShapeUtil("embed");
  }
  return void 0;
}
function useGetEmbedDefinition() {
  const embedUtil = useGetEmbedShapeUtil();
  return (url) => {
    return embedUtil ? embedUtil.getEmbedDefinition(url) : void 0;
  };
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useGetEmbedDefinitions.mjs
function useGetEmbedDefinitions() {
  const embedUtil = useGetEmbedShapeUtil();
  return embedUtil ? embedUtil.getEmbedDefinitions() : [];
}

// node_modules/tldraw/dist-esm/lib/ui/components/EmbedDialog.mjs
var EmbedDialog = track(function EmbedDialog2({ onClose }) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const assetUrls = useAssetUrls();
  const [embedDefinition, setEmbedDefinition] = (0, import_react65.useState)(null);
  const [url, setUrl] = (0, import_react65.useState)("");
  const [embedInfoForUrl, setEmbedInfoForUrl] = (0, import_react65.useState)(null);
  const [showError, setShowError] = (0, import_react65.useState)(false);
  const rShowErrorTimeout = (0, import_react65.useRef)(-1);
  const definitions = useGetEmbedDefinitions();
  const getEmbedDefinition = useGetEmbedDefinition();
  return (0, import_jsx_runtime96.jsxs)(import_jsx_runtime96.Fragment, { children: [
    (0, import_jsx_runtime96.jsxs)(TldrawUiDialogHeader, { children: [
      (0, import_jsx_runtime96.jsx)(TldrawUiDialogTitle, { children: embedDefinition ? `${msg2("embed-dialog.title")} — ${embedDefinition.title}` : msg2("embed-dialog.title") }),
      (0, import_jsx_runtime96.jsx)(TldrawUiDialogCloseButton, {})
    ] }),
    embedDefinition ? (0, import_jsx_runtime96.jsxs)(import_jsx_runtime96.Fragment, { children: [
      (0, import_jsx_runtime96.jsxs)(TldrawUiDialogBody, { className: "tlui-embed-dialog__enter", children: [
        (0, import_jsx_runtime96.jsx)(
          TldrawUiInput,
          {
            className: "tlui-embed-dialog__input",
            label: "embed-dialog.url",
            placeholder: "https://example.com",
            autoFocus: true,
            onValueChange: (value) => {
              setUrl(value);
              const embedInfo = getEmbedDefinition(value);
              setEmbedInfoForUrl(
                embedInfo && embedInfo.definition.type === embedDefinition.type ? embedInfo : null
              );
              setShowError(false);
              clearTimeout(rShowErrorTimeout.current);
              rShowErrorTimeout.current = editor.timers.setTimeout(
                () => setShowError(!embedInfo),
                320
              );
            }
          }
        ),
        url === "" ? (0, import_jsx_runtime96.jsxs)("div", { className: "tlui-embed-dialog__instruction", children: [
          (0, import_jsx_runtime96.jsx)("span", { children: msg2("embed-dialog.instruction") }),
          " ",
          embedDefinition.instructionLink && (0, import_jsx_runtime96.jsxs)(import_jsx_runtime96.Fragment, { children: [
            (0, import_jsx_runtime96.jsx)(
              "a",
              {
                target: "_blank",
                rel: "noopener noreferrer",
                href: embedDefinition.instructionLink,
                className: "tlui-embed-dialog__instruction__link",
                children: "Learn more"
              }
            ),
            "."
          ] })
        ] }) : (0, import_jsx_runtime96.jsx)("div", { className: "tlui-embed-dialog__warning", children: showError ? msg2("embed-dialog.invalid-url") : " " })
      ] }),
      (0, import_jsx_runtime96.jsxs)(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
        (0, import_jsx_runtime96.jsx)(
          TldrawUiButton,
          {
            type: "normal",
            onClick: () => {
              setEmbedDefinition(null);
              setEmbedInfoForUrl(null);
              setUrl("");
            },
            children: (0, import_jsx_runtime96.jsx)(TldrawUiButtonLabel, { children: msg2("embed-dialog.back") })
          }
        ),
        (0, import_jsx_runtime96.jsx)("div", { className: "tlui-embed__spacer" }),
        (0, import_jsx_runtime96.jsx)(TldrawUiButton, { type: "normal", onClick: onClose, children: (0, import_jsx_runtime96.jsx)(TldrawUiButtonLabel, { children: msg2("embed-dialog.cancel") }) }),
        (0, import_jsx_runtime96.jsx)(
          TldrawUiButton,
          {
            type: "primary",
            disabled: !embedInfoForUrl,
            onClick: () => {
              if (!embedInfoForUrl)
                return;
              editor.putExternalContent({
                type: "embed",
                url,
                point: editor.getViewportPageBounds().center,
                embed: embedInfoForUrl.definition
              });
              onClose();
            },
            children: (0, import_jsx_runtime96.jsx)(TldrawUiButtonLabel, { children: msg2("embed-dialog.create") })
          }
        )
      ] })
    ] }) : (0, import_jsx_runtime96.jsx)(import_jsx_runtime96.Fragment, { children: (0, import_jsx_runtime96.jsx)(TldrawUiDialogBody, { className: "tlui-embed-dialog__list", children: definitions.map((def) => {
      const url2 = isDefaultEmbedDefinitionType(def.type) ? assetUrls.embedIcons[def.type] : isCustomEmbedDefinition(def) ? def.icon : void 0;
      return (0, import_jsx_runtime96.jsxs)(TldrawUiButton, { type: "menu", onClick: () => setEmbedDefinition(def), children: [
        (0, import_jsx_runtime96.jsx)(TldrawUiButtonLabel, { children: untranslated(def.title) }),
        url2 && (0, import_jsx_runtime96.jsx)(
          "div",
          {
            className: "tlui-embed-dialog__item__image",
            style: { backgroundImage: `url(${url2})` }
          }
        )
      ] }, def.type);
    }) }) })
  ] });
});

// node_modules/tldraw/dist-esm/lib/ui/hooks/useCollaborationStatus.mjs
function useShowCollaborationUi() {
  const editor = useMaybeEditor();
  return (editor == null ? void 0 : editor.store.props.collaboration) !== void 0;
}
function useCollaborationStatus() {
  const editor = useMaybeEditor();
  return useValue(
    "sync status",
    () => {
      var _a5;
      if (!((_a5 = editor == null ? void 0 : editor.store.props.collaboration) == null ? void 0 : _a5.status)) {
        return null;
      }
      return editor.store.props.collaboration.status.get();
    },
    [editor]
  );
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useFlatten.mjs
var import_react66 = __toESM(require_react(), 1);
async function flattenShapesToImages(editor, shapeIds, flattenImageBoundsExpand) {
  const shapes = compact(
    shapeIds.map((id) => {
      const shape = editor.getShape(id);
      if (!shape)
        return;
      const util = editor.getShapeUtil(shape.type);
      if (util.toSvg === void 0)
        return;
      return shape;
    })
  );
  if (shapes.length === 0)
    return;
  if (shapes.length === 1) {
    const shape = shapes[0];
    if (!shape)
      return;
    if (editor.isShapeOfType(shape, "image"))
      return;
  }
  const groups = [];
  if (flattenImageBoundsExpand !== void 0) {
    const expandedBounds = shapes.map((shape) => {
      return {
        shape,
        bounds: editor.getShapeMaskedPageBounds(shape).clone().expandBy(flattenImageBoundsExpand)
      };
    });
    for (let i = 0; i < expandedBounds.length; i++) {
      const item = expandedBounds[i];
      if (i === 0) {
        groups[0] = {
          shapes: [item.shape],
          bounds: item.bounds
        };
        continue;
      }
      let didLand = false;
      for (const group of groups) {
        if (group.bounds.includes(item.bounds)) {
          group.shapes.push(item.shape);
          group.bounds.expand(item.bounds);
          didLand = true;
          break;
        }
      }
      if (!didLand) {
        groups.push({
          shapes: [item.shape],
          bounds: item.bounds
        });
      }
    }
  } else {
    const bounds = Box.Common(shapes.map((shape) => editor.getShapeMaskedPageBounds(shape)));
    groups.push({
      shapes,
      bounds
    });
  }
  const padding = editor.options.flattenImageBoundsPadding;
  for (const group of groups) {
    if (flattenImageBoundsExpand !== void 0) {
      group.bounds.expandBy(-flattenImageBoundsExpand);
    }
    const svgResult = await editor.getSvgString(group.shapes, {
      padding,
      background: false
    });
    if (!(svgResult == null ? void 0 : svgResult.svg))
      continue;
    const asset = await editor.getAssetForExternalContent({
      type: "file",
      file: new File([svgResult.svg], "asset.svg", { type: "image/svg+xml" })
    });
    if (!asset)
      continue;
    group.asset = asset;
  }
  const createdShapeIds = [];
  transact(() => {
    for (const group of groups) {
      const { asset, bounds, shapes: shapes2 } = group;
      if (!asset)
        continue;
      const commonAncestorId = editor.findCommonAncestor(shapes2) ?? editor.getCurrentPageId();
      if (!commonAncestorId)
        continue;
      let index3 = "a1";
      for (const shape of shapes2) {
        if (shape.parentId === commonAncestorId) {
          if (shape.index > index3) {
            index3 = shape.index;
          }
          break;
        }
      }
      let x;
      let y;
      let rotation;
      if (isShapeId(commonAncestorId)) {
        const commonAncestor = editor.getShape(commonAncestorId);
        if (!commonAncestor)
          continue;
        const point = editor.getPointInShapeSpace(commonAncestor, {
          x: bounds.x,
          y: bounds.y
        });
        rotation = editor.getShapePageTransform(commonAncestorId).rotation();
        point.sub(new Vec(padding, padding).rot(-rotation));
        x = point.x;
        y = point.y;
      } else {
        x = bounds.x - padding;
        y = bounds.y - padding;
        rotation = 0;
      }
      editor.deleteShapes(shapes2);
      editor.createAssets([{ ...asset, id: asset.id }]);
      const shapeId = createShapeId();
      editor.createShape({
        id: shapeId,
        type: "image",
        index: index3,
        parentId: commonAncestorId,
        x,
        y,
        rotation: -rotation,
        props: {
          assetId: asset.id,
          w: bounds.w + padding * 2,
          h: bounds.h + padding * 2
        }
      });
      createdShapeIds.push(shapeId);
    }
  });
  return createdShapeIds;
}

// node_modules/tldraw/dist-esm/lib/ui/overrides.mjs
var import_react75 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/constants.mjs
var PORTRAIT_BREAKPOINTS = [0, 389, 436, 476, 580, 640, 840, 1023];
var PORTRAIT_BREAKPOINT = ((PORTRAIT_BREAKPOINT2) => {
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["ZERO"] = 0] = "ZERO";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_XXS"] = 1] = "MOBILE_XXS";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_XS"] = 2] = "MOBILE_XS";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_SM"] = 3] = "MOBILE_SM";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE"] = 4] = "MOBILE";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["TABLET_SM"] = 5] = "TABLET_SM";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["TABLET"] = 6] = "TABLET";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["DESKTOP"] = 7] = "DESKTOP";
  return PORTRAIT_BREAKPOINT2;
})(PORTRAIT_BREAKPOINT || {});

// node_modules/tldraw/dist-esm/lib/ui/context/breakpoints.mjs
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react67 = __toESM(require_react(), 1);
var BreakpointContext = import_react67.default.createContext(null);
function BreakPointProvider({ forceMobile = false, children }) {
  const editor = useMaybeEditor();
  const breakpoint = useValue(
    "breakpoint",
    () => {
      const { width } = (editor == null ? void 0 : editor.getViewportScreenBounds()) ?? { width: window.innerWidth };
      const maxBreakpoint = forceMobile ? PORTRAIT_BREAKPOINT.MOBILE_SM : PORTRAIT_BREAKPOINTS.length - 1;
      for (let i = 0; i < maxBreakpoint; i++) {
        if (width > PORTRAIT_BREAKPOINTS[i] && width <= PORTRAIT_BREAKPOINTS[i + 1]) {
          return i;
        }
      }
      return maxBreakpoint;
    },
    [editor]
  );
  return (0, import_jsx_runtime97.jsx)(BreakpointContext.Provider, { value: breakpoint, children });
}
function useBreakpoint() {
  const breakpoint = (0, import_react67.useContext)(BreakpointContext);
  if (breakpoint === null) {
    throw new Error("useBreakpoint must be used inside of the <BreakpointProvider /> component");
  }
  return breakpoint;
}

// node_modules/tldraw/dist-esm/lib/ui/context/dialogs.mjs
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react68 = __toESM(require_react(), 1);
var DialogsContext = (0, import_react68.createContext)(null);
function TldrawUiDialogsProvider({ context, children }) {
  const ctx = (0, import_react68.useContext)(DialogsContext);
  const trackEvent = useUiEvents();
  const dialogs = useAtom("dialogs", []);
  const content = (0, import_react68.useMemo)(() => {
    return {
      dialogs,
      addDialog(dialog) {
        const id = dialog.id ?? uniqueId();
        dialogs.update((d) => {
          return [...d.filter((m) => m.id !== dialog.id), { ...dialog, id }];
        });
        trackEvent("open-menu", { source: "dialog", id });
        tlmenus.addOpenMenu(id, context);
        return id;
      },
      removeDialog(id) {
        var _a5;
        const dialog = dialogs.get().find((d) => d.id === id);
        if (dialog) {
          (_a5 = dialog.onClose) == null ? void 0 : _a5.call(dialog);
          trackEvent("close-menu", { source: "dialog", id });
          tlmenus.deleteOpenMenu(id, context);
          dialogs.update((d) => d.filter((m) => m !== dialog));
        }
        return id;
      },
      clearDialogs() {
        const current = dialogs.get();
        if (current.length === 0)
          return;
        current.forEach((d) => {
          var _a5;
          (_a5 = d.onClose) == null ? void 0 : _a5.call(d);
          trackEvent("close-menu", { source: "dialog", id: d.id });
          tlmenus.deleteOpenMenu(d.id, context);
        });
        dialogs.set([]);
      }
    };
  }, [trackEvent, dialogs, context]);
  if (ctx)
    return (0, import_jsx_runtime98.jsx)(import_jsx_runtime98.Fragment, { children });
  return (0, import_jsx_runtime98.jsx)(DialogsContext.Provider, { value: content, children });
}
function useDialogs() {
  const ctx = (0, import_react68.useContext)(DialogsContext);
  if (!ctx) {
    throw new Error("useDialogs must be used within a DialogsProvider");
  }
  return ctx;
}

// node_modules/tldraw/dist-esm/lib/ui/context/toasts.mjs
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_react69 = __toESM(require_react(), 1);
var ToastsContext = (0, import_react69.createContext)(null);
function TldrawUiToastsProvider({ children }) {
  const toasts = useAtom("toasts", []);
  const ctx = (0, import_react69.useContext)(ToastsContext);
  const current = (0, import_react69.useMemo)(() => {
    return {
      toasts,
      addToast(toast) {
        const id = toast.id ?? uniqueId();
        toasts.update((d) => [...d.filter((m) => m.id !== toast.id), { ...toast, id }]);
        return id;
      },
      removeToast(id) {
        toasts.update((d) => d.filter((m) => m.id !== id));
        return id;
      },
      clearToasts() {
        toasts.set([]);
      }
    };
  }, [toasts]);
  if (ctx) {
    return (0, import_jsx_runtime99.jsx)(import_jsx_runtime99.Fragment, { children });
  }
  return (0, import_jsx_runtime99.jsx)(dist_exports13.Provider, { children: (0, import_jsx_runtime99.jsx)(ToastsContext.Provider, { value: current, children }) });
}
function useToasts() {
  const ctx = (0, import_react69.useContext)(ToastsContext);
  if (!ctx) {
    throw new Error("useToasts must be used within a ToastsProvider");
  }
  return ctx;
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs
var import_lz_string = __toESM(require_lz_string(), 1);
var import_react70 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/utils/clipboard.mjs
var TLDRAW_CUSTOM_PNG_MIME_TYPE = "web image/vnd.tldraw+png";
var additionalClipboardWriteTypes = {
  png: TLDRAW_CUSTOM_PNG_MIME_TYPE
};
var canonicalClipboardReadTypes = {
  [TLDRAW_CUSTOM_PNG_MIME_TYPE]: "image/png"
};
function getAdditionalClipboardWriteType(format2) {
  return getOwnProperty(additionalClipboardWriteTypes, format2) ?? null;
}
function getCanonicalClipboardReadType(mimeType) {
  return getOwnProperty(canonicalClipboardReadTypes, mimeType) ?? mimeType;
}
function doesClipboardSupportType(mimeType) {
  return typeof ClipboardItem !== "undefined" && "supports" in ClipboardItem && ClipboardItem.supports(mimeType);
}
function clipboardWrite(types) {
  const entries = Object.entries(types);
  for (const [_, promise] of entries)
    promise.catch((err) => console.error(err));
  return navigator.clipboard.write([new ClipboardItem(types)]).catch((err) => {
    console.error(err);
    return Promise.all(
      entries.map(async ([type, promise]) => {
        return [type, await promise];
      })
    ).then((entries2) => {
      const resolvedTypes = objectMapFromEntries(entries2);
      return navigator.clipboard.write([new ClipboardItem(resolvedTypes)]);
    });
  });
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/clipboard/pasteFiles.mjs
async function pasteFiles(editor, blobs, point, sources) {
  const files = blobs.map(
    (blob) => blob instanceof File ? blob : new File([blob], "tldrawFile", { type: blob.type })
  );
  editor.markHistoryStoppingPoint("paste");
  await editor.putExternalContent({
    type: "files",
    files,
    point,
    ignoreParent: false,
    sources
  });
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/clipboard/pasteUrl.mjs
async function pasteUrl(editor, url, point, sources) {
  editor.markHistoryStoppingPoint("paste");
  return await editor.putExternalContent({
    type: "url",
    point,
    url,
    sources
  });
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs
var expectedPasteFileMimeTypes = [
  TLDRAW_CUSTOM_PNG_MIME_TYPE,
  "image/png",
  "image/jpeg",
  "image/webp",
  "image/svg+xml"
];
function stripHtml(html) {
  const doc3 = document.implementation.createHTMLDocument("");
  doc3.documentElement.innerHTML = html.trim();
  return doc3.body.textContent || doc3.body.innerText || "";
}
var isValidHttpURL = (url) => {
  try {
    const u = new URL(url);
    return u.protocol === "http:" || u.protocol === "https:";
  } catch {
    return false;
  }
};
var getValidHttpURLList = (url) => {
  const urls = url.split(/[\n\s]/);
  for (const url2 of urls) {
    try {
      const u = new URL(url2);
      if (!(u.protocol === "http:" || u.protocol === "https:")) {
        return;
      }
    } catch {
      return;
    }
  }
  return uniq(urls);
};
var isSvgText = (text) => {
  return /^<svg/.test(text);
};
var INPUTS = ["input", "select", "textarea"];
function areShortcutsDisabled2(editor) {
  const { activeElement } = document;
  return editor.menus.hasAnyOpenMenus() || activeElement && (activeElement.isContentEditable || INPUTS.indexOf(activeElement.tagName.toLowerCase()) > -1);
}
var handleText = (editor, data, point, sources) => {
  const validUrlList = getValidHttpURLList(data);
  if (validUrlList) {
    for (const url of validUrlList) {
      pasteUrl(editor, url, point);
    }
  } else if (isValidHttpURL(data)) {
    pasteUrl(editor, data, point);
  } else if (isSvgText(data)) {
    editor.markHistoryStoppingPoint("paste");
    editor.putExternalContent({
      type: "svg-text",
      text: data,
      point,
      sources
    });
  } else {
    editor.markHistoryStoppingPoint("paste");
    editor.putExternalContent({
      type: "text",
      text: data,
      point,
      sources
    });
  }
};
var handlePasteFromEventClipboardData = async (editor, clipboardData, point) => {
  if (editor.getEditingShapeId() !== null)
    return;
  if (!clipboardData) {
    throw Error("No clipboard data");
  }
  const things = [];
  for (const item of Object.values(clipboardData.items)) {
    switch (item.kind) {
      case "file": {
        things.push({
          type: "file",
          source: new Promise((r) => r(item.getAsFile()))
        });
        break;
      }
      case "string": {
        if (item.type === "text/html") {
          things.push({
            type: "html",
            source: new Promise((r) => item.getAsString(r))
          });
        } else if (item.type === "text/plain") {
          things.push({
            type: "text",
            source: new Promise((r) => item.getAsString(r))
          });
        } else {
          things.push({ type: item.type, source: new Promise((r) => item.getAsString(r)) });
        }
        break;
      }
    }
  }
  handleClipboardThings(editor, things, point);
};
var handlePasteFromClipboardApi = async ({
  editor,
  clipboardItems,
  point,
  fallbackFiles
}) => {
  const things = [];
  for (const item of clipboardItems) {
    for (const type of expectedPasteFileMimeTypes) {
      if (item.types.includes(type)) {
        const blobPromise = item.getType(type).then((blob) => FileHelpers.rewriteMimeType(blob, getCanonicalClipboardReadType(type)));
        things.push({
          type: "blob",
          source: blobPromise
        });
        break;
      }
    }
    if (item.types.includes("text/html")) {
      things.push({
        type: "html",
        source: (async () => {
          const blob = await item.getType("text/html");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
    if (item.types.includes("text/uri-list")) {
      things.push({
        type: "url",
        source: (async () => {
          const blob = await item.getType("text/uri-list");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
    if (item.types.includes("text/plain")) {
      things.push({
        type: "text",
        source: (async () => {
          const blob = await item.getType("text/plain");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
  }
  if ((fallbackFiles == null ? void 0 : fallbackFiles.length) && things.length === 1 && things[0].type === "text") {
    things.pop();
    things.push(
      ...fallbackFiles.map((f) => ({ type: "file", source: Promise.resolve(f) }))
    );
  } else if ((fallbackFiles == null ? void 0 : fallbackFiles.length) && things.length === 0) {
    things.push(
      ...fallbackFiles.map((f) => ({ type: "file", source: Promise.resolve(f) }))
    );
  }
  return await handleClipboardThings(editor, things, point);
};
async function handleClipboardThings(editor, things, point) {
  const files = things.filter(
    (t2) => (t2.type === "file" || t2.type === "blob") && t2.source !== null
  );
  if (files.length) {
    if (files.length > editor.options.maxFilesAtOnce) {
      throw Error("Too many files");
    }
    const fileBlobs = compact(await Promise.all(files.map((t2) => t2.source)));
    return await pasteFiles(editor, fileBlobs, point);
  }
  const results = await Promise.all(
    things.filter((t2) => t2.type !== "file").map(
      (t2) => new Promise((r) => {
        const thing = t2;
        if (thing.type === "file") {
          r({ type: "error", data: null, reason: "unexpected file" });
          return;
        }
        thing.source.then((text) => {
          var _a5;
          const tldrawHtmlComment = (_a5 = text.match(/<div data-tldraw[^>]*>(.*)<\/div>/)) == null ? void 0 : _a5[1];
          if (tldrawHtmlComment) {
            try {
              const jsonComment = import_lz_string.default.decompressFromBase64(tldrawHtmlComment);
              if (jsonComment === null) {
                r({
                  type: "error",
                  data: jsonComment,
                  reason: `found tldraw data comment but could not parse base64`
                });
                return;
              } else {
                const json = JSON.parse(jsonComment);
                if (json.type !== "application/tldraw") {
                  r({
                    type: "error",
                    data: json,
                    reason: `found tldraw data comment but JSON was of a different type: ${json.type}`
                  });
                }
                if (typeof json.data === "string") {
                  r({
                    type: "error",
                    data: json,
                    reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
                  });
                  return;
                }
                r({ type: "tldraw", data: json.data });
                return;
              }
            } catch {
              r({
                type: "error",
                data: tldrawHtmlComment,
                reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
              });
              return;
            }
          } else {
            if (thing.type === "html") {
              r({ type: "text", data: text, subtype: "html" });
              return;
            }
            if (thing.type === "url") {
              r({ type: "text", data: text, subtype: "url" });
              return;
            }
            try {
              const json = JSON.parse(text);
              if (json.type === "excalidraw/clipboard") {
                r({ type: "excalidraw", data: json });
                return;
              } else {
                r({ type: "text", data: text, subtype: "json" });
                return;
              }
            } catch {
              r({ type: "text", data: text, subtype: "text" });
              return;
            }
          }
          r({ type: "error", data: text, reason: "unhandled case" });
        });
      })
    )
  );
  for (const result of results) {
    if (result.type === "tldraw") {
      editor.markHistoryStoppingPoint("paste");
      editor.putExternalContent({ type: "tldraw", content: result.data, point });
      return;
    }
  }
  for (const result of results) {
    if (result.type === "excalidraw") {
      editor.markHistoryStoppingPoint("paste");
      editor.putExternalContent({ type: "excalidraw", content: result.data, point });
      return;
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "html") {
      const rootNode = new DOMParser().parseFromString(result.data, "text/html");
      const bodyNode = rootNode.querySelector("body");
      const isHtmlSingleLink = bodyNode && Array.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 && bodyNode.firstElementChild && bodyNode.firstElementChild.tagName === "A" && bodyNode.firstElementChild.hasAttribute("href") && bodyNode.firstElementChild.getAttribute("href") !== "";
      if (isHtmlSingleLink) {
        const href = bodyNode.firstElementChild.getAttribute("href");
        handleText(editor, href, point, results);
        return;
      }
      if (!results.some((r) => r.type === "text" && r.subtype !== "html") && result.data.trim()) {
        const html = stripHtml(result.data) ?? "";
        if (html) {
          handleText(editor, stripHtml(result.data), point, results);
          return;
        }
      }
      if (results.some((r) => r.type === "text" && r.subtype !== "html")) {
        const html = stripHtml(result.data) ?? "";
        if (html) {
          editor.markHistoryStoppingPoint("paste");
          editor.putExternalContent({
            type: "text",
            text: html,
            html: result.data,
            point,
            sources: results
          });
          return;
        }
      }
    }
    if (result.type === "text" && result.subtype === "text" && result.data.startsWith("<iframe ")) {
      const rootNode = new DOMParser().parseFromString(result.data, "text/html");
      const bodyNode = rootNode.querySelector("body");
      const isSingleIframe = bodyNode && Array.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 && bodyNode.firstElementChild && bodyNode.firstElementChild.tagName === "IFRAME" && bodyNode.firstElementChild.hasAttribute("src") && bodyNode.firstElementChild.getAttribute("src") !== "";
      if (isSingleIframe) {
        const src = bodyNode.firstElementChild.getAttribute("src");
        handleText(editor, src, point, results);
        return;
      }
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "url") {
      pasteUrl(editor, result.data, point, results);
      return;
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "text" && result.data.trim()) {
      handleText(editor, result.data, point, results);
      return;
    }
  }
}
var handleNativeOrMenuCopy = async (editor) => {
  var _a5;
  const content = await editor.resolveAssetsInContent(
    editor.getContentFromCurrentPage(editor.getSelectedShapeIds())
  );
  if (!content) {
    if (navigator && navigator.clipboard) {
      navigator.clipboard.writeText("");
    }
    return;
  }
  const stringifiedClipboard = import_lz_string.default.compressToBase64(
    JSON.stringify({
      type: "application/tldraw",
      kind: "content",
      data: content
    })
  );
  if (typeof navigator === "undefined") {
    return;
  } else {
    const textItems = content.shapes.map((shape) => {
      const util = editor.getShapeUtil(shape);
      return util.getText(shape);
    }).filter(isDefined);
    if ((_a5 = navigator.clipboard) == null ? void 0 : _a5.write) {
      const htmlBlob = new Blob([`<div data-tldraw>${stringifiedClipboard}</div>`], {
        type: "text/html"
      });
      let textContent = textItems.join(" ");
      if (textContent === "") {
        textContent = " ";
      }
      navigator.clipboard.write([
        new ClipboardItem({
          "text/html": htmlBlob,
          // What is this second blob used for?
          "text/plain": new Blob([textContent], { type: "text/plain" })
        })
      ]);
    } else if (navigator.clipboard.writeText) {
      navigator.clipboard.writeText(`<div data-tldraw>${stringifiedClipboard}</div>`);
    }
  }
};
function useMenuClipboardEvents() {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const copy2 = (0, import_react70.useCallback)(
    async function onCopy(source) {
      assert(editor, "editor is required for copy");
      if (editor.getSelectedShapeIds().length === 0)
        return;
      await handleNativeOrMenuCopy(editor);
      trackEvent("copy", { source });
    },
    [editor, trackEvent]
  );
  const cut2 = (0, import_react70.useCallback)(
    async function onCut(source) {
      if (!editor)
        return;
      if (editor.getSelectedShapeIds().length === 0)
        return;
      await handleNativeOrMenuCopy(editor);
      editor.deleteShapes(editor.getSelectedShapeIds());
      trackEvent("cut", { source });
    },
    [editor, trackEvent]
  );
  const paste = (0, import_react70.useCallback)(
    async function onPaste(data, source, point) {
      if (!editor)
        return;
      if (editor.getEditingShapeId() !== null)
        return;
      if (Array.isArray(data) && data[0] instanceof ClipboardItem) {
        handlePasteFromClipboardApi({ editor, clipboardItems: data, point });
        trackEvent("paste", { source: "menu" });
      } else {
        navigator.clipboard.read().then((clipboardItems) => {
          paste(clipboardItems, source, point);
        });
      }
    },
    [editor, trackEvent]
  );
  return {
    copy: copy2,
    cut: cut2,
    paste
  };
}
function useNativeClipboardEvents() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const appIsFocused = useValue("editor.isFocused", () => editor.getInstanceState().isFocused, [
    editor
  ]);
  (0, import_react70.useEffect)(() => {
    if (!appIsFocused)
      return;
    const copy2 = async (e) => {
      if (editor.getSelectedShapeIds().length === 0 || editor.getEditingShapeId() !== null || areShortcutsDisabled2(editor)) {
        return;
      }
      preventDefault(e);
      await handleNativeOrMenuCopy(editor);
      trackEvent("copy", { source: "kbd" });
    };
    async function cut2(e) {
      if (editor.getSelectedShapeIds().length === 0 || editor.getEditingShapeId() !== null || areShortcutsDisabled2(editor)) {
        return;
      }
      preventDefault(e);
      await handleNativeOrMenuCopy(editor);
      editor.deleteShapes(editor.getSelectedShapeIds());
      trackEvent("cut", { source: "kbd" });
    }
    let disablingMiddleClickPaste = false;
    const pointerUpHandler = (e) => {
      if (e.button === 1) {
        disablingMiddleClickPaste = true;
        editor.timers.requestAnimationFrame(() => {
          disablingMiddleClickPaste = false;
        });
      }
    };
    const paste = (e) => {
      var _a5, _b;
      if (disablingMiddleClickPaste) {
        stopEventPropagation(e);
        return;
      }
      if (editor.getEditingShapeId() !== null || areShortcutsDisabled2(editor))
        return;
      let point = void 0;
      let pasteAtCursor = false;
      if (editor.inputs.shiftKey)
        pasteAtCursor = true;
      if (editor.user.getIsPasteAtCursorMode())
        pasteAtCursor = !pasteAtCursor;
      if (pasteAtCursor)
        point = editor.inputs.currentPagePoint;
      const pasteFromEvent = () => {
        if (e.clipboardData) {
          handlePasteFromEventClipboardData(editor, e.clipboardData, point);
        }
      };
      if ((_a5 = navigator.clipboard) == null ? void 0 : _a5.read) {
        const fallbackFiles = Array.from(((_b = e.clipboardData) == null ? void 0 : _b.files) || []);
        navigator.clipboard.read().then(
          (clipboardItems) => {
            if (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {
              handlePasteFromClipboardApi({ editor, clipboardItems, point, fallbackFiles });
            }
          },
          () => {
            pasteFromEvent();
          }
        );
      } else {
        pasteFromEvent();
      }
      preventDefault(e);
      trackEvent("paste", { source: "kbd" });
    };
    document.addEventListener("copy", copy2);
    document.addEventListener("cut", cut2);
    document.addEventListener("paste", paste);
    document.addEventListener("pointerup", pointerUpHandler);
    return () => {
      document.removeEventListener("copy", copy2);
      document.removeEventListener("cut", cut2);
      document.removeEventListener("paste", paste);
      document.removeEventListener("pointerup", pointerUpHandler);
    };
  }, [editor, trackEvent, appIsFocused]);
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useCopyAs.mjs
var import_react71 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/utils/export/export.mjs
async function exportToBlob({
  editor,
  ids,
  format: format2,
  opts = {}
}) {
  const idsToUse = (ids == null ? void 0 : ids.length) ? ids : [...editor.getCurrentPageShapeIds()];
  switch (format2) {
    case "jpeg":
    case "png":
    case "webp":
    case "svg": {
      return (await editor.toImage(idsToUse, { ...opts, format: format2 })).blob;
    }
    default: {
      exhaustiveSwitchError(format2);
    }
  }
}
var clipboardMimeTypesByFormat = {
  jpeg: "image/jpeg",
  png: "image/png",
  webp: "image/webp",
  svg: "text/plain"
};
function exportToImagePromiseForClipboard(editor, ids, opts = {}) {
  const idsToUse = (ids == null ? void 0 : ids.length) ? ids : [...editor.getCurrentPageShapeIds()];
  const format2 = opts.format ?? "png";
  return {
    blobPromise: editor.toImage(idsToUse, opts).then(
      (result) => FileHelpers.rewriteMimeType(result.blob, clipboardMimeTypesByFormat[format2])
    ),
    mimeType: clipboardMimeTypesByFormat[format2]
  };
}

// node_modules/tldraw/dist-esm/lib/utils/export/copyAs.mjs
function copyAs(...args) {
  const [editor, ids, opts] = typeof args[2] === "string" ? [args[0], args[1], { ...args[3], format: args[2] }] : args;
  if (!navigator.clipboard)
    return Promise.reject(new Error("Copy not supported"));
  if (navigator.clipboard.write) {
    const { blobPromise, mimeType } = exportToImagePromiseForClipboard(editor, ids, opts);
    const types = { [mimeType]: blobPromise };
    const additionalMimeType = getAdditionalClipboardWriteType(opts.format);
    if (additionalMimeType && doesClipboardSupportType(additionalMimeType)) {
      types[additionalMimeType] = blobPromise.then(
        (blob) => FileHelpers.rewriteMimeType(blob, additionalMimeType)
      );
    }
    return clipboardWrite(types);
  }
  switch (opts.format) {
    case "svg": {
      return fallbackWriteTextAsync(async () => {
        const result = await editor.getSvgString(ids, opts);
        if (!result)
          throw new Error("Failed to copy");
        return result.svg;
      });
    }
    case "png":
      throw new Error("Copy not supported");
    default:
      exhaustiveSwitchError(opts.format);
  }
}
async function fallbackWriteTextAsync(getText3) {
  var _a5, _b;
  await ((_b = (_a5 = navigator.clipboard) == null ? void 0 : _a5.writeText) == null ? void 0 : _b.call(_a5, await getText3()));
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useCopyAs.mjs
function useCopyAs() {
  const editor = useMaybeEditor();
  const { addToast } = useToasts();
  const msg2 = useTranslation();
  return (0, import_react71.useCallback)(
    (ids, format2 = "svg") => {
      assert(editor, "useCopyAs: editor is required");
      copyAs(editor, ids, { format: format2 }).catch(() => {
        addToast({
          id: "copy-fail",
          severity: "warning",
          title: msg2("toast.error.copy-fail.title"),
          description: msg2("toast.error.copy-fail.desc")
        });
      });
    },
    [editor, addToast, msg2]
  );
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useExportAs.mjs
var import_react72 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/utils/export/exportAs.mjs
async function exportAs(...args) {
  const [editor, ids, opts] = typeof args[2] === "object" ? args : [args[0], args[1], { ...args[4], format: args[2] ?? "png", name: args[3] }];
  let name = opts.name;
  if (!name) {
    name = `shapes at ${getTimestamp()}`;
    if (ids.length === 1) {
      const first2 = editor.getShape(ids[0]);
      if (editor.isShapeOfType(first2, "frame")) {
        name = first2.props.name || "frame";
      } else {
        name = `${sanitizeId(first2.id)} at ${getTimestamp()}`;
      }
    }
  }
  name += `.${opts.format}`;
  const { blob } = await editor.toImage(ids, opts);
  const file = new File([blob], name, { type: blob.type });
  downloadFile(file);
}
function getTimestamp() {
  const now = /* @__PURE__ */ new Date();
  const year = String(now.getFullYear()).slice(2);
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${year}-${month}-${day} ${hours}.${minutes}.${seconds}`;
}
function downloadFile(file) {
  const link = document.createElement("a");
  const url = URL.createObjectURL(file);
  link.href = url;
  link.download = file.name;
  link.click();
  URL.revokeObjectURL(url);
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useExportAs.mjs
function useExportAs() {
  const editor = useMaybeEditor();
  const { addToast } = useToasts();
  const msg2 = useTranslation();
  return (0, import_react72.useCallback)(
    (ids, format2 = "png", name) => {
      assert(editor, "useExportAs: editor is required");
      exportAs(editor, ids, {
        format: format2,
        name,
        scale: 1
      }).catch((e) => {
        console.error(e.message);
        addToast({
          id: "export-fail",
          title: msg2("toast.error.export-fail.title"),
          description: msg2("toast.error.export-fail.desc"),
          severity: "error"
        });
      });
    },
    [editor, addToast, msg2]
  );
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useInsertMedia.mjs
var import_react73 = __toESM(require_react(), 1);
var MimeTypeContext = import_react73.default.createContext([]);
function useInsertMedia() {
  const _editor = useMaybeEditor();
  const inputRef = (0, import_react73.useRef)();
  const mimeTypes = useShallowArrayIdentity(import_react73.default.useContext(MimeTypeContext));
  (0, import_react73.useEffect)(() => {
    const editor = _editor;
    if (!editor)
      return;
    const input = window.document.createElement("input");
    input.type = "file";
    input.accept = (mimeTypes == null ? void 0 : mimeTypes.join(",")) ?? DEFAULT_SUPPORTED_MEDIA_TYPE_LIST;
    input.multiple = true;
    inputRef.current = input;
    async function onchange(e) {
      const fileList = e.target.files;
      if (!fileList || fileList.length === 0)
        return;
      editor.markHistoryStoppingPoint("insert media");
      await editor.putExternalContent({
        type: "files",
        files: Array.from(fileList),
        point: editor.getViewportPageBounds().center,
        ignoreParent: false
      });
      input.value = "";
    }
    input.addEventListener("change", onchange);
    return () => {
      inputRef.current = void 0;
      input.removeEventListener("change", onchange);
    };
  }, [_editor, mimeTypes]);
  return (0, import_react73.useCallback)(() => {
    var _a5;
    (_a5 = inputRef.current) == null ? void 0 : _a5.click();
  }, [inputRef]);
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/usePrint.mjs
var import_react74 = __toESM(require_react(), 1);
function usePrint() {
  const editor = useMaybeEditor();
  const prevPrintEl = (0, import_react74.useRef)(null);
  const prevStyleEl = (0, import_react74.useRef)(null);
  return (0, import_react74.useCallback)(
    async function printSelectionOrPages() {
      assert(editor, "usePrint: editor is required");
      const el = document.createElement("div");
      const style2 = document.createElement("style");
      const clearElements = (printEl, styleEl) => {
        if (printEl)
          printEl.innerHTML = "";
        if (styleEl && document.head.contains(styleEl))
          document.head.removeChild(styleEl);
        if (printEl && document.body.contains(printEl)) {
          document.body.removeChild(printEl);
        }
      };
      clearElements(prevPrintEl.current, prevStyleEl.current);
      prevPrintEl.current = el;
      prevStyleEl.current = style2;
      const className = `tl-print-surface-${uniqueId()}`;
      el.className = className;
      const enableMargins = false;
      const allowAllPages = false;
      style2.innerHTML = `
			.${className} {
				display: none;
			}

			.${className} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.tldraw__editor {
					display: none;
				}

				.${className} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${className}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${className}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${className}__item__header {
					display: none;
				}

				.${className}__item__footer {
					display: none;
					text-align: right;
				}

				.${className}__item__footer__hide {
					display: none;
				}

				${!enableMargins ? "" : `
					/**
					 * Note: Safari doesn't support removing the page margins to remove them all!
					 */
					@page {
						margin:0;
					}

					.${className} .${className}__item__header {
						display: block;
					}

					.${className} .${className}__item__footer {
						display: block;
					}
				`}
			}

		`;
      const beforePrintHandler = () => {
        document.head.appendChild(style2);
        document.body.appendChild(el);
      };
      const afterPrintHandler = () => {
        editor.once("tick", () => {
          clearElements(el, style2);
        });
      };
      window.addEventListener("beforeprint", beforePrintHandler);
      window.addEventListener("afterprint", afterPrintHandler);
      function addPageToPrint(title, footer, svg) {
        try {
          el.innerHTML += `<div class="${className}__item">
        <div class="${className}__item__header">
          ${title.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
        </div>
        <div class="${className}__item__main">
          ${svg}
        </div>
        <div class="${className}__item__footer ${className}__item__footer__${footer ? "" : "hide"}">
          ${footer ?? ""}
        </div>
      </div>`;
        } catch (e) {
          console.error(e);
        }
      }
      function triggerPrint() {
        if (tlenv.isChromeForIos) {
          beforePrintHandler();
          window.print();
        } else if (tlenv.isSafari) {
          beforePrintHandler();
          document.execCommand("print", false);
        } else {
          window.print();
        }
      }
      const selectedShapeIds = editor.getSelectedShapeIds();
      const currentPageId = editor.getCurrentPageId();
      const pages = editor.getPages();
      const preserveAspectRatio = "xMidYMid meet";
      const svgOpts = {
        scale: 1,
        background: false,
        darkMode: false,
        preserveAspectRatio
      };
      if (editor.getSelectedShapeIds().length > 0) {
        const svgExport = await editor.getSvgString(selectedShapeIds, svgOpts);
        if (svgExport) {
          const page = pages.find((p) => p.id === currentPageId);
          addPageToPrint(`tldraw — ${page == null ? void 0 : page.name}`, null, svgExport.svg);
          triggerPrint();
        }
      } else {
        if (allowAllPages) {
          for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            const svgExport = await editor.getSvgString(
              editor.getSortedChildIdsForParent(page.id),
              svgOpts
            );
            if (svgExport) {
              addPageToPrint(`tldraw — ${page.name}`, `${i}/${pages.length}`, svgExport.svg);
            }
          }
          triggerPrint();
        } else {
          const page = editor.getCurrentPage();
          const svgExport = await editor.getSvgString(
            editor.getSortedChildIdsForParent(page.id),
            svgOpts
          );
          if (svgExport) {
            addPageToPrint(`tldraw — ${page.name}`, null, svgExport.svg);
            triggerPrint();
          }
        }
      }
      window.removeEventListener("beforeprint", beforePrintHandler);
      window.removeEventListener("afterprint", afterPrintHandler);
    },
    [editor]
  );
}

// node_modules/tldraw/dist-esm/lib/ui/overrides.mjs
function useDefaultHelpers() {
  const { addToast, removeToast, clearToasts } = useToasts();
  const { addDialog, clearDialogs, removeDialog } = useDialogs();
  const msg2 = useTranslation();
  const insertMedia = useInsertMedia();
  const printSelectionOrPages = usePrint();
  const { cut: cut2, copy: copy2, paste } = useMenuClipboardEvents();
  const copyAs2 = useCopyAs();
  const exportAs2 = useExportAs();
  const getEmbedDefinition = useGetEmbedDefinition();
  const breakpoint = useBreakpoint();
  const isMobile = breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM;
  return (0, import_react75.useMemo)(
    () => ({
      addToast,
      removeToast,
      clearToasts,
      addDialog,
      removeDialog,
      clearDialogs,
      msg: msg2,
      isMobile,
      insertMedia,
      printSelectionOrPages,
      cut: cut2,
      copy: copy2,
      paste,
      copyAs: copyAs2,
      exportAs: exportAs2,
      getEmbedDefinition
    }),
    [
      addToast,
      removeToast,
      clearToasts,
      addDialog,
      removeDialog,
      clearDialogs,
      msg2,
      isMobile,
      insertMedia,
      printSelectionOrPages,
      cut2,
      copy2,
      paste,
      copyAs2,
      exportAs2,
      getEmbedDefinition
    ]
  );
}
function mergeOverrides(overrides, defaultHelpers) {
  const mergedTranslations = {};
  for (const override of overrides) {
    if (override.translations) {
      for (const [key, value] of objectMapEntries(override.translations)) {
        let strings = mergedTranslations[key];
        if (!strings) {
          strings = mergedTranslations[key] = {};
        }
        Object.assign(strings, value);
      }
    }
  }
  return {
    actions: (editor, schema, helpers) => {
      for (const override of overrides) {
        if (override.actions) {
          schema = override.actions(editor, schema, helpers);
        }
      }
      return schema;
    },
    tools: (editor, schema, helpers) => {
      for (const override of overrides) {
        if (override.tools) {
          schema = override.tools(editor, schema, { ...defaultHelpers, ...helpers });
        }
      }
      return schema;
    },
    translations: mergedTranslations
  };
}
function useShallowArrayEquality(array2) {
  return (0, import_react75.useMemo)(() => array2, array2);
}
function useMergedTranslationOverrides(overrides) {
  const overridesArray = useShallowArrayEquality(
    overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
  );
  return (0, import_react75.useMemo)(() => {
    const mergedTranslations = {};
    for (const override of overridesArray) {
      if (override.translations) {
        for (const [key, value] of objectMapEntries(override.translations)) {
          let strings = mergedTranslations[key];
          if (!strings) {
            strings = mergedTranslations[key] = {};
          }
          Object.assign(strings, value);
        }
      }
    }
    return mergedTranslations;
  }, [overridesArray]);
}
function useMergedOverrides(overrides) {
  const defaultHelpers = useDefaultHelpers();
  const overridesArray = useShallowArrayEquality(
    overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
  );
  return (0, import_react75.useMemo)(
    () => mergeOverrides(overridesArray, defaultHelpers),
    [overridesArray, defaultHelpers]
  );
}

// node_modules/tldraw/dist-esm/lib/ui/context/actions.mjs
var ActionsContext = React86.createContext(null);
function makeActions(actions) {
  return Object.fromEntries(actions.map((action) => [action.id, action]));
}
function getExportName(editor, defaultName) {
  const selectedShapes = editor.getSelectedShapes();
  if (selectedShapes.length === 0) {
    return editor.getDocumentSettings().name || defaultName;
  }
  return void 0;
}
function ActionsProvider({ overrides, children }) {
  const _editor = useMaybeEditor();
  const showCollaborationUi = useShowCollaborationUi();
  const helpers = useDefaultHelpers();
  const trackEvent = useUiEvents();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const defaultDocumentName = helpers.msg("document.default-name");
  const actions = React86.useMemo(() => {
    const editor = _editor;
    if (!editor)
      return {};
    function mustGoBackToSelectToolFirst() {
      if (!editor.isIn("select")) {
        editor.complete();
        editor.setCurrentTool("select");
        return false;
      }
      return false;
    }
    function canApplySelectionAction() {
      return editor.isIn("select") && editor.getSelectedShapeIds().length > 0;
    }
    function scaleShapes(scaleFactor) {
      if (!canApplySelectionAction())
        return;
      if (mustGoBackToSelectToolFirst())
        return;
      editor.markHistoryStoppingPoint("resize shapes");
      const selectedShapeIds = editor.getSelectedShapeIds();
      if (selectedShapeIds.length === 0)
        return;
      editor.run(() => {
        const shapes = selectedShapeIds.map((id) => editor.getShape(id)).filter(Boolean);
        shapes.forEach((shape) => {
          var _a5;
          editor.resizeShape(shape.id, new Vec(scaleFactor, scaleFactor), {
            scaleOrigin: (_a5 = editor.getSelectionPageBounds()) == null ? void 0 : _a5.center
          });
        });
      });
    }
    const actionItems = [
      {
        id: "edit-link",
        label: "action.edit-link",
        icon: "link",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("edit-link", { source });
          editor.markHistoryStoppingPoint("edit-link");
          helpers.addDialog({ component: EditLinkDialog });
        }
      },
      {
        id: "insert-embed",
        label: "action.insert-embed",
        kbd: "cmd+i,ctrl+i",
        onSelect(source) {
          trackEvent("insert-embed", { source });
          helpers.addDialog({ component: EmbedDialog });
        }
      },
      {
        id: "insert-media",
        label: "action.insert-media",
        kbd: "cmd+u,ctrl+u",
        onSelect(source) {
          trackEvent("insert-media", { source });
          helpers.insertMedia();
        }
      },
      {
        id: "undo",
        label: "action.undo",
        icon: "undo",
        kbd: "cmd+z,ctrl+z",
        onSelect(source) {
          trackEvent("undo", { source });
          editor.undo();
        }
      },
      {
        id: "redo",
        label: "action.redo",
        icon: "redo",
        kbd: "cmd+shift+z,ctrl+shift+z",
        onSelect(source) {
          trackEvent("redo", { source });
          editor.redo();
        }
      },
      {
        id: "export-as-svg",
        label: {
          default: "action.export-as-svg",
          menu: "action.export-as-svg.short",
          ["context-menu"]: "action.export-as-svg.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0)
            ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0)
            return;
          trackEvent("export-as", { format: "svg", source });
          helpers.exportAs(ids, "svg", getExportName(editor, defaultDocumentName));
        }
      },
      {
        id: "export-as-png",
        label: {
          default: "action.export-as-png",
          menu: "action.export-as-png.short",
          ["context-menu"]: "action.export-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0)
            ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0)
            return;
          trackEvent("export-as", { format: "png", source });
          helpers.exportAs(ids, "png", getExportName(editor, defaultDocumentName));
        }
      },
      {
        id: "export-all-as-svg",
        label: {
          default: "action.export-all-as-svg",
          menu: "action.export-all-as-svg.short",
          ["context-menu"]: "action.export-all-as-svg.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0)
            ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0)
            return;
          trackEvent("export-all-as", { format: "svg", source });
          helpers.exportAs(
            Array.from(editor.getCurrentPageShapeIds()),
            "svg",
            getExportName(editor, defaultDocumentName)
          );
        }
      },
      {
        id: "export-all-as-png",
        label: {
          default: "action.export-all-as-png",
          menu: "action.export-all-as-png.short",
          ["context-menu"]: "action.export-all-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          const ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0)
            return;
          trackEvent("export-all-as", { format: "png", source });
          helpers.exportAs(ids, "png", getExportName(editor, defaultDocumentName));
        }
      },
      {
        id: "copy-as-svg",
        label: {
          default: "action.copy-as-svg",
          menu: "action.copy-as-svg.short",
          ["context-menu"]: "action.copy-as-svg.short"
        },
        kbd: "cmd+shift+c,ctrl+shift+c",
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0)
            ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0)
            return;
          trackEvent("copy-as", { format: "svg", source });
          helpers.copyAs(ids, "svg");
        }
      },
      {
        id: "copy-as-png",
        label: {
          default: "action.copy-as-png",
          menu: "action.copy-as-png.short",
          ["context-menu"]: "action.copy-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0)
            ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0)
            return;
          trackEvent("copy-as", { format: "png", source });
          helpers.copyAs(ids, "png");
        }
      },
      {
        id: "toggle-auto-size",
        label: "action.toggle-auto-size",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("toggle-auto-size", { source });
          editor.markHistoryStoppingPoint("toggling auto size");
          editor.run(() => {
            const shapes = editor.getSelectedShapes().filter(
              (shape) => editor.isShapeOfType(shape, "text") && shape.props.autoSize === false
            );
            editor.updateShapes(
              shapes.map((shape) => {
                return {
                  id: shape.id,
                  type: shape.type,
                  props: {
                    ...shape.props,
                    w: 8,
                    autoSize: true
                  }
                };
              })
            );
            kickoutOccludedShapes(
              editor,
              shapes.map((shape) => shape.id)
            );
          });
        }
      },
      {
        id: "open-embed-link",
        label: "action.open-embed-link",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("open-embed-link", { source });
          const ids = editor.getSelectedShapeIds();
          const warnMsg = "No embed shapes selected";
          if (ids.length !== 1) {
            console.error(warnMsg);
            return;
          }
          const shape = editor.getShape(ids[0]);
          if (!shape || !editor.isShapeOfType(shape, "embed")) {
            console.error(warnMsg);
            return;
          }
          openWindow(shape.props.url, "_blank");
        }
      },
      {
        id: "select-zoom-tool",
        readonlyOk: true,
        kbd: "z",
        onSelect(source) {
          var _a5, _b;
          if (((_a5 = editor.root.getCurrent()) == null ? void 0 : _a5.id) === "zoom")
            return;
          trackEvent("zoom-tool", { source });
          if (!(editor.inputs.shiftKey || editor.inputs.ctrlKey)) {
            const currentTool = editor.root.getCurrent();
            if (currentTool && ((_b = currentTool.getCurrent()) == null ? void 0 : _b.id) === "idle") {
              editor.setCurrentTool("zoom", { onInteractionEnd: currentTool.id, maskAs: "zoom" });
            }
          }
        }
      },
      {
        id: "convert-to-bookmark",
        label: "action.convert-to-bookmark",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          editor.run(() => {
            trackEvent("convert-to-bookmark", { source });
            const shapes = editor.getSelectedShapes();
            const createList = [];
            const deleteList = [];
            for (const shape of shapes) {
              if (!shape || !editor.isShapeOfType(shape, "embed") || !shape.props.url)
                continue;
              const newPos = new Vec(shape.x, shape.y);
              newPos.rot(-shape.rotation);
              newPos.add(new Vec(shape.props.w / 2 - 300 / 2, shape.props.h / 2 - 320 / 2));
              newPos.rot(shape.rotation);
              const partial = {
                id: createShapeId(),
                type: "bookmark",
                rotation: shape.rotation,
                x: newPos.x,
                y: newPos.y,
                opacity: 1,
                props: {
                  url: shape.props.url
                }
              };
              createList.push(partial);
              deleteList.push(shape.id);
            }
            editor.markHistoryStoppingPoint("convert shapes to bookmark");
            editor.deleteShapes(deleteList);
            editor.createShapes(createList);
          });
        }
      },
      {
        id: "convert-to-embed",
        label: "action.convert-to-embed",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("convert-to-embed", { source });
          editor.run(() => {
            const ids = editor.getSelectedShapeIds();
            const shapes = compact(ids.map((id) => editor.getShape(id)));
            const createList = [];
            const deleteList = [];
            for (const shape of shapes) {
              if (!editor.isShapeOfType(shape, "bookmark"))
                continue;
              const { url } = shape.props;
              const embedInfo = helpers.getEmbedDefinition(url);
              if (!embedInfo)
                continue;
              if (!embedInfo.definition)
                continue;
              const { width, height } = embedInfo.definition;
              const newPos = new Vec(shape.x, shape.y);
              newPos.rot(-shape.rotation);
              newPos.add(new Vec(shape.props.w / 2 - width / 2, shape.props.h / 2 - height / 2));
              newPos.rot(shape.rotation);
              const shapeToCreate = {
                id: createShapeId(),
                type: "embed",
                x: newPos.x,
                y: newPos.y,
                rotation: shape.rotation,
                props: {
                  url,
                  w: width,
                  h: height
                }
              };
              createList.push(shapeToCreate);
              deleteList.push(shape.id);
            }
            editor.markHistoryStoppingPoint("convert shapes to embed");
            editor.deleteShapes(deleteList);
            editor.createShapes(createList);
          });
        }
      },
      {
        id: "duplicate",
        kbd: "cmd+d,ctrl+d",
        label: "action.duplicate",
        icon: "duplicate",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("duplicate-shapes", { source });
          const instanceState = editor.getInstanceState();
          let ids;
          let offset5;
          if (instanceState.duplicateProps) {
            ids = instanceState.duplicateProps.shapeIds;
            offset5 = instanceState.duplicateProps.offset;
          } else {
            ids = editor.getSelectedShapeIds();
            const commonBounds = Box.Common(compact(ids.map((id) => editor.getShapePageBounds(id))));
            offset5 = editor.getCameraOptions().isLocked ? {
              // same as the adjacent note margin
              x: editor.options.adjacentShapeMargin,
              y: editor.options.adjacentShapeMargin
            } : {
              x: commonBounds.width + editor.options.adjacentShapeMargin,
              y: 0
            };
          }
          editor.markHistoryStoppingPoint("duplicate shapes");
          editor.duplicateShapes(ids, offset5);
          if (instanceState.duplicateProps) {
            editor.updateInstanceState({
              duplicateProps: {
                ...instanceState.duplicateProps,
                shapeIds: editor.getSelectedShapeIds()
              }
            });
          }
        }
      },
      {
        id: "ungroup",
        label: "action.ungroup",
        kbd: "cmd+shift+g,ctrl+shift+g",
        icon: "ungroup",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("ungroup-shapes", { source });
          editor.markHistoryStoppingPoint("ungroup");
          editor.ungroupShapes(editor.getSelectedShapeIds());
        }
      },
      {
        id: "group",
        label: "action.group",
        kbd: "cmd+g,ctrl+g",
        icon: "group",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("group-shapes", { source });
          const onlySelectedShape = editor.getOnlySelectedShape();
          if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "group")) {
            editor.markHistoryStoppingPoint("ungroup");
            editor.ungroupShapes(editor.getSelectedShapeIds());
          } else {
            editor.markHistoryStoppingPoint("group");
            editor.groupShapes(editor.getSelectedShapeIds());
          }
        }
      },
      {
        id: "remove-frame",
        label: "action.remove-frame",
        kbd: "cmd+shift+f,ctrl+shift+f",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          trackEvent("remove-frame", { source });
          const selectedShapes = editor.getSelectedShapes();
          if (selectedShapes.length > 0 && selectedShapes.every((shape) => editor.isShapeOfType(shape, "frame"))) {
            editor.markHistoryStoppingPoint("remove-frame");
            removeFrame(
              editor,
              selectedShapes.map((shape) => shape.id)
            );
          }
        }
      },
      {
        id: "fit-frame-to-content",
        label: "action.fit-frame-to-content",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          trackEvent("fit-frame-to-content", { source });
          const onlySelectedShape = editor.getOnlySelectedShape();
          if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "frame")) {
            editor.markHistoryStoppingPoint("fit-frame-to-content");
            fitFrameToContent(editor, onlySelectedShape.id);
          }
        }
      },
      {
        id: "align-left",
        label: "action.align-left",
        kbd: "alt+A",
        icon: "align-left",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("align-shapes", { operation: "left", source });
          editor.markHistoryStoppingPoint("align left");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "left");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-center-horizontal",
        label: {
          default: "action.align-center-horizontal",
          ["context-menu"]: "action.align-center-horizontal.short"
        },
        kbd: "alt+H",
        icon: "align-center-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("align-shapes", { operation: "center-horizontal", source });
          editor.markHistoryStoppingPoint("align center horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "center-horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-right",
        label: "action.align-right",
        kbd: "alt+D",
        icon: "align-right",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("align-shapes", { operation: "right", source });
          editor.markHistoryStoppingPoint("align right");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "right");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-center-vertical",
        label: {
          default: "action.align-center-vertical",
          ["context-menu"]: "action.align-center-vertical.short"
        },
        kbd: "alt+V",
        icon: "align-center-vertical",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("align-shapes", { operation: "center-vertical", source });
          editor.markHistoryStoppingPoint("align center vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "center-vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-top",
        label: "action.align-top",
        icon: "align-top",
        kbd: "alt+W",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("align-shapes", { operation: "top", source });
          editor.markHistoryStoppingPoint("align top");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "top");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-bottom",
        label: "action.align-bottom",
        icon: "align-bottom",
        kbd: "alt+S",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("align-shapes", { operation: "bottom", source });
          editor.markHistoryStoppingPoint("align bottom");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "bottom");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "distribute-horizontal",
        label: {
          default: "action.distribute-horizontal",
          ["context-menu"]: "action.distribute-horizontal.short"
        },
        icon: "distribute-horizontal",
        kbd: "alt+shift+h",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("distribute-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("distribute horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.distributeShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "distribute-vertical",
        label: {
          default: "action.distribute-vertical",
          ["context-menu"]: "action.distribute-vertical.short"
        },
        icon: "distribute-vertical",
        kbd: "alt+shift+V",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("distribute-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("distribute vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.distributeShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stretch-horizontal",
        label: {
          default: "action.stretch-horizontal",
          ["context-menu"]: "action.stretch-horizontal.short"
        },
        icon: "stretch-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("stretch-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("stretch horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stretchShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stretch-vertical",
        label: {
          default: "action.stretch-vertical",
          ["context-menu"]: "action.stretch-vertical.short"
        },
        icon: "stretch-vertical",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("stretch-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("stretch vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stretchShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "flip-horizontal",
        label: {
          default: "action.flip-horizontal",
          ["context-menu"]: "action.flip-horizontal.short"
        },
        kbd: "shift+h",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("flip-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("flip horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.flipShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "flip-vertical",
        label: { default: "action.flip-vertical", ["context-menu"]: "action.flip-vertical.short" },
        kbd: "shift+v",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("flip-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("flip vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.flipShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "pack",
        label: "action.pack",
        icon: "pack",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("pack-shapes", { source });
          editor.markHistoryStoppingPoint("pack");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.packShapes(selectedShapeIds, editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stack-vertical",
        label: {
          default: "action.stack-vertical",
          ["context-menu"]: "action.stack-vertical.short"
        },
        icon: "stack-vertical",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("stack-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("stack-vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stackShapes(selectedShapeIds, "vertical", editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stack-horizontal",
        label: {
          default: "action.stack-horizontal",
          ["context-menu"]: "action.stack-horizontal.short"
        },
        icon: "stack-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("stack-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("stack-horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stackShapes(selectedShapeIds, "horizontal", editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "bring-to-front",
        label: "action.bring-to-front",
        kbd: "]",
        icon: "bring-to-front",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("reorder-shapes", { operation: "toFront", source });
          editor.markHistoryStoppingPoint("bring to front");
          editor.bringToFront(editor.getSelectedShapeIds());
        }
      },
      {
        id: "bring-forward",
        label: "action.bring-forward",
        icon: "bring-forward",
        kbd: "alt+]",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("reorder-shapes", { operation: "forward", source });
          editor.markHistoryStoppingPoint("bring forward");
          editor.bringForward(editor.getSelectedShapeIds());
        }
      },
      {
        id: "send-backward",
        label: "action.send-backward",
        icon: "send-backward",
        kbd: "alt+[",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("reorder-shapes", { operation: "backward", source });
          editor.markHistoryStoppingPoint("send backward");
          editor.sendBackward(editor.getSelectedShapeIds());
        }
      },
      {
        id: "send-to-back",
        label: "action.send-to-back",
        icon: "send-to-back",
        kbd: "[",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("reorder-shapes", { operation: "toBack", source });
          editor.markHistoryStoppingPoint("send to back");
          editor.sendToBack(editor.getSelectedShapeIds());
        }
      },
      {
        id: "cut",
        label: "action.cut",
        kbd: "cmd+x,ctrl+x",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          editor.markHistoryStoppingPoint("cut");
          helpers.cut(source);
        }
      },
      {
        id: "copy",
        label: "action.copy",
        kbd: "cmd+c,ctrl+c",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          helpers.copy(source);
        }
      },
      {
        id: "paste",
        label: "action.paste",
        kbd: "cmd+v,ctrl+v",
        onSelect(source) {
          var _a5;
          (_a5 = navigator.clipboard) == null ? void 0 : _a5.read().then((clipboardItems) => {
            helpers.paste(
              clipboardItems,
              source,
              source === "context-menu" ? editor.inputs.currentPagePoint : void 0
            );
          }).catch(() => {
            helpers.addToast({
              title: helpers.msg("action.paste-error-title"),
              description: helpers.msg("action.paste-error-description"),
              severity: "error"
            });
          });
        }
      },
      {
        id: "select-all",
        label: "action.select-all",
        kbd: "cmd+a,ctrl+a",
        readonlyOk: true,
        onSelect(source) {
          editor.run(() => {
            if (mustGoBackToSelectToolFirst())
              return;
            trackEvent("select-all-shapes", { source });
            editor.markHistoryStoppingPoint("select all kbd");
            editor.selectAll();
          });
        }
      },
      {
        id: "select-none",
        label: "action.select-none",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("select-none-shapes", { source });
          editor.markHistoryStoppingPoint("select none");
          editor.selectNone();
        }
      },
      {
        id: "delete",
        label: "action.delete",
        kbd: "⌫,del",
        icon: "trash",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("delete-shapes", { source });
          editor.markHistoryStoppingPoint("delete");
          editor.deleteShapes(editor.getSelectedShapeIds());
        }
      },
      {
        id: "rotate-cw",
        label: "action.rotate-cw",
        icon: "rotate-cw",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("rotate-cw", { source });
          editor.markHistoryStoppingPoint("rotate-cw");
          editor.run(() => {
            const offset5 = editor.getSelectionRotation() % (HALF_PI / 2);
            const dontUseOffset = approximately(offset5, 0) || approximately(offset5, HALF_PI / 2);
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.rotateShapesBy(selectedShapeIds, HALF_PI / 2 - (dontUseOffset ? 0 : offset5));
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "rotate-ccw",
        label: "action.rotate-ccw",
        icon: "rotate-ccw",
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("rotate-ccw", { source });
          editor.markHistoryStoppingPoint("rotate-ccw");
          editor.run(() => {
            const offset5 = editor.getSelectionRotation() % (HALF_PI / 2);
            const offsetCloseToZero = approximately(offset5, 0);
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.rotateShapesBy(selectedShapeIds, offsetCloseToZero ? -(HALF_PI / 2) : -offset5);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "zoom-in",
        label: "action.zoom-in",
        kbd: "cmd+=,ctrl+=,=",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-in", { source, towardsCursor: false });
          editor.zoomIn(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-in-on-cursor",
        label: "action.zoom-in",
        kbd: "shift+cmd+=,shift+ctrl+=,shift+=",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-in", { source, towardsCursor: true });
          editor.zoomIn(editor.inputs.currentScreenPoint, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out",
        label: "action.zoom-out",
        kbd: "cmd+-,ctrl+-,-",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-out", { source, towardsCursor: false });
          editor.zoomOut(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out-on-cursor",
        label: "action.zoom-out",
        kbd: "shift+cmd+-,shift+ctrl+-,shift+-",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-out", { source, towardsCursor: true });
          editor.zoomOut(editor.inputs.currentScreenPoint, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-100",
        label: "action.zoom-to-100",
        icon: "reset-zoom",
        kbd: "shift+0",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("reset-zoom", { source });
          editor.resetZoom(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-fit",
        label: "action.zoom-to-fit",
        kbd: "shift+1",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-to-fit", { source });
          editor.zoomToFit({ animation: { duration: editor.options.animationMediumMs } });
        }
      },
      {
        id: "zoom-to-selection",
        label: "action.zoom-to-selection",
        kbd: "shift+2",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction())
            return;
          if (mustGoBackToSelectToolFirst())
            return;
          trackEvent("zoom-to-selection", { source });
          editor.zoomToSelection({ animation: { duration: editor.options.animationMediumMs } });
        }
      },
      {
        id: "toggle-snap-mode",
        label: {
          default: "action.toggle-snap-mode",
          menu: "action.toggle-snap-mode.menu"
        },
        onSelect(source) {
          trackEvent("toggle-snap-mode", { source });
          editor.user.updateUserPreferences({ isSnapMode: !editor.user.getIsSnapMode() });
        },
        checkbox: true
      },
      {
        id: "toggle-dark-mode",
        label: {
          default: "action.toggle-dark-mode",
          menu: "action.toggle-dark-mode.menu"
        },
        kbd: "cmd+/,ctrl+/",
        readonlyOk: true,
        onSelect(source) {
          const value = editor.user.getIsDarkMode() ? "light" : "dark";
          trackEvent("color-scheme", { source, value });
          editor.user.updateUserPreferences({
            colorScheme: value
          });
        },
        checkbox: true
      },
      {
        id: "toggle-wrap-mode",
        label: {
          default: "action.toggle-wrap-mode",
          menu: "action.toggle-wrap-mode.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-wrap-mode", { source });
          editor.user.updateUserPreferences({
            isWrapMode: !editor.user.getIsWrapMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-dynamic-size-mode",
        label: {
          default: "action.toggle-dynamic-size-mode",
          menu: "action.toggle-dynamic-size-mode.menu"
        },
        readonlyOk: false,
        onSelect(source) {
          trackEvent("toggle-dynamic-size-mode", { source });
          editor.user.updateUserPreferences({
            isDynamicSizeMode: !editor.user.getIsDynamicResizeMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-paste-at-cursor",
        label: {
          default: "action.toggle-paste-at-cursor",
          menu: "action.toggle-paste-at-cursor.menu"
        },
        readonlyOk: false,
        onSelect(source) {
          trackEvent("toggle-paste-at-cursor", { source });
          editor.user.updateUserPreferences({
            isPasteAtCursorMode: !editor.user.getIsPasteAtCursorMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-reduce-motion",
        label: {
          default: "action.toggle-reduce-motion",
          menu: "action.toggle-reduce-motion.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-reduce-motion", { source });
          editor.user.updateUserPreferences({
            animationSpeed: editor.user.getAnimationSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: true
      },
      {
        id: "toggle-edge-scrolling",
        label: {
          default: "action.toggle-edge-scrolling",
          menu: "action.toggle-edge-scrolling.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-edge-scrolling", { source });
          editor.user.updateUserPreferences({
            edgeScrollSpeed: editor.user.getEdgeScrollSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: true
      },
      {
        id: "toggle-transparent",
        label: {
          default: "action.toggle-transparent",
          menu: "action.toggle-transparent.menu",
          ["context-menu"]: "action.toggle-transparent.context-menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-transparent", { source });
          editor.updateInstanceState({
            exportBackground: !editor.getInstanceState().exportBackground
          });
        },
        checkbox: true
      },
      {
        id: "toggle-tool-lock",
        label: {
          default: "action.toggle-tool-lock",
          menu: "action.toggle-tool-lock.menu"
        },
        kbd: "q",
        onSelect(source) {
          trackEvent("toggle-tool-lock", { source });
          editor.updateInstanceState({ isToolLocked: !editor.getInstanceState().isToolLocked });
        },
        checkbox: true
      },
      {
        id: "unlock-all",
        label: "action.unlock-all",
        onSelect(source) {
          trackEvent("unlock-all", { source });
          const updates = [];
          for (const shape of editor.getCurrentPageShapes()) {
            if (shape.isLocked) {
              updates.push({ id: shape.id, type: shape.type, isLocked: false });
            }
          }
          if (updates.length > 0) {
            editor.updateShapes(updates);
          }
        }
      },
      {
        id: "toggle-focus-mode",
        label: {
          default: "action.toggle-focus-mode",
          menu: "action.toggle-focus-mode.menu"
        },
        readonlyOk: true,
        kbd: "cmd+.,ctrl+.",
        checkbox: true,
        onSelect(source) {
          editor.timers.requestAnimationFrame(() => {
            editor.run(() => {
              trackEvent("toggle-focus-mode", { source });
              helpers.clearDialogs();
              helpers.clearToasts();
              editor.updateInstanceState({ isFocusMode: !editor.getInstanceState().isFocusMode });
            });
          });
        }
      },
      {
        id: "toggle-grid",
        label: {
          default: "action.toggle-grid",
          menu: "action.toggle-grid.menu"
        },
        readonlyOk: true,
        kbd: "cmd+',ctrl+'",
        onSelect(source) {
          trackEvent("toggle-grid-mode", { source });
          editor.updateInstanceState({ isGridMode: !editor.getInstanceState().isGridMode });
        },
        checkbox: true
      },
      {
        id: "toggle-debug-mode",
        label: {
          default: "action.toggle-debug-mode",
          menu: "action.toggle-debug-mode.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-debug-mode", { source });
          editor.updateInstanceState({
            isDebugMode: !editor.getInstanceState().isDebugMode
          });
        },
        checkbox: true
      },
      {
        id: "print",
        label: "action.print",
        kbd: "cmd+p,ctrl+p",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("print", { source });
          helpers.printSelectionOrPages();
        }
      },
      {
        id: "exit-pen-mode",
        label: "action.exit-pen-mode",
        icon: "cross-2",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("exit-pen-mode", { source });
          editor.updateInstanceState({ isPenMode: false });
        }
      },
      {
        id: "stop-following",
        label: "action.stop-following",
        icon: "cross-2",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("stop-following", { source });
          editor.stopFollowingUser();
        }
      },
      {
        id: "back-to-content",
        label: "action.back-to-content",
        icon: "arrow-left",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-to-content", { source });
          const bounds = editor.getSelectionPageBounds() ?? editor.getCurrentPageBounds();
          if (!bounds)
            return;
          editor.zoomToBounds(bounds, {
            targetZoom: Math.min(1, editor.getZoomLevel()),
            animation: { duration: 220 }
          });
        }
      },
      {
        id: "toggle-lock",
        label: "action.toggle-lock",
        kbd: "shift+l",
        onSelect(source) {
          editor.markHistoryStoppingPoint("locking");
          trackEvent("toggle-lock", { source });
          editor.toggleLock(editor.getSelectedShapeIds());
        }
      },
      {
        id: "move-to-new-page",
        label: "context.pages.new-page",
        onSelect(source) {
          const newPageId = PageRecordType.createId();
          const ids = editor.getSelectedShapeIds();
          editor.run(() => {
            editor.markHistoryStoppingPoint("move_shapes_to_page");
            editor.createPage({
              name: helpers.msg("page-menu.new-page-initial-name"),
              id: newPageId
            });
            editor.moveShapesToPage(ids, newPageId);
          });
          trackEvent("move-to-new-page", { source });
        }
      },
      {
        id: "select-white-color",
        label: "color-style.white",
        kbd: "alt+t",
        onSelect(source) {
          const style2 = DefaultColorStyle;
          editor.run(() => {
            editor.markHistoryStoppingPoint("change-color");
            if (editor.isIn("select")) {
              editor.setStyleForSelectedShapes(style2, "white");
            }
            editor.setStyleForNextShapes(style2, "white");
          });
          trackEvent("set-style", { source, id: style2.id, value: "white" });
        }
      },
      {
        id: "select-fill-fill",
        label: "fill-style.fill",
        kbd: "alt+f",
        onSelect(source) {
          const style2 = DefaultFillStyle;
          editor.run(() => {
            editor.markHistoryStoppingPoint("change-fill");
            if (editor.isIn("select")) {
              editor.setStyleForSelectedShapes(style2, "fill");
            }
            editor.setStyleForNextShapes(style2, "fill");
          });
          trackEvent("set-style", { source, id: style2.id, value: "fill" });
        }
      },
      {
        id: "flatten-to-image",
        label: "action.flatten-to-image",
        kbd: "shift+f",
        onSelect: async (source) => {
          const ids = editor.getSelectedShapeIds();
          if (ids.length === 0)
            return;
          editor.markHistoryStoppingPoint("flattening to image");
          trackEvent("flatten-to-image", { source });
          const newShapeIds = await flattenShapesToImages(
            editor,
            ids,
            editor.options.flattenImageBoundsExpand
          );
          if (newShapeIds == null ? void 0 : newShapeIds.length) {
            editor.setSelectedShapes(newShapeIds);
          }
        }
      },
      {
        id: "select-geo-tool",
        kbd: "g",
        onSelect: async (source) => {
          trackEvent("select-tool", { source, id: `geo-previous` });
          editor.setCurrentTool("geo");
        }
      },
      {
        id: "change-page-prev",
        kbd: "alt+left,alt+up",
        readonlyOk: true,
        onSelect: async (source) => {
          const pages = editor.getPages();
          const currentPageIndex = pages.findIndex((page) => page.id === editor.getCurrentPageId());
          if (currentPageIndex < 1)
            return;
          trackEvent("change-page", { source, direction: "prev" });
          editor.setCurrentPage(pages[currentPageIndex - 1].id);
        }
      },
      {
        id: "change-page-next",
        kbd: "alt+right,alt+down",
        readonlyOk: true,
        onSelect: async (source) => {
          const pages = editor.getPages();
          const currentPageIndex = pages.findIndex((page) => page.id === editor.getCurrentPageId());
          if (currentPageIndex === -1 || currentPageIndex >= pages.length - 1) {
            if (editor.getCurrentPageShapes().length <= 0 || editor.getIsReadonly()) {
              return;
            }
            trackEvent("new-page", { source });
            editor.run(() => {
              editor.markHistoryStoppingPoint("creating page");
              const newPageId = PageRecordType.createId();
              editor.createPage({
                name: helpers.msg("page-menu.new-page-initial-name"),
                id: newPageId
              });
              editor.setCurrentPage(newPageId);
            });
            return;
          }
          editor.setCurrentPage(pages[currentPageIndex + 1].id);
          trackEvent("change-page", { source, direction: "next" });
        }
      },
      {
        id: "adjust-shape-styles",
        label: "a11y.adjust-shape-styles",
        kbd: "cmd+Enter,ctrl+Enter",
        onSelect: async (source) => {
          if (!canApplySelectionAction())
            return;
          const firstButton = editor.getContainer().querySelector(".tlui-style-panel button");
          firstButton == null ? void 0 : firstButton.focus();
          trackEvent("adjust-shape-styles", { source });
        }
      },
      {
        id: "enlarge-shapes",
        label: "a11y.enlarge-shape",
        kbd: "cmd+alt+shift+=,ctrl+alt+shift+=",
        onSelect: async (source) => {
          scaleShapes(1.1);
          trackEvent("enlarge-shapes", { source });
        }
      },
      {
        id: "shrink-shapes",
        label: "a11y.shrink-shape",
        kbd: "cmd+alt+shift+-,ctrl+alt+shift+-",
        onSelect: async (source) => {
          scaleShapes(1 / 1.1);
          trackEvent("shrink-shapes", { source });
        }
      },
      {
        id: "a11y-repeat-shape-announce",
        kbd: "alt+r",
        label: "a11y.repeat-shape",
        readonlyOk: true,
        onSelect: async (source) => {
          const selectedShapeIds = editor.getSelectedShapeIds();
          if (!selectedShapeIds.length)
            return;
          const a11yLive = generateShapeAnnouncementMessage({
            editor,
            selectedShapeIds,
            msg: msg2
          });
          if (a11yLive) {
            a11y.announce({ msg: "" });
            editor.timers.requestAnimationFrame(() => {
              a11y.announce({ msg: a11yLive });
            });
            trackEvent("a11y-repeat-shape-announce", { source });
          }
        }
      }
    ];
    if (showCollaborationUi) {
      actionItems.push({
        id: "open-cursor-chat",
        label: "action.open-cursor-chat",
        readonlyOk: true,
        kbd: "/",
        onSelect(source) {
          trackEvent("open-cursor-chat", { source });
          if (editor.getInstanceState().isCoarsePointer) {
            return;
          }
          editor.timers.requestAnimationFrame(() => {
            editor.updateInstanceState({ isChatting: true });
          });
        }
      });
    }
    const actions2 = makeActions(actionItems);
    if (overrides) {
      return overrides(editor, actions2, helpers);
    }
    return actions2;
  }, [helpers, _editor, trackEvent, overrides, defaultDocumentName, showCollaborationUi, msg2, a11y]);
  return (0, import_jsx_runtime100.jsx)(ActionsContext.Provider, { value: asActions(actions), children });
}
function useActions() {
  const ctx = React86.useContext(ActionsContext);
  if (!ctx) {
    throw new Error("useTools must be used within a ToolProvider");
  }
  return ctx;
}
function asActions(actions) {
  return actions;
}
function unwrapLabel(label, menuType) {
  return label ? typeof label === "string" ? label : menuType ? label[menuType] ?? label["default"] : void 0 : void 0;
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useReadonly.mjs
function useReadonly() {
  const editor = useMaybeEditor();
  return useValue("isReadonlyMode", () => !!(editor == null ? void 0 : editor.getIsReadonly()), [editor]);
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiKbd.mjs
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/kbd-utils.mjs
var cmdKey = tlenv.isDarwin ? "⌘" : "Ctrl";
var altKey = tlenv.isDarwin ? "⌥" : "Alt";
function kbd(str) {
  if (str === ",")
    return [","];
  return str.split(",")[0].split(/(\[\[[^\]]+\]\])/g).map(
    (s) => s.startsWith("[[") ? s.replace(/[[\]]/g, "") : s.replace(/cmd\+/g, cmdKey).replace(/ctrl\+/g, cmdKey).replace(/alt\+/g, altKey).replace(/shift\+/g, "⇧").replace(/\$/g, cmdKey).replace(/\?/g, altKey).replace(/!/g, "⇧").split("")
  ).flat().map((sub) => {
    return sub[0].toUpperCase() + sub.slice(1);
  });
}
function kbdStr(str) {
  return "— " + kbd(str).join(" ");
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiKbd.mjs
function TldrawUiKbd({ children, visibleOnMobileLayout = false }) {
  const breakpoint = useBreakpoint();
  if (!visibleOnMobileLayout && breakpoint < PORTRAIT_BREAKPOINT.MOBILE)
    return null;
  return (0, import_jsx_runtime101.jsx)("kbd", { className: "tlui-kbd", children: kbd(children).map((k, i) => (0, import_jsx_runtime101.jsx)("span", { children: k }, i)) });
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuContext.mjs
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_react76 = __toESM(require_react(), 1);
var menuContext = (0, import_react76.createContext)(null);
function useTldrawUiMenuContext() {
  const context = (0, import_react76.useContext)(menuContext);
  if (!context) {
    throw new Error("useTldrawUiMenuContext must be used within a TldrawUiMenuContextProvider");
  }
  return context;
}
function TldrawUiMenuContextProvider({
  type,
  sourceId,
  children
}) {
  return (0, import_jsx_runtime102.jsx)(menuContext.Provider, { value: { type, sourceId }, children });
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuCheckboxItem.mjs
function TldrawUiMenuCheckboxItem({
  id,
  kbd: kbd2,
  label,
  readonlyOk,
  onSelect,
  toggle = false,
  disabled = false,
  checked = false
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const isReadonlyMode = useReadonly();
  const msg2 = useTranslation();
  if (isReadonlyMode && !readonlyOk)
    return null;
  const labelToUse = unwrapLabel(label, menuType);
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menuType) {
    case "menu": {
      return (0, import_jsx_runtime103.jsxs)(
        dist_exports9.CheckboxItem,
        {
          dir: "ltr",
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          title: labelStr,
          onSelect: (e) => {
            onSelect == null ? void 0 : onSelect(sourceId);
            preventDefault(e);
          },
          disabled,
          checked,
          children: [
            (0, import_jsx_runtime103.jsx)(
              TldrawUiIcon,
              {
                small: true,
                label: msg2(checked ? "ui.checked" : "ui.unchecked"),
                icon: toggle ? checked ? "toggle-on" : "toggle-off" : checked ? "check" : "none"
              }
            ),
            labelStr && (0, import_jsx_runtime103.jsx)("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            kbd2 && (0, import_jsx_runtime103.jsx)(TldrawUiKbd, { children: kbd2 })
          ]
        }
      );
    }
    case "context-menu": {
      return (0, import_jsx_runtime103.jsxs)(
        dist_exports7.CheckboxItem,
        {
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          dir: "ltr",
          title: labelStr,
          onSelect: (e) => {
            onSelect(sourceId);
            preventDefault(e);
          },
          disabled,
          checked,
          children: [
            (0, import_jsx_runtime103.jsx)(
              TldrawUiIcon,
              {
                small: true,
                label: msg2(checked ? "ui.checked" : "ui.unchecked"),
                icon: toggle ? checked ? "toggle-on" : "toggle-off" : checked ? "check" : "none"
              }
            ),
            labelStr && (0, import_jsx_runtime103.jsx)("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            kbd2 && (0, import_jsx_runtime103.jsx)(TldrawUiKbd, { children: kbd2 })
          ]
        },
        id
      );
    }
    default: {
      return null;
    }
  }
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuGroup.mjs
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var import_classnames18 = __toESM(require_classnames(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiDropdownMenu.mjs
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var import_classnames17 = __toESM(require_classnames(), 1);

// node_modules/tldraw/dist-esm/lib/ui/hooks/useMenuIsOpen.mjs
var import_react77 = __toESM(require_react(), 1);
function useMenuIsOpen(id, cb) {
  const editor = useMaybeEditor();
  const onChange = (0, import_react77.useCallback)(
    (isOpen) => {
      if (isOpen) {
        editor == null ? void 0 : editor.complete();
      }
      cb == null ? void 0 : cb(isOpen);
    },
    [editor, cb]
  );
  const trackEvent = useUiEvents();
  const onEvent = (0, import_react77.useCallback)(
    (eventName) => {
      trackEvent(eventName, { source: "unknown", id });
    },
    [id, trackEvent]
  );
  return useGlobalMenuIsOpen(editor ? `${id}-${editor.contextId}` : id, onChange, onEvent);
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiDropdownMenu.mjs
function TldrawUiDropdownMenuRoot({
  id,
  children,
  modal = false,
  debugOpen = false
}) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return (0, import_jsx_runtime104.jsx)(
    dist_exports9.Root,
    {
      open: debugOpen || open,
      dir: "ltr",
      modal,
      onOpenChange,
      children
    }
  );
}
function TldrawUiDropdownMenuTrigger({ children, ...rest }) {
  return (0, import_jsx_runtime104.jsx)(
    dist_exports9.Trigger,
    {
      dir: "ltr",
      asChild: true,
      onTouchEnd: (e) => preventDefault(e),
      ...rest,
      children
    }
  );
}
function TldrawUiDropdownMenuContent({
  className,
  side = "bottom",
  align = "start",
  sideOffset = 8,
  alignOffset = 8,
  children
}) {
  const container = useContainer();
  return (0, import_jsx_runtime104.jsx)(dist_exports9.Portal, { container, children: (0, import_jsx_runtime104.jsx)(
    dist_exports9.Content,
    {
      className: (0, import_classnames17.default)("tlui-menu", className),
      side,
      sideOffset,
      align,
      alignOffset,
      collisionPadding: 4,
      children
    }
  ) });
}
function TldrawUiDropdownMenuSub({ id, children }) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return (0, import_jsx_runtime104.jsx)(dist_exports9.Sub, { open, onOpenChange, children });
}
function TldrawUiDropdownMenuSubTrigger({
  id,
  label,
  title,
  disabled
}) {
  return (0, import_jsx_runtime104.jsx)(dist_exports9.SubTrigger, { dir: "ltr", asChild: true, disabled, children: (0, import_jsx_runtime104.jsxs)(
    TldrawUiButton,
    {
      "data-testid": id,
      type: "menu",
      className: "tlui-menu__submenu__trigger",
      disabled,
      title,
      children: [
        (0, import_jsx_runtime104.jsx)(TldrawUiButtonLabel, { children: label }),
        (0, import_jsx_runtime104.jsx)(TldrawUiButtonIcon, { icon: "chevron-right", small: true })
      ]
    }
  ) });
}
function TldrawUiDropdownMenuSubContent({
  id,
  alignOffset = -1,
  sideOffset = -6,
  size: size4 = "small",
  children
}) {
  const container = useContainer();
  return (0, import_jsx_runtime104.jsx)(dist_exports9.Portal, { container, children: (0, import_jsx_runtime104.jsx)(
    dist_exports9.SubContent,
    {
      "data-testid": id,
      className: "tlui-menu tlui-menu__submenu__content",
      alignOffset,
      sideOffset,
      collisionPadding: 4,
      "data-size": size4,
      children
    }
  ) });
}
function TldrawUiDropdownMenuGroup({ className, children }) {
  return (0, import_jsx_runtime104.jsx)("div", { dir: "ltr", className: (0, import_classnames17.default)("tlui-menu__group", className), children });
}
function TldrawUiDropdownMenuIndicator() {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime104.jsx)(dist_exports9.ItemIndicator, { dir: "ltr", asChild: true, children: (0, import_jsx_runtime104.jsx)(TldrawUiIcon, { label: msg2("ui.checked"), icon: "check" }) });
}
function TldrawUiDropdownMenuItem({ noClose, children }) {
  return (0, import_jsx_runtime104.jsx)(dist_exports9.Item, { dir: "ltr", asChild: true, onClick: noClose ? preventDefault : void 0, children });
}
function TldrawUiDropdownMenuCheckboxItem({
  children,
  onSelect,
  ...rest
}) {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime104.jsxs)(
    dist_exports9.CheckboxItem,
    {
      dir: "ltr",
      className: "tlui-button tlui-button__menu tlui-button__checkbox",
      onSelect: (e) => {
        onSelect == null ? void 0 : onSelect(e);
        preventDefault(e);
      },
      ...rest,
      children: [
        (0, import_jsx_runtime104.jsx)("div", { className: "tlui-button__checkbox__indicator", children: (0, import_jsx_runtime104.jsx)(dist_exports9.ItemIndicator, { dir: "ltr", children: (0, import_jsx_runtime104.jsx)(TldrawUiIcon, { label: msg2("ui.checked"), icon: "check", small: true }) }) }),
        children
      ]
    }
  );
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuGroup.mjs
function TldrawUiMenuGroup({ id, label, className, children }) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const msg2 = useTranslation();
  const labelToUse = unwrapLabel(label, menuType);
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menuType) {
    case "panel": {
      return (0, import_jsx_runtime105.jsx)(
        "div",
        {
          className: (0, import_classnames18.default)("tlui-menu__group", className),
          "data-testid": `${sourceId}-group.${id}`,
          children
        }
      );
    }
    case "menu": {
      return (0, import_jsx_runtime105.jsx)(TldrawUiDropdownMenuGroup, { className, "data-testid": `${sourceId}-group.${id}`, children });
    }
    case "context-menu": {
      return (0, import_jsx_runtime105.jsx)(
        "div",
        {
          dir: "ltr",
          className: (0, import_classnames18.default)("tlui-menu__group", className),
          "data-testid": `${sourceId}-group.${id}`,
          children
        }
      );
    }
    case "keyboard-shortcuts": {
      return (0, import_jsx_runtime105.jsxs)("div", { className: "tlui-shortcuts-dialog__group", "data-testid": `${sourceId}-group.${id}`, children: [
        (0, import_jsx_runtime105.jsx)("h2", { className: "tlui-shortcuts-dialog__group__title", children: labelStr }),
        (0, import_jsx_runtime105.jsx)("div", { className: "tlui-shortcuts-dialog__group__content", children })
      ] });
    }
    default: {
      return children;
    }
  }
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuSubmenu.mjs
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
function TldrawUiMenuSubmenu({
  id,
  disabled = false,
  label,
  size: size4 = "small",
  children
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const container = useContainer();
  const msg2 = useTranslation();
  const labelToUse = label ? typeof label === "string" ? label : label[menuType] ?? label["default"] : void 0;
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menuType) {
    case "menu": {
      return (0, import_jsx_runtime106.jsxs)(TldrawUiDropdownMenuSub, { id: `${sourceId}-sub.${id}`, children: [
        (0, import_jsx_runtime106.jsx)(
          TldrawUiDropdownMenuSubTrigger,
          {
            id: `${sourceId}-sub.${id}-button`,
            disabled,
            label: labelStr,
            title: labelStr
          }
        ),
        (0, import_jsx_runtime106.jsx)(TldrawUiDropdownMenuSubContent, { id: `${sourceId}-sub.${id}-content`, size: size4, children })
      ] });
    }
    case "context-menu": {
      if (disabled)
        return null;
      return (0, import_jsx_runtime106.jsxs)(ContextMenuSubWithMenu, { id: `${sourceId}-sub.${id}`, children: [
        (0, import_jsx_runtime106.jsx)(dist_exports7.ContextMenuSubTrigger, { dir: "ltr", disabled, asChild: true, children: (0, import_jsx_runtime106.jsxs)(
          TldrawUiButton,
          {
            "data-testid": `${sourceId}-sub.${id}-button`,
            type: "menu",
            className: "tlui-menu__submenu__trigger",
            children: [
              (0, import_jsx_runtime106.jsx)(TldrawUiButtonLabel, { children: labelStr }),
              (0, import_jsx_runtime106.jsx)(TldrawUiButtonIcon, { icon: "chevron-right", small: true })
            ]
          }
        ) }),
        (0, import_jsx_runtime106.jsx)(dist_exports7.ContextMenuPortal, { container, children: (0, import_jsx_runtime106.jsx)(
          dist_exports7.ContextMenuSubContent,
          {
            "data-testid": `${sourceId}-sub.${id}-content`,
            className: "tlui-menu tlui-menu__submenu__content",
            alignOffset: -1,
            sideOffset: -4,
            collisionPadding: 4,
            "data-size": size4,
            children
          }
        ) })
      ] });
    }
    default: {
      return children;
    }
  }
}
function ContextMenuSubWithMenu({ id, children }) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return (0, import_jsx_runtime106.jsx)(dist_exports7.ContextMenuSub, { open, onOpenChange, children });
}

// node_modules/tldraw/dist-esm/lib/ui/components/ColorSchemeMenu.mjs
var COLOR_SCHEMES = [
  { colorScheme: "light", label: "theme.light" },
  { colorScheme: "dark", label: "theme.dark" },
  { colorScheme: "system", label: "theme.system" }
];
function ColorSchemeMenu() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const currentColorScheme = useValue(
    "colorScheme",
    () => editor.user.getUserPreferences().colorScheme ?? (editor.user.getIsDarkMode() ? "dark" : "light"),
    [editor]
  );
  return (0, import_jsx_runtime107.jsx)(TldrawUiMenuSubmenu, { id: "help menu color-scheme", label: "menu.theme", children: (0, import_jsx_runtime107.jsx)(TldrawUiMenuGroup, { id: "theme", children: COLOR_SCHEMES.map(({ colorScheme, label }) => (0, import_jsx_runtime107.jsx)(
    TldrawUiMenuCheckboxItem,
    {
      id: `color-scheme-${colorScheme}`,
      label,
      checked: colorScheme === currentColorScheme,
      readonlyOk: true,
      onSelect: () => {
        editor.user.updateUserPreferences({ colorScheme });
        trackEvent("color-scheme", { source: "menu", value: colorScheme });
      }
    },
    colorScheme
  )) }) });
}

// node_modules/tldraw/dist-esm/lib/ui/components/Dialogs.mjs
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var import_react78 = __toESM(require_react(), 1);
var TldrawUiDialog = ({
  id,
  component: ModalContent,
  onClose,
  preventBackgroundClose
}) => {
  const { removeDialog } = useDialogs();
  const mouseDownInsideContentRef = (0, import_react78.useRef)(false);
  const container = useContainer();
  const handleOpenChange = (0, import_react78.useCallback)(
    (isOpen) => {
      if (!isOpen) {
        if (onClose) {
          try {
            onClose();
          } catch (err) {
            console.warn(err);
          }
        }
        removeDialog(id);
      }
    },
    [id, onClose, removeDialog]
  );
  return (0, import_jsx_runtime108.jsx)(dist_exports3.Root, { onOpenChange: handleOpenChange, defaultOpen: true, children: (0, import_jsx_runtime108.jsx)(dist_exports3.Portal, { container, children: (0, import_jsx_runtime108.jsx)(
    dist_exports3.Overlay,
    {
      dir: "ltr",
      className: "tlui-dialog__overlay",
      onClick: (e) => {
        if (mouseDownInsideContentRef.current)
          return;
        if (!preventBackgroundClose && e.target === e.currentTarget)
          handleOpenChange(false);
      },
      children: (0, import_jsx_runtime108.jsx)(
        dist_exports3.Content,
        {
          dir: "ltr",
          className: "tlui-dialog__content",
          "aria-describedby": void 0,
          onMouseDown: () => mouseDownInsideContentRef.current = true,
          onMouseUp: () => mouseDownInsideContentRef.current = false,
          onInteractOutside: (e) => {
            mouseDownInsideContentRef.current = false;
            if (preventBackgroundClose) {
              e.preventDefault();
            }
          },
          children: (0, import_jsx_runtime108.jsx)(
            ModalContent,
            {
              onClose: () => {
                mouseDownInsideContentRef.current = false;
                handleOpenChange(false);
              }
            }
          )
        }
      )
    }
  ) }) });
};
var DefaultDialogs = (0, import_react78.memo)(function DefaultDialogs2() {
  const { dialogs } = useDialogs();
  const dialogsArray = useValue("dialogs", () => dialogs.get(), [dialogs]);
  return dialogsArray.map((dialog) => (0, import_jsx_runtime108.jsx)(TldrawUiDialog, { ...dialog }, dialog.id));
});

// node_modules/tldraw/dist-esm/lib/ui/components/Toasts.mjs
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var import_react79 = __toESM(require_react(), 1);
var DEFAULT_TOAST_DURATION = 4e3;
var SEVERITY_TO_ICON = {
  success: "check-circle",
  warning: "warning-triangle",
  error: "cross-circle",
  info: "info-circle"
};
function TldrawUiToast({ toast }) {
  const { removeToast } = useToasts();
  const msg2 = useTranslation();
  const onOpenChange = (isOpen) => {
    if (!isOpen) {
      removeToast(toast.id);
    }
  };
  const hasActions = toast.actions && toast.actions.length > 0;
  const icon = toast.icon || toast.severity && SEVERITY_TO_ICON[toast.severity];
  const iconLabel = toast.iconLabel || (toast.severity ? msg2(`toast.${toast.severity}`) : "");
  return (0, import_jsx_runtime109.jsxs)(
    dist_exports13.Root,
    {
      onOpenChange,
      className: "tlui-toast__container",
      duration: toast.keepOpen ? Infinity : DEFAULT_TOAST_DURATION,
      "data-severity": toast.severity,
      children: [
        icon && (0, import_jsx_runtime109.jsx)("div", { className: "tlui-toast__icon", children: (0, import_jsx_runtime109.jsx)(TldrawUiIcon, { label: iconLabel, icon }) }),
        (0, import_jsx_runtime109.jsxs)(
          "div",
          {
            className: "tlui-toast__main",
            "data-title": !!toast.title,
            "data-description": !!toast.description,
            "data-actions": !!toast.actions,
            children: [
              (0, import_jsx_runtime109.jsxs)("div", { className: "tlui-toast__content", children: [
                toast.title && (0, import_jsx_runtime109.jsx)(dist_exports13.Title, { className: "tlui-toast__title", children: toast.title }),
                toast.description && (0, import_jsx_runtime109.jsx)(dist_exports13.Description, { className: "tlui-toast__description", children: toast.description })
              ] }),
              toast.actions && (0, import_jsx_runtime109.jsxs)("div", { className: "tlui-toast__actions", children: [
                toast.actions.map((action, i) => (0, import_jsx_runtime109.jsx)(dist_exports13.Action, { altText: action.label, asChild: true, onClick: action.onClick, children: (0, import_jsx_runtime109.jsx)(TldrawUiButton, { type: action.type, children: (0, import_jsx_runtime109.jsx)(TldrawUiButtonLabel, { children: action.label }) }) }, i)),
                (0, import_jsx_runtime109.jsx)(dist_exports13.Close, { asChild: true, children: (0, import_jsx_runtime109.jsx)(
                  TldrawUiButton,
                  {
                    type: "normal",
                    className: "tlui-toast__close",
                    style: { marginLeft: "auto" },
                    children: (0, import_jsx_runtime109.jsx)(TldrawUiButtonLabel, { children: toast.closeLabel ?? msg2("toast.close") })
                  }
                ) })
              ] })
            ]
          }
        ),
        !hasActions && (0, import_jsx_runtime109.jsx)(dist_exports13.Close, { asChild: true, children: (0, import_jsx_runtime109.jsx)(TldrawUiButton, { type: "normal", className: "tlui-toast__close", children: (0, import_jsx_runtime109.jsx)(TldrawUiButtonLabel, { children: toast.closeLabel ?? msg2("toast.close") }) }) })
      ]
    }
  );
}
var DefaultToasts = (0, import_react79.memo)(function TldrawUiToasts() {
  const { toasts } = useToasts();
  const toastsArray = useValue("toasts", () => toasts.get(), []);
  return (0, import_jsx_runtime109.jsxs)(import_jsx_runtime109.Fragment, { children: [
    toastsArray.map((toast) => (0, import_jsx_runtime109.jsx)(TldrawUiToast, { toast }, toast.id)),
    (0, import_jsx_runtime109.jsx)(dist_exports13.ToastViewport, { className: "tlui-toast__viewport" })
  ] });
});

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuActionCheckboxItem.mjs
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
function TldrawUiMenuActionCheckboxItem({
  actionId = "",
  ...rest
}) {
  const actions = useActions();
  const action = actions[actionId];
  if (!action)
    return null;
  return (0, import_jsx_runtime110.jsx)(TldrawUiMenuCheckboxItem, { ...action, ...rest });
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuActionItem.mjs
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuItem.mjs
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var import_react81 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/Spinner.mjs
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
function Spinner(props) {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime111.jsx)(
    "svg",
    {
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      ...props,
      "aria-label": msg2("app.loading"),
      "aria-hidden": "false",
      children: (0, import_jsx_runtime111.jsxs)("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
        (0, import_jsx_runtime111.jsx)("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
        (0, import_jsx_runtime111.jsx)("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor", children: (0, import_jsx_runtime111.jsx)(
          "animateTransform",
          {
            attributeName: "transform",
            type: "rotate",
            from: "0 8 8",
            to: "360 8 8",
            dur: "1s",
            repeatCount: "indefinite"
          }
        ) })
      ] })
    }
  );
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiToolbar.mjs
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var import_classnames19 = __toESM(require_classnames(), 1);
var import_react80 = __toESM(require_react(), 1);
var TldrawUiToolbar = import_react80.default.forwardRef(
  ({ children, className, label, ...props }, ref) => {
    return (0, import_jsx_runtime112.jsx)(
      dist_exports15.Root,
      {
        ref,
        ...props,
        className: (0, import_classnames19.default)("tlui-toolbar-container", className),
        "aria-label": label,
        children
      }
    );
  }
);
var TldrawUiToolbarButton = import_react80.default.forwardRef(
  ({ asChild, children, type, isActive: isActive2, ...props }, ref) => {
    return (0, import_jsx_runtime112.jsx)(
      dist_exports15.Button,
      {
        ref,
        asChild,
        draggable: false,
        "data-isactive": isActive2,
        ...props,
        className: (0, import_classnames19.default)("tlui-button", `tlui-button__${type}`, props.className),
        children
      }
    );
  }
);
var TldrawUiToolbarToggleGroup = ({
  children,
  className,
  type,
  ...props
}) => {
  return (0, import_jsx_runtime112.jsx)(
    dist_exports15.ToggleGroup,
    {
      type,
      ...props,
      className: (0, import_classnames19.default)("tlui-toolbar-toggle-group", className),
      children
    }
  );
};
var TldrawUiToolbarToggleItem = ({
  children,
  className,
  type,
  value,
  ...props
}) => {
  return (0, import_jsx_runtime112.jsx)(
    dist_exports15.ToggleItem,
    {
      ...props,
      className: (0, import_classnames19.default)(
        "tlui-button",
        `tlui-button__${type}`,
        "tlui-toolbar-toggle-group-item",
        className
      ),
      value,
      children
    }
  );
};

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuItem.mjs
function TldrawUiMenuItem({
  disabled = false,
  spinner = false,
  readonlyOk = false,
  id,
  kbd: kbd2,
  label,
  icon,
  iconLeft,
  onSelect,
  noClose,
  isSelected
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const msg2 = useTranslation();
  const [disableClicks, setDisableClicks] = (0, import_react81.useState)(false);
  const isReadonlyMode = useReadonly();
  if (isReadonlyMode && !readonlyOk)
    return null;
  const labelToUse = unwrapLabel(label, menuType);
  const kbdToUse = kbd2 ? kbdStr(kbd2) : void 0;
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  const titleStr = labelStr && kbdToUse ? `${labelStr} ${kbdToUse}` : labelStr;
  switch (menuType) {
    case "menu": {
      return (0, import_jsx_runtime113.jsx)(TldrawUiDropdownMenuItem, { children: (0, import_jsx_runtime113.jsxs)(
        TldrawUiButton,
        {
          type: "menu",
          "data-testid": `${sourceId}.${id}`,
          disabled,
          title: titleStr,
          onClick: (e) => {
            if (noClose) {
              preventDefault(e);
            }
            if (disableClicks) {
              setDisableClicks(false);
            } else {
              onSelect(sourceId);
            }
          },
          children: [
            iconLeft && (0, import_jsx_runtime113.jsx)(TldrawUiButtonIcon, { icon: iconLeft, small: true }),
            (0, import_jsx_runtime113.jsx)(TldrawUiButtonLabel, { children: labelStr }),
            kbd2 && (0, import_jsx_runtime113.jsx)(TldrawUiKbd, { children: kbd2 })
          ]
        }
      ) });
    }
    case "context-menu": {
      if (disabled)
        return null;
      return (0, import_jsx_runtime113.jsxs)(
        dist_exports7.Item,
        {
          dir: "ltr",
          title: titleStr,
          draggable: false,
          className: "tlui-button tlui-button__menu",
          "data-testid": `${sourceId}.${id}`,
          onSelect: (e) => {
            if (noClose)
              preventDefault(e);
            if (disableClicks) {
              setDisableClicks(false);
            } else {
              onSelect(sourceId);
            }
          },
          children: [
            (0, import_jsx_runtime113.jsx)("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            iconLeft && (0, import_jsx_runtime113.jsx)(TldrawUiButtonIcon, { icon: iconLeft, small: true }),
            kbd2 && (0, import_jsx_runtime113.jsx)(TldrawUiKbd, { children: kbd2 }),
            spinner && (0, import_jsx_runtime113.jsx)(Spinner, {})
          ]
        }
      );
    }
    case "panel": {
      return (0, import_jsx_runtime113.jsxs)(
        TldrawUiButton,
        {
          "data-testid": `${sourceId}.${id}`,
          type: "menu",
          title: titleStr,
          disabled,
          onClick: () => onSelect(sourceId),
          children: [
            (0, import_jsx_runtime113.jsx)(TldrawUiButtonLabel, { children: labelStr }),
            spinner ? (0, import_jsx_runtime113.jsx)(Spinner, {}) : icon && (0, import_jsx_runtime113.jsx)(TldrawUiButtonIcon, { icon })
          ]
        }
      );
    }
    case "small-icons":
    case "icons": {
      return (0, import_jsx_runtime113.jsx)(
        TldrawUiToolbarButton,
        {
          "data-testid": `${sourceId}.${id}`,
          type: "icon",
          title: titleStr,
          disabled,
          onClick: () => onSelect(sourceId),
          children: (0, import_jsx_runtime113.jsx)(TldrawUiButtonIcon, { icon, small: true })
        }
      );
    }
    case "keyboard-shortcuts": {
      if (!kbd2) {
        console.warn(
          `Menu item '${label}' isn't shown in the keyboard shortcuts dialog because it doesn't have a keyboard shortcut.`
        );
        return null;
      }
      return (0, import_jsx_runtime113.jsxs)("div", { className: "tlui-shortcuts-dialog__key-pair", "data-testid": `${sourceId}.${id}`, children: [
        (0, import_jsx_runtime113.jsx)("div", { className: "tlui-shortcuts-dialog__key-pair__key", children: labelStr }),
        (0, import_jsx_runtime113.jsx)("div", { className: "tlui-shortcuts-dialog__key-pair__value", children: (0, import_jsx_runtime113.jsx)(TldrawUiKbd, { visibleOnMobileLayout: true, children: kbd2 }) })
      ] });
    }
    case "helper-buttons": {
      return (0, import_jsx_runtime113.jsxs)(TldrawUiButton, { type: "low", onClick: () => onSelect(sourceId), children: [
        (0, import_jsx_runtime113.jsx)(TldrawUiButtonIcon, { icon }),
        (0, import_jsx_runtime113.jsx)(TldrawUiButtonLabel, { children: labelStr })
      ] });
    }
    case "toolbar": {
      return (0, import_jsx_runtime113.jsx)(
        TldrawUiToolbarButton,
        {
          "aria-label": labelStr,
          "aria-pressed": isSelected ? "true" : "false",
          "data-testid": `tools.${id}`,
          "data-value": id,
          disabled,
          onClick: () => onSelect("toolbar"),
          onTouchStart: (e) => {
            preventDefault(e);
            onSelect("toolbar");
          },
          role: "option",
          title: titleStr,
          type: "tool",
          children: (0, import_jsx_runtime113.jsx)(TldrawUiButtonIcon, { icon })
        }
      );
    }
    case "toolbar-overflow": {
      return (0, import_jsx_runtime113.jsx)(
        TldrawUiToolbarButton,
        {
          "aria-label": labelStr,
          "aria-pressed": isSelected ? "true" : "false",
          isActive: isSelected,
          className: "tlui-button-grid__button",
          "data-testid": `tools.more.${id}`,
          "data-value": id,
          disabled,
          onClick: () => onSelect("toolbar"),
          role: "option",
          title: titleStr,
          type: "icon",
          children: (0, import_jsx_runtime113.jsx)(TldrawUiButtonIcon, { icon })
        }
      );
    }
    default: {
      throw exhaustiveSwitchError(menuType);
    }
  }
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuActionItem.mjs
function TldrawUiMenuActionItem({ actionId = "", ...rest }) {
  const actions = useActions();
  const action = actions[actionId];
  if (!action)
    return null;
  return (0, import_jsx_runtime114.jsx)(TldrawUiMenuItem, { ...action, ...rest });
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuToolItem.mjs
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/hooks/useTools.mjs
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var React88 = __toESM(require_react(), 1);
var ToolsContext = React88.createContext(null);
function ToolsProvider({ overrides, children }) {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const helpers = useDefaultHelpers();
  const onToolSelect = React88.useCallback(
    (source, tool, id) => {
      a11y.announce({ msg: msg2(tool.label) });
      trackEvent("select-tool", { source, id: id ?? tool.id });
    },
    [a11y, msg2, trackEvent]
  );
  const tools = React88.useMemo(() => {
    if (!editor)
      return {};
    const toolsArray = [
      {
        id: "select",
        label: "tool.select",
        icon: "tool-pointer",
        kbd: "v",
        readonlyOk: true,
        onSelect(source) {
          if (editor.isIn("select")) {
            const currentNode = editor.root.getCurrent();
            currentNode.exit({}, currentNode.id);
            currentNode.enter({}, currentNode.id);
          }
          editor.setCurrentTool("select");
          onToolSelect(source, this);
        }
      },
      {
        id: "hand",
        label: "tool.hand",
        icon: "tool-hand",
        kbd: "h",
        readonlyOk: true,
        onSelect(source) {
          editor.setCurrentTool("hand");
          onToolSelect(source, this);
        }
      },
      {
        id: "eraser",
        label: "tool.eraser",
        icon: "tool-eraser",
        kbd: "e",
        onSelect(source) {
          editor.setCurrentTool("eraser");
          onToolSelect(source, this);
        }
      },
      {
        id: "draw",
        label: "tool.draw",
        icon: "tool-pencil",
        kbd: "d,b,x",
        onSelect(source) {
          editor.setCurrentTool("draw");
          onToolSelect(source, this);
        }
      },
      ...[...GeoShapeGeoStyle.values].map((id) => ({
        id,
        label: `tool.${id}`,
        meta: {
          geo: id
        },
        kbd: id === "rectangle" ? "r" : id === "ellipse" ? "o" : void 0,
        icon: "geo-" + id,
        onSelect(source) {
          editor.run(() => {
            editor.setStyleForNextShapes(GeoShapeGeoStyle, id);
            editor.setCurrentTool("geo");
            onToolSelect(source, this, `geo-${id}`);
          });
        }
      })),
      {
        id: "arrow",
        label: "tool.arrow",
        icon: "tool-arrow",
        kbd: "a",
        onSelect(source) {
          editor.setCurrentTool("arrow");
          onToolSelect(source, this);
        }
      },
      {
        id: "line",
        label: "tool.line",
        icon: "tool-line",
        kbd: "l",
        onSelect(source) {
          editor.setCurrentTool("line");
          onToolSelect(source, this);
        }
      },
      {
        id: "frame",
        label: "tool.frame",
        icon: "tool-frame",
        kbd: "f",
        onSelect(source) {
          editor.setCurrentTool("frame");
          onToolSelect(source, this);
        }
      },
      {
        id: "text",
        label: "tool.text",
        icon: "tool-text",
        kbd: "t",
        onSelect(source) {
          editor.setCurrentTool("text");
          onToolSelect(source, this);
        }
      },
      {
        id: "asset",
        label: "tool.media",
        icon: "tool-media",
        kbd: "cmd+u,ctrl+u",
        onSelect(source) {
          helpers.insertMedia();
          onToolSelect(source, this, "media");
        }
      },
      {
        id: "note",
        label: "tool.note",
        icon: "tool-note",
        kbd: "n",
        onSelect(source) {
          editor.setCurrentTool("note");
          onToolSelect(source, this);
        }
      },
      {
        id: "laser",
        label: "tool.laser",
        readonlyOk: true,
        icon: "tool-laser",
        kbd: "k",
        onSelect(source) {
          editor.setCurrentTool("laser");
          onToolSelect(source, this);
        }
      },
      {
        id: "embed",
        label: "tool.embed",
        icon: "dot",
        onSelect(source) {
          helpers.addDialog({ component: EmbedDialog });
          onToolSelect(source, this);
        }
      },
      {
        id: "highlight",
        label: "tool.highlight",
        icon: "tool-highlight",
        // TODO: pick a better shortcut
        kbd: "shift+d",
        onSelect(source) {
          editor.setCurrentTool("highlight");
          onToolSelect(source, this);
        }
      }
    ];
    toolsArray.forEach((t2) => t2.onSelect = t2.onSelect.bind(t2));
    const tools2 = Object.fromEntries(toolsArray.map((t2) => [t2.id, t2]));
    if (overrides) {
      return overrides(editor, tools2, helpers);
    }
    return tools2;
  }, [overrides, editor, helpers, onToolSelect]);
  return (0, import_jsx_runtime115.jsx)(ToolsContext.Provider, { value: tools, children });
}
function useTools() {
  const ctx = React88.useContext(ToolsContext);
  if (!ctx) {
    throw new Error("useTools must be used within a ToolProvider");
  }
  return ctx;
}

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuToolItem.mjs
function TldrawUiMenuToolItem({ toolId = "", ...rest }) {
  const tools = useTools();
  const tool = tools[toolId];
  if (!tool)
    return null;
  return (0, import_jsx_runtime116.jsx)(TldrawUiMenuItem, { ...tool, ...rest });
}

// node_modules/tldraw/dist-esm/lib/Tldraw.mjs
var import_jsx_runtime212 = __toESM(require_jsx_runtime(), 1);
var import_react141 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/canvas/TldrawHandles.mjs
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
function TldrawHandles({ children }) {
  const editor = useEditor();
  const shouldDisplayHandles = useValue(
    "shouldDisplayHandles",
    () => {
      if (editor.isInAny("select.idle", "select.pointing_handle", "select.pointing_shape")) {
        return true;
      }
      if (editor.isInAny("select.editing_shape")) {
        const onlySelectedShape = editor.getOnlySelectedShape();
        return onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "note");
      }
      return false;
    },
    [editor]
  );
  if (!shouldDisplayHandles)
    return null;
  return (0, import_jsx_runtime117.jsx)("svg", { className: "tl-user-handles tl-overlays__item", children });
}

// node_modules/tldraw/dist-esm/lib/canvas/TldrawOverlays.mjs
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/definitions.mjs
var ElbowArrowSides = ["right", "bottom", "left", "top"];
var ElbowArrowSideDeltas = {
  top: { x: 0, y: -1 },
  right: { x: 1, y: 0 },
  bottom: { x: 0, y: 1 },
  left: { x: -1, y: 0 }
};
var ElbowArrowSideAxes = {
  left: "x",
  right: "x",
  top: "y",
  bottom: "y"
};
var ElbowArrowSideOpposites = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var ElbowArrowAxes = {
  x: {
    v: (x, y) => new Vec(x, y),
    loEdge: "left",
    hiEdge: "right",
    crossMid: "midY",
    gap: "gapX",
    midRange: "midXRange",
    self: "x",
    cross: "y",
    size: "width"
  },
  y: {
    v: (y, x) => new Vec(x, y),
    loEdge: "top",
    hiEdge: "bottom",
    crossMid: "midX",
    gap: "gapY",
    midRange: "midYRange",
    self: "y",
    cross: "x",
    size: "height"
  }
};

// node_modules/tldraw/dist-esm/lib/shapes/arrow/arrowTargetState.mjs
var arrowTargetStore = new WeakCache();
function getArrowTargetAtom(editor) {
  return arrowTargetStore.get(editor, () => atom("arrowTarget", null));
}
function getArrowTargetState(editor) {
  return getArrowTargetAtom(editor).get();
}
function clearArrowTargetState(editor) {
  getArrowTargetAtom(editor).set(null);
}
function updateArrowTargetState({
  editor,
  pointInPageSpace,
  arrow: arrow6,
  isPrecise,
  isExact,
  currentBinding,
  oppositeBinding
}) {
  if (editor.inputs.ctrlKey) {
    getArrowTargetAtom(editor).set(null);
    return null;
  }
  const util = editor.getShapeUtil("arrow");
  const arrowKind = arrow6 ? arrow6.props.kind : editor.getStyleForNextShape(ArrowShapeKindStyle);
  const target = editor.getShapeAtPoint(pointInPageSpace, {
    hitInside: true,
    hitFrameInside: true,
    margin: arrowKind === "elbow" ? 8 : 0,
    filter: (targetShape) => {
      return !targetShape.isLocked && editor.canBindShapes({
        fromShape: arrow6 ?? targetFilterFallback,
        toShape: targetShape,
        binding: "arrow"
      });
    }
  });
  if (!target) {
    getArrowTargetAtom(editor).set(null);
    return null;
  }
  const targetGeometryInTargetSpace = editor.getShapeGeometry(target);
  const targetBoundsInTargetSpace = Box.ZeroFix(targetGeometryInTargetSpace.bounds);
  const targetCenterInTargetSpace = targetGeometryInTargetSpace.center;
  const targetTransform = editor.getShapePageTransform(target);
  const pointInTargetSpace = editor.getPointInShapeSpace(target, pointInPageSpace);
  const castDistance = Math.max(
    targetGeometryInTargetSpace.bounds.width,
    targetGeometryInTargetSpace.bounds.height
  );
  const handlesInPageSpace = mapObjectMapValues(ElbowArrowSideDeltas, (side, delta) => {
    const axis = ElbowArrowAxes[ElbowArrowSideAxes[side]];
    const farPoint = Vec.Mul(delta, castDistance).add(targetCenterInTargetSpace);
    let isEnabled = false;
    let handlePointInTargetSpace = axis.v(
      targetBoundsInTargetSpace[side],
      targetBoundsInTargetSpace[axis.crossMid]
    );
    let furthestDistance = 0;
    const intersections = targetGeometryInTargetSpace.intersectLineSegment(
      targetCenterInTargetSpace,
      farPoint,
      Geometry2dFilters.EXCLUDE_NON_STANDARD
    );
    for (const intersection of intersections) {
      const distance = Vec.Dist2(intersection, targetCenterInTargetSpace);
      if (distance > furthestDistance) {
        furthestDistance = distance;
        handlePointInTargetSpace = intersection;
        isEnabled = targetGeometryInTargetSpace.isClosed;
      }
    }
    const handlePointInPageSpace = targetTransform.applyToPoint(handlePointInTargetSpace);
    return { point: handlePointInPageSpace, isEnabled, far: targetTransform.applyToPoint(farPoint) };
  });
  const zoomLevel = editor.getZoomLevel();
  const minDistScaled = util.options.minElbowHandleDistance / zoomLevel;
  const targetCenterInPageSpace = targetTransform.applyToPoint(targetCenterInTargetSpace);
  for (const side of objectMapKeys(handlesInPageSpace)) {
    const handle = handlesInPageSpace[side];
    if (Vec.DistMin(handle.point, targetCenterInPageSpace, minDistScaled)) {
      handle.isEnabled = false;
    }
  }
  let precise2 = isPrecise || isExact;
  if (!precise2) {
    if (!currentBinding || currentBinding && target.id !== currentBinding.toId) {
      precise2 = editor.inputs.pointerVelocity.len() < 0.5;
    }
  }
  if (!isPrecise) {
    if (!targetGeometryInTargetSpace.isClosed) {
      precise2 = true;
    }
    if (oppositeBinding && target.id === oppositeBinding.toId && oppositeBinding.props.isPrecise) {
      precise2 = true;
    }
  }
  const shouldSnapCenter = !isExact && precise2 && targetGeometryInTargetSpace.isClosed;
  const shouldSnapEdges = !isExact && (precise2 && arrowKind === "elbow" || !targetGeometryInTargetSpace.isClosed);
  const shouldSnapEdgePoints = !isExact && precise2 && arrowKind === "elbow" && targetGeometryInTargetSpace.isClosed;
  const shouldSnapNone = precise2 && (targetGeometryInTargetSpace.isClosed || isExact);
  const shouldSnapCenterAxis = !isExact && precise2 && arrowKind === "elbow" && targetGeometryInTargetSpace.isClosed;
  let snap = "none";
  let anchorInPageSpace = pointInPageSpace;
  if (!shouldSnapNone) {
    snap = "center";
    anchorInPageSpace = targetCenterInPageSpace;
  }
  if (shouldSnapEdges) {
    const snapDistance = shouldSnapNone ? calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util.options.elbowArrowEdgeSnapDistance
    ) : Infinity;
    const nearestPointOnEdgeInTargetSpace = targetGeometryInTargetSpace.nearestPoint(
      pointInTargetSpace,
      {
        includeLabels: false,
        includeInternal: false
      }
    );
    const nearestPointOnEdgeInPageSpace = targetTransform.applyToPoint(
      nearestPointOnEdgeInTargetSpace
    );
    const distance = Vec.Dist(nearestPointOnEdgeInPageSpace, pointInPageSpace);
    if (distance < snapDistance) {
      snap = "edge";
      anchorInPageSpace = nearestPointOnEdgeInPageSpace;
    }
  }
  if (shouldSnapCenterAxis) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util.options.elbowArrowAxisSnapDistance
    );
    const distanceFromXAxis = Vec.DistanceToLineSegment(
      handlesInPageSpace.left.far,
      handlesInPageSpace.right.far,
      pointInPageSpace
    );
    const distanceFromYAxis = Vec.DistanceToLineSegment(
      handlesInPageSpace.top.far,
      handlesInPageSpace.bottom.far,
      pointInPageSpace
    );
    const snapAxis = distanceFromXAxis < distanceFromYAxis && distanceFromXAxis < snapDistance ? "x" : distanceFromYAxis < snapDistance ? "y" : null;
    if (snapAxis) {
      const axis = ElbowArrowAxes[snapAxis];
      const loDist2 = Vec.Dist2(handlesInPageSpace[axis.loEdge].far, pointInPageSpace);
      const hiDist2 = Vec.Dist2(handlesInPageSpace[axis.hiEdge].far, pointInPageSpace);
      const side = loDist2 < hiDist2 ? axis.loEdge : axis.hiEdge;
      if (handlesInPageSpace[side].isEnabled) {
        snap = "edge-point";
        anchorInPageSpace = handlesInPageSpace[side].point;
      }
    }
  }
  if (shouldSnapEdgePoints) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util.options.elbowArrowPointSnapDistance
    );
    let closestSide = null;
    let closestDistance = Infinity;
    for (const [side, handle] of objectMapEntries(handlesInPageSpace)) {
      if (!handle.isEnabled)
        continue;
      const distance = Vec.Dist(handle.point, pointInPageSpace);
      if (distance < snapDistance && distance < closestDistance) {
        closestDistance = distance;
        closestSide = side;
      }
    }
    if (closestSide) {
      snap = "edge-point";
      anchorInPageSpace = handlesInPageSpace[closestSide].point;
    }
  }
  if (shouldSnapCenter) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      arrowKind === "elbow" ? util.options.elbowArrowCenterSnapDistance : util.options.arcArrowCenterSnapDistance
    );
    if (Vec.Dist(pointInTargetSpace, targetBoundsInTargetSpace.center) < snapDistance) {
      snap = "center";
      anchorInPageSpace = targetCenterInPageSpace;
    }
  }
  const snapPointInTargetSpace = editor.getPointInShapeSpace(target, anchorInPageSpace);
  const normalizedAnchor = {
    x: invLerp(
      targetBoundsInTargetSpace.minX,
      targetBoundsInTargetSpace.maxX,
      snapPointInTargetSpace.x
    ),
    y: invLerp(
      targetBoundsInTargetSpace.minY,
      targetBoundsInTargetSpace.maxY,
      snapPointInTargetSpace.y
    )
  };
  const result = {
    target,
    arrowKind,
    handlesInPageSpace,
    centerInPageSpace: targetCenterInPageSpace,
    anchorInPageSpace,
    isExact,
    isPrecise: precise2,
    snap,
    normalizedAnchor
  };
  getArrowTargetAtom(editor).set(result);
  return result;
}
var targetFilterFallback = { type: "arrow" };
function calculateSnapDistance(editor, targetBoundsInTargetSpace, idealSnapDistance) {
  return clamp(
    Math.min(targetBoundsInTargetSpace.width, targetBoundsInTargetSpace.height) * 0.15,
    4,
    idealSnapDistance
  ) / editor.getZoomLevel();
}

// node_modules/tldraw/dist-esm/lib/canvas/TldrawOverlays.mjs
function TldrawOverlays() {
  const editor = useEditor();
  const shouldShowArrowHints = useValue(
    "should show arrow hints",
    () => {
      if (editor.isInAny("arrow.idle", "arrow.pointing"))
        return true;
      if (editor.isIn("select.pointing_handle")) {
        const node = editor.getStateDescendant("select.pointing_handle");
        if (node.info.shape.type === "arrow" && (node.info.handle.id === "start" || node.info.handle.id === "end")) {
          return true;
        }
      }
      if (editor.isIn("select.dragging_handle")) {
        const node = editor.getStateDescendant("select.dragging_handle");
        if (node.info.shape.type === "arrow" && (node.info.handle.id === "start" || node.info.handle.id === "end")) {
          return true;
        }
      }
      return false;
    },
    [editor]
  );
  if (!shouldShowArrowHints)
    return null;
  return (0, import_jsx_runtime118.jsx)(TldrawArrowHints, {});
}
function TldrawArrowHints() {
  const editor = useEditor();
  const { ShapeIndicator } = useEditorComponents();
  const targetInfo = useValue("arrow target info", () => getArrowTargetState(editor), [editor]);
  if (!targetInfo)
    return null;
  const { handlesInPageSpace, snap, anchorInPageSpace, arrowKind, isExact, isPrecise } = targetInfo;
  const showEdgeHints = !isExact && arrowKind === "elbow";
  return (0, import_jsx_runtime118.jsxs)(import_jsx_runtime118.Fragment, { children: [
    ShapeIndicator && (0, import_jsx_runtime118.jsx)(ShapeIndicator, { shapeId: targetInfo.target.id }),
    showEdgeHints && (0, import_jsx_runtime118.jsxs)("svg", { className: "tl-overlays__item", children: [
      (0, import_jsx_runtime118.jsx)(
        "circle",
        {
          cx: anchorInPageSpace.x,
          cy: anchorInPageSpace.y,
          className: `tl-arrow-hint-snap tl-arrow-hint-snap__${isPrecise ? snap ?? "none" : "none"}`
        }
      ),
      Object.entries(handlesInPageSpace).map(([side, handle]) => {
        if (!handle.isEnabled)
          return null;
        return (0, import_jsx_runtime118.jsx)(
          "circle",
          {
            cx: handle.point.x,
            cy: handle.point.y,
            className: "tl-arrow-hint-handle"
          },
          side
        );
      })
    ] })
  ] });
}

// node_modules/tldraw/dist-esm/lib/canvas/TldrawScribble.mjs
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var import_classnames20 = __toESM(require_classnames(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/getStrokeOutlinePoints.mjs
var { PI: PI3 } = Math;
var FIXED_PI = PI3 + 1e-4;
function getStrokeOutlineTracks(strokePoints, options2 = {}) {
  const { size: size4 = 16, smoothing = 0.5 } = options2;
  if (strokePoints.length === 0 || size4 <= 0) {
    return { left: [], right: [] };
  }
  const firstStrokePoint = strokePoints[0];
  const lastStrokePoint = strokePoints[strokePoints.length - 1];
  const totalLength = lastStrokePoint.runningLength;
  const minDistance = Math.pow(size4 * smoothing, 2);
  const leftPts = [];
  const rightPts = [];
  let prevVector = strokePoints[0].vector;
  let pl = strokePoints[0].point;
  let pr = pl;
  let tl = pl;
  let tr2 = pr;
  let isPrevPointSharpCorner = false;
  let strokePoint;
  for (let i = 0; i < strokePoints.length; i++) {
    strokePoint = strokePoints[i];
    const { point, vector } = strokePoints[i];
    const prevDpr = strokePoint.vector.dpr(prevVector);
    const nextVector = (i < strokePoints.length - 1 ? strokePoints[i + 1] : strokePoints[i]).vector;
    const nextDpr = i < strokePoints.length - 1 ? nextVector.dpr(strokePoint.vector) : 1;
    const isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner;
    const isNextPointSharpCorner = nextDpr !== null && nextDpr < 0.2;
    if (isPointSharpCorner || isNextPointSharpCorner) {
      if (nextDpr > -0.62 && totalLength - strokePoint.runningLength > strokePoint.radius) {
        const offset22 = prevVector.clone().mul(strokePoint.radius);
        const cpr = prevVector.clone().cpr(nextVector);
        if (cpr < 0) {
          tl = Vec.Add(point, offset22);
          tr2 = Vec.Sub(point, offset22);
        } else {
          tl = Vec.Sub(point, offset22);
          tr2 = Vec.Add(point, offset22);
        }
        leftPts.push(tl);
        rightPts.push(tr2);
      } else {
        const offset22 = prevVector.clone().mul(strokePoint.radius).per();
        const start2 = Vec.Sub(strokePoint.input, offset22);
        for (let step = 1 / 13, t2 = 0; t2 < 1; t2 += step) {
          tl = Vec.RotWith(start2, strokePoint.input, FIXED_PI * t2);
          leftPts.push(tl);
          tr2 = Vec.RotWith(start2, strokePoint.input, FIXED_PI + FIXED_PI * -t2);
          rightPts.push(tr2);
        }
      }
      pl = tl;
      pr = tr2;
      if (isNextPointSharpCorner) {
        isPrevPointSharpCorner = true;
      }
      continue;
    }
    isPrevPointSharpCorner = false;
    if (strokePoint === firstStrokePoint || strokePoint === lastStrokePoint) {
      const offset22 = Vec.Per(vector).mul(strokePoint.radius);
      leftPts.push(Vec.Sub(point, offset22));
      rightPts.push(Vec.Add(point, offset22));
      continue;
    }
    const offset5 = Vec.Lrp(nextVector, vector, nextDpr).per().mul(strokePoint.radius);
    tl = Vec.Sub(point, offset5);
    if (i <= 1 || Vec.Dist2(pl, tl) > minDistance) {
      leftPts.push(tl);
      pl = tl;
    }
    tr2 = Vec.Add(point, offset5);
    if (i <= 1 || Vec.Dist2(pr, tr2) > minDistance) {
      rightPts.push(tr2);
      pr = tr2;
    }
    prevVector = vector;
    continue;
  }
  return {
    left: leftPts,
    right: rightPts
  };
}
function getStrokeOutlinePoints(strokePoints, options2 = {}) {
  const { size: size4 = 16, start: start2 = {}, end: end2 = {}, last: isComplete = false } = options2;
  const { cap: capStart = true } = start2;
  const { cap: capEnd = true } = end2;
  if (strokePoints.length === 0 || size4 <= 0) {
    return [];
  }
  const firstStrokePoint = strokePoints[0];
  const lastStrokePoint = strokePoints[strokePoints.length - 1];
  const totalLength = lastStrokePoint.runningLength;
  const taperStart = start2.taper === false ? 0 : start2.taper === true ? Math.max(size4, totalLength) : start2.taper;
  const taperEnd = end2.taper === false ? 0 : end2.taper === true ? Math.max(size4, totalLength) : end2.taper;
  const { left: leftPts, right: rightPts } = getStrokeOutlineTracks(strokePoints, options2);
  const firstPoint = firstStrokePoint.point;
  const lastPoint = strokePoints.length > 1 ? strokePoints[strokePoints.length - 1].point : Vec.AddXY(firstStrokePoint.point, 1, 1);
  if (strokePoints.length === 1) {
    if (!(taperStart || taperEnd) || isComplete) {
      const start22 = Vec.Add(
        firstPoint,
        Vec.Sub(firstPoint, lastPoint).uni().per().mul(-firstStrokePoint.radius)
      );
      const dotPts = [];
      for (let step = 1 / 13, t2 = step; t2 <= 1; t2 += step) {
        dotPts.push(Vec.RotWith(start22, firstPoint, FIXED_PI * 2 * t2));
      }
      return dotPts;
    }
  }
  const startCap = [];
  if (taperStart || taperEnd && strokePoints.length === 1) {
  } else if (capStart) {
    for (let step = 1 / 8, t2 = step; t2 <= 1; t2 += step) {
      const pt = Vec.RotWith(rightPts[0], firstPoint, FIXED_PI * t2);
      startCap.push(pt);
    }
  } else {
    const cornersVector = Vec.Sub(leftPts[0], rightPts[0]);
    const offsetA = Vec.Mul(cornersVector, 0.5);
    const offsetB = Vec.Mul(cornersVector, 0.51);
    startCap.push(
      Vec.Sub(firstPoint, offsetA),
      Vec.Sub(firstPoint, offsetB),
      Vec.Add(firstPoint, offsetB),
      Vec.Add(firstPoint, offsetA)
    );
  }
  const endCap = [];
  const direction = lastStrokePoint.vector.clone().per().neg();
  if (taperEnd || taperStart && strokePoints.length === 1) {
    endCap.push(lastPoint);
  } else if (capEnd) {
    const start22 = Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius));
    for (let step = 1 / 29, t2 = step; t2 < 1; t2 += step) {
      endCap.push(Vec.RotWith(start22, lastPoint, FIXED_PI * 3 * t2));
    }
  } else {
    endCap.push(
      Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius)),
      Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),
      Vec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),
      Vec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius))
    );
  }
  return leftPts.concat(endCap, rightPts.reverse(), startCap);
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/getStrokePoints.mjs
var MIN_START_PRESSURE = 0.025;
var MIN_END_PRESSURE = 0.01;
function getStrokePoints(rawInputPoints, options2 = {}) {
  var _a5;
  const { streamline = 0.5, size: size4 = 16, simulatePressure = false } = options2;
  if (rawInputPoints.length === 0)
    return [];
  const t2 = 0.15 + (1 - streamline) * 0.85;
  let pts = rawInputPoints.map(Vec.From);
  let pointsRemovedFromNearEnd = 0;
  if (!simulatePressure) {
    let pt2 = pts[0];
    while (pt2) {
      if (pt2.z >= MIN_START_PRESSURE)
        break;
      pts.shift();
      pt2 = pts[0];
    }
  }
  if (!simulatePressure) {
    let pt2 = pts[pts.length - 1];
    while (pt2) {
      if (pt2.z >= MIN_END_PRESSURE)
        break;
      pts.pop();
      pt2 = pts[pts.length - 1];
    }
  }
  if (pts.length === 0)
    return [
      {
        point: Vec.From(rawInputPoints[0]),
        input: Vec.From(rawInputPoints[0]),
        pressure: simulatePressure ? 0.5 : 0.15,
        vector: new Vec(1, 1),
        distance: 0,
        runningLength: 0,
        radius: 1
      }
    ];
  let pt = pts[1];
  while (pt) {
    if (Vec.Dist2(pt, pts[0]) > (size4 / 3) ** 2)
      break;
    pts[0].z = Math.max(pts[0].z, pt.z);
    pts.splice(1, 1);
    pt = pts[1];
  }
  const last3 = pts.pop();
  pt = pts[pts.length - 1];
  while (pt) {
    if (Vec.Dist2(pt, last3) > (size4 / 3) ** 2)
      break;
    pts.pop();
    pt = pts[pts.length - 1];
    pointsRemovedFromNearEnd++;
  }
  pts.push(last3);
  const isComplete = options2.last || !options2.simulatePressure || pts.length > 1 && Vec.Dist2(pts[pts.length - 1], pts[pts.length - 2]) < size4 ** 2 || pointsRemovedFromNearEnd > 0;
  if (pts.length === 2 && options2.simulatePressure) {
    const last22 = pts[1];
    pts = pts.slice(0, -1);
    for (let i = 1; i < 5; i++) {
      const next = Vec.Lrp(pts[0], last22, i / 4);
      next.z = (pts[0].z + (last22.z - pts[0].z)) * i / 4;
      pts.push(next);
    }
  }
  const strokePoints = [
    {
      point: pts[0],
      input: pts[0],
      pressure: simulatePressure ? 0.5 : pts[0].z,
      vector: new Vec(1, 1),
      distance: 0,
      runningLength: 0,
      radius: 1
    }
  ];
  let totalLength = 0;
  let prev = strokePoints[0];
  let point, distance;
  if (isComplete && streamline > 0) {
    pts.push(pts[pts.length - 1].clone());
  }
  for (let i = 1, n = pts.length; i < n; i++) {
    point = !t2 || options2.last && i === n - 1 ? pts[i].clone() : pts[i].clone().lrp(prev.point, 1 - t2);
    if (prev.point.equals(point))
      continue;
    distance = Vec.Dist(point, prev.point);
    totalLength += distance;
    if (i < 4 && totalLength < size4) {
      continue;
    }
    prev = {
      input: pts[i],
      // The adjusted point
      point,
      // The input pressure (or .5 if not specified)
      pressure: simulatePressure ? 0.5 : pts[i].z,
      // The vector from the current point to the previous point
      vector: Vec.Sub(prev.point, point).uni(),
      // The distance between the current point and the previous point
      distance,
      // The total distance so far
      runningLength: totalLength,
      // The stroke point's radius
      radius: 1
    };
    strokePoints.push(prev);
  }
  if ((_a5 = strokePoints[1]) == null ? void 0 : _a5.vector) {
    strokePoints[0].vector = strokePoints[1].vector.clone();
  }
  if (totalLength < 1) {
    const maxPressureAmongPoints = Math.max(0.5, ...strokePoints.map((s) => s.pressure));
    strokePoints.forEach((s) => s.pressure = maxPressureAmongPoints);
  }
  return strokePoints;
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/setStrokePointRadii.mjs
var { min: min2 } = Math;
var RATE_OF_PRESSURE_CHANGE = 0.275;
function setStrokePointRadii(strokePoints, options2) {
  const {
    size: size4 = 16,
    thinning = 0.5,
    simulatePressure = true,
    easing = (t2) => t2,
    start: start2 = {},
    end: end2 = {}
  } = options2;
  const { easing: taperStartEase = EASINGS.easeOutQuad } = start2;
  const { easing: taperEndEase = EASINGS.easeOutCubic } = end2;
  const totalLength = strokePoints[strokePoints.length - 1].runningLength;
  let firstRadius;
  let prevPressure = strokePoints[0].pressure;
  let strokePoint;
  if (!simulatePressure && totalLength < size4) {
    const max3 = strokePoints.reduce((max22, curr) => Math.max(max22, curr.pressure), 0.5);
    strokePoints.forEach((sp) => {
      sp.pressure = max3;
      sp.radius = size4 * easing(0.5 - thinning * (0.5 - sp.pressure));
    });
    return strokePoints;
  } else {
    let p;
    for (let i = 0, n = strokePoints.length; i < n; i++) {
      strokePoint = strokePoints[i];
      if (strokePoint.runningLength > size4 * 5)
        break;
      const sp = min2(1, strokePoint.distance / size4);
      if (simulatePressure) {
        const rp = min2(1, 1 - sp);
        p = min2(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
      } else {
        p = min2(1, prevPressure + (strokePoint.pressure - prevPressure) * 0.5);
      }
      prevPressure = prevPressure + (p - prevPressure) * 0.5;
    }
    for (let i = 0; i < strokePoints.length; i++) {
      strokePoint = strokePoints[i];
      if (thinning) {
        let { pressure } = strokePoint;
        const sp = min2(1, strokePoint.distance / size4);
        if (simulatePressure) {
          const rp = min2(1, 1 - sp);
          pressure = min2(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
        } else {
          pressure = min2(
            1,
            prevPressure + (pressure - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE)
          );
        }
        strokePoint.radius = size4 * easing(0.5 - thinning * (0.5 - pressure));
        prevPressure = pressure;
      } else {
        strokePoint.radius = size4 / 2;
      }
      if (firstRadius === void 0) {
        firstRadius = strokePoint.radius;
      }
    }
  }
  const taperStart = start2.taper === false ? 0 : start2.taper === true ? Math.max(size4, totalLength) : start2.taper;
  const taperEnd = end2.taper === false ? 0 : end2.taper === true ? Math.max(size4, totalLength) : end2.taper;
  if (taperStart || taperEnd) {
    for (let i = 0; i < strokePoints.length; i++) {
      strokePoint = strokePoints[i];
      const { runningLength } = strokePoint;
      const ts2 = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1;
      const te = totalLength - runningLength < taperEnd ? taperEndEase((totalLength - runningLength) / taperEnd) : 1;
      strokePoint.radius = Math.max(0.01, strokePoint.radius * Math.min(ts2, te));
    }
  }
  return strokePoints;
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/getStroke.mjs
function getStroke(points, options2 = {}) {
  return getStrokeOutlinePoints(
    setStrokePointRadii(getStrokePoints(points, options2), options2),
    options2
  );
}

// node_modules/tldraw/dist-esm/lib/canvas/TldrawScribble.mjs
function TldrawScribble({ scribble, zoom, color, opacity, className }) {
  if (!scribble.points.length)
    return null;
  const stroke = getStroke(scribble.points, {
    size: scribble.size / zoom,
    start: { taper: scribble.taper, easing: EASINGS.linear },
    last: scribble.state === "stopping",
    simulatePressure: false,
    streamline: 0.32
  });
  let d;
  if (stroke.length < 4) {
    const r = scribble.size / zoom / 2;
    const { x, y } = scribble.points[scribble.points.length - 1];
    d = `M ${x - r},${y} a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 ${-r * 2},0`;
  } else {
    d = getSvgPathFromPoints(stroke);
  }
  return (0, import_jsx_runtime119.jsx)("svg", { className: className ? (0, import_classnames20.default)("tl-overlays__item", className) : className, children: (0, import_jsx_runtime119.jsx)(
    "path",
    {
      className: "tl-scribble",
      d,
      fill: color ?? `var(--color-${scribble.color})`,
      opacity: opacity ?? scribble.opacity
    }
  ) });
}

// node_modules/tldraw/dist-esm/lib/canvas/TldrawSelectionForeground.mjs
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var import_classnames22 = __toESM(require_classnames(), 1);
var import_react82 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/canvas/TldrawCropHandles.mjs
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var import_classnames21 = __toESM(require_classnames(), 1);
function TldrawCropHandles({
  size: size4,
  width,
  height,
  hideAlternateHandles
}) {
  const cropStrokeWidth = toDomPrecision(size4 / 3);
  const offset5 = cropStrokeWidth / 2;
  const msg2 = useTranslation();
  return (0, import_jsx_runtime120.jsxs)("svg", { className: "tl-overlays__item", children: [
    (0, import_jsx_runtime120.jsx)(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${toDomPrecision(0 - offset5)},${toDomPrecision(size4)} 
						${toDomPrecision(0 - offset5)},${toDomPrecision(0 - offset5)} 
						${toDomPrecision(size4)},${toDomPrecision(0 - offset5)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top_left",
        role: "button",
        "aria-label": msg2("handle.crop.top-left")
      }
    ),
    (0, import_jsx_runtime120.jsx)(
      "line",
      {
        className: (0, import_classnames21.default)("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width / 2 - size4),
        y1: toDomPrecision(0 - offset5),
        x2: toDomPrecision(width / 2 + size4),
        y2: toDomPrecision(0 - offset5),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top",
        role: "button",
        "aria-label": msg2("handle.crop.top")
      }
    ),
    (0, import_jsx_runtime120.jsx)(
      "polyline",
      {
        className: (0, import_classnames21.default)("tl-corner-crop-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        points: `
						${toDomPrecision(width - size4)},${toDomPrecision(0 - offset5)} 
						${toDomPrecision(width + offset5)},${toDomPrecision(0 - offset5)} 
						${toDomPrecision(width + offset5)},${toDomPrecision(size4)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top_right",
        role: "button",
        "aria-label": msg2("handle.crop.top-right")
      }
    ),
    (0, import_jsx_runtime120.jsx)(
      "line",
      {
        className: (0, import_classnames21.default)("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width + offset5),
        y1: toDomPrecision(height / 2 - size4),
        x2: toDomPrecision(width + offset5),
        y2: toDomPrecision(height / 2 + size4),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.right",
        role: "button",
        "aria-label": msg2("handle.crop.right")
      }
    ),
    (0, import_jsx_runtime120.jsx)(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${toDomPrecision(width + offset5)},${toDomPrecision(height - size4)} 
						${toDomPrecision(width + offset5)},${toDomPrecision(height + offset5)}
						${toDomPrecision(width - size4)},${toDomPrecision(height + offset5)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom_right",
        role: "button",
        "aria-label": msg2("handle.crop.bottom-right")
      }
    ),
    (0, import_jsx_runtime120.jsx)(
      "line",
      {
        className: (0, import_classnames21.default)("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width / 2 - size4),
        y1: toDomPrecision(height + offset5),
        x2: toDomPrecision(width / 2 + size4),
        y2: toDomPrecision(height + offset5),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom",
        role: "button",
        "aria-label": msg2("handle.crop.bottom")
      }
    ),
    (0, import_jsx_runtime120.jsx)(
      "polyline",
      {
        className: (0, import_classnames21.default)("tl-corner-crop-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        points: `
						${toDomPrecision(0 + size4)},${toDomPrecision(height + offset5)} 
						${toDomPrecision(0 - offset5)},${toDomPrecision(height + offset5)}
						${toDomPrecision(0 - offset5)},${toDomPrecision(height - size4)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom_left",
        role: "button",
        "aria-label": msg2("handle.crop.bottom-left")
      }
    ),
    (0, import_jsx_runtime120.jsx)(
      "line",
      {
        className: (0, import_classnames21.default)("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(0 - offset5),
        y1: toDomPrecision(height / 2 - size4),
        x2: toDomPrecision(0 - offset5),
        y2: toDomPrecision(height / 2 + size4),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.left",
        role: "button",
        "aria-label": msg2("handle.crop.left")
      }
    )
  ] });
}

// node_modules/tldraw/dist-esm/lib/canvas/TldrawSelectionForeground.mjs
var TldrawSelectionForeground = track(function TldrawSelectionForeground2({
  bounds,
  rotation
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const rSvg = (0, import_react82.useRef)(null);
  const isReadonlyMode = useReadonly();
  const topEvents = useSelectionEvents("top");
  const rightEvents = useSelectionEvents("right");
  const bottomEvents = useSelectionEvents("bottom");
  const leftEvents = useSelectionEvents("left");
  const topLeftEvents = useSelectionEvents("top_left");
  const topRightEvents = useSelectionEvents("top_right");
  const bottomRightEvents = useSelectionEvents("bottom_right");
  const bottomLeftEvents = useSelectionEvents("bottom_left");
  const isDefaultCursor = editor.getInstanceState().cursor.type === "default";
  const isCoarsePointer = editor.getInstanceState().isCoarsePointer;
  const onlyShape = editor.getOnlySelectedShape();
  const isLockedShape = onlyShape && editor.isShapeOrAncestorLocked(onlyShape);
  const expandOutlineBy = onlyShape ? editor.getShapeUtil(onlyShape).expandSelectionOutlinePx(onlyShape) : 0;
  const expandedBounds = expandOutlineBy instanceof Box ? bounds.clone().expand(expandOutlineBy).zeroFix() : bounds.clone().expandBy(expandOutlineBy).zeroFix();
  useTransform(rSvg, bounds == null ? void 0 : bounds.x, bounds == null ? void 0 : bounds.y, 1, editor.getSelectionRotation(), {
    x: expandedBounds.x - bounds.x,
    y: expandedBounds.y - bounds.y
  });
  if (onlyShape && editor.isShapeHidden(onlyShape))
    return null;
  const zoom = editor.getZoomLevel();
  const isChangingStyle = editor.getInstanceState().isChangingStyle;
  const width = expandedBounds.width;
  const height = expandedBounds.height;
  const size4 = 8 / zoom;
  const isTinyX = width < size4 * 2;
  const isTinyY = height < size4 * 2;
  const isSmallX = width < size4 * 4;
  const isSmallY = height < size4 * 4;
  const isSmallCropX = width < size4 * 5;
  const isSmallCropY = height < size4 * 5;
  const mobileHandleMultiplier = isCoarsePointer ? 1.75 : 1;
  const targetSize = 6 / zoom * mobileHandleMultiplier;
  const targetSizeX = (isSmallX ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75);
  const targetSizeY = (isSmallY ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75);
  const showSelectionBounds = (onlyShape ? !editor.getShapeUtil(onlyShape).hideSelectionBoundsFg(onlyShape) : true) && !isChangingStyle;
  let shouldDisplayBox = showSelectionBounds && editor.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_canvas",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle",
    "select.pointing_resize_handle"
  ) || showSelectionBounds && editor.isIn("select.resizing") && onlyShape && editor.isShapeOfType(onlyShape, "text");
  if (onlyShape && shouldDisplayBox) {
    if (tlenv.isFirefox && editor.isShapeOfType(onlyShape, "embed")) {
      shouldDisplayBox = false;
    }
  }
  const showCropHandles = editor.isInAny(
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle"
  ) && !isChangingStyle && !isReadonlyMode;
  const shouldDisplayControls = editor.isInAny(
    "select.idle",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle"
  ) && !isChangingStyle && !isReadonlyMode;
  const showCornerRotateHandles = !isCoarsePointer && !(isTinyX || isTinyY) && (shouldDisplayControls || showCropHandles) && (onlyShape ? !editor.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true) && !isLockedShape;
  const showMobileRotateHandle = isCoarsePointer && (!isSmallX || !isSmallY) && (shouldDisplayControls || showCropHandles) && (onlyShape ? !editor.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true) && !isLockedShape;
  const showResizeHandles = shouldDisplayControls && (onlyShape ? editor.getShapeUtil(onlyShape).canResize(onlyShape) && !editor.getShapeUtil(onlyShape).hideResizeHandles(onlyShape) : true) && !showCropHandles && !isLockedShape;
  const hideAlternateCornerHandles = isTinyX || isTinyY;
  const showOnlyOneHandle = isTinyX && isTinyY;
  const hideAlternateCropHandles = isSmallCropX || isSmallCropY;
  const showHandles = showResizeHandles || showCropHandles;
  const hideRotateCornerHandles = !showCornerRotateHandles;
  const hideMobileRotateHandle = !shouldDisplayControls || !showMobileRotateHandle;
  const hideTopLeftCorner = !shouldDisplayControls || !showHandles;
  const hideTopRightCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles;
  const hideBottomLeftCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles;
  const hideBottomRightCorner = !shouldDisplayControls || !showHandles || showOnlyOneHandle && !showCropHandles;
  let hideVerticalEdgeTargets = true;
  let hideHorizontalEdgeTargets = true;
  if (showCropHandles) {
    hideVerticalEdgeTargets = hideAlternateCropHandles;
    hideHorizontalEdgeTargets = hideAlternateCropHandles;
  } else if (showResizeHandles) {
    hideVerticalEdgeTargets = hideAlternateCornerHandles || showOnlyOneHandle || isCoarsePointer;
    const isMobileAndTextShape = isCoarsePointer && onlyShape && onlyShape.type === "text";
    hideHorizontalEdgeTargets = hideVerticalEdgeTargets && !isMobileAndTextShape;
  }
  const textHandleHeight = Math.min(24 / zoom, height - targetSizeY * 3);
  const showTextResizeHandles = shouldDisplayControls && isCoarsePointer && onlyShape && editor.isShapeOfType(onlyShape, "text") && textHandleHeight * zoom >= 4;
  return (0, import_jsx_runtime121.jsx)("svg", { className: "tl-overlays__item tl-selection__fg", "data-testid": "selection-foreground", children: (0, import_jsx_runtime121.jsxs)("g", { ref: rSvg, children: [
    shouldDisplayBox && (0, import_jsx_runtime121.jsx)(
      "rect",
      {
        className: "tl-selection__fg__outline",
        width: toDomPrecision(width),
        height: toDomPrecision(height)
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      RotateCornerHandle,
      {
        "data-testid": "selection.rotate.top-left",
        cx: 0,
        cy: 0,
        targetSize,
        corner: "top_left_rotate",
        cursor: isDefaultCursor ? getCursor("nwse-rotate", rotation) : void 0,
        isHidden: hideRotateCornerHandles
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      RotateCornerHandle,
      {
        "data-testid": "selection.rotate.top-right",
        cx: width + targetSize * 3,
        cy: 0,
        targetSize,
        corner: "top_right_rotate",
        cursor: isDefaultCursor ? getCursor("nesw-rotate", rotation) : void 0,
        isHidden: hideRotateCornerHandles
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      RotateCornerHandle,
      {
        "data-testid": "selection.rotate.bottom-left",
        cx: 0,
        cy: height + targetSize * 3,
        targetSize,
        corner: "bottom_left_rotate",
        cursor: isDefaultCursor ? getCursor("swne-rotate", rotation) : void 0,
        isHidden: hideRotateCornerHandles
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      RotateCornerHandle,
      {
        "data-testid": "selection.rotate.bottom-right",
        cx: width + targetSize * 3,
        cy: height + targetSize * 3,
        targetSize,
        corner: "bottom_right_rotate",
        cursor: isDefaultCursor ? getCursor("senw-rotate", rotation) : void 0,
        isHidden: hideRotateCornerHandles
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      MobileRotateHandle,
      {
        "data-testid": "selection.rotate.mobile",
        cx: isSmallX ? -targetSize * 1.5 : width / 2,
        cy: isSmallX ? height / 2 : -targetSize * 1.5,
        size: size4,
        isHidden: hideMobileRotateHandle
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      ResizeHandle,
      {
        hide: hideVerticalEdgeTargets,
        dataTestId: "selection.resize.top",
        ariaLabel: msg2("handle.resize-top"),
        x: 0,
        y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY)),
        width: toDomPrecision(width),
        height: toDomPrecision(Math.max(1, targetSizeY * 2)),
        cursor: isDefaultCursor ? getCursor("ns-resize", rotation) : void 0,
        events: topEvents
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      ResizeHandle,
      {
        hide: hideHorizontalEdgeTargets,
        dataTestId: "selection.resize.right",
        ariaLabel: msg2("handle.resize-right"),
        x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX)),
        y: 0,
        height: toDomPrecision(height),
        width: toDomPrecision(Math.max(1, targetSizeX * 2)),
        cursor: isDefaultCursor ? getCursor("ew-resize", rotation) : void 0,
        events: rightEvents
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      ResizeHandle,
      {
        hide: hideVerticalEdgeTargets,
        dataTestId: "selection.resize.bottom",
        ariaLabel: msg2("handle.resize-bottom"),
        x: 0,
        y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY)),
        width: toDomPrecision(width),
        height: toDomPrecision(Math.max(1, targetSizeY * 2)),
        cursor: isDefaultCursor ? getCursor("ns-resize", rotation) : void 0,
        events: bottomEvents
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      ResizeHandle,
      {
        hide: hideHorizontalEdgeTargets,
        dataTestId: "selection.resize.left",
        ariaLabel: msg2("handle.resize-left"),
        x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX)),
        y: 0,
        height: toDomPrecision(height),
        width: toDomPrecision(Math.max(1, targetSizeX * 2)),
        cursor: isDefaultCursor ? getCursor("ew-resize", rotation) : void 0,
        events: leftEvents
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      ResizeHandle,
      {
        hide: hideTopLeftCorner,
        dataTestId: "selection.target.top-left",
        ariaLabel: msg2("handle.resize-top-left"),
        x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX * 1.5)),
        y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
        width: toDomPrecision(targetSizeX * 3),
        height: toDomPrecision(targetSizeY * 3),
        cursor: isDefaultCursor ? getCursor("nwse-resize", rotation) : void 0,
        events: topLeftEvents
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      ResizeHandle,
      {
        hide: hideTopRightCorner,
        dataTestId: "selection.target.top-right",
        ariaLabel: msg2("handle.resize-top-right"),
        x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX * 1.5)),
        y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
        width: toDomPrecision(targetSizeX * 3),
        height: toDomPrecision(targetSizeY * 3),
        cursor: isDefaultCursor ? getCursor("nesw-resize", rotation) : void 0,
        events: topRightEvents
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      ResizeHandle,
      {
        hide: hideBottomRightCorner,
        dataTestId: "selection.target.bottom-right",
        ariaLabel: msg2("handle.resize-bottom-right"),
        x: toDomPrecision(width - (isSmallX ? targetSizeX : targetSizeX * 1.5)),
        y: toDomPrecision(height - (isSmallY ? targetSizeY : targetSizeY * 1.5)),
        width: toDomPrecision(targetSizeX * 3),
        height: toDomPrecision(targetSizeY * 3),
        cursor: isDefaultCursor ? getCursor("nwse-resize", rotation) : void 0,
        events: bottomRightEvents
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      ResizeHandle,
      {
        hide: hideBottomLeftCorner,
        dataTestId: "selection.target.bottom-left",
        ariaLabel: msg2("handle.resize-bottom-left"),
        x: toDomPrecision(0 - (isSmallX ? targetSizeX * 3 : targetSizeX * 1.5)),
        y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY * 1.5)),
        width: toDomPrecision(targetSizeX * 3),
        height: toDomPrecision(targetSizeY * 3),
        cursor: isDefaultCursor ? getCursor("nesw-resize", rotation) : void 0,
        events: bottomLeftEvents
      }
    ),
    showResizeHandles && (0, import_jsx_runtime121.jsxs)(import_jsx_runtime121.Fragment, { children: [
      (0, import_jsx_runtime121.jsx)(
        "rect",
        {
          "data-testid": "selection.resize.top-left",
          className: (0, import_classnames22.default)("tl-corner-handle", {
            "tl-hidden": hideTopLeftCorner
          }),
          x: toDomPrecision(0 - size4 / 2),
          y: toDomPrecision(0 - size4 / 2),
          width: toDomPrecision(size4),
          height: toDomPrecision(size4)
        }
      ),
      (0, import_jsx_runtime121.jsx)(
        "rect",
        {
          "data-testid": "selection.resize.top-right",
          className: (0, import_classnames22.default)("tl-corner-handle", {
            "tl-hidden": hideTopRightCorner
          }),
          x: toDomPrecision(width - size4 / 2),
          y: toDomPrecision(0 - size4 / 2),
          width: toDomPrecision(size4),
          height: toDomPrecision(size4)
        }
      ),
      (0, import_jsx_runtime121.jsx)(
        "rect",
        {
          "data-testid": "selection.resize.bottom-right",
          className: (0, import_classnames22.default)("tl-corner-handle", {
            "tl-hidden": hideBottomRightCorner
          }),
          x: toDomPrecision(width - size4 / 2),
          y: toDomPrecision(height - size4 / 2),
          width: toDomPrecision(size4),
          height: toDomPrecision(size4)
        }
      ),
      (0, import_jsx_runtime121.jsx)(
        "rect",
        {
          "data-testid": "selection.resize.bottom-left",
          className: (0, import_classnames22.default)("tl-corner-handle", {
            "tl-hidden": hideBottomLeftCorner
          }),
          x: toDomPrecision(0 - size4 / 2),
          y: toDomPrecision(height - size4 / 2),
          width: toDomPrecision(size4),
          height: toDomPrecision(size4)
        }
      )
    ] }),
    showTextResizeHandles && (0, import_jsx_runtime121.jsxs)(import_jsx_runtime121.Fragment, { children: [
      (0, import_jsx_runtime121.jsx)(
        "rect",
        {
          "data-testid": "selection.text-resize.left.handle",
          className: "tl-text-handle",
          x: toDomPrecision(0 - size4 / 4),
          y: toDomPrecision(height / 2 - textHandleHeight / 2),
          rx: size4 / 4,
          width: toDomPrecision(size4 / 2),
          height: toDomPrecision(textHandleHeight)
        }
      ),
      (0, import_jsx_runtime121.jsx)(
        "rect",
        {
          "data-testid": "selection.text-resize.right.handle",
          className: "tl-text-handle",
          rx: size4 / 4,
          x: toDomPrecision(width - size4 / 4),
          y: toDomPrecision(height / 2 - textHandleHeight / 2),
          width: toDomPrecision(size4 / 2),
          height: toDomPrecision(textHandleHeight)
        }
      )
    ] }),
    showCropHandles && (0, import_jsx_runtime121.jsx)(
      TldrawCropHandles,
      {
        ...{
          size: size4,
          width,
          height,
          hideAlternateHandles: hideAlternateCropHandles
        }
      }
    )
  ] }) });
});
var ResizeHandle = function ResizeHandle2({
  hide: hide5,
  dataTestId,
  ariaLabel,
  x,
  y,
  width,
  height,
  cursor,
  events
}) {
  return (0, import_jsx_runtime121.jsx)(
    "rect",
    {
      className: (0, import_classnames22.default)("tl-resize-handle", "tl-transparent", {
        "tl-hidden": hide5
      }),
      "data-testid": dataTestId,
      role: "button",
      "aria-label": ariaLabel,
      pointerEvents: "all",
      x,
      y,
      width,
      height,
      cursor,
      ...events
    }
  );
};
var RotateCornerHandle = function RotateCornerHandle2({
  cx,
  cy,
  targetSize,
  corner,
  cursor,
  isHidden: isHidden2,
  "data-testid": testId
}) {
  const events = useSelectionEvents(corner);
  const msg2 = useTranslation();
  const label = msg2(`handle.rotate.${corner}`);
  return (0, import_jsx_runtime121.jsx)(
    "rect",
    {
      className: (0, import_classnames22.default)("tl-transparent", "tl-rotate-corner", { "tl-hidden": isHidden2 }),
      "data-testid": testId,
      role: "button",
      "aria-label": label,
      pointerEvents: "all",
      x: toDomPrecision(cx - targetSize * 3),
      y: toDomPrecision(cy - targetSize * 3),
      width: toDomPrecision(Math.max(1, targetSize * 3)),
      height: toDomPrecision(Math.max(1, targetSize * 3)),
      cursor,
      ...events
    }
  );
};
var SQUARE_ROOT_PI = Math.sqrt(Math.PI);
var MobileRotateHandle = function RotateHandle({
  cx,
  cy,
  size: size4,
  isHidden: isHidden2,
  "data-testid": testId
}) {
  const events = useSelectionEvents("mobile_rotate");
  const editor = useEditor();
  const zoom = useValue("zoom level", () => editor.getZoomLevel(), [editor]);
  const bgRadius = Math.max(14 * (1 / zoom), 20 / Math.max(1, zoom));
  const msg2 = useTranslation();
  return (0, import_jsx_runtime121.jsxs)("g", { role: "button", "aria-label": msg2("handle.rotate.mobile_rotate"), children: [
    (0, import_jsx_runtime121.jsx)(
      "circle",
      {
        "data-testid": testId,
        pointerEvents: "all",
        className: (0, import_classnames22.default)("tl-transparent", "tl-mobile-rotate__bg", { "tl-hidden": isHidden2 }),
        cx,
        cy,
        r: bgRadius,
        ...events
      }
    ),
    (0, import_jsx_runtime121.jsx)(
      "circle",
      {
        className: (0, import_classnames22.default)("tl-mobile-rotate__fg", { "tl-hidden": isHidden2 }),
        cx,
        cy,
        r: size4 / SQUARE_ROOT_PI
      }
    )
  ] });
};

// node_modules/tldraw/dist-esm/lib/canvas/TldrawShapeIndicators.mjs
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
function TldrawShapeIndicators() {
  const editor = useEditor();
  const isInSelectState = useValue(
    "is in a valid select state",
    () => {
      return editor.isInAny(
        "select.idle",
        "select.brushing",
        "select.scribble_brushing",
        "select.editing_shape",
        "select.pointing_shape",
        "select.pointing_selection",
        "select.pointing_handle"
      );
    },
    [editor]
  );
  return (0, import_jsx_runtime122.jsx)(DefaultShapeIndicators, { hideAll: !isInSelectState });
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/straight-arrow.mjs
function getStraightArrowInfo(editor, shape, bindings) {
  const { arrowheadStart, arrowheadEnd } = shape.props;
  const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings);
  const a = terminalsInArrowSpace.start.clone();
  const b = terminalsInArrowSpace.end.clone();
  const c = Vec.Med(a, b);
  if (Vec.Equals(a, b)) {
    return {
      bindings,
      type: "straight",
      start: {
        handle: a,
        point: a,
        arrowhead: shape.props.arrowheadStart
      },
      end: {
        handle: b,
        point: b,
        arrowhead: shape.props.arrowheadEnd
      },
      middle: c,
      isValid: false,
      length: 0
    };
  }
  const uAB = Vec.Sub(b, a).uni();
  const startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "start");
  const endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "end");
  const arrowPageTransform = editor.getShapePageTransform(shape);
  updateArrowheadPointWithBoundShape(
    b,
    // <-- will be mutated
    terminalsInArrowSpace.start,
    arrowPageTransform,
    endShapeInfo
  );
  updateArrowheadPointWithBoundShape(
    a,
    // <-- will be mutated
    terminalsInArrowSpace.end,
    arrowPageTransform,
    startShapeInfo
  );
  let offsetA = 0;
  let offsetB = 0;
  let strokeOffsetA = 0;
  let strokeOffsetB = 0;
  let minLength = MIN_ARROW_LENGTH * shape.props.scale;
  const isSelfIntersection = startShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape;
  const relationship = startShapeInfo && endShapeInfo ? getBoundShapeRelationships(editor, startShapeInfo.shape.id, endShapeInfo.shape.id) : "safe";
  if (relationship === "safe" && startShapeInfo && endShapeInfo && !isSelfIntersection && !startShapeInfo.isExact && !endShapeInfo.isExact) {
    if (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {
      if (startShapeInfo.isClosed) {
        a.setTo(b.clone().add(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)));
      }
    } else if (!endShapeInfo.didIntersect) {
      if (endShapeInfo.isClosed) {
        b.setTo(a.clone().sub(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)));
      }
    }
  }
  const distance = Vec.Sub(b, a);
  const u = Vec.Len(distance) ? distance.uni() : Vec.From(distance);
  const didFlip = !Vec.Equals(u, uAB);
  if (!isSelfIntersection) {
    if (relationship !== "start-contains-end" && startShapeInfo && arrowheadStart !== "none" && !startShapeInfo.isExact) {
      strokeOffsetA = STROKE_SIZES[shape.props.size] / 2 + ("size" in startShapeInfo.shape.props ? STROKE_SIZES[startShapeInfo.shape.props.size] / 2 : 0);
      offsetA = (BOUND_ARROW_OFFSET + strokeOffsetA) * shape.props.scale;
      minLength += strokeOffsetA * shape.props.scale;
    }
    if (relationship !== "end-contains-start" && endShapeInfo && arrowheadEnd !== "none" && !endShapeInfo.isExact) {
      strokeOffsetB = STROKE_SIZES[shape.props.size] / 2 + ("size" in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0);
      offsetB = (BOUND_ARROW_OFFSET + strokeOffsetB) * shape.props.scale;
      minLength += strokeOffsetB * shape.props.scale;
    }
  }
  const tA = a.clone().add(u.clone().mul(offsetA * (didFlip ? -1 : 1)));
  const tB = b.clone().sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)));
  if (Vec.DistMin(tA, tB, minLength)) {
    if (offsetA !== 0 && offsetB !== 0) {
      offsetA *= -1.5;
      offsetB *= -1.5;
    } else if (offsetA !== 0) {
      offsetA *= -1;
    } else if (offsetB !== 0) {
      offsetB *= -1;
    } else {
    }
  }
  a.add(u.clone().mul(offsetA * (didFlip ? -1 : 1)));
  b.sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)));
  if (didFlip) {
    if (startShapeInfo && endShapeInfo) {
      b.setTo(Vec.Add(a, u.clone().mul(-MIN_ARROW_LENGTH * shape.props.scale)));
    }
    c.setTo(Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end));
  } else {
    c.setTo(Vec.Med(a, b));
  }
  const length = Vec.Dist(a, b);
  return {
    bindings,
    type: "straight",
    start: {
      handle: terminalsInArrowSpace.start,
      point: a,
      arrowhead: shape.props.arrowheadStart
    },
    end: {
      handle: terminalsInArrowSpace.end,
      point: b,
      arrowhead: shape.props.arrowheadEnd
    },
    middle: c,
    isValid: length > 0,
    length
  };
}
function updateArrowheadPointWithBoundShape(point, opposite, arrowPageTransform, targetShapeInfo) {
  if (targetShapeInfo === void 0) {
    return;
  }
  if (targetShapeInfo.isExact) {
    return;
  }
  const pageFrom = Mat.applyToPoint(arrowPageTransform, opposite);
  const pageTo = Mat.applyToPoint(arrowPageTransform, point);
  const targetFrom = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageFrom);
  const targetTo = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageTo);
  const intersection = Array.from(
    targetShapeInfo.geometry.intersectLineSegment(targetFrom, targetTo, {
      includeLabels: false,
      includeInternal: false
    })
  );
  let targetInt;
  if (intersection.length) {
    targetInt = intersection.sort((p1, p2) => Vec.Dist2(p1, targetFrom) - Vec.Dist2(p2, targetFrom))[0] ?? (targetShapeInfo.isClosed ? void 0 : targetTo);
  }
  if (targetInt === void 0) {
    targetInt = targetShapeInfo.geometry.nearestPoint(targetTo);
    if (!Vec.DistMin(targetInt, targetTo, 1)) {
      return;
    }
  }
  const pageInt = Mat.applyToPoint(targetShapeInfo.transform, targetInt);
  const arrowInt = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pageInt);
  point.setTo(arrowInt);
  targetShapeInfo.didIntersect = true;
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/curved-arrow.mjs
function getCurvedArrowInfo(editor, shape, bindings) {
  const { arrowheadEnd, arrowheadStart } = shape.props;
  const bend = shape.props.bend;
  if (Math.abs(bend) > Math.abs(shape.props.bend * (WAY_TOO_BIG_ARROW_BEND_FACTOR * shape.props.scale))) {
    return getStraightArrowInfo(editor, shape, bindings);
  }
  const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings);
  const med = Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end);
  const distance = Vec.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start);
  const u = Vec.Len(distance) ? distance.uni() : Vec.From(distance);
  const middle = Vec.Add(med, u.per().mul(-bend));
  const startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "start");
  const endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "end");
  const a = terminalsInArrowSpace.start.clone();
  const b = terminalsInArrowSpace.end.clone();
  const c = middle.clone();
  if (Vec.Equals(a, b)) {
    return {
      bindings,
      type: "straight",
      start: {
        handle: a,
        point: a,
        arrowhead: shape.props.arrowheadStart
      },
      end: {
        handle: b,
        point: b,
        arrowhead: shape.props.arrowheadEnd
      },
      middle: c,
      isValid: false,
      length: 0
    };
  }
  const isClockwise = shape.props.bend < 0;
  const distFn = isClockwise ? clockwiseAngleDist : counterClockwiseAngleDist;
  const handleArc = getArcInfo(a, b, c);
  const handle_aCA = Vec.Angle(handleArc.center, a);
  const handle_aCB = Vec.Angle(handleArc.center, b);
  const handle_dAB = distFn(handle_aCA, handle_aCB);
  if (handleArc.length === 0 || handleArc.size === 0 || !isSafeFloat(handleArc.length) || !isSafeFloat(handleArc.size)) {
    return getStraightArrowInfo(editor, shape, bindings);
  }
  const tempA = a.clone();
  const tempB = b.clone();
  const tempC = c.clone();
  const arrowPageTransform = editor.getShapePageTransform(shape);
  let offsetA = 0;
  let offsetB = 0;
  let minLength = MIN_ARROW_LENGTH * shape.props.scale;
  if (startShapeInfo && !startShapeInfo.isExact) {
    const startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA);
    const centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center);
    const endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB);
    const inverseTransform = Mat.Inverse(startShapeInfo.transform);
    const startInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace);
    const centerInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace);
    const endInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace);
    const { isClosed } = startShapeInfo;
    let point;
    let intersections = Array.from(
      startShapeInfo.geometry.intersectCircle(centerInStartShapeLocalSpace, handleArc.radius, {
        includeLabels: false,
        includeInternal: false
      })
    );
    if (intersections.length) {
      const angleToStart = centerInStartShapeLocalSpace.angle(startInStartShapeLocalSpace);
      const angleToEnd = centerInStartShapeLocalSpace.angle(endInStartShapeLocalSpace);
      const dAB2 = distFn(angleToStart, angleToEnd);
      intersections = intersections.filter(
        (pt) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(pt)) <= dAB2
      );
      const targetDist = dAB2 * 0.25;
      intersections.sort(
        isClosed ? (p0, p1) => Math.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) - targetDist) < Math.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) - targetDist) ? -1 : 1 : (p0, p1) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) < distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) ? -1 : 1
      );
      point = intersections[0];
    }
    if (!point) {
      if (isClosed) {
        const nearestPoint = startShapeInfo.geometry.nearestPoint(startInStartShapeLocalSpace);
        if (Vec.DistMin(nearestPoint, startInStartShapeLocalSpace, 1)) {
          point = nearestPoint;
        }
      } else {
        point = startInStartShapeLocalSpace;
      }
    }
    if (point) {
      tempA.setTo(
        editor.getPointInShapeSpace(shape, Mat.applyToPoint(startShapeInfo.transform, point))
      );
      startShapeInfo.didIntersect = true;
      if (arrowheadStart !== "none") {
        const strokeOffset = STROKE_SIZES[shape.props.size] / 2 + ("size" in startShapeInfo.shape.props ? STROKE_SIZES[startShapeInfo.shape.props.size] / 2 : 0);
        offsetA = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale;
        minLength += strokeOffset * shape.props.scale;
      }
    }
  }
  if (endShapeInfo && !endShapeInfo.isExact) {
    const startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA);
    const endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB);
    const centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center);
    const inverseTransform = Mat.Inverse(endShapeInfo.transform);
    const startInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace);
    const centerInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace);
    const endInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace);
    const isClosed = endShapeInfo.isClosed;
    let point;
    let intersections = Array.from(
      endShapeInfo.geometry.intersectCircle(centerInEndShapeLocalSpace, handleArc.radius, {
        includeLabels: false,
        includeInternal: false
      })
    );
    if (intersections.length) {
      const angleToStart = centerInEndShapeLocalSpace.angle(startInEndShapeLocalSpace);
      const angleToEnd = centerInEndShapeLocalSpace.angle(endInEndShapeLocalSpace);
      const dAB2 = distFn(angleToStart, angleToEnd);
      const targetDist = dAB2 * 0.75;
      intersections = intersections.filter(
        (pt) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(pt)) <= dAB2
      );
      intersections.sort(
        isClosed ? (p0, p1) => Math.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) - targetDist) < Math.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) - targetDist) ? -1 : 1 : (p0, p1) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) < distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) ? -1 : 1
      );
      point = intersections[0];
    }
    if (!point) {
      if (isClosed) {
        const nearestPoint = endShapeInfo.geometry.nearestPoint(endInEndShapeLocalSpace);
        if (Vec.DistMin(nearestPoint, endInEndShapeLocalSpace, 1)) {
          point = nearestPoint;
        }
      } else {
        point = endInEndShapeLocalSpace;
      }
    }
    if (point) {
      tempB.setTo(
        editor.getPointInShapeSpace(shape, Mat.applyToPoint(endShapeInfo.transform, point))
      );
      endShapeInfo.didIntersect = true;
      if (arrowheadEnd !== "none") {
        const strokeOffset = STROKE_SIZES[shape.props.size] / 2 + ("size" in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0);
        offsetB = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale;
        minLength += strokeOffset * shape.props.scale;
      }
    }
  }
  let aCA = Vec.Angle(handleArc.center, tempA);
  let aCB = Vec.Angle(handleArc.center, tempB);
  let dAB = distFn(aCA, aCB);
  let lAB = dAB * handleArc.radius;
  const tA = tempA.clone();
  const tB = tempB.clone();
  if (offsetA !== 0) {
    tA.setTo(handleArc.center).add(
      Vec.FromAngle(aCA + dAB * (offsetA / lAB * (isClockwise ? 1 : -1))).mul(handleArc.radius)
    );
  }
  if (offsetB !== 0) {
    tB.setTo(handleArc.center).add(
      Vec.FromAngle(aCB + dAB * (offsetB / lAB * (isClockwise ? -1 : 1))).mul(handleArc.radius)
    );
  }
  if (Vec.DistMin(tA, tB, minLength)) {
    if (offsetA !== 0 && offsetB !== 0) {
      offsetA *= -1.5;
      offsetB *= -1.5;
    } else if (offsetA !== 0) {
      offsetA *= -2;
    } else if (offsetB !== 0) {
      offsetB *= -2;
    } else {
    }
    const minOffsetA = 0.1 - distFn(handle_aCA, aCA) * handleArc.radius;
    const minOffsetB = 0.1 - distFn(aCB, handle_aCB) * handleArc.radius;
    offsetA = Math.max(offsetA, minOffsetA);
    offsetB = Math.max(offsetB, minOffsetB);
  }
  if (offsetA !== 0) {
    tempA.setTo(handleArc.center).add(
      Vec.FromAngle(aCA + dAB * (offsetA / lAB * (isClockwise ? 1 : -1))).mul(handleArc.radius)
    );
  }
  if (offsetB !== 0) {
    tempB.setTo(handleArc.center).add(
      Vec.FromAngle(aCB + dAB * (offsetB / lAB * (isClockwise ? -1 : 1))).mul(handleArc.radius)
    );
  }
  if (startShapeInfo && endShapeInfo && !startShapeInfo.isExact && !endShapeInfo.isExact) {
    aCA = Vec.Angle(handleArc.center, tempA);
    aCB = Vec.Angle(handleArc.center, tempB);
    dAB = distFn(aCA, aCB);
    lAB = dAB * handleArc.radius;
    const relationship = getBoundShapeRelationships(
      editor,
      startShapeInfo.shape.id,
      endShapeInfo.shape.id
    );
    if (relationship === "double-bound" && lAB < 30) {
      tempA.setTo(a);
      tempB.setTo(b);
      tempC.setTo(c);
    } else if (relationship === "safe") {
      if (startShapeInfo && !startShapeInfo.didIntersect) {
        tempA.setTo(a);
      }
      if (endShapeInfo && !endShapeInfo.didIntersect || distFn(handle_aCA, aCA) > distFn(handle_aCA, aCB)) {
        tempB.setTo(handleArc.center).add(
          Vec.FromAngle(
            aCA + dAB * (Math.min(0.9, MIN_ARROW_LENGTH * shape.props.scale / lAB) * (isClockwise ? 1 : -1))
          ).mul(handleArc.radius)
        );
      }
    }
  }
  placeCenterHandle(
    handleArc.center,
    handleArc.radius,
    tempA,
    tempB,
    tempC,
    handle_dAB,
    isClockwise
  );
  if (tempA.equals(tempB)) {
    tempA.setTo(tempC.clone().addXY(1, 1));
    tempB.setTo(tempC.clone().subXY(1, 1));
  }
  a.setTo(tempA);
  b.setTo(tempB);
  c.setTo(tempC);
  const bodyArc = getArcInfo(a, b, c);
  return {
    bindings,
    type: "arc",
    start: {
      point: a,
      handle: terminalsInArrowSpace.start,
      arrowhead: shape.props.arrowheadStart
    },
    end: {
      point: b,
      handle: terminalsInArrowSpace.end,
      arrowhead: shape.props.arrowheadEnd
    },
    middle: c,
    handleArc,
    bodyArc,
    isValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y)
  };
}
function getArcInfo(a, b, c) {
  const center = centerOfCircleFromThreePoints(a, b, c) ?? Vec.Med(a, b);
  const radius = Vec.Dist(center, a);
  const sweepFlag = +Vec.Clockwise(a, c, b);
  const ab = ((a.y - b.y) ** 2 + (a.x - b.x) ** 2) ** 0.5;
  const bc = ((b.y - c.y) ** 2 + (b.x - c.x) ** 2) ** 0.5;
  const ca = ((c.y - a.y) ** 2 + (c.x - a.x) ** 2) ** 0.5;
  const theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2;
  const largeArcFlag = +(PI > theta);
  const size4 = (PI2 - theta) * (sweepFlag ? 1 : -1);
  const length = size4 * radius;
  return {
    center,
    radius,
    size: size4,
    length,
    largeArcFlag,
    sweepFlag
  };
}
function placeCenterHandle(center, radius, tempA, tempB, tempC, originalArcLength, isClockwise) {
  const aCA = Vec.Angle(center, tempA);
  const aCB = Vec.Angle(center, tempB);
  let dAB = clockwiseAngleDist(aCA, aCB);
  if (!isClockwise)
    dAB = PI2 - dAB;
  tempC.setTo(center).add(Vec.FromAngle(aCA + dAB * (0.5 * (isClockwise ? 1 : -1))).mul(radius));
  if (dAB > originalArcLength) {
    tempC.rotWith(center, PI);
    const t2 = tempB.clone();
    tempB.setTo(tempA);
    tempA.setTo(t2);
  }
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/range.mjs
function expandRange(range, amount) {
  const newRange = {
    min: range.min - amount,
    max: range.max + amount
  };
  if (newRange.min > newRange.max) {
    return null;
  }
  return newRange;
}
function subtractRange(a, b) {
  assert(a.min <= a.max && b.min <= b.max);
  if (a.min <= b.min && b.max <= a.max) {
    return [
      { min: a.min, max: b.min },
      { min: b.max, max: a.max }
    ];
  }
  if (b.max <= a.min || b.min >= a.max) {
    return [a];
  }
  if (b.min <= a.min && a.max <= b.max) {
    return [];
  }
  if (isWithinRange(a.min, b)) {
    return [{ min: b.max, max: a.max }];
  }
  if (isWithinRange(a.max, b)) {
    return [{ min: a.min, max: b.min }];
  }
  return [];
}
function createRange(a, b) {
  return { min: Math.min(a, b), max: Math.max(a, b) };
}
function isWithinRange(value, range) {
  return value >= range.min && value <= range.max;
}
function rangeSize(range) {
  return range.max - range.min;
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/routes/ElbowArrowWorkingInfo.mjs
function flipEdgeCrossInPlace(edge) {
  if (!edge)
    return;
  const tmp = edge.cross.min;
  edge.cross.min = -edge.cross.max;
  edge.cross.max = -tmp;
  edge.crossTarget = -edge.crossTarget;
}
function flipEdgeValueInPlace(edge) {
  if (!edge)
    return;
  edge.value = -edge.value;
  edge.expanded = edge.expanded === null ? null : -edge.expanded;
}
var ElbowArrowTransform = {
  Identity: { x: 1, y: 1, transpose: false },
  Rotate90: { x: -1, y: 1, transpose: true },
  Rotate180: { x: -1, y: -1, transpose: false },
  Rotate270: { x: 1, y: -1, transpose: true },
  FlipX: { x: -1, y: 1, transpose: false },
  FlipY: { x: 1, y: -1, transpose: false }
};
function invertElbowArrowTransform(transform) {
  if (transform.transpose) {
    return {
      x: transform.y,
      y: transform.x,
      transpose: true
    };
  }
  return transform;
}
function transformElbowArrowTransform(a, b) {
  const next = { ...a };
  if (b.transpose) {
    swap(next, "x", "y");
    next.transpose = !next.transpose;
  }
  if (b.x === -1) {
    next.x = -next.x;
  }
  if (b.y === -1) {
    next.y = -next.y;
  }
  return next;
}
function swap(object2, a, b) {
  const temp = object2[a];
  object2[a] = object2[b];
  object2[b] = temp;
}
function transformVecInPlace(transform, point) {
  point.x = transform.x * point.x;
  point.y = transform.y * point.y;
  if (transform.transpose) {
    swap(point, "x", "y");
  }
}
function transformBoxInPlace(transform, box) {
  if (transform.x === -1) {
    box.x = -(box.x + box.width);
  }
  if (transform.y === -1) {
    box.y = -(box.y + box.height);
  }
  if (transform.transpose) {
    swap(box, "x", "y");
    swap(box, "width", "height");
  }
}
function transformEdgesInPlace(transform, edges) {
  if (transform.x === -1) {
    swap(edges, "left", "right");
    flipEdgeCrossInPlace(edges.top);
    flipEdgeCrossInPlace(edges.bottom);
    flipEdgeValueInPlace(edges.left);
    flipEdgeValueInPlace(edges.right);
  }
  if (transform.y === -1) {
    swap(edges, "top", "bottom");
    flipEdgeCrossInPlace(edges.left);
    flipEdgeCrossInPlace(edges.right);
    flipEdgeValueInPlace(edges.top);
    flipEdgeValueInPlace(edges.bottom);
  }
  if (transform.transpose) {
    swap(edges, "left", "top");
    swap(edges, "right", "bottom");
  }
}
var ElbowArrowWorkingInfo = class {
  constructor(info) {
    __publicField(this, "options");
    __publicField(this, "A");
    __publicField(this, "B");
    __publicField(this, "common");
    __publicField(this, "gapX");
    __publicField(this, "gapY");
    __publicField(this, "midX");
    __publicField(this, "midY");
    __publicField(this, "bias");
    __publicField(this, "transform", ElbowArrowTransform.Identity);
    __publicField(this, "inverse", ElbowArrowTransform.Identity);
    this.options = info.options;
    this.A = info.A;
    this.B = info.B;
    this.common = info.common;
    this.midX = info.midX;
    this.midY = info.midY;
    this.gapX = info.gapX;
    this.gapY = info.gapY;
    this.bias = new Vec(1, 1);
  }
  apply(transform) {
    this.transform = transformElbowArrowTransform(transform, this.transform);
    this.inverse = invertElbowArrowTransform(this.transform);
    transformBoxInPlace(transform, this.A.original);
    transformBoxInPlace(transform, this.B.original);
    transformBoxInPlace(transform, this.common.original);
    transformBoxInPlace(transform, this.A.expanded);
    transformBoxInPlace(transform, this.B.expanded);
    transformBoxInPlace(transform, this.common.expanded);
    transformEdgesInPlace(transform, this.A.edges);
    transformEdgesInPlace(transform, this.B.edges);
    transformVecInPlace(transform, this.bias);
    if (transform.x === -1) {
      this.gapX = -this.gapX;
      this.midX = this.midX === null ? null : -this.midX;
    }
    if (transform.y === -1) {
      this.gapY = -this.gapY;
      this.midY = this.midY === null ? null : -this.midY;
    }
    if (transform.transpose) {
      let temp = this.midX;
      this.midX = this.midY;
      this.midY = temp;
      temp = this.gapX;
      this.gapX = this.gapY;
      this.gapY = temp;
    }
  }
  reset() {
    this.apply(this.inverse);
  }
  vec(x, y) {
    const point = new Vec(x, y);
    transformVecInPlace(this.inverse, point);
    return point;
  }
};

// node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/routes/ElbowArrowRouteBuilder.mjs
var MIN_DISTANCE = 0.01;
var ElbowArrowRouteBuilder = class {
  constructor(info, name) {
    __publicField(this, "points", []);
    __publicField(this, "_midpointHandle", null);
    this.info = info;
    this.name = name;
  }
  add(x, y) {
    this.points.push(this.info.vec(x, y));
    return this;
  }
  midpointHandle(axis) {
    assert(this._midpointHandle === null, "midX/midY called multiple times");
    const point = Vec.Lrp(
      this.points[this.points.length - 2],
      this.points[this.points.length - 1],
      0.5
    );
    this._midpointHandle = {
      axis: this.info.transform.transpose ? axis === "x" ? "y" : "x" : axis,
      point,
      segmentStart: this.points[this.points.length - 2].clone(),
      segmentEnd: this.points[this.points.length - 1].clone()
    };
    return this;
  }
  build() {
    const finalPoints = [];
    for (let i = 0; i < this.points.length; i++) {
      const p0 = this.points[i];
      const p1 = finalPoints[finalPoints.length - 1];
      const p2 = finalPoints[finalPoints.length - 2];
      if (!p1 || !p2) {
        finalPoints.push(p0);
      } else {
        const d1x = Math.abs(p0.x - p1.x);
        const d1y = Math.abs(p0.y - p1.y);
        const d2x = Math.abs(p0.x - p2.x);
        const d2y = Math.abs(p0.y - p2.y);
        if (d1x < MIN_DISTANCE && d1y < MIN_DISTANCE) {
        } else if (d1x < MIN_DISTANCE && d2x < MIN_DISTANCE) {
          p1.y = p0.y;
        } else if (d1y < MIN_DISTANCE && d2y < MIN_DISTANCE) {
          p1.x = p0.x;
        } else {
          finalPoints.push(p0);
        }
      }
    }
    return {
      name: this.name,
      points: finalPoints,
      distance: measureRouteManhattanDistance(finalPoints),
      aEdgePicking: "manual",
      bEdgePicking: "manual",
      skipPointsWhenDrawing: /* @__PURE__ */ new Set(),
      midpointHandle: this._midpointHandle
    };
  }
};
function measureRouteManhattanDistance(path) {
  let distance = 0;
  for (let i = 0; i < path.length - 1; i++) {
    const start2 = path[i];
    const end2 = path[i + 1];
    distance += Math.abs(end2.x - start2.x) + Math.abs(end2.y - start2.y);
  }
  return distance;
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/routes/elbowArrowRoutes.mjs
function routeRightToLeft(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.left;
  if (!aEdge || !bEdge)
    return null;
  if (aEdge.crossTarget > bEdge.crossTarget) {
    info.apply(ElbowArrowTransform.FlipY);
  }
  if (info.gapX > 0 && info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 1").add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, bEdge.crossTarget).midpointHandle("x").add(bEdge.value, bEdge.crossTarget).build();
  }
  if (aEdge.expanded === null || bEdge.expanded === null)
    return null;
  if (info.midY !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 2").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(bEdge.expanded, info.midY).midpointHandle("y").add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  const arrow3Distance = Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.common.expanded.bottom) + Math.abs(info.common.expanded.right - bEdge.expanded) + Math.abs(info.common.expanded.bottom - bEdge.crossTarget) + info.options.expandElbowLegLength + 6;
  const arrow4Distance = info.options.expandElbowLegLength + Math.abs(aEdge.crossTarget - info.common.expanded.top) + Math.abs(aEdge.expanded - info.common.expanded.left) + Math.abs(info.common.expanded.top - bEdge.crossTarget) + Math.abs(info.common.expanded.left - bEdge.value) + // 6 points in this arrow, plus bias towards down/right:
  6 + info.bias.y;
  const arrow5Distance = info.gapX < 0 && info.midX !== null ? info.options.expandElbowLegLength + Math.abs(aEdge.crossTarget - info.A.expanded.bottom) + info.common.expanded.width + Math.abs(info.A.expanded.bottom - info.B.expanded.top) + Math.abs(info.B.expanded.top - bEdge.crossTarget) + info.options.expandElbowLegLength + // 8 points in this arrow
  8 : Infinity;
  if (arrow3Distance < arrow4Distance && arrow3Distance < arrow5Distance) {
    return new ElbowArrowRouteBuilder(info, "to left 3").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, info.common.expanded.bottom).add(bEdge.expanded, info.common.expanded.bottom).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (arrow4Distance < arrow5Distance) {
    return new ElbowArrowRouteBuilder(info, "to left 4").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.common.expanded.top).add(info.common.expanded.left, info.common.expanded.top).add(info.common.expanded.left, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 5").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded.bottom).add(info.midX, info.A.expanded.bottom).add(info.midX, info.B.expanded.top).midpointHandle("y").add(bEdge.expanded, info.B.expanded.top).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  return null;
}
function routeRightToTop(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.top;
  if (!aEdge || !bEdge)
    return null;
  if (aEdge.crossTarget < (bEdge.expanded ?? bEdge.value) && bEdge.crossTarget > (aEdge.expanded ?? aEdge.value) || info.A.isPoint && info.B.expanded.containsPoint(info.A.original.center)) {
    return new ElbowArrowRouteBuilder(info, "to top 1").add(aEdge.value, aEdge.crossTarget).add(bEdge.crossTarget, aEdge.crossTarget).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (info.gapX > 0 && info.midX !== null && bEdge.expanded !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 2").add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, bEdge.expanded).midpointHandle("x").add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (info.gapY > 0 && aEdge.expanded !== null && bEdge.crossTarget < aEdge.expanded && info.midY !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 3").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(bEdge.crossTarget, info.midY).midpointHandle("y").add(bEdge.crossTarget, bEdge.value).build();
  }
  const arrow4Length = Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.common.expanded.top) + Math.abs(bEdge.crossTarget - info.common.expanded.right) + Math.abs(bEdge.value - info.common.expanded.top);
  const arrow5Length = aEdge.expanded !== null && info.midY !== null && bEdge.expanded !== null ? Math.abs(aEdge.value - aEdge.expanded) + Math.abs(info.B.expanded.left - aEdge.expanded) + Math.abs(info.B.expanded.left - bEdge.crossTarget) + Math.abs(aEdge.crossTarget - info.B.expanded.top) + Math.abs(bEdge.value - bEdge.expanded) : Infinity;
  const arrow6Length = aEdge.expanded !== null && info.midX !== null && bEdge.expanded !== null ? Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.A.expanded.bottom) + Math.abs(aEdge.expanded - bEdge.crossTarget) + Math.abs(info.A.expanded.bottom - bEdge.expanded) + Math.abs(bEdge.expanded - bEdge.value) : Infinity;
  if (arrow4Length < arrow5Length && arrow4Length < arrow6Length) {
    return new ElbowArrowRouteBuilder(info, "to top 4").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, info.common.expanded.top).add(bEdge.crossTarget, info.common.expanded.top).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (bEdge.expanded !== null && aEdge.expanded !== null && info.midY !== null && arrow5Length < arrow6Length) {
    return new ElbowArrowRouteBuilder(info, "to top 5").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(info.B.expanded.left, info.midY).midpointHandle("y").add(info.B.expanded.left, bEdge.expanded).add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (bEdge.expanded !== null && aEdge.expanded !== null && info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 6").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded.bottom).add(info.midX, info.A.expanded.bottom).add(info.midX, bEdge.expanded).midpointHandle("x").add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  return null;
}
function routeRightToBottom(info) {
  info.apply(ElbowArrowTransform.FlipY);
  return routeRightToTop(info);
}
function routeRightToRight(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.right;
  if (!aEdge || !bEdge)
    return null;
  if ((info.gapX <= 0 || aEdge.crossTarget > info.B.expanded.bottom || aEdge.crossTarget < info.B.expanded.top) && (bEdge.value > info.A.original.left || bEdge.crossTarget > info.A.expanded.bottom || bEdge.crossTarget < info.A.expanded.top)) {
    return new ElbowArrowRouteBuilder(info, "to right 1").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (info.midX === null)
    return null;
  if (bEdge.expanded !== null && info.gapX >= 0) {
    const viaBottomLength = Math.abs(bEdge.crossTarget - info.B.expanded.bottom) + Math.abs(aEdge.crossTarget - info.B.expanded.bottom);
    const viaTopLength = Math.abs(bEdge.crossTarget - info.B.expanded.top) + Math.abs(aEdge.crossTarget - info.B.expanded.top);
    const topOrBottom = viaBottomLength < viaTopLength ? "bottom" : "top";
    return new ElbowArrowRouteBuilder(info, `to right 2 via ${topOrBottom}`).add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, info.B.expanded[topOrBottom]).midpointHandle("x").add(bEdge.expanded, info.B.expanded[topOrBottom]).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (aEdge.expanded !== null && info.gapX <= 0) {
    const viaBottomLength = Math.abs(bEdge.crossTarget - info.A.expanded.bottom) + Math.abs(aEdge.crossTarget - info.A.expanded.bottom);
    const viaTopLength = Math.abs(bEdge.crossTarget - info.A.expanded.top) + Math.abs(aEdge.crossTarget - info.A.expanded.top);
    const topOrBottom = viaBottomLength < viaTopLength ? "bottom" : "top";
    return new ElbowArrowRouteBuilder(info, `to right 3 via ${topOrBottom}`).add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded[topOrBottom]).add(info.midX, info.A.expanded[topOrBottom]).add(info.midX, bEdge.crossTarget).midpointHandle("x").add(bEdge.value, bEdge.crossTarget).build();
  }
  return null;
}
var routes = {
  top: {
    top: [ElbowArrowTransform.Rotate270, routeRightToRight],
    left: [ElbowArrowTransform.Rotate270, routeRightToTop],
    bottom: [ElbowArrowTransform.Rotate270, routeRightToLeft],
    right: [ElbowArrowTransform.Rotate270, routeRightToBottom]
  },
  right: {
    top: [ElbowArrowTransform.Identity, routeRightToTop],
    right: [ElbowArrowTransform.Identity, routeRightToRight],
    bottom: [ElbowArrowTransform.Identity, routeRightToBottom],
    left: [ElbowArrowTransform.Identity, routeRightToLeft]
  },
  bottom: {
    top: [ElbowArrowTransform.Rotate90, routeRightToLeft],
    left: [ElbowArrowTransform.Rotate90, routeRightToBottom],
    bottom: [ElbowArrowTransform.Rotate90, routeRightToRight],
    right: [ElbowArrowTransform.Rotate90, routeRightToTop]
  },
  left: {
    top: [ElbowArrowTransform.Rotate180, routeRightToBottom],
    left: [ElbowArrowTransform.Rotate180, routeRightToRight],
    bottom: [ElbowArrowTransform.Rotate180, routeRightToTop],
    right: [ElbowArrowTransform.Rotate180, routeRightToLeft]
  }
};
function tryRouteArrow(info, aEdge, bEdge) {
  const [transform, routeFn] = routes[aEdge][bEdge];
  info.apply(transform);
  const route = routeFn(info);
  info.reset();
  return route;
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/routes/routeArrowWithAutoEdgePicking.mjs
function routeArrowWithAutoEdgePicking(info, reason) {
  let idealRoute = null;
  if (
    // +1 to bias us towards the x-axis. without this, we get flicker as we move an arrow locket
    // to 45 deg (as gapx/gapy are almost equal and the result depends on floating point
    // precision)
    Math.abs(info.gapX) + 1 > Math.abs(info.gapY) && info.midX !== null
  ) {
    if (info.gapX > 0) {
      idealRoute = tryRouteArrow(info, "right", "left");
    } else {
      idealRoute = tryRouteArrow(info, "left", "right");
    }
  } else {
    const aRight = info.A.edges.right;
    const aLeft = info.A.edges.left;
    const bTop = info.B.edges.top;
    const bBottom = info.B.edges.bottom;
    if (info.A.isPoint && info.B.isPoint) {
      if (info.gapY > 0) {
        idealRoute = tryRouteArrow(info, "bottom", "top");
      } else {
        idealRoute = tryRouteArrow(info, "top", "bottom");
      }
    } else if (aRight && bTop && (aRight.expanded ?? aRight.value) <= bTop.crossTarget && aRight.crossTarget <= (bTop.expanded ?? bTop.value)) {
      idealRoute = tryRouteArrow(info, "right", "top");
    } else if (aRight && bBottom && (aRight.expanded ?? aRight.value) <= bBottom.crossTarget && aRight.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
      idealRoute = tryRouteArrow(info, "right", "bottom");
    } else if (aLeft && bTop && (aLeft.expanded ?? aLeft.value) >= bTop.crossTarget && aLeft.crossTarget <= (bTop.expanded ?? bTop.value)) {
      idealRoute = tryRouteArrow(info, "left", "top");
    } else if (aLeft && bBottom && (aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget && aLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
      idealRoute = tryRouteArrow(info, "left", "bottom");
    } else if (info.gapY > 0 && info.midY !== null) {
      idealRoute = tryRouteArrow(info, "bottom", "top");
    } else if (info.gapY < 0 && info.midY !== null) {
      idealRoute = tryRouteArrow(info, "top", "bottom");
    }
  }
  if (idealRoute) {
    idealRoute.aEdgePicking = reason;
    idealRoute.bEdgePicking = reason;
    return idealRoute;
  }
  const aAvailableSide = ElbowArrowSides.filter((side) => info.A.edges[side]);
  const bAvailableSides = ElbowArrowSides.filter((side) => info.B.edges[side]);
  const nonPartialRouteCandidates = aAvailableSide.flatMap(
    (aSide) => bAvailableSides.map((bSide) => [aSide, bSide, reason, reason])
  );
  return pickBest(info, nonPartialRouteCandidates);
}
function routeArrowWithPartialEdgePicking(info, aSide) {
  let idealRoute = null;
  const aRight = info.A.edges.right;
  const aLeft = info.A.edges.left;
  const bTop = info.B.edges.top;
  const bBottom = info.B.edges.bottom;
  switch (aSide) {
    case "right":
      if (info.gapX > 0 && info.gapX > Math.abs(info.gapY) && info.midX !== null) {
        idealRoute = tryRouteArrow(info, "right", "left");
      } else if (aRight && bTop && (aRight.expanded ?? aRight.value) <= bTop.crossTarget && aRight.crossTarget <= (bTop.expanded ?? bTop.value)) {
        idealRoute = tryRouteArrow(info, "right", "top");
      } else if (aRight && bBottom && (aRight.expanded ?? aRight.value) <= bBottom.crossTarget && aRight.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
        idealRoute = tryRouteArrow(info, "right", "bottom");
      }
      break;
    case "left":
      if (info.gapX < 0 && Math.abs(info.gapX) > Math.abs(info.gapY) && info.midX !== null) {
        idealRoute = tryRouteArrow(info, "left", "right");
      } else if (aLeft && bTop && (aLeft.expanded ?? aLeft.value) >= bTop.crossTarget && aLeft.crossTarget <= (bTop.expanded ?? bTop.value)) {
        idealRoute = tryRouteArrow(info, "left", "top");
      } else if (aLeft && bBottom && (aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget && aLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
        idealRoute = tryRouteArrow(info, "left", "bottom");
      }
      break;
    case "top":
    case "bottom":
      break;
    default:
      exhaustiveSwitchError(aSide);
  }
  if (idealRoute) {
    idealRoute.aEdgePicking = "manual";
    idealRoute.bEdgePicking = "auto";
    return idealRoute;
  }
  switch (aSide) {
    case "top":
      return pickBest(info, [
        ["top", "bottom", "manual", "auto"],
        ["top", "right", "manual", "auto"],
        ["top", "left", "manual", "auto"],
        ["top", "top", "manual", "auto"]
      ]);
    case "bottom":
      return pickBest(info, [
        ["bottom", "top", "manual", "auto"],
        ["bottom", "right", "manual", "auto"],
        ["bottom", "left", "manual", "auto"],
        ["bottom", "bottom", "manual", "auto"]
      ]);
    case "left":
      return pickBest(info, [
        ["left", "right", "manual", "auto"],
        ["left", "bottom", "manual", "auto"],
        ["left", "left", "manual", "auto"],
        ["left", "top", "manual", "auto"]
      ]);
    case "right":
      return pickBest(info, [
        ["right", "left", "manual", "auto"],
        ["right", "bottom", "manual", "auto"],
        ["right", "right", "manual", "auto"],
        ["right", "top", "manual", "auto"]
      ]);
  }
}
function routeArrowWithManualEdgePicking(info, aSide, bSide) {
  const route = tryRouteArrow(info, aSide, bSide);
  if (route)
    return route;
  if (info.A.isPoint && info.B.isPoint) {
    return pickBest(info, [
      [ElbowArrowSideOpposites[aSide], ElbowArrowSideOpposites[bSide], "manual", "manual"],
      [aSide, ElbowArrowSideOpposites[bSide], "manual", "auto"],
      [ElbowArrowSideOpposites[aSide], bSide, "auto", "manual"]
    ]);
  } else if (info.A.isPoint) {
    return tryRouteArrow(info, ElbowArrowSideOpposites[aSide], bSide);
  } else if (info.B.isPoint) {
    return tryRouteArrow(info, aSide, ElbowArrowSideOpposites[bSide]);
  }
  return null;
}
function pickBest(info, edges) {
  let bestRoute = null;
  let bestCornerCount = Infinity;
  let bestDistance = Infinity;
  let distanceBias = 0;
  for (const [aSide, bSide, aEdgePicking, bEdgePicking] of edges) {
    distanceBias += 1;
    const route = tryRouteArrow(info, aSide, bSide);
    if (route) {
      route.aEdgePicking = aEdgePicking;
      route.bEdgePicking = bEdgePicking;
      if (route.points.length < bestCornerCount) {
        bestCornerCount = route.points.length;
        bestDistance = route.distance;
        bestRoute = route;
      } else if (route.points.length === bestCornerCount && route.distance + distanceBias < bestDistance) {
        bestDistance = route.distance;
        bestRoute = route;
      }
    }
  }
  return bestRoute;
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/getElbowArrowInfo.mjs
function getElbowArrowInfo(editor, arrow6, bindings) {
  const shapeOptions = editor.getShapeUtil(arrow6.type).options;
  const options2 = {
    elbowMidpoint: arrow6.props.elbowMidPoint,
    expandElbowLegLength: shapeOptions.expandElbowLegLength[arrow6.props.size] * arrow6.props.scale,
    minElbowLegLength: shapeOptions.minElbowLegLength[arrow6.props.size] * arrow6.props.scale
  };
  let startTerminal = getElbowArrowTerminalInfo(editor, arrow6, bindings.start, arrow6.props.start);
  let endTerminal = getElbowArrowTerminalInfo(editor, arrow6, bindings.end, arrow6.props.end);
  startTerminal = adjustTerminalForUnclosedPathIfNeeded(startTerminal, endTerminal, options2);
  endTerminal = adjustTerminalForUnclosedPathIfNeeded(endTerminal, startTerminal, options2);
  const swapOrder = !!(!startTerminal.side && endTerminal.side);
  let { aTerminal, bTerminal } = swapOrder ? { aTerminal: endTerminal, bTerminal: startTerminal } : { aTerminal: startTerminal, bTerminal: endTerminal };
  let edgesA = {
    top: getUsableEdge(aTerminal, bTerminal, "top", options2),
    right: getUsableEdge(aTerminal, bTerminal, "right", options2),
    bottom: getUsableEdge(aTerminal, bTerminal, "bottom", options2),
    left: getUsableEdge(aTerminal, bTerminal, "left", options2)
  };
  let edgesB = {
    top: getUsableEdge(bTerminal, aTerminal, "top", options2),
    right: getUsableEdge(bTerminal, aTerminal, "right", options2),
    bottom: getUsableEdge(bTerminal, aTerminal, "bottom", options2),
    left: getUsableEdge(bTerminal, aTerminal, "left", options2)
  };
  const aIsUsable = hasUsableEdge(edgesA, aTerminal.side);
  const bIsUsable = hasUsableEdge(edgesB, bTerminal.side);
  let needsNewEdges = false;
  if (!aIsUsable || !bIsUsable) {
    needsNewEdges = true;
    if (!aIsUsable) {
      bTerminal = convertTerminalToPoint(bTerminal);
    }
    if (!bIsUsable) {
      aTerminal = convertTerminalToPoint(aTerminal);
    }
    if (bTerminal.bounds.containsPoint(aTerminal.target, options2.expandElbowLegLength)) {
      bTerminal = convertTerminalToPoint(bTerminal);
    }
    if (aTerminal.bounds.containsPoint(bTerminal.target, options2.expandElbowLegLength)) {
      aTerminal = convertTerminalToPoint(aTerminal);
    }
  }
  if (needsNewEdges) {
    edgesA = {
      top: getUsableEdge(aTerminal, bTerminal, "top", options2),
      right: getUsableEdge(aTerminal, bTerminal, "right", options2),
      bottom: getUsableEdge(aTerminal, bTerminal, "bottom", options2),
      left: getUsableEdge(aTerminal, bTerminal, "left", options2)
    };
    edgesB = {
      top: getUsableEdge(bTerminal, aTerminal, "top", options2),
      right: getUsableEdge(bTerminal, aTerminal, "right", options2),
      bottom: getUsableEdge(bTerminal, aTerminal, "bottom", options2),
      left: getUsableEdge(bTerminal, aTerminal, "left", options2)
    };
  }
  const expandedA = aTerminal.isPoint ? aTerminal.bounds : aTerminal.bounds.clone().expandBy(options2.expandElbowLegLength);
  const expandedB = bTerminal.isPoint ? bTerminal.bounds : bTerminal.bounds.clone().expandBy(options2.expandElbowLegLength);
  const common = {
    original: Box.Common([aTerminal.bounds, bTerminal.bounds]),
    expanded: Box.Common([expandedA, expandedB])
  };
  let gapX = bTerminal.bounds.minX - aTerminal.bounds.maxX;
  if (gapX < 0) {
    gapX = aTerminal.bounds.minX - bTerminal.bounds.maxX;
    if (gapX < 0) {
      gapX = 0;
    }
    gapX = -gapX;
  }
  let gapY = bTerminal.bounds.minY - aTerminal.bounds.maxY;
  if (gapY < 0) {
    gapY = aTerminal.bounds.minY - bTerminal.bounds.maxY;
    if (gapY < 0) {
      gapY = 0;
    }
    gapY = -gapY;
  }
  const aMinLength = aTerminal.minEndSegmentLength * 3;
  const bMinLength = bTerminal.minEndSegmentLength * 3;
  const minLegDistanceNeeded = (aTerminal.isPoint ? aMinLength : options2.minElbowLegLength) + (bTerminal.isPoint ? bMinLength : options2.minElbowLegLength);
  let mxRange = null;
  if (gapX > minLegDistanceNeeded) {
    mxRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.maxX + aMinLength : expandedA.maxX,
      b: bTerminal.isPoint ? bTerminal.bounds.minX - bMinLength : expandedB.minX
    };
  } else if (gapX < -minLegDistanceNeeded) {
    mxRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.minX - aMinLength : expandedA.minX,
      b: bTerminal.isPoint ? bTerminal.bounds.maxX + bMinLength : expandedB.maxX
    };
  }
  let myRange = null;
  if (gapY > minLegDistanceNeeded) {
    myRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.maxY + aMinLength : expandedA.maxY,
      b: bTerminal.isPoint ? bTerminal.bounds.minY - bMinLength : expandedB.minY
    };
  } else if (gapY < -minLegDistanceNeeded) {
    myRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.minY - aMinLength : expandedA.minY,
      b: bTerminal.isPoint ? bTerminal.bounds.maxY + bMinLength : expandedB.maxY
    };
  }
  const midpoint = swapOrder ? 1 - options2.elbowMidpoint : options2.elbowMidpoint;
  const mx = mxRange ? lerp(mxRange.a, mxRange.b, midpoint) : null;
  const my = myRange ? lerp(myRange.a, myRange.b, midpoint) : null;
  const info = {
    options: options2,
    swapOrder,
    A: {
      isPoint: aTerminal.isPoint,
      target: aTerminal.target,
      isExact: aTerminal.isExact,
      arrowheadOffset: aTerminal.arrowheadOffset,
      minEndSegmentLength: aTerminal.minEndSegmentLength,
      original: aTerminal.bounds,
      expanded: expandedA,
      edges: edgesA,
      geometry: aTerminal.geometry
    },
    B: {
      isPoint: bTerminal.isPoint,
      target: bTerminal.target,
      isExact: bTerminal.isExact,
      arrowheadOffset: bTerminal.arrowheadOffset,
      minEndSegmentLength: bTerminal.minEndSegmentLength,
      original: bTerminal.bounds,
      expanded: expandedB,
      edges: edgesB,
      geometry: bTerminal.geometry
    },
    common,
    gapX,
    gapY,
    midX: mx,
    midY: my
  };
  const workingInfo = new ElbowArrowWorkingInfo(info);
  const aSide = getSideToUse(aTerminal, bTerminal, info.A.edges);
  const bSide = getSideToUse(bTerminal, aTerminal, info.B.edges);
  let route;
  if (aSide && bSide) {
    route = routeArrowWithManualEdgePicking(workingInfo, aSide, bSide);
  } else if (aSide && !bSide) {
    route = routeArrowWithPartialEdgePicking(workingInfo, aSide);
  }
  if (!route) {
    route = routeArrowWithAutoEdgePicking(workingInfo, aSide || bSide ? "fallback" : "auto");
  }
  if (route) {
    castPathSegmentIntoGeometry("first", info.A, info.B, route);
    castPathSegmentIntoGeometry("last", info.B, info.A, route);
    fixTinyEndNubs(route, aTerminal, bTerminal);
    if (swapOrder)
      route.points.reverse();
  }
  return {
    ...info,
    route,
    midXRange: mxRange ? swapOrder ? { lo: mxRange.b, hi: mxRange.a } : { lo: mxRange.a, hi: mxRange.b } : null,
    midYRange: myRange ? swapOrder ? { lo: myRange.b, hi: myRange.a } : { lo: myRange.a, hi: myRange.b } : null
  };
}
function getRouteHandlePath(info, route) {
  const startTarget = info.swapOrder ? info.B.target : info.A.target;
  const endTarget = info.swapOrder ? info.A.target : info.B.target;
  const firstSegmentLength = Vec.ManhattanDist(route.points[0], route.points[1]);
  const lastSegmentLength = Vec.ManhattanDist(
    route.points[route.points.length - 2],
    route.points[route.points.length - 1]
  );
  const newFirstSegmentLength = Vec.ManhattanDist(startTarget, route.points[1]);
  const newLastSegmentLength = Vec.ManhattanDist(route.points[route.points.length - 2], endTarget);
  const firstSegmentLengthChange = firstSegmentLength - newFirstSegmentLength;
  const lastSegmentLengthChange = lastSegmentLength - newLastSegmentLength;
  const newPoints = [startTarget, ...route.points, endTarget];
  return {
    name: route.name,
    distance: route.distance + firstSegmentLengthChange + lastSegmentLengthChange,
    points: newPoints.filter((p) => !route.skipPointsWhenDrawing.has(p)),
    aEdgePicking: route.aEdgePicking,
    bEdgePicking: route.bEdgePicking,
    skipPointsWhenDrawing: route.skipPointsWhenDrawing,
    midpointHandle: route.midpointHandle
  };
}
function getEdgeFromNormalizedAnchor(normalizedAnchor) {
  if (approximately(normalizedAnchor.x, 0.5) && approximately(normalizedAnchor.y, 0.5)) {
    return null;
  }
  if (Math.abs(normalizedAnchor.x - 0.5) > // slightly bias towards x arrows to prevent flickering when the anchor is right on the line
  // between the two directions
  Math.abs(normalizedAnchor.y - 0.5) - 1e-4) {
    return normalizedAnchor.x < 0.5 ? "left" : "right";
  }
  return normalizedAnchor.y < 0.5 ? "top" : "bottom";
}
function getElbowArrowTerminalInfo(editor, arrow6, binding, point) {
  const arrowStrokeSize = STROKE_SIZES[arrow6.props.size] * arrow6.props.scale / 2;
  const minEndSegmentLength = arrowStrokeSize * arrow6.props.scale * 3;
  if (binding) {
    const target = editor.getShape(binding.toId);
    const geometry = getBindingGeometryInArrowSpace(editor, arrow6, binding.toId, binding.props);
    if (geometry && target) {
      let arrowheadOffset = 0;
      const arrowheadProp = binding.props.terminal === "start" ? "arrowheadStart" : "arrowheadEnd";
      if (arrow6.props[arrowheadProp] !== "none") {
        const targetScale = "scale" in target.props ? target.props.scale : 1;
        const targetStrokeSize = "size" in target.props ? (STROKE_SIZES[target.props.size] ?? 0) * targetScale / 2 : 0;
        arrowheadOffset = arrowStrokeSize + targetStrokeSize + BOUND_ARROW_OFFSET * arrow6.props.scale;
      }
      let side = null;
      const targetPoint = geometry.target;
      if (binding.props.isPrecise) {
        side = getEdgeFromNormalizedAnchor(
          Vec.RotWith(
            binding.props.normalizedAnchor,
            { x: 0.5, y: 0.5 },
            geometry.shapeToArrowTransform.rotation()
          )
        );
      }
      return {
        targetShapeId: binding.toId,
        isPoint: false,
        isExact: binding.props.isExact,
        bounds: geometry.bounds,
        geometry: geometry.geometry,
        target: targetPoint,
        arrowheadOffset,
        minEndSegmentLength,
        side,
        snap: binding.props.snap
      };
    }
  }
  return {
    targetShapeId: null,
    bounds: Box.FromCenter(point, { x: 0, y: 0 }),
    geometry: null,
    isExact: false,
    isPoint: true,
    target: Vec.From(point),
    arrowheadOffset: 0,
    minEndSegmentLength,
    side: null,
    snap: "none"
  };
}
function getBindingGeometryInArrowSpace(editor, arrow6, targetId, bindingProps) {
  const hasArrowhead = bindingProps.terminal === "start" ? arrow6.props.arrowheadStart !== "none" : arrow6.props.arrowheadEnd !== "none";
  const targetGeometryInTargetSpace = editor.getShapeGeometry(
    targetId,
    hasArrowhead ? void 0 : { context: "@tldraw/arrow-without-arrowhead" }
  );
  if (!targetGeometryInTargetSpace) {
    return null;
  }
  const arrowTransform = editor.getShapePageTransform(arrow6.id);
  const shapeTransform = editor.getShapePageTransform(targetId);
  const shapeToArrowTransform = arrowTransform.clone().invert().multiply(shapeTransform);
  const targetGeometryInArrowSpace = targetGeometryInTargetSpace.transform(shapeToArrowTransform);
  const center = { x: 0.5, y: 0.5 };
  const normalizedAnchor = bindingProps.isPrecise ? bindingProps.normalizedAnchor : center;
  const targetInShapeSpace = {
    x: lerp(
      targetGeometryInTargetSpace.bounds.minX,
      targetGeometryInTargetSpace.bounds.maxX,
      normalizedAnchor.x
    ),
    y: lerp(
      targetGeometryInTargetSpace.bounds.minY,
      targetGeometryInTargetSpace.bounds.maxY,
      normalizedAnchor.y
    )
  };
  const centerInShapeSpace = {
    x: lerp(
      targetGeometryInTargetSpace.bounds.minX,
      targetGeometryInTargetSpace.bounds.maxX,
      center.x
    ),
    y: lerp(
      targetGeometryInTargetSpace.bounds.minY,
      targetGeometryInTargetSpace.bounds.maxY,
      center.y
    )
  };
  const targetInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, targetInShapeSpace);
  const centerInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, centerInShapeSpace);
  return {
    bounds: targetGeometryInArrowSpace.bounds,
    geometry: targetGeometryInArrowSpace,
    target: targetInArrowSpace,
    center: centerInArrowSpace,
    shapeToArrowTransform
  };
}
var sideProps = {
  top: {
    expand: -1,
    main: "minY",
    opposite: "maxY",
    crossMid: "midX",
    crossMin: "minX",
    crossMax: "maxX",
    bRangeExpand: "max",
    crossAxis: "x"
  },
  bottom: {
    expand: 1,
    main: "maxY",
    opposite: "minY",
    crossMid: "midX",
    crossMin: "minX",
    crossMax: "maxX",
    bRangeExpand: "min",
    crossAxis: "x"
  },
  left: {
    expand: -1,
    main: "minX",
    opposite: "maxX",
    crossMid: "midY",
    crossMin: "minY",
    crossMax: "maxY",
    bRangeExpand: "max",
    crossAxis: "y"
  },
  right: {
    expand: 1,
    main: "maxX",
    opposite: "minX",
    crossMid: "midY",
    crossMin: "minY",
    crossMax: "maxY",
    bRangeExpand: "min",
    crossAxis: "y"
  }
};
function getUsableEdge(a, b, side, options2) {
  const props = sideProps[side];
  const isSelfBoundAndShouldRouteExternal = a.targetShapeId === b.targetShapeId && a.targetShapeId !== null && (a.snap === "edge" || a.snap === "edge-point") && (b.snap === "edge" || b.snap === "edge-point");
  const aValue = a.bounds[props.main];
  const aExpanded = a.isPoint ? null : aValue + props.expand * options2.expandElbowLegLength;
  const originalACrossRange = createRange(a.bounds[props.crossMin], a.bounds[props.crossMax]);
  let aCrossRange = originalACrossRange;
  if (!aCrossRange) {
    return null;
  }
  assert(originalACrossRange);
  const bRange = createRange(b.bounds[props.main], b.bounds[props.opposite]);
  if (!b.isPoint) {
    bRange[props.bRangeExpand] -= options2.minElbowLegLength * 2 * props.expand;
  }
  const bCrossRange = expandRange(
    createRange(b.bounds[props.crossMin], b.bounds[props.crossMax]),
    options2.expandElbowLegLength
  );
  assert(bRange && bCrossRange);
  let isPartial = false;
  if (isWithinRange(aValue, bRange) && !a.isPoint && !b.isPoint && !isSelfBoundAndShouldRouteExternal) {
    const subtracted = subtractRange(aCrossRange, bCrossRange);
    switch (subtracted.length) {
      case 0:
        return null;
      case 1:
        isPartial = subtracted[0] !== aCrossRange;
        aCrossRange = subtracted[0];
        break;
      case 2:
        isPartial = true;
        aCrossRange = rangeSize(subtracted[0]) > rangeSize(subtracted[1]) ? subtracted[0] : subtracted[1];
        break;
      default:
        exhaustiveSwitchError(subtracted);
    }
  }
  if (!isWithinRange(a.target[props.crossAxis], aCrossRange)) {
    return null;
  }
  const crossTarget = a.target[props.crossAxis];
  return {
    value: aValue,
    expanded: aExpanded,
    cross: aCrossRange,
    crossTarget,
    isPartial
  };
}
function hasUsableEdge(edges, side) {
  if (side === null) {
    return !!(edges.bottom || edges.left || edges.right || edges.top);
  }
  if (side === "x") {
    return !!edges.left || !!edges.right;
  }
  if (side === "y") {
    return !!edges.top || !!edges.bottom;
  }
  return !!edges[side];
}
function getSideToUse(binding, other, edges) {
  switch (binding.side) {
    case null:
      return null;
    case "x":
      if (binding.bounds.center.x > other.bounds.center.x && (edges == null ? void 0 : edges.left)) {
        return "left";
      } else if (edges == null ? void 0 : edges.right) {
        return "right";
      }
      return null;
    case "y":
      if (binding.bounds.center.y > other.bounds.center.y && (edges == null ? void 0 : edges.top)) {
        return "top";
      } else if (edges == null ? void 0 : edges.bottom) {
        return "bottom";
      }
      return null;
    default:
      return binding.side;
  }
}
function convertTerminalToPoint(terminal) {
  if (terminal.isPoint)
    return terminal;
  let side = null;
  let arrowheadOffset = 0;
  if (terminal.snap === "edge" || terminal.snap === "edge-point") {
    arrowheadOffset = terminal.arrowheadOffset;
    if (terminal.side === "x" || terminal.side === "left" || terminal.side === "right") {
      side = "x";
    }
    if (terminal.side === "y" || terminal.side === "top" || terminal.side === "bottom") {
      side = "y";
    }
  }
  return {
    targetShapeId: terminal.targetShapeId,
    side,
    bounds: new Box(terminal.target.x, terminal.target.y, 0, 0),
    geometry: terminal.geometry,
    target: terminal.target,
    arrowheadOffset,
    minEndSegmentLength: terminal.minEndSegmentLength,
    isExact: terminal.isExact,
    isPoint: true,
    snap: terminal.snap
  };
}
function castPathSegmentIntoGeometry(segment, target, other, route) {
  if (!target.geometry)
    return;
  const point1 = segment === "first" ? route.points[0] : route.points[route.points.length - 1];
  const point2 = segment === "first" ? route.points[1] : route.points[route.points.length - 2];
  const pointToFindClosestIntersectionTo = target.geometry.isClosed ? point2 : target.target;
  const initialDistance = Vec.ManhattanDist(point1, pointToFindClosestIntersectionTo);
  let nearestIntersectionToPoint2 = null;
  let nearestDistanceToPoint2 = Infinity;
  if (target.isExact) {
    nearestIntersectionToPoint2 = target.target;
  } else if (target.geometry) {
    const intersections = target.geometry.intersectLineSegment(point2, target.target, {
      includeLabels: false,
      includeInternal: false
    });
    if (target.geometry.hitTestPoint(
      target.target,
      Math.max(1, target.arrowheadOffset),
      true,
      Geometry2dFilters.EXCLUDE_NON_STANDARD
    )) {
      intersections.push(target.target);
    }
    for (const intersection of intersections) {
      const point2Distance = Vec.ManhattanDist(pointToFindClosestIntersectionTo, intersection);
      if (point2Distance < nearestDistanceToPoint2) {
        nearestDistanceToPoint2 = point2Distance;
        nearestIntersectionToPoint2 = intersection;
      }
    }
  }
  if (nearestIntersectionToPoint2) {
    let offset5 = target.arrowheadOffset;
    const currentFinalSegmentLength = Vec.ManhattanDist(point2, nearestIntersectionToPoint2);
    const minLength = target.arrowheadOffset * 2;
    if (currentFinalSegmentLength < minLength) {
      const targetLength = minLength - target.arrowheadOffset;
      offset5 = currentFinalSegmentLength - targetLength;
    }
    if (offset5 < target.minEndSegmentLength) {
      if (target.geometry.bounds.containsPoint(other.target)) {
        offset5 = Math.max(0, offset5);
      } else {
        offset5 = -target.arrowheadOffset;
      }
    }
    let nudgedPoint = nearestIntersectionToPoint2;
    let shouldAddExtraPointForNudge = false;
    if (!target.isExact && offset5 !== 0) {
      const nudged = Vec.Nudge(nearestIntersectionToPoint2, point2, offset5);
      nudgedPoint = nudged;
      if (offset5 < 0 && !target.geometry.hitTestPoint(nudged, 0, true, Geometry2dFilters.EXCLUDE_NON_STANDARD)) {
        nudgedPoint = nearestIntersectionToPoint2;
      } else {
        if (offset5 < 0) {
          shouldAddExtraPointForNudge = true;
        }
        nudgedPoint = nudged;
      }
    }
    const newDistance = Vec.ManhattanDist(point2, nudgedPoint);
    route.distance += newDistance - initialDistance;
    point1.x = nudgedPoint.x;
    point1.y = nudgedPoint.y;
    if (shouldAddExtraPointForNudge) {
      const midPoint2 = Vec.Lrp(point2, point1, 0.5);
      route.skipPointsWhenDrawing.add(midPoint2);
      route.points.splice(segment === "first" ? 1 : route.points.length - 1, 0, midPoint2);
    }
  }
}
function fixTinyEndNubs(route, aTerminal, bTerminal) {
  if (!route)
    return;
  if (route.points.length >= 3) {
    const a = route.points[0];
    const b = route.points[1];
    const firstSegmentLength = Vec.ManhattanDist(a, b);
    if (firstSegmentLength < aTerminal.minEndSegmentLength) {
      route.points.splice(1, 1);
      if (route.points.length >= 3) {
        const matchAxis = approximately(a.x, b.x) ? "y" : "x";
        route.points[1][matchAxis] = a[matchAxis];
      }
    }
  }
  if (route.points.length >= 3) {
    const a = route.points[route.points.length - 1];
    const b = route.points[route.points.length - 2];
    const lastSegmentLength = Vec.ManhattanDist(a, b);
    if (lastSegmentLength < bTerminal.minEndSegmentLength) {
      route.points.splice(route.points.length - 2, 1);
      if (route.points.length >= 3) {
        const matchAxis = approximately(a.x, b.x) ? "y" : "x";
        route.points[route.points.length - 2][matchAxis] = a[matchAxis];
      }
    }
  }
}
function adjustTerminalForUnclosedPathIfNeeded(terminal, otherTerminal, options2) {
  if (!terminal.geometry || terminal.geometry.isClosed)
    return terminal;
  const normalizedPointAlongPath = terminal.geometry.uninterpolateAlongEdge(
    terminal.target,
    Geometry2dFilters.EXCLUDE_NON_STANDARD
  );
  const prev = terminal.geometry.interpolateAlongEdge(
    normalizedPointAlongPath - 0.01 / terminal.geometry.length
  );
  const next = terminal.geometry.interpolateAlongEdge(
    normalizedPointAlongPath + 0.01 / terminal.geometry.length
  );
  const normal = next.sub(prev).per().uni();
  const axis = Math.abs(normal.x) > Math.abs(normal.y) ? ElbowArrowAxes.x : ElbowArrowAxes.y;
  if (terminal.geometry.bounds.containsPoint(otherTerminal.target, options2.expandElbowLegLength)) {
    terminal.side = axis.self;
    return convertTerminalToPoint(terminal);
  }
  const min4 = axis.v(
    terminal.target[axis.self] - terminal.bounds[axis.size] * 2,
    terminal.target[axis.cross]
  );
  const max3 = axis.v(
    terminal.target[axis.self] + terminal.bounds[axis.size] * 2,
    terminal.target[axis.cross]
  );
  let furthestIntersectionTowardsMin = null;
  let furthestIntersectionTowardsMinDistance = 0;
  let furthestIntersectionTowardsMax = null;
  let furthestIntersectionTowardsMaxDistance = 0;
  let side = axis.self;
  for (const intersection of terminal.geometry.intersectLineSegment(
    min4,
    max3,
    Geometry2dFilters.EXCLUDE_NON_STANDARD
  )) {
    if (Math.abs(intersection[axis.self] - terminal.target[axis.self]) < 1) {
      continue;
    }
    if (intersection[axis.self] < terminal.target[axis.self]) {
      if (Vec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMinDistance) {
        furthestIntersectionTowardsMinDistance = Vec.ManhattanDist(intersection, terminal.target);
        furthestIntersectionTowardsMin = intersection;
      }
    } else {
      if (Vec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMaxDistance) {
        furthestIntersectionTowardsMaxDistance = Vec.ManhattanDist(intersection, terminal.target);
        furthestIntersectionTowardsMax = intersection;
      }
    }
  }
  if (furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {
    if (furthestIntersectionTowardsMinDistance > furthestIntersectionTowardsMaxDistance) {
      side = axis.hiEdge;
    } else {
      side = axis.loEdge;
    }
  } else if (furthestIntersectionTowardsMin && !furthestIntersectionTowardsMax) {
    side = axis.hiEdge;
  } else if (!furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {
    side = axis.loEdge;
  }
  terminal.side = side;
  return terminal;
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/shared.mjs
var MIN_ARROW_BEND = 8;
function getIsArrowStraight(shape) {
  if (shape.props.kind !== "arc")
    return false;
  return Math.abs(shape.props.bend) < MIN_ARROW_BEND * shape.props.scale;
}
function getBoundShapeInfoForTerminal(editor, arrow6, terminalName) {
  const binding = editor.getBindingsFromShape(arrow6, "arrow").find((b) => b.props.terminal === terminalName);
  if (!binding)
    return;
  const boundShape = editor.getShape(binding.toId);
  if (!boundShape)
    return;
  const transform = editor.getShapePageTransform(boundShape);
  const hasArrowhead = terminalName === "start" ? arrow6.props.arrowheadStart !== "none" : arrow6.props.arrowheadEnd !== "none";
  const geometry = editor.getShapeGeometry(
    boundShape,
    hasArrowhead ? void 0 : { context: "@tldraw/arrow-without-arrowhead" }
  );
  return {
    shape: boundShape,
    transform,
    isClosed: geometry.isClosed,
    isExact: binding.props.isExact,
    didIntersect: false,
    geometry
  };
}
function getArrowTerminalInArrowSpace(editor, arrowPageTransform, binding, forceImprecise) {
  const boundShape = editor.getShape(binding.toId);
  if (!boundShape) {
    return new Vec(0, 0);
  } else {
    const { point, size: size4 } = editor.getShapeGeometry(boundShape).bounds;
    const shapePoint = Vec.Add(
      point,
      Vec.MulV(
        // if the parent is the bound shape, then it's ALWAYS precise
        binding.props.isPrecise || forceImprecise ? binding.props.normalizedAnchor : { x: 0.5, y: 0.5 },
        size4
      )
    );
    const pagePoint = Mat.applyToPoint(editor.getShapePageTransform(boundShape), shapePoint);
    const arrowPoint = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pagePoint);
    return arrowPoint;
  }
}
function getArrowBindings(editor, shape) {
  const bindings = editor.getBindingsFromShape(shape, "arrow");
  return {
    start: bindings.find((b) => b.props.terminal === "start"),
    end: bindings.find((b) => b.props.terminal === "end")
  };
}
var arrowInfoCache = createComputedCache(
  "arrow info",
  (editor, shape) => {
    const bindings = getArrowBindings(editor, shape);
    if (shape.props.kind === "elbow") {
      const elbowInfo = getElbowArrowInfo(editor, shape, bindings);
      if (!(elbowInfo == null ? void 0 : elbowInfo.route))
        return getStraightArrowInfo(editor, shape, bindings);
      const start2 = elbowInfo.swapOrder ? elbowInfo.B : elbowInfo.A;
      const end2 = elbowInfo.swapOrder ? elbowInfo.A : elbowInfo.B;
      return {
        type: "elbow",
        bindings,
        start: {
          handle: start2.target,
          point: elbowInfo.route.points[0],
          arrowhead: shape.props.arrowheadStart
        },
        end: {
          handle: end2.target,
          point: elbowInfo.route.points[elbowInfo.route.points.length - 1],
          arrowhead: shape.props.arrowheadEnd
        },
        elbow: elbowInfo,
        route: elbowInfo.route,
        isValid: true
      };
    }
    return getIsArrowStraight(shape) ? getStraightArrowInfo(editor, shape, bindings) : getCurvedArrowInfo(editor, shape, bindings);
  }
);
function getArrowInfo(editor, shape) {
  const id = typeof shape === "string" ? shape : shape.id;
  return arrowInfoCache.get(editor, id);
}
function getArrowTerminalsInArrowSpace(editor, shape, bindings) {
  var _a5, _b;
  const arrowPageTransform = editor.getShapePageTransform(shape);
  const boundShapeRelationships = getBoundShapeRelationships(
    editor,
    (_a5 = bindings.start) == null ? void 0 : _a5.toId,
    (_b = bindings.end) == null ? void 0 : _b.toId
  );
  const start2 = bindings.start ? getArrowTerminalInArrowSpace(
    editor,
    arrowPageTransform,
    bindings.start,
    boundShapeRelationships === "double-bound" || boundShapeRelationships === "start-contains-end"
  ) : Vec.From(shape.props.start);
  const end2 = bindings.end ? getArrowTerminalInArrowSpace(
    editor,
    arrowPageTransform,
    bindings.end,
    boundShapeRelationships === "double-bound" || boundShapeRelationships === "end-contains-start"
  ) : Vec.From(shape.props.end);
  return { start: start2, end: end2 };
}
function createOrUpdateArrowBinding(editor, arrow6, target, props) {
  const arrowId = typeof arrow6 === "string" ? arrow6 : arrow6.id;
  const targetId = typeof target === "string" ? target : target.id;
  const existingMany = editor.getBindingsFromShape(arrowId, "arrow").filter((b) => b.props.terminal === props.terminal);
  if (existingMany.length > 1) {
    editor.deleteBindings(existingMany.slice(1));
  }
  const existing = existingMany[0];
  if (existing) {
    editor.updateBinding({
      ...existing,
      toId: targetId,
      props
    });
  } else {
    editor.createBinding({
      type: "arrow",
      fromId: arrowId,
      toId: targetId,
      props
    });
  }
}
function removeArrowBinding(editor, arrow6, terminal) {
  const existing = editor.getBindingsFromShape(arrow6, "arrow").filter((b) => b.props.terminal === terminal);
  editor.deleteBindings(existing);
}
var MIN_ARROW_LENGTH = 10;
var BOUND_ARROW_OFFSET = 10;
var WAY_TOO_BIG_ARROW_BEND_FACTOR = 10;
var STROKE_SIZES = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
function getBoundShapeRelationships(editor, startShapeId, endShapeId) {
  if (!startShapeId || !endShapeId)
    return "safe";
  if (startShapeId === endShapeId)
    return "double-bound";
  const startBounds = editor.getShapePageBounds(startShapeId);
  const endBounds = editor.getShapePageBounds(endShapeId);
  if (startBounds && endBounds) {
    if (startBounds.contains(endBounds))
      return "start-contains-end";
    if (endBounds.contains(startBounds))
      return "end-contains-start";
  }
  return "safe";
}

// node_modules/tldraw/dist-esm/lib/bindings/arrow/ArrowBindingUtil.mjs
var ArrowBindingUtil = class extends BindingUtil {
  getDefaultProps() {
    return {
      isPrecise: false,
      isExact: false,
      normalizedAnchor: { x: 0.5, y: 0.5 },
      snap: "none"
    };
  }
  // when the binding itself changes
  onAfterCreate({ binding }) {
    const arrow6 = this.editor.getShape(binding.fromId);
    if (!arrow6)
      return;
    arrowDidUpdate(this.editor, arrow6);
  }
  // when the binding itself changes
  onAfterChange({ bindingAfter }) {
    const arrow6 = this.editor.getShape(bindingAfter.fromId);
    if (!arrow6)
      return;
    arrowDidUpdate(this.editor, arrow6);
  }
  // when the arrow itself changes
  onAfterChangeFromShape({
    shapeAfter
  }) {
    arrowDidUpdate(this.editor, shapeAfter);
  }
  // when the shape an arrow is bound to changes
  onAfterChangeToShape({ binding }) {
    reparentArrow(this.editor, binding.fromId);
  }
  // when the arrow is isolated we need to update it's x,y positions
  onBeforeIsolateFromShape({
    binding
  }) {
    const arrow6 = this.editor.getShape(binding.fromId);
    if (!arrow6)
      return;
    updateArrowTerminal({
      editor: this.editor,
      arrow: arrow6,
      terminal: binding.props.terminal
    });
  }
};
__publicField(ArrowBindingUtil, "type", "arrow");
__publicField(ArrowBindingUtil, "props", arrowBindingProps);
__publicField(ArrowBindingUtil, "migrations", arrowBindingMigrations);
function reparentArrow(editor, arrowId) {
  var _a5;
  const arrow6 = editor.getShape(arrowId);
  if (!arrow6)
    return;
  const bindings = getArrowBindings(editor, arrow6);
  const { start: start2, end: end2 } = bindings;
  const startShape = start2 ? editor.getShape(start2.toId) : void 0;
  const endShape = end2 ? editor.getShape(end2.toId) : void 0;
  const parentPageId = editor.getAncestorPageId(arrow6);
  if (!parentPageId)
    return;
  let nextParentId;
  if (startShape && endShape) {
    nextParentId = editor.findCommonAncestor([startShape, endShape]) ?? parentPageId;
  } else if (startShape || endShape) {
    const bindingParentId = (_a5 = startShape || endShape) == null ? void 0 : _a5.parentId;
    if (bindingParentId && bindingParentId === arrow6.parentId) {
      nextParentId = arrow6.parentId;
    } else {
      nextParentId = parentPageId;
    }
  } else {
    return;
  }
  if (nextParentId && nextParentId !== arrow6.parentId) {
    editor.reparentShapes([arrowId], nextParentId);
  }
  const reparentedArrow = editor.getShape(arrowId);
  if (!reparentedArrow)
    throw Error("no reparented arrow");
  const startSibling = editor.getShapeNearestSibling(reparentedArrow, startShape);
  const endSibling = editor.getShapeNearestSibling(reparentedArrow, endShape);
  let highestSibling;
  if (startSibling && endSibling) {
    highestSibling = startSibling.index > endSibling.index ? startSibling : endSibling;
  } else if (startSibling && !endSibling) {
    highestSibling = startSibling;
  } else if (endSibling && !startSibling) {
    highestSibling = endSibling;
  } else {
    return;
  }
  let finalIndex;
  const higherSiblings = editor.getSortedChildIdsForParent(highestSibling.parentId).map((id) => editor.getShape(id)).filter((sibling) => sibling.index > highestSibling.index);
  if (higherSiblings.length) {
    const nextHighestNonArrowSibling = higherSiblings.find((sibling) => sibling.type !== "arrow");
    if (
      // ...then, if we're above the last shape we want to be above...
      reparentedArrow.index > highestSibling.index && // ...but below the next non-arrow sibling...
      (!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)
    ) {
      return;
    }
    finalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index);
  } else {
    finalIndex = getIndexAbove(highestSibling.index);
  }
  if (finalIndex !== reparentedArrow.index) {
    editor.updateShapes([{ id: arrowId, type: "arrow", index: finalIndex }]);
  }
}
function arrowDidUpdate(editor, arrow6) {
  const bindings = getArrowBindings(editor, arrow6);
  for (const handle of ["start", "end"]) {
    const binding = bindings[handle];
    if (!binding)
      continue;
    const boundShape = editor.getShape(binding.toId);
    const isShapeInSamePageAsArrow = editor.getAncestorPageId(arrow6) === editor.getAncestorPageId(boundShape);
    if (!boundShape || !isShapeInSamePageAsArrow) {
      updateArrowTerminal({ editor, arrow: arrow6, terminal: handle, unbind: true });
    }
  }
  reparentArrow(editor, arrow6.id);
}
function updateArrowTerminal({
  editor,
  arrow: arrow6,
  terminal,
  unbind: unbind2 = false,
  useHandle = false
}) {
  const info = getArrowInfo(editor, arrow6);
  if (!info) {
    throw new Error("expected arrow info");
  }
  const startPoint = useHandle ? info.start.handle : info.start.point;
  const endPoint = useHandle ? info.end.handle : info.end.point;
  const point = terminal === "start" ? startPoint : endPoint;
  const update = {
    id: arrow6.id,
    type: "arrow",
    props: {
      [terminal]: { x: point.x, y: point.y },
      bend: arrow6.props.bend
    }
  };
  if (info.type === "arc") {
    const newStart = terminal === "start" ? startPoint : info.start.handle;
    const newEnd = terminal === "end" ? endPoint : info.end.handle;
    const newMidPoint = Vec.Med(newStart, newEnd);
    const lineSegment = Vec.Sub(newStart, newEnd).per().uni().mul(info.handleArc.radius * 2 * Math.sign(arrow6.props.bend));
    const intersections = intersectLineSegmentCircle(
      info.handleArc.center,
      Vec.Add(newMidPoint, lineSegment),
      info.handleArc.center,
      info.handleArc.radius
    );
    assert((intersections == null ? void 0 : intersections.length) === 1);
    const bend = Vec.Dist(newMidPoint, intersections[0]) * Math.sign(arrow6.props.bend);
    if (!approximately(bend, update.props.bend)) {
      update.props.bend = bend;
    }
  }
  editor.updateShape(update);
  if (unbind2) {
    removeArrowBinding(editor, arrow6, terminal);
  }
}

// node_modules/tldraw/dist-esm/lib/defaultBindingUtils.mjs
var defaultBindingUtils = [ArrowBindingUtil];

// node_modules/tldraw/dist-esm/lib/shapes/shared/default-shape-constants.mjs
var TEXT_PROPS = {
  lineHeight: 1.35,
  fontWeight: "normal",
  fontVariant: "normal",
  fontStyle: "normal",
  padding: "0px"
};
var STROKE_SIZES2 = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
var FONT_SIZES = {
  s: 18,
  m: 24,
  l: 36,
  xl: 44
};
var LABEL_FONT_SIZES = {
  s: 18,
  m: 22,
  l: 26,
  xl: 32
};
var ARROW_LABEL_FONT_SIZES = {
  s: 18,
  m: 20,
  l: 24,
  xl: 28
};
var FONT_FAMILIES = {
  draw: "var(--tl-font-draw)",
  sans: "var(--tl-font-sans)",
  serif: "var(--tl-font-serif)",
  mono: "var(--tl-font-mono)"
};
var LABEL_TO_ARROW_PADDING = 20;
var ARROW_LABEL_PADDING = 4.25;
var LABEL_PADDING = 16;

// node_modules/tldraw/dist-esm/lib/utils/assets/assets.mjs
function containBoxSize(originalSize, containBoxSize2) {
  const overByXScale = originalSize.w / containBoxSize2.w;
  const overByYScale = originalSize.h / containBoxSize2.h;
  if (overByXScale <= 1 && overByYScale <= 1) {
    return originalSize;
  } else if (overByXScale > overByYScale) {
    return {
      w: originalSize.w / overByXScale,
      h: originalSize.h / overByXScale
    };
  } else {
    return {
      w: originalSize.w / overByYScale,
      h: originalSize.h / overByYScale
    };
  }
}
async function downsizeImage(blob, width, height, opts = {}) {
  const { w, h, image } = await MediaHelpers.usingObjectURL(
    blob,
    MediaHelpers.getImageAndDimensions
  );
  const { type = blob.type, quality = 0.85 } = opts;
  const [desiredWidth, desiredHeight] = clampToBrowserMaxCanvasSize(
    Math.min(width * 2, w),
    Math.min(height * 2, h)
  );
  const canvas = document.createElement("canvas");
  canvas.width = desiredWidth;
  canvas.height = desiredHeight;
  const ctx = assertExists(
    canvas.getContext("2d", { willReadFrequently: true }),
    "Could not get canvas context"
  );
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.drawImage(image, 0, 0, desiredWidth, desiredHeight);
  return new Promise((resolve, reject) => {
    canvas.toBlob(
      (blob2) => {
        if (blob2) {
          resolve(blob2);
        } else {
          reject(new Error("Could not resize image"));
        }
      },
      type,
      quality
    );
  });
}

// node_modules/tldraw/dist-esm/lib/utils/excalidraw/putExcalidrawContent.mjs
async function putExcalidrawContent(editor, excalidrawClipboardContent, point) {
  var _a5, _b, _c;
  const { elements, files } = excalidrawClipboardContent;
  const tldrawContent = {
    shapes: [],
    bindings: [],
    rootShapeIds: [],
    assets: [],
    schema: editor.store.schema.serialize()
  };
  const groupShapeIdToChildren = /* @__PURE__ */ new Map();
  const rotatedElements = /* @__PURE__ */ new Map();
  const currentPageId = editor.getCurrentPageId();
  const excElementIdsToTldrawShapeIds = /* @__PURE__ */ new Map();
  const rootShapeIds = [];
  const skipIds = /* @__PURE__ */ new Set();
  elements.forEach((element) => {
    excElementIdsToTldrawShapeIds.set(element.id, createShapeId());
    if (element.boundElements !== null) {
      for (const boundElement of element.boundElements) {
        if (boundElement.type === "text") {
          skipIds.add(boundElement.id);
        }
      }
    }
  });
  let index3 = ZERO_INDEX_KEY;
  for (const element of elements) {
    if (skipIds.has(element.id)) {
      continue;
    }
    const id = excElementIdsToTldrawShapeIds.get(element.id);
    const base2 = {
      id,
      typeName: "shape",
      parentId: currentPageId,
      index: index3,
      x: element.x,
      y: element.y,
      rotation: 0,
      isLocked: element.locked,
      opacity: getOpacity(element.opacity),
      meta: {}
    };
    if (element.angle !== 0) {
      rotatedElements.set(id, element.angle);
    }
    if (element.groupIds && element.groupIds.length > 0) {
      if (groupShapeIdToChildren.has(element.groupIds[0])) {
        (_a5 = groupShapeIdToChildren.get(element.groupIds[0])) == null ? void 0 : _a5.push(id);
      } else {
        groupShapeIdToChildren.set(element.groupIds[0], [id]);
      }
    } else {
      rootShapeIds.push(id);
    }
    switch (element.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        let text = "";
        let align = "middle";
        if (element.boundElements !== null) {
          for (const boundElement of element.boundElements) {
            if (boundElement.type === "text") {
              const labelElement = elements.find((elm) => elm.id === boundElement.id);
              if (labelElement) {
                text = labelElement.text;
                align = textAlignToAlignTypes[labelElement.textAlign];
              }
            }
          }
        }
        const colorToUse = element.backgroundColor === "transparent" ? element.strokeColor : element.backgroundColor;
        tldrawContent.shapes.push({
          ...base2,
          type: "geo",
          props: {
            geo: element.type,
            url: element.link ?? "",
            w: element.width,
            h: element.height,
            size: strokeWidthsToSizes[element.strokeWidth] ?? "draw",
            color: colorsToColors[colorToUse] ?? "black",
            richText: toRichText(text),
            align,
            dash: getDash(element),
            fill: getFill(element)
          }
        });
        break;
      }
      case "freedraw": {
        tldrawContent.shapes.push({
          ...base2,
          type: "draw",
          props: {
            dash: getDash(element),
            size: strokeWidthsToSizes[element.strokeWidth],
            color: colorsToColors[element.strokeColor] ?? "black",
            segments: [
              {
                type: "free",
                points: element.points.map(([x, y, z = 0.5]) => ({
                  x,
                  y,
                  z
                }))
              }
            ]
          }
        });
        break;
      }
      case "line": {
        const points = element.points.slice();
        if (points.length < 2) {
          break;
        }
        const indices = getIndices(element.points.length);
        tldrawContent.shapes.push({
          ...base2,
          type: "line",
          props: {
            dash: getDash(element),
            size: strokeWidthsToSizes[element.strokeWidth],
            color: colorsToColors[element.strokeColor] ?? "black",
            spline: element.roundness ? "cubic" : "line",
            points: {
              ...Object.fromEntries(
                element.points.map(([x, y], i) => {
                  const index22 = indices[i];
                  return [index22, { id: index22, index: index22, x, y }];
                })
              )
            }
          }
        });
        break;
      }
      case "arrow": {
        let text = "";
        if (element.boundElements !== null) {
          for (const boundElement of element.boundElements) {
            if (boundElement.type === "text") {
              const labelElement = elements.find((elm) => elm.id === boundElement.id);
              if (labelElement) {
                text = labelElement.text;
              }
            }
          }
        }
        const start2 = element.points[0];
        const end2 = element.points[element.points.length - 1];
        const startTargetId = excElementIdsToTldrawShapeIds.get((_b = element.startBinding) == null ? void 0 : _b.elementId);
        const endTargetId = excElementIdsToTldrawShapeIds.get((_c = element.endBinding) == null ? void 0 : _c.elementId);
        tldrawContent.shapes.push({
          ...base2,
          type: "arrow",
          props: {
            text,
            kind: element.elbowed ? "elbow" : "arc",
            bend: getBend(element, start2, end2),
            dash: getDash(element),
            size: strokeWidthsToSizes[element.strokeWidth] ?? "m",
            color: colorsToColors[element.strokeColor] ?? "black",
            start: { x: start2[0], y: start2[1] },
            end: { x: end2[0], y: end2[1] },
            arrowheadEnd: arrowheadsToArrowheadTypes[element.endArrowhead] ?? "none",
            arrowheadStart: arrowheadsToArrowheadTypes[element.startArrowhead] ?? "none"
          }
        });
        if (startTargetId) {
          tldrawContent.bindings.push({
            id: createBindingId(),
            typeName: "binding",
            type: "arrow",
            fromId: id,
            toId: startTargetId,
            props: {
              terminal: "start",
              normalizedAnchor: { x: 0.5, y: 0.5 },
              isPrecise: false,
              isExact: false
            },
            meta: {}
          });
        }
        if (endTargetId) {
          tldrawContent.bindings.push({
            id: createBindingId(),
            typeName: "binding",
            type: "arrow",
            fromId: id,
            toId: endTargetId,
            props: {
              terminal: "end",
              normalizedAnchor: { x: 0.5, y: 0.5 },
              isPrecise: false,
              isExact: false
            },
            meta: {}
          });
        }
        break;
      }
      case "text": {
        const { size: size4, scale } = getFontSizeAndScale(element.fontSize);
        tldrawContent.shapes.push({
          ...base2,
          type: "text",
          props: {
            size: size4,
            scale,
            font: fontFamilyToFontType[element.fontFamily] ?? "draw",
            color: colorsToColors[element.strokeColor] ?? "black",
            richText: toRichText(element.text),
            textAlign: textAlignToTextAlignTypes[element.textAlign]
          }
        });
        break;
      }
      case "image": {
        const file = files[element.fileId];
        if (!file)
          break;
        const assetId = AssetRecordType.createId();
        tldrawContent.assets.push({
          id: assetId,
          typeName: "asset",
          type: "image",
          props: {
            w: element.width,
            h: element.height,
            fileSize: file.size,
            name: element.id ?? "Untitled",
            isAnimated: false,
            mimeType: file.mimeType,
            src: file.dataURL
          },
          meta: {}
        });
        tldrawContent.shapes.push({
          ...base2,
          type: "image",
          props: {
            w: element.width,
            h: element.height,
            assetId
          }
        });
      }
    }
    index3 = getIndexAbove(index3);
  }
  const p = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : void 0);
  editor.putContentOntoCurrentPage(tldrawContent, {
    point: p,
    select: false,
    preserveIds: true
  });
  for (const groupedShapeIds of groupShapeIdToChildren.values()) {
    if (groupedShapeIds.length > 1) {
      editor.groupShapes(groupedShapeIds);
      const groupShape = editor.getShape(groupedShapeIds[0]);
      if ((groupShape == null ? void 0 : groupShape.parentId) && isShapeId(groupShape.parentId)) {
        rootShapeIds.push(groupShape.parentId);
      }
    }
  }
  for (const [id, angle] of rotatedElements) {
    editor.select(id);
    editor.rotateShapesBy([id], angle);
  }
  const rootShapes = compact(rootShapeIds.map((id) => editor.getShape(id)));
  const bounds = Box.Common(rootShapes.map((s) => editor.getShapePageBounds(s)));
  const viewPortCenter = editor.getViewportPageBounds().center;
  editor.updateShapes(
    rootShapes.map((s) => {
      const delta = {
        x: (s.x ?? 0) - (bounds.x + bounds.w / 2),
        y: (s.y ?? 0) - (bounds.y + bounds.h / 2)
      };
      return {
        id: s.id,
        type: s.type,
        x: viewPortCenter.x + delta.x,
        y: viewPortCenter.y + delta.y
      };
    })
  );
  editor.setSelectedShapes(rootShapeIds);
}
var getOpacity = (opacity) => {
  const t2 = opacity / 100;
  if (t2 < 0.2) {
    return 0.1;
  } else if (t2 < 0.4) {
    return 0.25;
  } else if (t2 < 0.6) {
    return 0.5;
  } else if (t2 < 0.8) {
    return 0.75;
  }
  return 1;
};
var strokeWidthsToSizes = {
  1: "s",
  2: "m",
  3: "l",
  4: "xl"
};
var fontSizesToSizes = {
  16: "s",
  20: "m",
  28: "l",
  36: "xl"
};
function getFontSizeAndScale(fontSize) {
  const size4 = fontSizesToSizes[fontSize];
  if (size4) {
    return { size: size4, scale: 1 };
  }
  if (fontSize < 16) {
    return { size: "s", scale: fontSize / 16 };
  }
  if (fontSize > 36) {
    return { size: "xl", scale: fontSize / 36 };
  }
  return { size: "m", scale: 1 };
}
var fontFamilyToFontType = {
  1: "draw",
  2: "sans",
  3: "mono"
};
var oc = {
  gray: ["#f8f9fa", "#e9ecef", "#ced4da", "#868e96", "#343a40"],
  red: ["#fff5f5", "#ffc9c9", "#ff8787", "#fa5252", "#e03131"],
  pink: ["#fff0f6", "#fcc2d7", "#f783ac", "#e64980", "#c2255c"],
  grape: ["#f8f0fc", "#eebefa", "#da77f2", "#be4bdb", "#9c36b5"],
  violet: ["#f3f0ff", "#d0bfff", "#9775fa", "#7950f2", "#6741d9"],
  indigo: ["#edf2ff", "#bac8ff", "#748ffc", "#4c6ef5", "#3b5bdb"],
  blue: ["#e7f5ff", "#a5d8ff", "#4dabf7", "#228be6", "#1971c2"],
  cyan: ["#e3fafc", "#99e9f2", "#3bc9db", "#15aabf", "#0c8599"],
  teal: ["#e6fcf5", "#96f2d7", "#38d9a9", "#12b886", "#099268"],
  green: ["#ebfbee", "#b2f2bb", "#69db7c", "#40c057", "#2f9e44"],
  lime: ["#f4fce3", "#d8f5a2", "#a9e34b", "#82c91e", "#66a80f"],
  yellow: ["#fff9db", "#ffec99", "#ffd43b", "#fab005", "#f08c00"],
  orange: ["#fff4e6", "#ffd8a8", "#ffa94d", "#fd7e14", "#e8590c"]
};
function mapExcalidrawColorToTldrawColors(excalidrawColor, light, dark) {
  const colors = [0, 1, 2, 3, 4].map((index3) => oc[excalidrawColor][index3]);
  return Object.fromEntries(colors.map((c, i) => [c, i < 3 ? light : dark]));
}
var colorsToColors = {
  ...mapExcalidrawColorToTldrawColors("gray", "grey", "black"),
  ...mapExcalidrawColorToTldrawColors("red", "light-red", "red"),
  ...mapExcalidrawColorToTldrawColors("pink", "light-red", "red"),
  ...mapExcalidrawColorToTldrawColors("grape", "light-violet", "violet"),
  ...mapExcalidrawColorToTldrawColors("blue", "light-blue", "blue"),
  ...mapExcalidrawColorToTldrawColors("cyan", "light-blue", "blue"),
  ...mapExcalidrawColorToTldrawColors("teal", "light-green", "green"),
  ...mapExcalidrawColorToTldrawColors("green", "light-green", "green"),
  ...mapExcalidrawColorToTldrawColors("yellow", "yellow", "orange"),
  ...mapExcalidrawColorToTldrawColors("orange", "yellow", "orange"),
  "#ffffff": "white",
  "#000000": "black"
};
var strokeStylesToStrokeTypes = {
  solid: "draw",
  dashed: "dashed",
  dotted: "dotted"
};
var fillStylesToFillType = {
  "cross-hatch": "pattern",
  hachure: "pattern",
  solid: "solid"
};
var textAlignToAlignTypes = {
  left: "start",
  center: "middle",
  right: "end"
};
var textAlignToTextAlignTypes = {
  left: "start",
  center: "middle",
  right: "end"
};
var arrowheadsToArrowheadTypes = {
  arrow: "arrow",
  dot: "dot",
  triangle: "triangle",
  bar: "pipe"
};
function getBend(element, startPoint, endPoint) {
  let bend = 0;
  if (element.points.length > 2) {
    const start2 = new Vec(startPoint[0], startPoint[1]);
    const end2 = new Vec(endPoint[0], endPoint[1]);
    const handle = new Vec(element.points[1][0], element.points[1][1]);
    const delta = Vec.Sub(end2, start2);
    const v = Vec.Per(delta);
    const med = Vec.Med(end2, start2);
    const A = Vec.Sub(med, v);
    const B = Vec.Add(med, v);
    const point = Vec.NearestPointOnLineSegment(A, B, handle, false);
    bend = Vec.Dist(point, med);
    if (Vec.Clockwise(point, end2, med))
      bend *= -1;
  }
  return bend;
}
var getDash = (element) => {
  let dash = strokeStylesToStrokeTypes[element.strokeStyle] ?? "draw";
  if (dash === "draw" && element.roughness === 0) {
    dash = "solid";
  }
  return dash;
};
var getFill = (element) => {
  if (element.backgroundColor === "transparent") {
    return "none";
  }
  return fillStylesToFillType[element.fillStyle] ?? "solid";
};

// node_modules/@tiptap/extension-code/dist/index.js
var inputRegex = /(^|[^`])`([^`]+)`(?!`)/;
var pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;
var Code = Mark2.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleCode: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetCode: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-highlight/dist/index.js
var inputRegex2 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/;
var pasteRegex2 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g;
var Highlight = Mark2.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/linkifyjs/dist/linkify.es.js
var encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
var encodedUtlds = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2";
var assign = (target, properties) => {
  for (const key in properties) {
    target[key] = properties[key];
  }
  return target;
};
var numeric = "numeric";
var ascii = "ascii";
var alpha = "alpha";
var asciinumeric = "asciinumeric";
var alphanumeric = "alphanumeric";
var domain = "domain";
var emoji = "emoji";
var scheme = "scheme";
var slashscheme = "slashscheme";
var whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t2, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t2) < 0) {
      group.push(t2);
    }
  }
}
function flagsForToken(t2, groups) {
  const result = {};
  for (const c in groups) {
    if (groups[c].indexOf(t2) >= 0) {
      result[c] = true;
    }
  }
  return result;
}
function State(token = null) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i = 0; i < state.jr.length; i++) {
      const regex = state.jr[i][0];
      const nextState2 = state.jr[i][1];
      if (nextState2 && regex.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly = false) {
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp2, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp2, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t2 = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t2) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t2, allFlags, groups);
        } else if (flags) {
          addToGroups(t2, flags, groups);
        }
      }
      nextState.t = t2;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
var ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
var tr = (state, regexp2, next, flags, groups) => state.tr(regexp2, next, flags, groups);
var ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
var tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
var WORD = "WORD";
var UWORD = "UWORD";
var ASCIINUMERICAL = "ASCIINUMERICAL";
var ALPHANUMERICAL = "ALPHANUMERICAL";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var UTLD = "UTLD";
var SCHEME = "SCHEME";
var SLASH_SCHEME = "SLASH_SCHEME";
var NUM = "NUM";
var WS = "WS";
var NL = "NL";
var OPENBRACE = "OPENBRACE";
var CLOSEBRACE = "CLOSEBRACE";
var OPENBRACKET = "OPENBRACKET";
var CLOSEBRACKET = "CLOSEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEPAREN = "CLOSEPAREN";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
var FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
var LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
var RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
var LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
var RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
var FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
var FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var FULLWIDTHMIDDLEDOT = "FULLWIDTHMIDDLEDOT";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var EMOJI$1 = "EMOJI";
var SYM = "SYM";
var tk = Object.freeze({
  __proto__: null,
  WORD,
  UWORD,
  ASCIINUMERICAL,
  ALPHANUMERICAL,
  LOCALHOST,
  TLD,
  UTLD,
  SCHEME,
  SLASH_SCHEME,
  NUM,
  WS,
  NL,
  OPENBRACE,
  CLOSEBRACE,
  OPENBRACKET,
  CLOSEBRACKET,
  OPENPAREN,
  CLOSEPAREN,
  OPENANGLEBRACKET,
  CLOSEANGLEBRACKET,
  FULLWIDTHLEFTPAREN,
  FULLWIDTHRIGHTPAREN,
  LEFTCORNERBRACKET,
  RIGHTCORNERBRACKET,
  LEFTWHITECORNERBRACKET,
  RIGHTWHITECORNERBRACKET,
  FULLWIDTHLESSTHAN,
  FULLWIDTHGREATERTHAN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  FULLWIDTHMIDDLEDOT,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  EMOJI: EMOJI$1,
  SYM
});
var ASCII_LETTER = /[a-z]/;
var LETTER = /\p{L}/u;
var EMOJI = /\p{Emoji}/u;
var EMOJI_VARIATION$1 = /\ufe0f/;
var DIGIT = /\d/;
var SPACE = /\s/;
var regexp = Object.freeze({
  __proto__: null,
  ASCII_LETTER,
  LETTER,
  EMOJI,
  EMOJI_VARIATION: EMOJI_VARIATION$1,
  DIGIT,
  SPACE
});
var CR = "\r";
var LF = "\n";
var EMOJI_VARIATION = "️";
var EMOJI_JOINER = "‍";
var OBJECT_REPLACEMENT = "￼";
var tlds = null;
var utlds = null;
function init$2(customSchemes = []) {
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, "（", FULLWIDTHLEFTPAREN);
  tt(Start, "）", FULLWIDTHRIGHTPAREN);
  tt(Start, "「", LEFTCORNERBRACKET);
  tt(Start, "」", RIGHTCORNERBRACKET);
  tt(Start, "『", LEFTWHITECORNERBRACKET);
  tt(Start, "』", RIGHTWHITECORNERBRACKET);
  tt(Start, "＜", FULLWIDTHLESSTHAN);
  tt(Start, "＞", FULLWIDTHGREATERTHAN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  tt(Start, "・", FULLWIDTHMIDDLEDOT);
  const Num = tr(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr(Num, DIGIT, Num);
  const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {
    [asciinumeric]: true
  });
  const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {
    [alphanumeric]: true
  });
  const Word = tr(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr(Word, DIGIT, Asciinumeric);
  tr(Word, ASCII_LETTER, Word);
  tr(Asciinumeric, DIGIT, Asciinumeric);
  tr(Asciinumeric, ASCII_LETTER, Asciinumeric);
  const UWord = tr(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr(UWord, ASCII_LETTER);
  tr(UWord, DIGIT, Alphanumeric);
  tr(UWord, LETTER, UWord);
  tr(Alphanumeric, DIGIT, Alphanumeric);
  tr(Alphanumeric, ASCII_LETTER);
  tr(Alphanumeric, LETTER, Alphanumeric);
  const Nl2 = tt(Start, LF, NL, {
    [whitespace]: true
  });
  const Cr = tt(Start, CR, WS, {
    [whitespace]: true
  });
  const Ws = tr(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt(Start, OBJECT_REPLACEMENT, Ws);
  tt(Cr, LF, Nl2);
  tt(Cr, OBJECT_REPLACEMENT, Ws);
  tr(Cr, SPACE, Ws);
  tt(Ws, CR);
  tt(Ws, LF);
  tr(Ws, SPACE, Ws);
  tt(Ws, OBJECT_REPLACEMENT, Ws);
  const Emoji = tr(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tt(Emoji, "#");
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tt(EmojiJoiner, "#");
  tr(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];
  for (let i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (let i = 0; i < utlds.length; i++) {
    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
  for (let i = 0; i < customSchemes.length; i++) {
    const sch = customSchemes[i][0];
    const optionalSlashSlash = customSchemes[i][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign({
      groups
    }, tk)
  };
}
function run$12(start2, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start2;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index3 = 0;
  while (index3 < len) {
    let first2 = str.charCodeAt(index3);
    let second;
    let char = first2 < 55296 || first2 > 56319 || index3 + 1 === len || (second = str.charCodeAt(index3 + 1)) < 56320 || second > 57343 ? str[index3] : str.slice(index3, index3 + 2);
    result.push(char);
    index3 += char.length;
  }
  return result;
}
function fastts(state, input, t2, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i = 0; i < len - 1; i++) {
    const char = input[i];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t2);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack2 = [];
  let i = 0;
  let digits = "0123456789";
  while (i < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack2.join(""));
      for (let popCount2 = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount2 > 0; popCount2--) {
        stack2.pop();
      }
      i += popDigitCount;
    } else {
      stack2.push(encoded[i]);
      i++;
    }
  }
  return words;
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop5,
  formatHref: noop5,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender = null) {
  let o = assign({}, defaults);
  if (opts) {
    o = assign(o, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  this.o = o;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop5(val) {
  return val;
}
var options = Object.freeze({
  __proto__: null,
  defaults,
  Options,
  assign
});
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options2) {
    const val = this.toString();
    const truncate = options2.get("truncate", val, this);
    const formatted = options2.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "…" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options2) {
    return options2.get("formatHref", this.toHref(options2.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol = defaults.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options2) {
    return {
      type: this.t,
      value: this.toFormattedString(options2),
      isLink: this.isLink,
      href: this.toFormattedHref(options2),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options2) {
    return options2.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options2) {
    const token = this;
    const href = this.toHref(options2.get("defaultProtocol"));
    const formattedHref = options2.get("formatHref", href, this);
    const tagName = options2.get("tagName", href, token);
    const content = this.toFormattedString(options2);
    const attributes = {};
    const className = options2.get("className", href, token);
    const target = options2.get("target", href, token);
    const rel = options2.get("rel", href, token);
    const attrs = options2.getObj("attributes", href, token);
    const eventListeners = options2.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      assign(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}
var Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2 = defaults.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var multi = Object.freeze({
  __proto__: null,
  MultiToken,
  Base: MultiToken,
  createTokenClass,
  Email,
  Text,
  Nl,
  Url
});
var makeState = (arg) => new State(arg);
function init$1({
  groups
}) {
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  tt(DomainHyphen, HYPHEN, DomainHyphen);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  tt(SchemeColon, QUERY, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // （）
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 「」
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 『』
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // ＜＞
  ];
  for (let i = 0; i < bracketPairs.length; i++) {
    const [OPEN, CLOSE] = bracketPairs[i];
    const UrlOpen = tt(Url$1, OPEN);
    tt(UrlNonaccept, OPEN, UrlOpen);
    tt(UrlOpen, CLOSE, Url$1);
    const UrlOpenQ = makeState(Url);
    ta(UrlOpen, qsAccepting, UrlOpenQ);
    const UrlOpenSyms = makeState();
    ta(UrlOpen, qsNonAccepting);
    ta(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt(UrlOpenQ, CLOSE, Url$1);
    tt(UrlOpenSyms, CLOSE, Url$1);
  }
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run2(start2, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start2;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var warn = typeof console !== "undefined" && console && console.warn || (() => {
});
var warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
var INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
  return INIT;
}
function registerCustomProtocol(scheme2, optionalSlashSlash = false) {
  if (INIT.initialized) {
    warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
  return INIT;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run2(INIT.parser.start, str, run$12(INIT.scanner.start, str));
}
tokenize.scan = run$12;
function find(str, type = null, opts = null) {
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options2 = new Options(opts);
  const tokens = tokenize(str);
  const filtered = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.isLink && (!type || token.t === type) && options2.check(token)) {
      filtered.push(token.toFormattedObject(options2));
    }
  }
  return filtered;
}

// node_modules/@tiptap/extension-link/dist/index.js
function isValidLinkStructure(tokens) {
  if (tokens.length === 1) {
    return tokens[0].isLink;
  }
  if (tokens.length === 3 && tokens[1].isLink) {
    return ["()", "[]"].includes(tokens[0].value + tokens[2].value);
  }
  return false;
}
function autolink(options2) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction2) => transaction2.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction2) => transaction2.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr2 } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
        } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s) => s !== "");
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map((t2) => t2.toObject(options2.defaultProtocol));
          if (!isValidLinkStructure(linksBeforeSpace)) {
            return false;
          }
          linksBeforeSpace.filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => options2.validate(link.value)).filter((link) => options2.shouldAutoLink(link.value)).forEach((link) => {
            if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options2.type)) {
              return;
            }
            tr2.addMark(link.from, link.to, options2.type.create({
              href: link.href
            }));
          });
        }
      });
      if (!tr2.steps.length) {
        return;
      }
      return tr2;
    }
  });
}
function clickHandler(options2) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a5, _b;
        if (event.button !== 0) {
          return false;
        }
        if (!view.editable) {
          return false;
        }
        let a = event.target;
        const els = [];
        while (a.nodeName !== "DIV") {
          els.push(a);
          a = a.parentNode;
        }
        if (!els.find((value) => value.nodeName === "A")) {
          return false;
        }
        const attrs = getAttributes(view.state, options2.type.name);
        const link = event.target;
        const href = (_a5 = link === null || link === void 0 ? void 0 : link.href) !== null && _a5 !== void 0 ? _a5 : attrs.href;
        const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;
        if (link && href) {
          window.open(href, target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options2) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice2) => {
        const { state } = view;
        const { selection } = state;
        const { empty: empty2 } = selection;
        if (empty2) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link = find(textContent, { defaultProtocol: options2.defaultProtocol }).find((item) => item.isLink && item.value === textContent);
        if (!textContent || !link) {
          return false;
        }
        return options2.editor.commands.setMark(options2.type, {
          href: link.href
        });
      }
    }
  });
}
var ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function isAllowedUri(uri, protocols) {
  const allowedProtocols = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return !uri || uri.replace(ATTR_WHITESPACE, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
var Link2 = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  exitable: true,
  onCreate() {
    if (this.options.validate && !this.options.shouldAutoLink) {
      this.options.shouldAutoLink = this.options.validate;
      console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.");
    }
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),
      validate: (url) => !!url,
      shouldAutoLink: (url) => !!url
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(element) {
          return element.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (dom) => {
          const href = dom.getAttribute("href");
          if (!href || !this.options.isAllowedUri(href, {
            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          })) {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    if (!this.options.isAllowedUri(HTMLAttributes.href, {
      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    })) {
      return [
        "a",
        mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }),
        0
      ];
    }
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain: chain2 }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain2().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain: chain2 }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain2().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain: chain2 }) => {
        return chain2().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text) => {
          const foundLinks = [];
          if (text) {
            const { protocols, defaultProtocol } = this.options;
            const links = find(text).filter((item) => item.isLink && this.options.isAllowedUri(item.value, {
              defaultValidate: (href) => !!isAllowedUri(href, protocols),
              protocols,
              defaultProtocol
            }));
            if (links.length) {
              links.forEach((link) => foundLinks.push({
                text: link.value,
                data: {
                  href: link.href
                },
                index: link.start
              }));
            }
          }
          return foundLinks;
        },
        type: this.type,
        getAttributes: (match) => {
          var _a5;
          return {
            href: (_a5 = match.data) === null || _a5 === void 0 ? void 0 : _a5.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    const { protocols, defaultProtocol } = this.options;
    if (this.options.autolink) {
      plugins.push(autolink({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (url) => this.options.isAllowedUri(url, {
          defaultValidate: (href) => !!isAllowedUri(href, protocols),
          protocols,
          defaultProtocol
        }),
        shouldAutoLink: this.options.shouldAutoLink
      }));
    }
    if (this.options.openOnClick === true) {
      plugins.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins.push(pasteHandler({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type
      }));
    }
    return plugins;
  }
});

// node_modules/@tiptap/extension-blockquote/dist/index.js
var inputRegex3 = /^\s*>\s$/;
var Blockquote = Node3.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: commands2 }) => {
        return commands2.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands: commands2 }) => {
        return commands2.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex3,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-bold/dist/index.js
var starInputRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
var starPasteRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
var underscoreInputRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
var underscorePasteRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
var Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-bullet-list/dist/index.js
var ListItemName = "listItem";
var TextStyleName = "textStyle";
var inputRegex4 = /^\s*([-+*])\s$/;
var BulletList = Node3.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: commands2, chain: chain2 }) => {
        if (this.options.keepAttributes) {
          return chain2().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex4,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex4,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyleName);
        },
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// node_modules/@tiptap/extension-code-block/dist/index.js
var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock = Node3.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (element) => {
          var _a5;
          const { languageClassPrefix } = this.options;
          const classNames35 = [...((_a5 = element.firstElementChild) === null || _a5 === void 0 ? void 0 : _a5.classList) || []];
          const languages = classNames35.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty2, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty2 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr: tr2 }) => {
          tr2.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc3 } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc3.nodeAt(after);
        if (nodeAfter) {
          return editor.commands.command(({ tr: tr2 }) => {
            tr2.setSelection(Selection.near(doc3.resolve(after)));
            return true;
          });
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
            if (!text || !language) {
              return false;
            }
            const { tr: tr2, schema } = view.state;
            const textNode = schema.text(text.replace(/\r\n?/g, "\n"));
            tr2.replaceSelectionWith(this.type.create({ language }, textNode));
            if (tr2.selection.$from.parent.type !== this.type) {
              tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
            }
            tr2.setMeta("paste", true);
            view.dispatch(tr2);
            return true;
          }
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-document/dist/index.js
var Document = Node3.create({
  name: "doc",
  topNode: true,
  content: "block+"
});

// node_modules/prosemirror-dropcursor/dist/index.js
function dropCursor(options2 = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options2);
    }
  });
}
var DropCursorView = class {
  constructor(editorView, options2) {
    var _a5;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a5 = options2.width) !== null && _a5 !== void 0 ? _a5 : 1;
    this.color = options2.color === false ? void 0 : options2.color || "black";
    this.class = options2.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top2 = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - this.width / 2, bottom: top2 + this.width / 2 };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      parentLeft = rect2.left - parent.scrollLeft;
      parentTop = rect2.top - parent.scrollTop;
    }
    this.element.style.left = rect.left - parentLeft + "px";
    this.element.style.top = rect.top - parentTop + "px";
    this.element.style.width = rect.right - rect.left + "px";
    this.element.style.height = rect.bottom - rect.top + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
};

// node_modules/@tiptap/extension-dropcursor/dist/index.js
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      dropCursor(this.options)
    ];
  }
});

// node_modules/prosemirror-gapcursor/dist/index.js
var GapCursor = class _GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc3, mapping) {
    let $pos = doc3.resolve(mapping.map(this.head));
    return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof _GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new _GapCursor(doc3.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search:
      for (; ; ) {
        if (!mustMove && _GapCursor.valid($pos))
          return $pos;
        let pos = $pos.pos, next = null;
        for (let d = $pos.depth; ; d--) {
          let parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        for (; ; ) {
          let inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        return null;
      }
  }
};
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = class _GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new _GapBookmark(mapping.map(this.pos));
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
};
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index3 = $pos.index(d), parent = $pos.node(d);
    if (index3 == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index3 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index3 = $pos.indexAfter(d), parent = $pos.node(d);
    if (index3 == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index3); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow4("horiz", -1),
  "ArrowRight": arrow4("horiz", 1),
  "ArrowUp": arrow4("vert", -1),
  "ArrowDown": arrow4("vert", 1)
});
function arrow4(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch2, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch2)
      dispatch2(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment12.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment12.from(insert[i].createAndFill(null, frag));
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}

// node_modules/@tiptap/extension-gapcursor/dist/index.js
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      gapCursor()
    ];
  },
  extendNodeSchema(extension) {
    var _a5;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a5 = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a5 !== void 0 ? _a5 : null
    };
  }
});

// node_modules/@tiptap/extension-hard-break/dist/index.js
var HardBreak = Node3.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  linebreakReplacement: true,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: commands2, chain: chain2, state, editor }) => {
        return commands2.first([
          () => commands2.exitCode(),
          () => commands2.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain2().insertContent({ type: this.name }).command(({ tr: tr2, dispatch: dispatch2 }) => {
              if (dispatch2 && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr2.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});

// node_modules/@tiptap/extension-heading/dist/index.js
var Heading = Node3.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items, level) => ({
      ...items,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});

// node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var dist_default2 = RopeSequence;

// node_modules/prosemirror-history/dist/index.js
var max_empty_items = 500;
var Branch2 = class _Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end2 = this.items.length;
    for (; ; end2--) {
      let next = this.items.get(end2 - 1);
      if (next.selection) {
        --end2;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end2, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end2, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item3(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item3(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new _Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item3(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new _Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array2) {
    if (this.eventCount == 0)
      return this;
    return new _Branch(this.items.append(array2.map((map2) => new Item3(map2))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start2);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item3(map2, step, selection));
      } else {
        rebasedItems.push(new Item3(map2));
      }
    }, start2);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item3(mapping.maps[i]));
    let items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    let branch = new _Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count3 = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count3++;
    });
    return count3;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item3(map2.invert(), step, selection), merged, last3 = items.length - 1;
          if (merged = items.length && items[last3].merge(newItem))
            items[last3] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new _Branch(dist_default2.from(items.reverse()), events);
  }
};
Branch2.empty = new Branch2(dist_default2.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item3 = class _Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new _Item(step.getMap().invert(), step, this.selection);
    }
  }
};
var HistoryState = class {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
};
var DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr2, options2) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr2, void 0, options2, mustPreserveItems(state)), history2.undone, rangesFor(tr2.mapping.maps), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options2, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options2.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps);
    return new HistoryState(history2.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options2, mustPreserveItems(state)), Branch2.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start2, end2) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start2 <= prevRanges[i + 1] && end2 >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)
    maps[i].forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch2.empty, Branch2.empty, null, 0, -1);
      },
      apply(tr2, hist, state) {
        return applyTransaction(hist, state, tr2, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll) {
  return (state, dispatch2) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch2) {
      let tr2 = histTransaction(hist, state, redo2);
      if (tr2)
        dispatch2(scroll ? tr2.scrollIntoView() : tr2);
    }
    return true;
  };
}
var undo = buildCommand(false, true);
var redo = buildCommand(true, true);
var undoNoScroll = buildCommand(false, false);
var redoNoScroll = buildCommand(true, false);

// node_modules/@tiptap/extension-history/dist/index.js
var History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch: dispatch2 }) => {
        return undo(state, dispatch2);
      },
      redo: () => ({ state, dispatch: dispatch2 }) => {
        return redo(state, dispatch2);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
});

// node_modules/@tiptap/extension-horizontal-rule/dist/index.js
var HorizontalRule = Node3.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: chain2, state }) => {
        const { selection } = state;
        const { $from: $originFrom, $to: $originTo } = selection;
        const currentChain = chain2();
        if ($originFrom.parentOffset === 0) {
          currentChain.insertContentAt({
            from: Math.max($originFrom.pos - 1, 0),
            to: $originTo.pos
          }, {
            type: this.name
          });
        } else if (isNodeSelection(selection)) {
          currentChain.insertContentAt($originTo.pos, {
            type: this.name
          });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ tr: tr2, dispatch: dispatch2 }) => {
          var _a5;
          if (dispatch2) {
            const { $to } = tr2.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr2.setSelection(NodeSelection.create(tr2.doc, $to.pos));
              } else {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos));
              }
            } else {
              const node = (_a5 = $to.parent.type.contentMatch.defaultType) === null || _a5 === void 0 ? void 0 : _a5.create();
              if (node) {
                tr2.insert(posAfter, node);
                tr2.setSelection(TextSelection.create(tr2.doc, posAfter + 1));
              }
            }
            tr2.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-italic/dist/index.js
var starInputRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
var starPasteRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
var underscoreInputRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
var underscorePasteRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
var Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex2,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex2,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-list-item/dist/index.js
var ListItem = Node3.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});

// node_modules/@tiptap/extension-ordered-list/dist/index.js
var ListItemName2 = "listItem";
var TextStyleName2 = "textStyle";
var inputRegex5 = /^(\d+)\.\s$/;
var OrderedList = Node3.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      },
      type: {
        default: void 0,
        parseHTML: (element) => element.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start: start2, ...attributesWithoutStart } = HTMLAttributes;
    return start2 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: commands2, chain: chain2 }) => {
        if (this.options.keepAttributes) {
          return chain2().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex5,
      type: this.type,
      getAttributes: (match) => ({ start: +match[1] }),
      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex5,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName2) }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// node_modules/@tiptap/extension-paragraph/dist/index.js
var Paragraph = Node3.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});

// node_modules/@tiptap/extension-strike/dist/index.js
var inputRegex6 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
var pasteRegex3 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
var Strike = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex3,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-text/dist/index.js
var Text2 = Node3.create({
  name: "text",
  group: "inline"
});

// node_modules/@tiptap/starter-kit/dist/index.js
var StarterKit = Extension.create({
  name: "starterKit",
  addExtensions() {
    var _a5, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const extensions = [];
    if (this.options.bold !== false) {
      extensions.push(Bold.configure((_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.bold));
    }
    if (this.options.blockquote !== false) {
      extensions.push(Blockquote.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.blockquote));
    }
    if (this.options.bulletList !== false) {
      extensions.push(BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
    }
    if (this.options.code !== false) {
      extensions.push(Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
    }
    if (this.options.codeBlock !== false) {
      extensions.push(CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
    }
    if (this.options.document !== false) {
      extensions.push(Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
    }
    if (this.options.dropcursor !== false) {
      extensions.push(Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions.push(Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions.push(HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions.push(Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
    }
    if (this.options.history !== false) {
      extensions.push(History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
    }
    if (this.options.horizontalRule !== false) {
      extensions.push(HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions.push(Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions.push(Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
    }
    if (this.options.strike !== false) {
      extensions.push(Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
    }
    if (this.options.text !== false) {
      extensions.push(Text2.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
    }
    return extensions;
  }
});

// node_modules/tldraw/dist-esm/lib/shapes/shared/defaultFonts.mjs
var DefaultFontFaces = {
  tldraw_draw: {
    normal: {
      normal: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw", format: "woff2" },
        weight: "normal"
      },
      bold: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_bold", format: "woff2" },
        weight: "bold"
      }
    },
    italic: {
      normal: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_sans: {
    normal: {
      normal: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_serif: {
    normal: {
      normal: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_mono: {
    normal: {
      normal: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  }
};
var allDefaultFontFaces = objectMapValues(DefaultFontFaces).flatMap(
  (font) => objectMapValues(font).flatMap((fontFace) => Object.values(fontFace))
);

// node_modules/tldraw/dist-esm/lib/utils/text/textDirection.mjs
var TextDirection = Extension.create({
  name: "textDirection",
  addGlobalAttributes() {
    return [
      {
        types: ["heading", "paragraph"],
        attributes: {
          dir: {
            default: "auto",
            parseHTML: (element) => {
              const dirAttribute = element.getAttribute("dir");
              if (dirAttribute && ["ltr", "rtl", "auto"].includes(dirAttribute)) {
                return dirAttribute;
              } else {
                return "auto";
              }
            },
            renderHTML: (attributes) => {
              return { dir: attributes.dir };
            }
          }
        }
      }
    ];
  }
});

// node_modules/tldraw/dist-esm/lib/utils/text/richText.mjs
var KeyboardShiftEnterTweakExtension = Extension.create({
  name: "keyboardShiftEnterHandler",
  addKeyboardShortcuts() {
    return {
      // We don't support soft breaks, so we just use the default enter command.
      "Shift-Enter": ({ editor }) => editor.commands.enter()
    };
  }
});
Code.config.excludes = void 0;
Highlight.config.priority = 1100;
var tipTapDefaultExtensions = [
  StarterKit.configure({
    blockquote: false,
    codeBlock: false,
    horizontalRule: false
  }),
  Link2.configure({
    openOnClick: false,
    autolink: true
  }),
  Highlight,
  KeyboardShiftEnterTweakExtension,
  TextDirection
];
function renderHtmlFromRichText(editor, richText) {
  var _a5;
  const tipTapExtensions = ((_a5 = editor.getTextOptions().tipTapConfig) == null ? void 0 : _a5.extensions) ?? tipTapDefaultExtensions;
  const html = generateHTML(richText, tipTapExtensions);
  return html.replaceAll('<p dir="auto"></p>', "<p><br /></p>") ?? "";
}
function renderHtmlFromRichTextForMeasurement(editor, richText) {
  const html = renderHtmlFromRichText(editor, richText);
  return `<div class="tl-rich-text">${html}</div>`;
}
var plainTextFromRichTextCache = new WeakCache();
function isEmptyRichText(richText) {
  if (richText.content.length === 1) {
    if (!richText.content[0].content)
      return true;
  }
  return false;
}
function renderPlaintextFromRichText(editor, richText) {
  if (isEmptyRichText(richText))
    return "";
  return plainTextFromRichTextCache.get(richText, () => {
    var _a5;
    const tipTapExtensions = ((_a5 = editor.getTextOptions().tipTapConfig) == null ? void 0 : _a5.extensions) ?? tipTapDefaultExtensions;
    return generateText(richText, tipTapExtensions, {
      blockSeparator: "\n"
    });
  });
}
function renderRichTextFromHTML(editor, html) {
  var _a5;
  const tipTapExtensions = ((_a5 = editor.getTextOptions().tipTapConfig) == null ? void 0 : _a5.extensions) ?? tipTapDefaultExtensions;
  return generateJSON(html, tipTapExtensions);
}
function defaultAddFontsFromNode(node, state, addFont) {
  for (const mark of node.marks) {
    if (mark.type.name === "bold" && state.weight !== "bold") {
      state = { ...state, weight: "bold" };
    }
    if (mark.type.name === "italic" && state.style !== "italic") {
      state = { ...state, style: "italic" };
    }
    if (mark.type.name === "code" && state.family !== "tldraw_mono") {
      state = { ...state, family: "tldraw_mono" };
    }
  }
  const fontsForFamily = getOwnProperty(DefaultFontFaces, state.family);
  if (!fontsForFamily)
    return state;
  const fontsForStyle = getOwnProperty(fontsForFamily, state.style);
  if (!fontsForStyle)
    return state;
  const fontsForWeight = getOwnProperty(fontsForStyle, state.weight);
  if (!fontsForWeight)
    return state;
  addFont(fontsForWeight);
  return state;
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/TextHelpers.mjs
var INDENT = "  ";
var _TextHelpers = class _TextHelpers {
  static normalizeText(text) {
    return text.replace(_TextHelpers.fixNewLines, "\n");
  }
  static normalizeTextForDom(text) {
    return text.replace(_TextHelpers.fixNewLines, "\n").split("\n").map((x) => x || " ").join("\n");
  }
};
__publicField(_TextHelpers, "fixNewLines", /\r?\n|\r/g);
var TextHelpers = _TextHelpers;

// node_modules/tldraw/dist-esm/lib/utils/text/text.mjs
var rtlRegex = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
function isRightToLeftLanguage(text) {
  return rtlRegex.test(text);
}
function replaceTabsWithSpaces(text) {
  return text.replace(/\t/g, INDENT);
}
function stripCommonMinimumIndentation(text) {
  const lines = text.split("\n");
  while (lines[0] && lines[0].trim().length === 0) {
    lines.shift();
  }
  let minIndentation = Infinity;
  for (const line of lines) {
    if (line.trim().length > 0) {
      const indentation = line.length - line.trimStart().length;
      minIndentation = Math.min(minIndentation, indentation);
    }
  }
  return lines.map((line) => line.slice(minIndentation)).join("\n");
}
var COMMON_ENTITY_MAP = {
  "&amp;": "&",
  "&quot;": '"',
  "&apos;": "'",
  "&#27;": "'",
  "&#34;": '"',
  "&#38;": "&",
  "&#39;": "'",
  "&#8211;": "–",
  "&#8212;": "—",
  "&#8216;": "‘",
  "&#8217;": "’",
  "&#8220;": "“",
  "&#8221;": "”",
  "&#8230;": "…"
};
var entityRegex = new RegExp(Object.keys(COMMON_ENTITY_MAP).join("|"), "g");
function convertCommonTitleHTMLEntities(text) {
  return text.replace(entityRegex, (m) => COMMON_ENTITY_MAP[m]);
}
function stripTrailingWhitespace(text) {
  return text.replace(/[ \t]+$/gm, "").replace(/\n+$/, "");
}
function cleanupText(text) {
  return stripTrailingWhitespace(stripCommonMinimumIndentation(replaceTabsWithSpaces(text)));
}
var truncateStringWithEllipsis = (str, maxLength) => {
  return str.length <= maxLength ? str : str.substring(0, maxLength - 3) + "...";
};

// node_modules/tldraw/dist-esm/lib/defaultExternalContentHandlers.mjs
var DEFAULT_MAX_IMAGE_DIMENSION = 5e3;
var DEFAULT_MAX_ASSET_SIZE = 10 * 1024 * 1024;
function registerDefaultExternalContentHandlers(editor, options2) {
  editor.registerExternalAssetHandler("file", async (externalAsset) => {
    return defaultHandleExternalFileAsset(editor, externalAsset, options2);
  });
  editor.registerExternalAssetHandler("url", async (externalAsset) => {
    return defaultHandleExternalUrlAsset(editor, externalAsset, options2);
  });
  editor.registerExternalContentHandler("svg-text", async (externalContent) => {
    return defaultHandleExternalSvgTextContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("embed", (externalContent) => {
    return defaultHandleExternalEmbedContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("files", async (externalContent) => {
    return defaultHandleExternalFileContent(editor, externalContent, options2);
  });
  editor.registerExternalContentHandler("text", async (externalContent) => {
    return defaultHandleExternalTextContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("url", async (externalContent) => {
    return defaultHandleExternalUrlContent(editor, externalContent, options2);
  });
  editor.registerExternalContentHandler("tldraw", async (externalContent) => {
    return defaultHandleExternalTldrawContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("excalidraw", async (externalContent) => {
    return defaultHandleExternalExcalidrawContent(editor, externalContent);
  });
}
async function defaultHandleExternalFileAsset(editor, { file, assetId }, {
  acceptedImageMimeTypes = DEFAULT_SUPPORTED_IMAGE_TYPES,
  acceptedVideoMimeTypes = DEFAULT_SUPPORT_VIDEO_TYPES,
  maxAssetSize = DEFAULT_MAX_ASSET_SIZE,
  maxImageDimension = DEFAULT_MAX_IMAGE_DIMENSION,
  toasts,
  msg: msg2
}) {
  const isImageType = acceptedImageMimeTypes.includes(file.type);
  const isVideoType = acceptedVideoMimeTypes.includes(file.type);
  if (!isImageType && !isVideoType) {
    toasts.addToast({
      title: msg2("assets.files.type-not-allowed"),
      severity: "error"
    });
  }
  assert(isImageType || isVideoType, `File type not allowed: ${file.type}`);
  if (file.size > maxAssetSize) {
    toasts.addToast({
      title: msg2("assets.files.size-too-big"),
      severity: "error"
    });
  }
  assert(
    file.size <= maxAssetSize,
    `File size too big: ${(file.size / 1024).toFixed()}kb > ${(maxAssetSize / 1024).toFixed()}kb`
  );
  const hash4 = getHashForBuffer(await file.arrayBuffer());
  assetId = assetId ?? AssetRecordType.createId(hash4);
  const assetInfo = await getMediaAssetInfoPartial(
    file,
    assetId,
    isImageType,
    isVideoType,
    maxImageDimension
  );
  const result = await editor.uploadAsset(assetInfo, file);
  assetInfo.props.src = result.src;
  if (result.meta)
    assetInfo.meta = { ...assetInfo.meta, ...result.meta };
  return AssetRecordType.create(assetInfo);
}
async function defaultHandleExternalUrlAsset(editor, { url }, { toasts, msg: msg2 }) {
  var _a5, _b, _c, _d, _e;
  let meta;
  try {
    const resp = await fetch(url, {
      method: "GET",
      mode: "no-cors"
    });
    const html = await resp.text();
    const doc3 = new DOMParser().parseFromString(html, "text/html");
    meta = {
      image: ((_a5 = doc3.head.querySelector('meta[property="og:image"]')) == null ? void 0 : _a5.getAttribute("content")) ?? "",
      favicon: ((_b = doc3.head.querySelector('link[rel="apple-touch-icon"]')) == null ? void 0 : _b.getAttribute("href")) ?? ((_c = doc3.head.querySelector('link[rel="icon"]')) == null ? void 0 : _c.getAttribute("href")) ?? "",
      title: ((_d = doc3.head.querySelector('meta[property="og:title"]')) == null ? void 0 : _d.getAttribute("content")) ?? url,
      description: ((_e = doc3.head.querySelector('meta[property="og:description"]')) == null ? void 0 : _e.getAttribute("content")) ?? ""
    };
    if (!meta.image.startsWith("http")) {
      meta.image = new URL(meta.image, url).href;
    }
    if (!meta.favicon.startsWith("http")) {
      meta.favicon = new URL(meta.favicon, url).href;
    }
  } catch (error) {
    console.error(error);
    toasts.addToast({
      title: msg2("assets.url.failed"),
      severity: "error"
    });
    meta = { image: "", favicon: "", title: "", description: "" };
  }
  return {
    id: AssetRecordType.createId(getHashForString(url)),
    typeName: "asset",
    type: "bookmark",
    props: {
      src: url,
      description: meta.description,
      image: meta.image,
      favicon: meta.favicon,
      title: meta.title
    },
    meta: {}
  };
}
async function defaultHandleExternalSvgTextContent(editor, { point, text }) {
  const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageBounds().center);
  const svg = new DOMParser().parseFromString(text, "image/svg+xml").querySelector("svg");
  if (!svg) {
    throw new Error("No <svg/> element present");
  }
  let width = parseFloat(svg.getAttribute("width") || "0");
  let height = parseFloat(svg.getAttribute("height") || "0");
  if (!(width && height)) {
    document.body.appendChild(svg);
    const box = svg.getBoundingClientRect();
    document.body.removeChild(svg);
    width = box.width;
    height = box.height;
  }
  const asset = await editor.getAssetForExternalContent({
    type: "file",
    file: new File([text], "asset.svg", { type: "image/svg+xml" })
  });
  if (!asset)
    throw Error("Could not create an asset");
  createShapesForAssets(editor, [asset], position);
}
function defaultHandleExternalEmbedContent(editor, { point, url, embed }) {
  const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageBounds().center);
  const { width, height } = embed;
  const id = createShapeId();
  const newPoint = maybeSnapToGrid(
    new Vec(position.x - (width || 450) / 2, position.y - (height || 450) / 2),
    editor
  );
  const shapePartial = {
    id,
    type: "embed",
    x: newPoint.x,
    y: newPoint.y,
    props: {
      w: width,
      h: height,
      url
    }
  };
  editor.createShapes([shapePartial]).select(id);
}
async function defaultHandleExternalFileContent(editor, { point, files }, {
  maxAssetSize = DEFAULT_MAX_ASSET_SIZE,
  maxImageDimension = DEFAULT_MAX_IMAGE_DIMENSION,
  acceptedImageMimeTypes = DEFAULT_SUPPORTED_IMAGE_TYPES,
  acceptedVideoMimeTypes = DEFAULT_SUPPORT_VIDEO_TYPES,
  toasts,
  msg: msg2
}) {
  if (files.length > editor.options.maxFilesAtOnce) {
    toasts.addToast({ title: msg2("assets.files.amount-too-big"), severity: "error" });
    return;
  }
  const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageBounds().center);
  const pagePoint = new Vec(position.x, position.y);
  const assetPartials = [];
  const assetsToUpdate = [];
  for (const file of files) {
    if (file.size > maxAssetSize) {
      toasts.addToast({
        title: msg2("assets.files.size-too-big"),
        severity: "error"
      });
      console.warn(
        `File size too big: ${(file.size / 1024).toFixed()}kb > ${(maxAssetSize / 1024).toFixed()}kb`
      );
      continue;
    }
    if (!file.type) {
      toasts.addToast({
        title: msg2("assets.files.upload-failed"),
        severity: "error"
      });
      console.error("No mime type");
      continue;
    }
    const acceptedTypes = [...acceptedImageMimeTypes, ...acceptedVideoMimeTypes];
    if (!acceptedTypes.includes(file.type)) {
      toasts.addToast({
        title: msg2("assets.files.type-not-allowed"),
        severity: "error"
      });
      console.warn(`${file.name} not loaded - Mime type not allowed ${file.type}.`);
      continue;
    }
    const isImageType = acceptedImageMimeTypes.includes(file.type);
    const isVideoType = acceptedVideoMimeTypes.includes(file.type);
    const hash4 = getHashForBuffer(await file.arrayBuffer());
    const assetId = AssetRecordType.createId(hash4);
    const assetInfo = await getMediaAssetInfoPartial(
      file,
      assetId,
      isImageType,
      isVideoType,
      maxImageDimension
    );
    let temporaryAssetPreview;
    if (isImageType) {
      temporaryAssetPreview = editor.createTemporaryAssetPreview(assetId, file);
    }
    assetPartials.push(assetInfo);
    assetsToUpdate.push({ asset: assetInfo, file, temporaryAssetPreview });
  }
  Promise.allSettled(
    assetsToUpdate.map(async (assetAndFile) => {
      try {
        const newAsset = await editor.getAssetForExternalContent({
          type: "file",
          file: assetAndFile.file
        });
        if (!newAsset) {
          throw Error("Could not create an asset");
        }
        editor.updateAssets([{ ...newAsset, id: assetAndFile.asset.id }]);
      } catch (error) {
        toasts.addToast({
          title: msg2("assets.files.upload-failed"),
          severity: "error"
        });
        console.error(error);
        editor.deleteAssets([assetAndFile.asset.id]);
        return;
      }
    })
  );
  createShapesForAssets(editor, assetPartials, pagePoint);
}
async function defaultHandleExternalTextContent(editor, { point, text, html }) {
  const p = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageBounds().center);
  const defaultProps2 = editor.getShapeUtil("text").getDefaultProps();
  const cleanedUpPlaintext = cleanupText(text);
  const richTextToPaste = html ? renderRichTextFromHTML(editor, html) : toRichText(cleanedUpPlaintext);
  let w;
  let h;
  let autoSize;
  let align = "middle";
  const htmlToMeasure = html ?? cleanedUpPlaintext.replace(/\n/g, "<br>");
  const isMultiLine = html ? richTextToPaste.content.length > 1 : cleanedUpPlaintext.split("\n").length > 1;
  const isRtl = isRightToLeftLanguage(cleanedUpPlaintext);
  if (isMultiLine) {
    align = isMultiLine ? isRtl ? "end" : "start" : "middle";
  }
  const rawSize = editor.textMeasure.measureHtml(htmlToMeasure, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[defaultProps2.font],
    fontSize: FONT_SIZES[defaultProps2.size],
    maxWidth: null
  });
  const minWidth = Math.min(
    isMultiLine ? editor.getViewportPageBounds().width * 0.9 : 920,
    Math.max(200, editor.getViewportPageBounds().width * 0.9)
  );
  if (rawSize.w > minWidth) {
    const shrunkSize = editor.textMeasure.measureHtml(htmlToMeasure, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[defaultProps2.font],
      fontSize: FONT_SIZES[defaultProps2.size],
      maxWidth: minWidth
    });
    w = shrunkSize.w;
    h = shrunkSize.h;
    autoSize = false;
    align = isRtl ? "end" : "start";
  } else {
    w = rawSize.w;
    h = rawSize.h;
    autoSize = true;
  }
  if (p.y - h / 2 < editor.getViewportPageBounds().minY + 40) {
    p.y = editor.getViewportPageBounds().minY + 40 + h / 2;
  }
  const newPoint = maybeSnapToGrid(new Vec(p.x - w / 2, p.y - h / 2), editor);
  editor.createShapes([
    {
      id: createShapeId(),
      type: "text",
      x: newPoint.x,
      y: newPoint.y,
      props: {
        richText: richTextToPaste,
        // if the text has more than one line, align it to the left
        textAlign: align,
        autoSize,
        w
      }
    }
  ]);
}
async function defaultHandleExternalUrlContent(editor, { point, url }, { toasts, msg: msg2 }) {
  const embedUtil = editor.getShapeUtil("embed");
  const embedInfo = embedUtil == null ? void 0 : embedUtil.getEmbedDefinition(url);
  if (embedInfo) {
    return editor.putExternalContent({
      type: "embed",
      url: embedInfo.url,
      point,
      embed: embedInfo.definition
    });
  }
  const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageBounds().center);
  const assetId = AssetRecordType.createId(getHashForString(url));
  const shape = createEmptyBookmarkShape(editor, url, position);
  let asset = editor.getAsset(assetId);
  let shouldAlsoCreateAsset = false;
  if (!asset) {
    shouldAlsoCreateAsset = true;
    try {
      const bookmarkAsset = await editor.getAssetForExternalContent({ type: "url", url });
      if (!bookmarkAsset)
        throw Error("Could not create an asset");
      asset = bookmarkAsset;
    } catch {
      toasts.addToast({
        title: msg2("assets.url.failed"),
        severity: "error"
      });
      return;
    }
  }
  editor.run(() => {
    if (shouldAlsoCreateAsset) {
      editor.createAssets([asset]);
    }
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: {
          assetId: asset.id
        }
      }
    ]);
  });
}
async function defaultHandleExternalTldrawContent(editor, { point, content }) {
  editor.run(() => {
    const selectionBoundsBefore = editor.getSelectionPageBounds();
    editor.markHistoryStoppingPoint("paste");
    editor.putContentOntoCurrentPage(content, {
      point,
      select: true
    });
    const selectedBoundsAfter = editor.getSelectionPageBounds();
    if (selectionBoundsBefore && selectedBoundsAfter && (selectionBoundsBefore == null ? void 0 : selectionBoundsBefore.collides(selectedBoundsAfter))) {
      editor.updateInstanceState({ isChangingStyle: true });
      editor.timers.setTimeout(() => {
        editor.updateInstanceState({ isChangingStyle: false });
      }, 150);
    }
  });
}
async function defaultHandleExternalExcalidrawContent(editor, { point, content }) {
  editor.run(() => {
    putExcalidrawContent(editor, content, point);
  });
}
async function getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType, maxImageDimension) {
  let fileType = file.type;
  if (file.type === "video/quicktime") {
    fileType = "video/mp4";
  }
  const size4 = isImageType ? await MediaHelpers.getImageSize(file) : await MediaHelpers.getVideoSize(file);
  const isAnimated = await MediaHelpers.isAnimated(file) || isVideoType;
  const assetInfo = {
    id: assetId,
    type: isImageType ? "image" : "video",
    typeName: "asset",
    props: {
      name: file.name,
      src: "",
      w: size4.w,
      h: size4.h,
      fileSize: file.size,
      mimeType: fileType,
      isAnimated
    },
    meta: {}
  };
  if (maxImageDimension && isFinite(maxImageDimension)) {
    const size22 = { w: assetInfo.props.w, h: assetInfo.props.h };
    const resizedSize = containBoxSize(size22, { w: maxImageDimension, h: maxImageDimension });
    if (size22 !== resizedSize && MediaHelpers.isStaticImageType(file.type)) {
      assetInfo.props.w = resizedSize.w;
      assetInfo.props.h = resizedSize.h;
    }
  }
  return assetInfo;
}
async function createShapesForAssets(editor, assets, position) {
  if (!assets.length)
    return [];
  const currentPoint = Vec.From(position);
  const partials = [];
  for (let i = 0; i < assets.length; i++) {
    const asset = assets[i];
    switch (asset.type) {
      case "image": {
        partials.push({
          id: createShapeId(),
          type: "image",
          x: currentPoint.x,
          y: currentPoint.y,
          opacity: 1,
          props: {
            assetId: asset.id,
            w: asset.props.w,
            h: asset.props.h
          }
        });
        currentPoint.x += asset.props.w;
        break;
      }
      case "video": {
        partials.push({
          id: createShapeId(),
          type: "video",
          x: currentPoint.x,
          y: currentPoint.y,
          opacity: 1,
          props: {
            assetId: asset.id,
            w: asset.props.w,
            h: asset.props.h
          }
        });
        currentPoint.x += asset.props.w;
      }
    }
  }
  editor.run(() => {
    const assetsToCreate = assets.filter((asset) => !editor.getAsset(asset.id));
    editor.store.atomic(() => {
      if (assetsToCreate.length) {
        editor.createAssets(assetsToCreate);
      }
      editor.createShapes(partials).select(...partials.map((p) => p.id));
      centerSelectionAroundPoint(editor, position);
    });
  });
  return partials.map((p) => p.id);
}
function centerSelectionAroundPoint(editor, position) {
  const viewportPageBounds = editor.getViewportPageBounds();
  let selectionPageBounds = editor.getSelectionPageBounds();
  if (selectionPageBounds) {
    const offset5 = selectionPageBounds.center.sub(position);
    editor.updateShapes(
      editor.getSelectedShapes().map((shape) => {
        const localRotation = editor.getShapeParentTransform(shape).decompose().rotation;
        const localDelta = Vec.Rot(offset5, -localRotation);
        return {
          id: shape.id,
          type: shape.type,
          x: shape.x - localDelta.x,
          y: shape.y - localDelta.y
        };
      })
    );
  }
  selectionPageBounds = editor.getSelectionPageBounds();
  if (selectionPageBounds && editor.getInstanceState().isGridMode) {
    const gridSize = editor.getDocumentSettings().gridSize;
    const topLeft = new Vec(selectionPageBounds.minX, selectionPageBounds.minY);
    const gridSnappedPoint = topLeft.clone().snapToGrid(gridSize);
    const delta = Vec.Sub(topLeft, gridSnappedPoint);
    editor.updateShapes(
      editor.getSelectedShapes().map((shape) => {
        const newPoint = { x: shape.x - delta.x, y: shape.y - delta.y };
        return {
          id: shape.id,
          type: shape.type,
          x: newPoint.x,
          y: newPoint.y
        };
      })
    );
  }
  selectionPageBounds = editor.getSelectionPageBounds();
  if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
    editor.zoomToSelection({ animation: { duration: editor.options.animationMediumMs } });
  }
}
function createEmptyBookmarkShape(editor, url, position) {
  const partial = {
    id: createShapeId(),
    type: "bookmark",
    x: position.x - 150,
    y: position.y - 160,
    opacity: 1,
    props: {
      assetId: null,
      url
    }
  };
  editor.run(() => {
    editor.createShapes([partial]).select(partial.id);
    centerSelectionAroundPoint(editor, position);
  });
  return editor.getShape(partial.id);
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/toolStates/Idle.mjs
var Idle2 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "options", this.editor.getShapeUtil("arrow").options);
    __publicField(this, "isPrecise", false);
    __publicField(this, "isPreciseTimerId", null);
    __publicField(this, "preciseTargetId", null);
  }
  onPointerMove() {
    this.update();
  }
  onPointerDown(info) {
    this.parent.transition("pointing", { ...info, isPrecise: this.isPrecise });
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
    this.update();
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
  onExit() {
    clearArrowTargetState(this.editor);
    if (this.isPreciseTimerId !== null) {
      clearTimeout(this.isPreciseTimerId);
    }
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp(info) {
    var _a5;
    this.update();
    if (info.key === "Enter") {
      if (this.editor.getIsReadonly())
        return null;
      const onlySelectedShape = this.editor.getOnlySelectedShape();
      if (onlySelectedShape && this.editor.getShapeUtil(onlySelectedShape).canEdit(onlySelectedShape)) {
        this.editor.setCurrentTool("select");
        this.editor.setEditingShape(onlySelectedShape.id);
        (_a5 = this.editor.root.getCurrent()) == null ? void 0 : _a5.transition("editing_shape", {
          ...info,
          target: "shape",
          shape: onlySelectedShape
        });
      }
    }
  }
  update() {
    const targetState = updateArrowTargetState({
      editor: this.editor,
      pointInPageSpace: this.editor.inputs.currentPagePoint,
      arrow: void 0,
      isPrecise: this.isPrecise,
      isExact: this.editor.inputs.altKey,
      currentBinding: void 0,
      oppositeBinding: void 0
    });
    if (targetState && targetState.target.id !== this.preciseTargetId) {
      if (this.isPreciseTimerId !== null) {
        clearTimeout(this.isPreciseTimerId);
      }
      this.preciseTargetId = targetState.target.id;
      this.isPreciseTimerId = this.editor.timers.setTimeout(() => {
        this.isPrecise = true;
        this.update();
      }, this.options.hoverPreciseTimeout);
    } else if (!targetState && this.preciseTargetId) {
      this.isPrecise = false;
      this.preciseTargetId = null;
      if (this.isPreciseTimerId !== null) {
        clearTimeout(this.isPreciseTimerId);
      }
    }
  }
};
__publicField(Idle2, "id", "idle");

// node_modules/tldraw/dist-esm/lib/shapes/arrow/toolStates/Pointing.mjs
var Pointing2 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "options", this.editor.getShapeUtil("arrow").options);
    __publicField(this, "shape");
    __publicField(this, "isPrecise", false);
    __publicField(this, "isPreciseTimerId", null);
    __publicField(this, "markId", "");
  }
  onEnter(info) {
    this.markId = "";
    this.isPrecise = !!info.isPrecise;
    const targetState = updateArrowTargetState({
      editor: this.editor,
      pointInPageSpace: this.editor.inputs.currentPagePoint,
      arrow: void 0,
      isPrecise: this.isPrecise,
      isExact: this.editor.inputs.altKey,
      currentBinding: void 0,
      oppositeBinding: void 0
    });
    if (!targetState) {
      this.createArrowShape();
    }
    this.startPreciseTimeout();
  }
  onExit() {
    this.shape = void 0;
    clearArrowTargetState(this.editor);
    this.clearPreciseTimeout();
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      if (!this.shape) {
        this.createArrowShape();
      }
      if (!this.shape)
        throw Error(`expected shape`);
      this.updateArrowShapeEndHandle();
      this.editor.setCurrentTool("select.dragging_handle", {
        shape: this.shape,
        handle: { id: "end", type: "vertex", index: "a3", x: 0, y: 0 },
        isCreating: true,
        creatingMarkId: this.markId || void 0,
        onInteractionEnd: "arrow"
      });
    }
  }
  onPointerUp() {
    this.cancel();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    if (this.shape) {
      this.editor.bailToMark(this.markId);
    }
    this.parent.transition("idle");
  }
  createArrowShape() {
    var _a5;
    const { originPagePoint } = this.editor.inputs;
    const id = createShapeId();
    this.markId = this.editor.markHistoryStoppingPoint(`creating_arrow:${id}`);
    const newPoint = maybeSnapToGrid(originPagePoint, this.editor);
    this.editor.createShape({
      id,
      type: "arrow",
      x: newPoint.x,
      y: newPoint.y,
      props: {
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const shape = this.editor.getShape(id);
    if (!shape)
      throw Error(`expected shape`);
    const handles = this.editor.getShapeHandles(shape);
    if (!handles)
      throw Error(`expected handles for arrow`);
    const util = this.editor.getShapeUtil("arrow");
    const initial = this.shape;
    const startHandle = handles.find((h) => h.id === "start");
    const change = (_a5 = util.onHandleDrag) == null ? void 0 : _a5.call(util, shape, {
      handle: { ...startHandle, x: 0, y: 0 },
      isPrecise: true,
      initial
    });
    if (change) {
      this.editor.updateShapes([change]);
    }
    this.shape = this.editor.getShape(id);
    this.editor.select(id);
  }
  updateArrowShapeEndHandle() {
    var _a5, _b;
    const shape = this.shape;
    if (!shape)
      throw Error(`expected shape`);
    const handles = this.editor.getShapeHandles(shape);
    if (!handles)
      throw Error(`expected handles for arrow`);
    {
      const util = this.editor.getShapeUtil("arrow");
      const initial = this.shape;
      const startHandle = handles.find((h) => h.id === "start");
      const change = (_a5 = util.onHandleDrag) == null ? void 0 : _a5.call(util, shape, {
        handle: { ...startHandle, x: 0, y: 0 },
        isPrecise: this.isPrecise,
        initial
      });
      if (change) {
        this.editor.updateShapes([change]);
      }
    }
    {
      const util = this.editor.getShapeUtil("arrow");
      const initial = this.shape;
      const point = this.editor.getPointInShapeSpace(shape, this.editor.inputs.currentPagePoint);
      const endHandle = handles.find((h) => h.id === "end");
      const change = (_b = util.onHandleDrag) == null ? void 0 : _b.call(util, this.editor.getShape(shape), {
        handle: { ...endHandle, x: point.x, y: point.y },
        isPrecise: false,
        initial
      });
      if (change) {
        this.editor.updateShapes([change]);
      }
    }
    this.shape = this.editor.getShape(shape.id);
  }
  startPreciseTimeout() {
    this.isPreciseTimerId = this.editor.timers.setTimeout(() => {
      if (!this.getIsActive())
        return;
      this.isPrecise = true;
    }, this.options.pointingPreciseTimeout);
  }
  clearPreciseTimeout() {
    if (this.isPreciseTimerId !== null) {
      clearTimeout(this.isPreciseTimerId);
    }
  }
};
__publicField(Pointing2, "id", "pointing");

// node_modules/tldraw/dist-esm/lib/shapes/arrow/ArrowShapeTool.mjs
var ArrowShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "arrow");
  }
  static children() {
    return [Idle2, Pointing2];
  }
};
__publicField(ArrowShapeTool, "id", "arrow");
__publicField(ArrowShapeTool, "initial", "idle");

// node_modules/tldraw/dist-esm/lib/shapes/draw/toolStates/Drawing.mjs
var Drawing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "initialShape");
    __publicField(this, "shapeType", this.parent.id === "highlight" ? "highlight" : "draw");
    __publicField(this, "util", this.editor.getShapeUtil(this.shapeType));
    __publicField(this, "isPen", false);
    __publicField(this, "isPenOrStylus", false);
    __publicField(this, "segmentMode", "free");
    __publicField(this, "didJustShiftClickToExtendPreviousShapeLine", false);
    __publicField(this, "pagePointWhereCurrentSegmentChanged", {});
    __publicField(this, "pagePointWhereNextSegmentChanged", null);
    __publicField(this, "lastRecordedPoint", {});
    __publicField(this, "mergeNextPoint", false);
    __publicField(this, "currentLineLength", 0);
    __publicField(this, "markId", null);
  }
  onEnter(info) {
    this.markId = null;
    this.info = info;
    this.lastRecordedPoint = this.editor.inputs.currentPagePoint.clone();
    this.startShape();
  }
  onPointerMove() {
    const { inputs } = this.editor;
    if (this.isPen && !inputs.isPen) {
      if (this.markId) {
        this.editor.bailToMark(this.markId);
        this.startShape();
        return;
      }
    }
    if (this.isPenOrStylus) {
      if (Vec.Dist(inputs.currentPagePoint, this.lastRecordedPoint) >= 1 / this.editor.getZoomLevel()) {
        this.lastRecordedPoint = inputs.currentPagePoint.clone();
        this.mergeNextPoint = false;
      } else {
        this.mergeNextPoint = true;
      }
    } else {
      this.mergeNextPoint = false;
    }
    this.updateDrawingShape();
  }
  onKeyDown(info) {
    if (info.key === "Shift") {
      switch (this.segmentMode) {
        case "free": {
          this.segmentMode = "starting_straight";
          this.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_free": {
          this.segmentMode = "starting_straight";
        }
      }
    }
    this.updateDrawingShape();
  }
  onKeyUp(info) {
    if (info.key === "Shift") {
      this.editor.snaps.clearIndicators();
      switch (this.segmentMode) {
        case "straight": {
          this.segmentMode = "starting_free";
          this.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_straight": {
          this.pagePointWhereNextSegmentChanged = null;
          this.segmentMode = "free";
          break;
        }
      }
    }
    this.updateDrawingShape();
  }
  onExit() {
    this.editor.snaps.clearIndicators();
    this.pagePointWhereCurrentSegmentChanged = this.editor.inputs.currentPagePoint.clone();
  }
  canClose() {
    return this.shapeType !== "highlight";
  }
  getIsClosed(segments, size4, scale) {
    if (!this.canClose())
      return false;
    const strokeWidth = STROKE_SIZES2[size4];
    const firstPoint = segments[0].points[0];
    const lastSegment = segments[segments.length - 1];
    const lastPoint = lastSegment.points[lastSegment.points.length - 1];
    return firstPoint !== lastPoint && this.currentLineLength > strokeWidth * 4 * scale && Vec.DistMin(firstPoint, lastPoint, strokeWidth * 2 * scale);
  }
  startShape() {
    const {
      inputs: { originPagePoint, isPen }
    } = this.editor;
    this.markId = this.editor.markHistoryStoppingPoint("draw start");
    const { z = 0.5 } = this.info.point;
    this.isPen = isPen;
    this.isPenOrStylus = isPen || z > 0 && z < 0.5 || z > 0.5 && z < 1;
    const pressure = this.isPenOrStylus ? z * 1.25 : 0.5;
    this.segmentMode = this.editor.inputs.shiftKey ? "straight" : "free";
    this.didJustShiftClickToExtendPreviousShapeLine = false;
    this.lastRecordedPoint = originPagePoint.clone();
    if (this.initialShape) {
      const shape = this.editor.getShape(this.initialShape.id);
      if (shape && this.segmentMode === "straight") {
        this.didJustShiftClickToExtendPreviousShapeLine = true;
        const prevSegment = last(shape.props.segments);
        if (!prevSegment)
          throw Error("Expected a previous segment!");
        const prevPoint = last(prevSegment.points);
        if (!prevPoint)
          throw Error("Expected a previous point!");
        const { x, y } = this.editor.getPointInShapeSpace(shape, originPagePoint).toFixed();
        const newSegment = {
          type: this.segmentMode,
          points: [
            {
              x: prevPoint.x,
              y: prevPoint.y,
              z: +pressure.toFixed(2)
            },
            {
              x,
              y,
              z: +pressure.toFixed(2)
            }
          ]
        };
        const prevPointPageSpace = Mat.applyToPoint(
          this.editor.getShapePageTransform(shape.id),
          prevPoint
        );
        this.pagePointWhereCurrentSegmentChanged = prevPointPageSpace;
        this.pagePointWhereNextSegmentChanged = null;
        const segments = [...shape.props.segments, newSegment];
        if (this.currentLineLength < STROKE_SIZES2[shape.props.size] * 4) {
          this.currentLineLength = this.getLineLength(segments);
        }
        const shapePartial = {
          id: shape.id,
          type: this.shapeType,
          props: {
            segments
          }
        };
        if (this.canClose()) {
          ;
          shapePartial.props.isClosed = this.getIsClosed(
            segments,
            shape.props.size,
            shape.props.scale
          );
        }
        this.editor.updateShapes([shapePartial]);
        return;
      }
    }
    this.pagePointWhereCurrentSegmentChanged = originPagePoint.clone();
    const id = createShapeId();
    this.editor.createShapes([
      {
        id,
        type: this.shapeType,
        x: originPagePoint.x,
        y: originPagePoint.y,
        props: {
          isPen: this.isPenOrStylus,
          scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,
          segments: [
            {
              type: this.segmentMode,
              points: [
                {
                  x: 0,
                  y: 0,
                  z: +pressure.toFixed(2)
                }
              ]
            }
          ]
        }
      }
    ]);
    this.currentLineLength = 0;
    this.initialShape = this.editor.getShape(id);
  }
  updateDrawingShape() {
    const { initialShape } = this;
    const { inputs } = this.editor;
    if (!initialShape)
      return;
    const {
      id,
      props: { size: size4, scale }
    } = initialShape;
    const shape = this.editor.getShape(id);
    if (!shape)
      return;
    const { segments } = shape.props;
    const { x, y, z } = this.editor.getPointInShapeSpace(shape, inputs.currentPagePoint).toFixed();
    const pressure = this.isPenOrStylus ? +(inputs.currentPagePoint.z * 1.25).toFixed(2) : 0.5;
    const newPoint = { x, y, z: pressure };
    switch (this.segmentMode) {
      case "starting_straight": {
        const { pagePointWhereNextSegmentChanged } = this;
        if (pagePointWhereNextSegmentChanged === null) {
          throw Error("We should have a point where the segment changed");
        }
        const hasMovedFarEnough = Vec.Dist2(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > this.editor.options.dragDistanceSquared;
        if (hasMovedFarEnough) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone();
          this.pagePointWhereNextSegmentChanged = null;
          this.segmentMode = "straight";
          const prevSegment = last(segments);
          if (!prevSegment)
            throw Error("Expected a previous segment!");
          const prevLastPoint = last(prevSegment.points);
          if (!prevLastPoint)
            throw Error("Expected a previous last point!");
          let newSegment;
          const newLastPoint = this.editor.getPointInShapeSpace(shape, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson();
          if (prevSegment.type === "straight") {
            this.currentLineLength += Vec.Dist(prevLastPoint, newLastPoint);
            newSegment = {
              type: "straight",
              points: [{ ...prevLastPoint }, newLastPoint]
            };
            const transform = this.editor.getShapePageTransform(shape);
            this.pagePointWhereCurrentSegmentChanged = Mat.applyToPoint(transform, prevLastPoint);
          } else {
            newSegment = {
              type: "straight",
              points: [newLastPoint, newPoint]
            };
          }
          const shapePartial = {
            id,
            type: this.shapeType,
            props: {
              segments: [...segments, newSegment]
            }
          };
          if (this.canClose()) {
            ;
            shapePartial.props.isClosed = this.getIsClosed(
              segments,
              size4,
              scale
            );
          }
          this.editor.updateShapes([shapePartial]);
        }
        break;
      }
      case "starting_free": {
        const { pagePointWhereNextSegmentChanged } = this;
        if (pagePointWhereNextSegmentChanged === null) {
          throw Error("We should have a point where the segment changed");
        }
        const hasMovedFarEnough = Vec.Dist2(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > this.editor.options.dragDistanceSquared;
        if (hasMovedFarEnough) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone();
          this.pagePointWhereNextSegmentChanged = null;
          this.segmentMode = "free";
          const newSegments = segments.slice();
          const prevStraightSegment = newSegments[newSegments.length - 1];
          const prevPoint = last(prevStraightSegment.points);
          if (!prevPoint) {
            throw Error("No previous point!");
          }
          const newFreeSegment = {
            type: "free",
            points: [
              ...Vec.PointsBetween(prevPoint, newPoint, 6).map((p) => ({
                x: toFixed(p.x),
                y: toFixed(p.y),
                z: toFixed(p.z)
              }))
            ]
          };
          const finalSegments = [...newSegments, newFreeSegment];
          if (this.currentLineLength < STROKE_SIZES2[shape.props.size] * 4) {
            this.currentLineLength = this.getLineLength(finalSegments);
          }
          const shapePartial = {
            id,
            type: this.shapeType,
            props: {
              segments: finalSegments
            }
          };
          if (this.canClose()) {
            ;
            shapePartial.props.isClosed = this.getIsClosed(
              finalSegments,
              size4,
              scale
            );
          }
          this.editor.updateShapes([shapePartial]);
        }
        break;
      }
      case "straight": {
        const newSegments = segments.slice();
        const newSegment = newSegments[newSegments.length - 1];
        const { pagePointWhereCurrentSegmentChanged } = this;
        const { ctrlKey, currentPagePoint } = this.editor.inputs;
        if (!pagePointWhereCurrentSegmentChanged)
          throw Error("We should have a point where the segment changed");
        let pagePoint;
        let shouldSnapToAngle = false;
        if (this.didJustShiftClickToExtendPreviousShapeLine) {
          if (this.editor.inputs.isDragging) {
            shouldSnapToAngle = !ctrlKey;
            this.didJustShiftClickToExtendPreviousShapeLine = false;
          } else {
          }
        } else {
          shouldSnapToAngle = !ctrlKey;
        }
        let newPoint2 = this.editor.getPointInShapeSpace(shape, currentPagePoint).toFixed().toJson();
        let didSnap = false;
        let snapSegment = void 0;
        const shouldSnap = this.editor.user.getIsSnapMode() ? !ctrlKey : ctrlKey;
        if (shouldSnap) {
          if (newSegments.length > 2) {
            let nearestPoint = void 0;
            let minDistance = 8 / this.editor.getZoomLevel();
            for (let i = 0, n = segments.length - 2; i < n; i++) {
              const segment = segments[i];
              if (!segment)
                break;
              if (segment.type === "free")
                continue;
              const first2 = segment.points[0];
              const lastPoint = last(segment.points);
              if (!(first2 && lastPoint))
                continue;
              const nearestPointOnSegment = Vec.NearestPointOnLineSegment(
                first2,
                lastPoint,
                newPoint2
              );
              if (Vec.DistMin(nearestPointOnSegment, newPoint2, minDistance)) {
                nearestPoint = nearestPointOnSegment.toFixed().toJson();
                minDistance = Vec.Dist(nearestPointOnSegment, newPoint2);
                snapSegment = segment;
                break;
              }
            }
            if (nearestPoint) {
              didSnap = true;
              newPoint2 = nearestPoint;
            }
          }
        }
        if (didSnap && snapSegment) {
          const transform = this.editor.getShapePageTransform(shape);
          const first2 = snapSegment.points[0];
          const lastPoint = last(snapSegment.points);
          if (!lastPoint)
            throw Error("Expected a last point!");
          const A = Mat.applyToPoint(transform, first2);
          const B = Mat.applyToPoint(transform, lastPoint);
          const snappedPoint = Mat.applyToPoint(transform, newPoint2);
          this.editor.snaps.setIndicators([
            {
              id: uniqueId(),
              type: "points",
              points: [A, snappedPoint, B]
            }
          ]);
        } else {
          this.editor.snaps.clearIndicators();
          if (shouldSnapToAngle) {
            const currentAngle = Vec.Angle(pagePointWhereCurrentSegmentChanged, currentPagePoint);
            const snappedAngle = snapAngle(currentAngle, 24);
            const angleDiff = snappedAngle - currentAngle;
            pagePoint = Vec.RotWith(
              currentPagePoint,
              pagePointWhereCurrentSegmentChanged,
              angleDiff
            );
          } else {
            pagePoint = currentPagePoint;
          }
          newPoint2 = this.editor.getPointInShapeSpace(shape, pagePoint).toFixed().toJson();
        }
        this.currentLineLength += Vec.Dist(newSegment.points[0], newPoint2);
        newSegments[newSegments.length - 1] = {
          ...newSegment,
          type: "straight",
          points: [newSegment.points[0], newPoint2]
        };
        const shapePartial = {
          id,
          type: this.shapeType,
          props: {
            segments: newSegments
          }
        };
        if (this.canClose()) {
          ;
          shapePartial.props.isClosed = this.getIsClosed(
            segments,
            size4,
            scale
          );
        }
        this.editor.updateShapes([shapePartial]);
        break;
      }
      case "free": {
        const newSegments = segments.slice();
        const newSegment = newSegments[newSegments.length - 1];
        const newPoints = [...newSegment.points];
        if (newPoints.length && this.mergeNextPoint) {
          const { z: z2 } = newPoints[newPoints.length - 1];
          newPoints[newPoints.length - 1] = {
            x: newPoint.x,
            y: newPoint.y,
            z: z2 ? Math.max(z2, newPoint.z) : newPoint.z
          };
        } else {
          this.currentLineLength += Vec.Dist(newPoints[newPoints.length - 1], newPoint);
          newPoints.push(newPoint);
        }
        newSegments[newSegments.length - 1] = {
          ...newSegment,
          points: newPoints
        };
        if (this.currentLineLength < STROKE_SIZES2[shape.props.size] * 4) {
          this.currentLineLength = this.getLineLength(newSegments);
        }
        const shapePartial = {
          id,
          type: this.shapeType,
          props: {
            segments: newSegments
          }
        };
        if (this.canClose()) {
          ;
          shapePartial.props.isClosed = this.getIsClosed(
            newSegments,
            size4,
            scale
          );
        }
        this.editor.updateShapes([shapePartial]);
        if (newPoints.length > this.util.options.maxPointsPerShape) {
          this.editor.updateShapes([{ id, type: this.shapeType, props: { isComplete: true } }]);
          const newShapeId = createShapeId();
          const props = this.editor.getShape(id).props;
          this.editor.createShapes([
            {
              id: newShapeId,
              type: this.shapeType,
              x: toFixed(inputs.currentPagePoint.x),
              y: toFixed(inputs.currentPagePoint.y),
              props: {
                isPen: this.isPenOrStylus,
                scale: props.scale,
                segments: [
                  {
                    type: "free",
                    points: [{ x: 0, y: 0, z: this.isPenOrStylus ? +(z * 1.25).toFixed() : 0.5 }]
                  }
                ]
              }
            }
          ]);
          this.initialShape = structuredClone(this.editor.getShape(newShapeId));
          this.mergeNextPoint = false;
          this.lastRecordedPoint = inputs.currentPagePoint.clone();
          this.currentLineLength = 0;
        }
        break;
      }
    }
  }
  getLineLength(segments) {
    let length = 0;
    for (const segment of segments) {
      for (let i = 0; i < segment.points.length - 1; i++) {
        const A = segment.points[i];
        const B = segment.points[i + 1];
        length += Vec.Dist2(B, A);
      }
    }
    return Math.sqrt(length);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    if (this.editor.inputs.isDragging) {
      return;
    }
    if (this.markId) {
      this.editor.bailToMark(this.markId);
    }
    this.cancel();
  }
  complete() {
    const { initialShape } = this;
    if (!initialShape)
      return;
    this.editor.updateShapes([
      { id: initialShape.id, type: initialShape.type, props: { isComplete: true } }
    ]);
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
};
__publicField(Drawing, "id", "drawing");

// node_modules/tldraw/dist-esm/lib/shapes/draw/toolStates/Idle.mjs
var Idle3 = class extends StateNode {
  onPointerDown(info) {
    this.parent.transition("drawing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle3, "id", "idle");

// node_modules/tldraw/dist-esm/lib/shapes/draw/DrawShapeTool.mjs
var DrawShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "draw");
  }
  static children() {
    return [Idle3, Drawing];
  }
  onExit() {
    const drawingState = this.children["drawing"];
    drawingState.initialShape = void 0;
  }
};
__publicField(DrawShapeTool, "id", "draw");
__publicField(DrawShapeTool, "initial", "idle");
__publicField(DrawShapeTool, "isLockable", false);
__publicField(DrawShapeTool, "useCoalescedEvents", true);

// node_modules/tldraw/dist-esm/lib/shapes/frame/FrameShapeTool.mjs
var FrameShapeTool = class extends BaseBoxShapeTool {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "frame");
  }
  onCreate(shape) {
    if (!shape)
      return;
    const bounds = this.editor.getShapePageBounds(shape);
    const shapesToAddToFrame = [];
    const ancestorIds = this.editor.getShapeAncestors(shape).map((shape2) => shape2.id);
    this.editor.getSortedChildIdsForParent(shape.parentId).map((siblingShapeId) => {
      const siblingShape = this.editor.getShape(siblingShapeId);
      if (!siblingShape)
        return;
      if (siblingShape.id === shape.id)
        return;
      if (siblingShape.isLocked)
        return;
      const pageShapeBounds = this.editor.getShapePageBounds(siblingShape);
      if (!pageShapeBounds)
        return;
      if (bounds.contains(pageShapeBounds)) {
        if (canEnclose(siblingShape, ancestorIds, shape)) {
          shapesToAddToFrame.push(siblingShape.id);
        }
      }
    });
    this.editor.reparentShapes(shapesToAddToFrame, shape.id);
    if (this.editor.getInstanceState().isToolLocked) {
      this.editor.setCurrentTool("frame");
    } else {
      this.editor.setCurrentTool("select.idle");
    }
  }
};
__publicField(FrameShapeTool, "id", "frame");
__publicField(FrameShapeTool, "initial", "idle");
function canEnclose(shape, ancestorIds, frame2) {
  if (ancestorIds.includes(shape.id)) {
    return false;
  }
  if (shape.parentId === frame2.parentId) {
    return true;
  }
  return false;
}

// node_modules/tldraw/dist-esm/lib/shapes/geo/toolStates/Idle.mjs
var Idle4 = class extends StateNode {
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onKeyUp(info) {
    var _a5;
    if (info.key === "Enter") {
      if (this.editor.getIsReadonly())
        return null;
      const onlySelectedShape = this.editor.getOnlySelectedShape();
      if (onlySelectedShape && this.editor.getShapeUtil(onlySelectedShape).canEdit(onlySelectedShape)) {
        this.editor.setCurrentTool("select");
        this.editor.setEditingShape(onlySelectedShape.id);
        (_a5 = this.editor.root.getCurrent()) == null ? void 0 : _a5.transition("editing_shape", {
          ...info,
          target: "shape",
          shape: onlySelectedShape
        });
      }
    }
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle4, "id", "idle");

// node_modules/tldraw/dist-esm/lib/shapes/geo/toolStates/Pointing.mjs
var Pointing3 = class extends StateNode {
  onPointerUp() {
    this.complete();
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      const { originPagePoint } = this.editor.inputs;
      const id = createShapeId();
      const creatingMarkId = this.editor.markHistoryStoppingPoint(`creating_geo:${id}`);
      const newPoint = maybeSnapToGrid(originPagePoint, this.editor);
      this.editor.createShapes([
        {
          id,
          type: "geo",
          x: newPoint.x,
          y: newPoint.y,
          props: {
            w: 1,
            h: 1,
            geo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),
            scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
          }
        }
      ]).select(id).setCurrentTool("select.resizing", {
        ...info,
        target: "selection",
        handle: "bottom_right",
        isCreating: true,
        creatingMarkId,
        creationCursorOffset: { x: 1, y: 1 },
        onInteractionEnd: "geo"
      });
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { originPagePoint } = this.editor.inputs;
    const id = createShapeId();
    this.editor.markHistoryStoppingPoint(`creating_geo:${id}`);
    const scale = this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1;
    const geo = this.editor.getStyleForNextShape(GeoShapeGeoStyle);
    const size4 = geo === "star" ? { w: 200, h: 190 } : geo === "cloud" ? { w: 300, h: 180 } : { w: 200, h: 200 };
    this.editor.createShapes([
      {
        id,
        type: "geo",
        x: originPagePoint.x,
        y: originPagePoint.y,
        props: {
          geo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),
          scale,
          ...size4
        }
      }
    ]);
    const shape = this.editor.getShape(id);
    if (!shape)
      return;
    const { w, h } = shape.props;
    const delta = new Vec(w / 2, h / 2).mul(scale);
    const parentTransform = this.editor.getShapeParentTransform(shape);
    if (parentTransform)
      delta.rot(-parentTransform.rotation());
    const newPoint = maybeSnapToGrid(new Vec(shape.x - delta.x, shape.y - delta.y), this.editor);
    this.editor.select(id);
    this.editor.updateShape({
      id: shape.id,
      type: "geo",
      x: newPoint.x,
      y: newPoint.y,
      props: {
        geo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),
        w: w * scale,
        h: h * scale
      }
    });
    if (this.editor.getInstanceState().isToolLocked) {
      this.parent.transition("idle");
    } else {
      this.editor.setCurrentTool("select", {});
    }
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(Pointing3, "id", "pointing");

// node_modules/tldraw/dist-esm/lib/shapes/geo/GeoShapeTool.mjs
var GeoShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "geo");
  }
  static children() {
    return [Idle4, Pointing3];
  }
};
__publicField(GeoShapeTool, "id", "geo");
__publicField(GeoShapeTool, "initial", "idle");

// node_modules/tldraw/dist-esm/lib/shapes/highlight/HighlightShapeTool.mjs
var HighlightShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "highlight");
  }
  static children() {
    return [Idle3, Drawing];
  }
  onExit() {
    const drawingState = this.children["drawing"];
    drawingState.initialShape = void 0;
  }
};
__publicField(HighlightShapeTool, "id", "highlight");
__publicField(HighlightShapeTool, "initial", "idle");
__publicField(HighlightShapeTool, "useCoalescedEvents", true);
__publicField(HighlightShapeTool, "isLockable", false);

// node_modules/tldraw/dist-esm/lib/shapes/line/toolStates/Idle.mjs
var Idle5 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeId", "");
  }
  onEnter(info) {
    this.shapeId = info.shapeId;
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onPointerDown() {
    this.parent.transition("pointing", { shapeId: this.shapeId });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle5, "id", "idle");

// node_modules/tldraw/dist-esm/lib/shapes/line/toolStates/Pointing.mjs
var MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES = 2;
var Pointing4 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shape", {});
    __publicField(this, "markId");
  }
  onEnter(info) {
    const { inputs } = this.editor;
    const { currentPagePoint } = inputs;
    this.markId = void 0;
    const shape = info.shapeId && this.editor.getShape(info.shapeId);
    if (shape && inputs.shiftKey) {
      this.markId = this.editor.markHistoryStoppingPoint(`creating_line:${shape.id}`);
      this.shape = shape;
      const handles = this.editor.getShapeHandles(this.shape);
      if (!handles)
        return;
      const vertexHandles = handles.filter((h) => h.type === "vertex").sort(sortByIndex);
      const endHandle = vertexHandles[vertexHandles.length - 1];
      const prevEndHandle = vertexHandles[vertexHandles.length - 2];
      const shapePagePoint = Mat.applyToPoint(
        this.editor.getShapeParentTransform(this.shape),
        new Vec(this.shape.x, this.shape.y)
      );
      const nudgedPoint = Vec.Sub(currentPagePoint, shapePagePoint).addXY(0.1, 0.1);
      const nextPoint = maybeSnapToGrid(nudgedPoint, this.editor);
      const points = structuredClone(this.shape.props.points);
      if (Vec.DistMin(endHandle, prevEndHandle, MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES) || Vec.DistMin(nextPoint, endHandle, MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES)) {
        points[endHandle.id] = {
          id: endHandle.id,
          index: endHandle.index,
          x: nextPoint.x,
          y: nextPoint.y
        };
      } else {
        const nextIndex = getIndexAbove(endHandle.index);
        points[nextIndex] = {
          id: nextIndex,
          index: nextIndex,
          x: nextPoint.x,
          y: nextPoint.y
        };
      }
      this.editor.updateShapes([
        {
          id: this.shape.id,
          type: this.shape.type,
          props: {
            points
          }
        }
      ]);
    } else {
      const id = createShapeId();
      this.markId = this.editor.markHistoryStoppingPoint(`creating_line:${id}`);
      const newPoint = maybeSnapToGrid(currentPagePoint, this.editor);
      this.editor.createShapes([
        {
          id,
          type: "line",
          x: newPoint.x,
          y: newPoint.y,
          props: {
            scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
          }
        }
      ]);
      this.editor.select(id);
      this.shape = this.editor.getShape(id);
    }
  }
  onPointerMove() {
    if (!this.shape)
      return;
    if (this.editor.inputs.isDragging) {
      const handles = this.editor.getShapeHandles(this.shape);
      if (!handles) {
        if (this.markId)
          this.editor.bailToMark(this.markId);
        throw Error("No handles found");
      }
      const lastHandle = last(handles);
      this.editor.setCurrentTool("select.dragging_handle", {
        shape: this.shape,
        isCreating: true,
        creatingMarkId: this.markId,
        // remove the offset that we added to the handle when we created it
        handle: { ...lastHandle, x: lastHandle.x - 0.1, y: lastHandle.y - 0.1 },
        onInteractionEnd: "line"
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.parent.transition("idle");
    if (this.markId)
      this.editor.bailToMark(this.markId);
    this.editor.snaps.clearIndicators();
  }
  complete() {
    this.parent.transition("idle", { shapeId: this.shape.id });
    this.editor.snaps.clearIndicators();
  }
  cancel() {
    if (this.markId)
      this.editor.bailToMark(this.markId);
    this.parent.transition("idle", { shapeId: this.shape.id });
    this.editor.snaps.clearIndicators();
  }
};
__publicField(Pointing4, "id", "pointing");

// node_modules/tldraw/dist-esm/lib/shapes/line/LineShapeTool.mjs
var LineShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "line");
  }
  static children() {
    return [Idle5, Pointing4];
  }
};
__publicField(LineShapeTool, "id", "line");
__publicField(LineShapeTool, "initial", "idle");

// node_modules/tldraw/dist-esm/lib/shapes/note/toolStates/Idle.mjs
var Idle6 = class extends StateNode {
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle6, "id", "idle");

// node_modules/tldraw/dist-esm/lib/shapes/note/noteHelpers.mjs
var CLONE_HANDLE_MARGIN = 0;
var NOTE_SIZE = 200;
var NOTE_CENTER_OFFSET = new Vec(NOTE_SIZE / 2, NOTE_SIZE / 2);
var NOTE_ADJACENT_POSITION_SNAP_RADIUS = 10;
var BASE_NOTE_POSITIONS = (editor) => [
  [
    ["a1"],
    new Vec(NOTE_SIZE * 0.5, NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin)
  ],
  // t
  [
    ["a2"],
    new Vec(NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5)
  ],
  // r
  [
    ["a3"],
    new Vec(NOTE_SIZE * 0.5, NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin)
  ],
  // b
  [
    ["a4"],
    new Vec(NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5)
  ]
  // l
];
function getBaseAdjacentNotePositions(editor, scale) {
  if (scale === 1)
    return BASE_NOTE_POSITIONS(editor);
  const s = NOTE_SIZE * scale;
  const m = editor.options.adjacentShapeMargin * scale;
  return [
    [["a1"], new Vec(s * 0.5, s * -0.5 - m)],
    // t
    [["a2"], new Vec(s * 1.5 + m, s * 0.5)],
    // r
    [["a3"], new Vec(s * 0.5, s * 1.5 + m)],
    // b
    [["a4"], new Vec(s * -0.5 - m, s * 0.5)]
    // l
  ];
}
function getNoteAdjacentPositions(editor, pagePoint, pageRotation, growY, extraHeight, scale) {
  return Object.fromEntries(
    getBaseAdjacentNotePositions(editor, scale).map(([id, v], i) => {
      const point = v.clone();
      if (i === 0 && extraHeight) {
        point.y -= extraHeight;
      } else if (i === 2 && growY) {
        point.y += growY;
      }
      return [id, point.rot(pageRotation).add(pagePoint)];
    })
  );
}
function getAvailableNoteAdjacentPositions(editor, rotation, scale, extraHeight) {
  const selectedShapeIds = new Set(editor.getSelectedShapeIds());
  const minSize = (NOTE_SIZE + editor.options.adjacentShapeMargin + extraHeight) ** 2;
  const allCenters = /* @__PURE__ */ new Map();
  const positions = [];
  for (const shape of editor.getCurrentPageShapes()) {
    if (!editor.isShapeOfType(shape, "note") || scale !== shape.props.scale || selectedShapeIds.has(shape.id)) {
      continue;
    }
    const transform = editor.getShapePageTransform(shape.id);
    if (rotation !== transform.rotation())
      continue;
    allCenters.set(shape, editor.getShapePageBounds(shape).center);
    positions.push(
      ...Object.values(
        getNoteAdjacentPositions(
          editor,
          transform.point(),
          rotation,
          shape.props.growY,
          extraHeight,
          scale
        )
      )
    );
  }
  const len = positions.length;
  let position;
  for (const [shape, center] of allCenters) {
    for (let i = 0; i < len; i++) {
      position = positions[i];
      if (!position)
        continue;
      if (Vec.Dist2(center, position) > minSize)
        continue;
      if (editor.isPointInShape(shape, position)) {
        positions[i] = void 0;
      }
    }
  }
  return compact(positions);
}
function getNoteShapeForAdjacentPosition(editor, shape, center, pageRotation, forceNew = false) {
  let nextNote;
  const allShapesOnPage = editor.getCurrentPageShapesSorted();
  const minDistance = (NOTE_SIZE + editor.options.adjacentShapeMargin ** 2) ** shape.props.scale;
  for (let i = allShapesOnPage.length - 1; i >= 0; i--) {
    const otherNote = allShapesOnPage[i];
    if (otherNote.type === "note" && otherNote.id !== shape.id) {
      const otherBounds = editor.getShapePageBounds(otherNote);
      if (otherBounds && Vec.Dist2(otherBounds.center, center) < minDistance && editor.isPointInShape(otherNote, center)) {
        nextNote = otherNote;
        break;
      }
    }
  }
  editor.complete();
  if (!nextNote || forceNew) {
    editor.markHistoryStoppingPoint("creating note shape");
    const id = createShapeId();
    editor.createShape({
      id,
      type: "note",
      x: center.x,
      y: center.y,
      rotation: pageRotation,
      opacity: shape.opacity,
      props: {
        // Use the props of the shape we're cloning
        ...shape.props,
        richText: toRichText(""),
        growY: 0,
        fontSizeAdjustment: 0,
        url: ""
      }
    });
    const createdShape = editor.getShape(id);
    if (!createdShape)
      return;
    const topLeft = editor.getPointInParentSpace(
      createdShape,
      Vec.Sub(
        center,
        Vec.Rot(NOTE_CENTER_OFFSET.clone().mul(createdShape.props.scale), pageRotation)
      )
    );
    editor.updateShape({
      id,
      type: "note",
      x: topLeft.x,
      y: topLeft.y
    });
    nextNote = editor.getShape(id);
  }
  editor.zoomToSelectionIfOffscreen(16, {
    animation: {
      duration: editor.options.animationMediumMs
    },
    inset: 0
  });
  return nextNote;
}

// node_modules/tldraw/dist-esm/lib/shapes/note/toolStates/Pointing.mjs
var Pointing5 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "dragged", false);
    __publicField(this, "info", {});
    __publicField(this, "markId", "");
    __publicField(this, "shape", {});
  }
  onEnter() {
    const { editor } = this;
    const id = createShapeId();
    this.markId = editor.markHistoryStoppingPoint(`creating_note:${id}`);
    const center = this.editor.inputs.originPagePoint.clone();
    const offset5 = getNoteShapeAdjacentPositionOffset(
      this.editor,
      center,
      this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
    );
    if (offset5) {
      center.sub(offset5);
    }
    this.shape = createNoteShape(this.editor, id, center);
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      this.editor.setCurrentTool("select.translating", {
        ...info,
        target: "shape",
        shape: this.shape,
        onInteractionEnd: "note",
        isCreating: true,
        creatingMarkId: this.markId,
        onCreate: () => {
          this.editor.setEditingShape(this.shape.id);
          this.editor.setCurrentTool("select.editing_shape");
        }
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  complete() {
    if (this.editor.getInstanceState().isToolLocked) {
      this.parent.transition("idle");
    } else {
      this.editor.setEditingShape(this.shape.id);
      this.editor.setCurrentTool("select.editing_shape", {
        ...this.info,
        target: "shape",
        shape: this.shape
      });
    }
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    this.parent.transition("idle", this.info);
  }
};
__publicField(Pointing5, "id", "pointing");
function getNoteShapeAdjacentPositionOffset(editor, center, scale) {
  let min4 = NOTE_ADJACENT_POSITION_SNAP_RADIUS / editor.getZoomLevel();
  let offset5;
  for (const pit of getAvailableNoteAdjacentPositions(editor, 0, scale, 0)) {
    const deltaToPit = Vec.Sub(center, pit);
    const dist = deltaToPit.len();
    if (dist < min4) {
      min4 = dist;
      offset5 = deltaToPit;
    }
  }
  return offset5;
}
function createNoteShape(editor, id, center) {
  editor.createShape({
    id,
    type: "note",
    x: center.x,
    y: center.y,
    props: {
      scale: editor.user.getIsDynamicResizeMode() ? 1 / editor.getZoomLevel() : 1
    }
  }).select(id);
  const shape = editor.getShape(id);
  const bounds = editor.getShapeGeometry(shape).bounds;
  const newPoint = maybeSnapToGrid(
    new Vec(shape.x - bounds.width / 2, shape.y - bounds.height / 2),
    editor
  );
  editor.updateShapes([
    {
      id,
      type: "note",
      x: newPoint.x,
      y: newPoint.y
    }
  ]);
  return editor.getShape(id);
}

// node_modules/tldraw/dist-esm/lib/shapes/note/NoteShapeTool.mjs
var NoteShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "note");
  }
  static children() {
    return [Idle6, Pointing5];
  }
};
__publicField(NoteShapeTool, "id", "note");
__publicField(NoteShapeTool, "initial", "idle");

// node_modules/tldraw/dist-esm/lib/tools/selection-logic/updateHoveredShapeId.mjs
function _updateHoveredShapeId(editor) {
  const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint, {
    hitInside: false,
    hitLabels: false,
    margin: editor.options.hitTestMargin / editor.getZoomLevel(),
    renderingOnly: true
  });
  if (!hitShape)
    return editor.setHoveredShape(null);
  let shapeToHover = void 0;
  const outermostShape = editor.getOutermostSelectableShape(hitShape);
  if (outermostShape === hitShape) {
    shapeToHover = hitShape;
  } else {
    if (outermostShape.id === editor.getFocusedGroupId() || editor.getSelectedShapeIds().includes(outermostShape.id)) {
      shapeToHover = hitShape;
    } else {
      shapeToHover = outermostShape;
    }
  }
  return editor.setHoveredShape(shapeToHover.id);
}
var updateHoveredShapeId = (0, import_lodash.default)(
  _updateHoveredShapeId,
  false ? 0 : 32
);

// node_modules/tldraw/dist-esm/lib/shapes/text/toolStates/Idle.mjs
var Idle7 = class extends StateNode {
  onPointerMove(info) {
    switch (info.target) {
      case "shape":
      case "canvas": {
        updateHoveredShapeId(this.editor);
      }
    }
  }
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onExit() {
    updateHoveredShapeId.cancel();
  }
  onKeyDown(info) {
    var _a5;
    if (info.key === "Enter") {
      if (this.editor.getIsReadonly())
        return null;
      const onlySelectedShape = this.editor.getOnlySelectedShape();
      if (onlySelectedShape && this.editor.getShapeUtil(onlySelectedShape).canEdit(onlySelectedShape)) {
        this.editor.setCurrentTool("select");
        this.editor.setEditingShape(onlySelectedShape.id);
        (_a5 = this.editor.root.getCurrent()) == null ? void 0 : _a5.transition("editing_shape", {
          ...info,
          target: "shape",
          shape: onlySelectedShape
        });
      }
    }
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle7, "id", "idle");

// node_modules/tldraw/dist-esm/lib/shapes/text/toolStates/Pointing.mjs
var Pointing6 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shape");
    __publicField(this, "markId", "");
    __publicField(this, "enterTime", 0);
  }
  onEnter() {
    this.enterTime = Date.now();
  }
  onExit() {
    this.editor.setHintingShapes([]);
  }
  onPointerMove(info) {
    if (Date.now() - this.enterTime < 150)
      return;
    const { editor } = this;
    const { isPointing } = editor.inputs;
    if (!isPointing)
      return;
    const { originPagePoint, currentPagePoint } = editor.inputs;
    const currentDragDist = Math.abs(originPagePoint.x - currentPagePoint.x);
    const baseMinDragDistForFixedWidth = Math.sqrt(
      editor.getInstanceState().isCoarsePointer ? editor.options.coarseDragDistanceSquared : editor.options.dragDistanceSquared
    );
    const minSquaredDragDist = baseMinDragDistForFixedWidth * 6 / editor.getZoomLevel();
    if (currentDragDist > minSquaredDragDist) {
      const id = createShapeId();
      this.markId = editor.markHistoryStoppingPoint(`creating_text:${id}`);
      const shape = this.createTextShape(id, originPagePoint, false, currentDragDist);
      if (!shape) {
        this.cancel();
        return;
      }
      this.shape = editor.getShape(shape);
      editor.select(id);
      editor.setCurrentTool("select.resizing", {
        ...info,
        target: "selection",
        handle: "right",
        isCreating: true,
        creatingMarkId: this.markId,
        // Make sure the cursor offset takes into account how far we've already dragged
        creationCursorOffset: { x: currentDragDist, y: 1 },
        onInteractionEnd: "text",
        onCreate: () => {
          editor.setEditingShape(shape.id);
        }
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.cancel();
  }
  onCancel() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    this.editor.markHistoryStoppingPoint("creating text shape");
    const id = createShapeId();
    const { originPagePoint } = this.editor.inputs;
    const shape = this.createTextShape(id, originPagePoint, true, 20);
    if (!shape)
      return;
    this.editor.select(id);
    this.editor.setEditingShape(id);
  }
  cancel() {
    this.parent.transition("idle");
    this.editor.bailToMark(this.markId);
  }
  createTextShape(id, point, autoSize, width) {
    this.editor.createShape({
      id,
      type: "text",
      x: point.x,
      y: point.y,
      props: {
        richText: toRichText(""),
        autoSize,
        w: width,
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const shape = this.editor.getShape(id);
    if (!shape) {
      this.cancel();
      return;
    }
    const bounds = this.editor.getShapePageBounds(shape);
    const delta = new Vec();
    if (autoSize) {
      switch (shape.props.textAlign) {
        case "start": {
          delta.x = 0;
          break;
        }
        case "middle": {
          delta.x = -bounds.width / 2;
          break;
        }
        case "end": {
          delta.x = -bounds.width;
          break;
        }
      }
    } else {
      delta.x = 0;
    }
    delta.y = -bounds.height / 2;
    if (isShapeId(shape.parentId)) {
      const transform = this.editor.getShapeParentTransform(shape);
      delta.rot(-transform.rotation());
    }
    const shapeX = shape.x + delta.x;
    const shapeY = shape.y + delta.y;
    if (this.editor.getInstanceState().isGridMode) {
      const topLeft = new Vec(shapeX, shapeY);
      const gridSnappedPoint = maybeSnapToGrid(topLeft, this.editor);
      const gridDelta = Vec.Sub(topLeft, gridSnappedPoint);
      this.editor.updateShape({
        ...shape,
        x: shapeX - gridDelta.x,
        y: shapeY - gridDelta.y
      });
    } else {
      this.editor.updateShape({
        ...shape,
        x: shapeX,
        y: shapeY
      });
    }
    return shape;
  }
};
__publicField(Pointing6, "id", "pointing");

// node_modules/tldraw/dist-esm/lib/shapes/text/TextShapeTool.mjs
var TextShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "text");
  }
  static children() {
    return [Idle7, Pointing6];
  }
};
__publicField(TextShapeTool, "id", "text");
__publicField(TextShapeTool, "initial", "idle");

// node_modules/tldraw/dist-esm/lib/defaultShapeTools.mjs
var defaultShapeTools = [
  TextShapeTool,
  DrawShapeTool,
  GeoShapeTool,
  NoteShapeTool,
  LineShapeTool,
  FrameShapeTool,
  ArrowShapeTool,
  HighlightShapeTool
];

// node_modules/tldraw/dist-esm/lib/shapes/arrow/ArrowShapeUtil.mjs
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var import_react88 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/shared/PathBuilder.mjs
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
function getVerticesCountForLength2(length, spacing = 20) {
  return Math.max(8, Math.ceil(length / spacing));
}
var PathBuilder = class _PathBuilder {
  constructor() {
    __publicField(this, "lines", []);
  }
  static throughPoints(points, opts) {
    const path = new _PathBuilder();
    path.moveTo(points[0].x, points[0].y, opts);
    for (let i = 1; i < points.length; i++) {
      path.lineTo(points[i].x, points[i].y);
    }
    return path;
  }
  currentLine() {
    const lastLine = this.lines[this.lines.length - 1];
    assert(lastLine, "Start an SVGPathBuilder with `.moveTo()`");
    assert(!lastLine.closed, "Cannot work on a closed line");
    return lastLine;
  }
  moveTo(x, y, opts) {
    this.lines.push({
      initial: { type: "moveTo", x, y, opts },
      segments: [],
      closed: false
    });
    return this;
  }
  lineTo(x, y, opts) {
    this.currentLine().segments.push({ type: "lineTo", x, y, opts });
    return this;
  }
  arcTo(radius, largeArcFlag, sweepFlag, x, y, opts) {
    this.currentLine().segments.push({
      type: "arcTo",
      radius,
      largeArcFlag,
      sweepFlag,
      x,
      y,
      opts
    });
    return this;
  }
  close() {
    this.currentLine().closed = true;
    return this;
  }
  toD(opts = {}) {
    const closedOnly = opts.closedOnly ?? false;
    const parts = [];
    for (const { initial, segments, closed } of this.lines) {
      if (closedOnly && !closed)
        continue;
      parts.push("M", toDomPrecision(initial.x), toDomPrecision(initial.y));
      for (const segment of segments) {
        switch (segment.type) {
          case "lineTo":
            parts.push("L", toDomPrecision(segment.x), toDomPrecision(segment.y));
            break;
          case "arcTo":
            parts.push(
              "A",
              segment.radius,
              segment.radius,
              0,
              segment.largeArcFlag ? "1" : "0",
              segment.sweepFlag ? "1" : "0",
              toDomPrecision(segment.x),
              toDomPrecision(segment.y)
            );
            break;
        }
      }
      if (closed) {
        parts.push("Z");
      }
    }
    return parts.join(" ");
  }
  toSvg(opts) {
    if (opts.forceSolid) {
      return this.toSolidSvg(opts);
    }
    switch (opts.style) {
      case "solid":
        return this.toSolidSvg(opts);
      case "dashed":
      case "dotted":
        return this.toDashedSvg(opts);
      case "draw":
        return this.toDrawSvg(opts);
      default:
        exhaustiveSwitchError(opts, "style");
    }
  }
  toGeometry() {
    var _a5, _b, _c;
    const geometries = [];
    for (const { initial, segments, closed } of this.lines) {
      if (((_a5 = initial.opts) == null ? void 0 : _a5.geometry) === false)
        continue;
      const vertices = [new Vec(initial.x, initial.y)];
      for (const segment of segments) {
        switch (segment.type) {
          case "lineTo": {
            vertices.push(new Vec(segment.x, segment.y));
            break;
          }
          case "arcTo": {
            const info = getArcSegmentInfo(vertices[vertices.length - 1], segment);
            if (info === null)
              break;
            if (info === "straight-line") {
              vertices.push(new Vec(segment.x, segment.y));
              break;
            }
            const verticesCount = getVerticesCountForLength2(info.length);
            for (let i = 0; i < verticesCount + 1; i++) {
              const t2 = i / verticesCount * info.sweepAngle;
              const point = Vec.Rot(info.startVector, t2).mul(info.radius).add(info.center);
              vertices.push(point);
            }
            break;
          }
          default:
            exhaustiveSwitchError(segment, "type");
        }
      }
      const geometry = closed ? new Polygon2d({ points: vertices, isFilled: false, ...(_b = initial.opts) == null ? void 0 : _b.geometry }) : new Polyline2d({ points: vertices, ...(_c = initial.opts) == null ? void 0 : _c.geometry });
      geometries.push(geometry);
    }
    if (geometries.length === 0)
      return null;
    if (geometries.length === 1)
      return geometries[0];
    return new Group2d({ children: geometries });
  }
  toSolidSvg(opts) {
    const { strokeWidth, props } = opts;
    return (0, import_jsx_runtime123.jsx)("path", { strokeWidth, d: this.toD(), ...props });
  }
  toDashedSvg(opts) {
    const {
      style: style2,
      strokeWidth,
      snap,
      end: end2,
      start: start2,
      lengthRatio,
      props: { markerStart, markerEnd, ...props } = {}
    } = opts;
    const parts = [];
    for (const { initial, segments, closed } of this.lines) {
      let lastPoint = initial;
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        const isFirst = i === 0;
        const isLast = i === segments.length - 1 && !closed;
        const segmentLength = this.segmentLength(lastPoint, segment);
        const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
          segmentLength,
          strokeWidth,
          {
            style: style2,
            snap,
            lengthRatio,
            start: isFirst ? closed ? "none" : start2 : "outset",
            end: isLast ? closed ? "none" : end2 : "outset"
          }
        );
        switch (segment.type) {
          case "lineTo":
            parts.push(
              (0, import_jsx_runtime123.jsx)(
                "line",
                {
                  x1: toDomPrecision(lastPoint.x),
                  y1: toDomPrecision(lastPoint.y),
                  x2: toDomPrecision(segment.x),
                  y2: toDomPrecision(segment.y),
                  strokeDasharray,
                  strokeDashoffset,
                  markerStart: isFirst ? markerStart : void 0,
                  markerEnd: isLast ? markerEnd : void 0
                },
                i
              )
            );
            break;
          case "arcTo":
            parts.push(
              (0, import_jsx_runtime123.jsx)(
                "path",
                {
                  d: [
                    "M",
                    toDomPrecision(lastPoint.x),
                    toDomPrecision(lastPoint.y),
                    "A",
                    segment.radius,
                    segment.radius,
                    0,
                    segment.largeArcFlag ? "1" : "0",
                    segment.sweepFlag ? "1" : "0",
                    toDomPrecision(segment.x),
                    toDomPrecision(segment.y)
                  ].join(" "),
                  strokeDasharray,
                  strokeDashoffset,
                  markerStart: isFirst ? markerStart : void 0,
                  markerEnd: isLast ? markerEnd : void 0
                },
                i
              )
            );
            break;
          default:
            exhaustiveSwitchError(segment, "type");
        }
        lastPoint = segment;
      }
      if (closed && lastPoint !== initial) {
        const dist = Vec.Dist(lastPoint, initial);
        const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(dist, strokeWidth, {
          style: style2,
          snap,
          lengthRatio,
          start: "outset",
          end: "none"
        });
        parts.push(
          (0, import_jsx_runtime123.jsx)(
            "line",
            {
              x1: toDomPrecision(lastPoint.x),
              y1: toDomPrecision(lastPoint.y),
              x2: toDomPrecision(initial.x),
              y2: toDomPrecision(initial.y),
              strokeDasharray,
              strokeDashoffset,
              markerEnd
            },
            "last"
          )
        );
      }
    }
    return (0, import_jsx_runtime123.jsx)("g", { strokeWidth, ...props, children: parts });
  }
  toDrawSvg(opts) {
    var _a5, _b, _c, _d, _e;
    const {
      strokeWidth,
      randomSeed,
      offset: defaultOffset = strokeWidth / 3,
      roundness: defaultRoundness = strokeWidth * 2,
      passes = 2,
      props
    } = opts;
    const parts = [];
    const tangents = this.lines.map(({ initial, segments, closed }) => {
      const tangents2 = [];
      const segmentCount = closed ? segments.length + 1 : segments.length;
      for (let i = 0; i < segmentCount; i++) {
        let previous = segments[i - 1];
        let current = segments[i];
        let next = segments[i + 1];
        if (!previous)
          previous = initial;
        if (!current) {
          current = initial;
          next = segments[0];
        }
        if (!next) {
          next = initial;
        }
        let tangentBefore, tangentAfter;
        switch (current.type) {
          case "lineTo":
          case "moveTo": {
            tangentBefore = Vec.Sub(previous, current).norm();
            break;
          }
          case "arcTo": {
            const info = getArcSegmentInfo(previous, current);
            if (info === null || info === "straight-line") {
              tangentBefore = Vec.Sub(current, previous).norm().per();
              break;
            }
            tangentBefore = Vec.Per(info.endVector).mul(Math.sign(info.sweepAngle));
            break;
          }
          default:
            exhaustiveSwitchError(current, "type");
        }
        switch (next.type) {
          case "lineTo":
          case "moveTo": {
            tangentAfter = Vec.Sub(next, current).norm();
            break;
          }
          case "arcTo": {
            const info = getArcSegmentInfo(current, next);
            if (info === null || info === "straight-line") {
              tangentAfter = Vec.Sub(next, current).norm().per();
              break;
            }
            tangentAfter = Vec.Per(info.startVector).mul(Math.sign(info.sweepAngle));
            break;
          }
          default:
            exhaustiveSwitchError(next, "type");
        }
        tangents2.push({ tangentBefore, tangentAfter });
      }
      return tangents2;
    });
    for (let pass = 0; pass < passes; pass++) {
      for (let lineIdx = 0; lineIdx < this.lines.length; lineIdx++) {
        const { initial, segments, closed } = this.lines[lineIdx];
        const random = rng(randomSeed + pass + lineIdx);
        const initialOffset = ((_a5 = initial.opts) == null ? void 0 : _a5.offset) ?? defaultOffset;
        const initialPOffset = {
          x: initial.x + random() * initialOffset,
          y: initial.y + random() * initialOffset
        };
        const offsetPoints = [];
        let lastDistance = Vec.Dist(initialPOffset, segments[0]);
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          const nextSegment = i === segments.length - 1 ? closed ? segments[0] : null : segments[i + 1];
          const nextDistance = nextSegment ? Vec.Dist(segment, nextSegment) : Infinity;
          const shortestDistance = Math.min(lastDistance, nextDistance) - (((_b = segment.opts) == null ? void 0 : _b.roundness) ?? defaultRoundness);
          const offset5 = clamp(((_c = segment.opts) == null ? void 0 : _c.offset) ?? defaultOffset, 0, shortestDistance / 10);
          const offsetPoint = {
            x: segment.x + random() * offset5,
            y: segment.y + random() * offset5
          };
          offsetPoints.push(offsetPoint);
          lastDistance = nextDistance;
        }
        if (closed) {
          const roundness = ((_d = initial.opts) == null ? void 0 : _d.roundness) ?? defaultRoundness;
          offsetPoints.push(initialPOffset);
          const next = offsetPoints[0];
          const nudgeAmount = Math.min(Vec.Dist(initialPOffset, next) / 2, roundness);
          const nudged = Vec.Nudge(initialPOffset, next, nudgeAmount);
          parts.push("M", toDomPrecision(nudged.x), toDomPrecision(nudged.y));
        } else {
          parts.push("M", toDomPrecision(initialPOffset.x), toDomPrecision(initialPOffset.y));
        }
        const segmentCount = closed ? segments.length + 1 : segments.length;
        for (let i = 0; i < segmentCount; i++) {
          const segment = i === segments.length ? initial : segments[i];
          const roundness = ((_e = segment.opts) == null ? void 0 : _e.roundness) ?? defaultRoundness;
          const offsetP = offsetPoints[i];
          const { tangentBefore, tangentAfter } = tangents[lineIdx][i];
          const previousOffsetP = i === 0 ? initialPOffset : offsetPoints[i - 1];
          const nextOffsetP = i === segments.length - 1 && !closed ? null : offsetPoints[(i + 1) % offsetPoints.length];
          switch (segment.type) {
            case "lineTo":
            case "moveTo": {
              if (!nextOffsetP || roundness === 0) {
                parts.push("L", toDomPrecision(offsetP.x), toDomPrecision(offsetP.y));
                break;
              }
              const clampedRoundness = lerp(
                roundness,
                0,
                clamp(
                  invLerp(
                    Math.PI / 2,
                    Math.PI,
                    Math.abs(Vec.AngleBetween(tangentBefore, tangentAfter))
                  ),
                  0,
                  1
                )
              );
              const nudgeBeforeAmount = Math.min(
                Vec.Dist(previousOffsetP, offsetP) / 2,
                clampedRoundness
              );
              const nudgeBefore = Vec.Mul(tangentBefore, nudgeBeforeAmount).add(offsetP);
              const nudgeAfterAmount = Math.min(
                Vec.Dist(nextOffsetP, offsetP) / 2,
                clampedRoundness
              );
              const nudgeAfter = Vec.Mul(tangentAfter, nudgeAfterAmount).add(offsetP);
              parts.push(
                "L",
                toDomPrecision(nudgeBefore.x),
                toDomPrecision(nudgeBefore.y),
                "Q",
                toDomPrecision(offsetP.x),
                toDomPrecision(offsetP.y),
                toDomPrecision(nudgeAfter.x),
                toDomPrecision(nudgeAfter.y)
              );
              break;
            }
            case "arcTo":
              parts.push(
                "A",
                segment.radius,
                segment.radius,
                0,
                segment.largeArcFlag ? "1" : "0",
                segment.sweepFlag ? "1" : "0",
                toDomPrecision(offsetP.x),
                toDomPrecision(offsetP.y)
              );
              break;
            default:
              exhaustiveSwitchError(segment, "type");
          }
        }
        if (closed) {
          parts.push("Z");
        }
      }
    }
    return (0, import_jsx_runtime123.jsx)("path", { strokeWidth, d: parts.join(" "), ...props });
  }
  segmentLength(lastPoint, segment) {
    switch (segment.type) {
      case "lineTo":
        return Vec.Dist(lastPoint, segment);
      case "arcTo": {
        const info = getArcSegmentInfo(lastPoint, segment);
        if (info === null)
          return 0;
        if (info === "straight-line")
          return Vec.Dist(lastPoint, segment);
        return info.length;
      }
      default:
        exhaustiveSwitchError(segment, "type");
    }
  }
};
function getArcSegmentInfo(lastPoint, { radius, largeArcFlag, sweepFlag, x, y }) {
  radius = Math.abs(radius);
  if (lastPoint.x === x && lastPoint.y === y) {
    return null;
  }
  if (radius === 0) {
    return "straight-line";
  }
  const dx = (lastPoint.x - x) / 2;
  const dy = (lastPoint.y - y) / 2;
  const radiiCheck = Math.pow(dx, 2) / Math.pow(radius, 2) + Math.pow(dy, 2) / Math.pow(radius, 2);
  if (radiiCheck > 1) {
    radius = Math.sqrt(radiiCheck) * radius;
  }
  const cSquareNumerator = Math.pow(radius, 2) * Math.pow(radius, 2) - Math.pow(radius, 2) * Math.pow(dy, 2) - Math.pow(radius, 2) * Math.pow(dx, 2);
  const cSquareRootDenom = Math.pow(radius, 2) * Math.pow(dy, 2) + Math.pow(radius, 2) * Math.pow(dx, 2);
  let cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  const cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
  const transformedCenter = {
    x: cCoef * (radius * dy / radius),
    y: cCoef * (-(radius * dx) / radius)
  };
  const center = {
    x: transformedCenter.x + (lastPoint.x + x) / 2,
    y: transformedCenter.y + (lastPoint.y + y) / 2
  };
  const startVector = {
    x: (dx - transformedCenter.x) / radius,
    y: (dy - transformedCenter.y) / radius
  };
  const endVector = {
    x: (-dx - transformedCenter.x) / radius,
    y: (-dy - transformedCenter.y) / radius
  };
  let sweepAngle = Vec.AngleBetween(startVector, endVector);
  if (!sweepFlag && sweepAngle > 0) {
    sweepAngle -= 2 * Math.PI;
  } else if (sweepFlag && sweepAngle < 0) {
    sweepAngle += 2 * Math.PI;
  }
  sweepAngle %= 2 * Math.PI;
  return {
    length: Math.abs(sweepAngle * radius),
    radius,
    sweepAngle,
    startVector,
    endVector,
    center
  };
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/PlainTextLabel.mjs
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var import_react85 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/text/PlainTextArea.mjs
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
var import_react83 = __toESM(require_react(), 1);
var PlainTextArea = import_react83.default.forwardRef(function TextArea({
  isEditing,
  text,
  handleFocus,
  handleChange,
  handleKeyDown: handleKeyDown2,
  handleBlur,
  handleInputPointerDown,
  handleDoubleClick: handleDoubleClick2
}, ref) {
  const onChange = (e) => {
    handleChange({ plaintext: e.target.value });
  };
  return (0, import_jsx_runtime124.jsx)(
    "textarea",
    {
      ref,
      className: "tl-text tl-text-input",
      name: "text",
      tabIndex: -1,
      disabled: !isEditing,
      readOnly: !isEditing,
      autoComplete: "off",
      autoCapitalize: "off",
      autoCorrect: "off",
      autoSave: "off",
      placeholder: "",
      spellCheck: "true",
      wrap: "off",
      dir: "auto",
      defaultValue: text,
      onFocus: handleFocus,
      onChange,
      onKeyDown: (e) => handleKeyDown2(e.nativeEvent),
      onBlur: handleBlur,
      onTouchEnd: stopEventPropagation,
      onContextMenu: isEditing ? stopEventPropagation : void 0,
      onPointerDown: handleInputPointerDown,
      onDoubleClick: handleDoubleClick2,
      onDragStart: preventDefault
    }
  );
});

// node_modules/tldraw/dist-esm/lib/shapes/shared/legacyProps.mjs
function getLegacyOffsetX(align, padding, spans, totalWidth) {
  if ((align === "start-legacy" || align === "end-legacy") && spans.length !== 0) {
    const spansBounds = Box.From(spans[0].box);
    for (const { box } of spans) {
      spansBounds.union(box);
    }
    if (align === "start-legacy") {
      return (totalWidth - 2 * padding - spansBounds.width) / 2;
    } else if (align === "end-legacy") {
      return -(totalWidth - 2 * padding - spansBounds.width) / 2;
    }
  }
}
function isLegacyAlign(align) {
  return align === "start-legacy" || align === "middle-legacy" || align === "end-legacy";
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/useEditablePlainText.mjs
var import_react84 = __toESM(require_react(), 1);
function useEditablePlainText(shapeId, type, text) {
  const commonUseEditableTextHandlers = useEditableTextCommon(shapeId);
  const isEditing = commonUseEditableTextHandlers.isEditing;
  const editor = useEditor();
  const rInput = (0, import_react84.useRef)(null);
  const isEmpty = (text || "").trim().length === 0;
  (0, import_react84.useEffect)(() => {
    function selectAllIfEditing(event) {
      var _a5, _b;
      if (event.shapeId === shapeId) {
        (_b = (_a5 = rInput.current) == null ? void 0 : _a5.select) == null ? void 0 : _b.call(_a5);
      }
    }
    editor.on("select-all-text", selectAllIfEditing);
    return () => {
      editor.off("select-all-text", selectAllIfEditing);
    };
  }, [editor, shapeId, isEditing]);
  (0, import_react84.useEffect)(() => {
    var _a5, _b, _c, _d;
    if (!isEditing)
      return;
    if (document.activeElement !== rInput.current) {
      (_a5 = rInput.current) == null ? void 0 : _a5.focus();
    }
    if (editor.getInstanceState().isCoarsePointer) {
      (_b = rInput.current) == null ? void 0 : _b.select();
    }
    if (tlenv.isSafari) {
      (_c = rInput.current) == null ? void 0 : _c.blur();
      (_d = rInput.current) == null ? void 0 : _d.focus();
    }
  }, [editor, isEditing]);
  const handleKeyDown2 = (0, import_react84.useCallback)(
    (e) => {
      if (editor.getEditingShapeId() !== shapeId)
        return;
      switch (e.key) {
        case "Enter": {
          if (e.ctrlKey || e.metaKey) {
            editor.complete();
          }
          break;
        }
      }
    },
    [editor, shapeId]
  );
  const handleChange = (0, import_react84.useCallback)(
    ({ plaintext }) => {
      if (editor.getEditingShapeId() !== shapeId)
        return;
      const normalizedPlaintext = TextHelpers.normalizeText(plaintext || "");
      editor.updateShape({
        id: shapeId,
        type,
        props: { text: normalizedPlaintext }
      });
    },
    [editor, shapeId, type]
  );
  return {
    rInput,
    handleKeyDown: handleKeyDown2,
    handleChange,
    isEmpty,
    ...commonUseEditableTextHandlers
  };
}
function useIsReadyForEditing(editor, shapeId) {
  return useValue(
    "isReadyForEditing",
    () => {
      const editingShapeId = editor.getEditingShapeId();
      return (
        // something's being editing... and either it's this shape OR this shape is hovered
        editingShapeId !== null && (editingShapeId === shapeId || editor.getHoveredShapeId() === shapeId)
      );
    },
    [editor, shapeId]
  );
}
function useEditableTextCommon(shapeId) {
  const editor = useEditor();
  const isEditing = useValue("isEditing", () => editor.getEditingShapeId() === shapeId, [editor]);
  const isReadyForEditing = useIsReadyForEditing(editor, shapeId);
  const handleInputPointerDown = (0, import_react84.useCallback)(
    (e) => {
      editor.dispatch({
        ...getPointerInfo(e),
        type: "pointer",
        name: "pointer_down",
        target: "shape",
        shape: editor.getShape(shapeId)
      });
      stopEventPropagation(e);
    },
    [editor, shapeId]
  );
  return {
    handleFocus: noop,
    handleBlur: noop,
    handleInputPointerDown,
    handleDoubleClick: stopEventPropagation,
    isEditing,
    isReadyForEditing
  };
}
var useEditableText = useEditablePlainText;

// node_modules/tldraw/dist-esm/lib/shapes/shared/PlainTextLabel.mjs
var PlainTextLabel = import_react85.default.memo(function PlainTextLabel2({
  shapeId,
  type,
  text: plaintext,
  labelColor,
  font,
  fontSize,
  lineHeight,
  align,
  verticalAlign,
  wrap: wrap3,
  isSelected,
  padding = 0,
  onKeyDown: handleKeyDownCustom,
  classNamePrefix,
  style: style2,
  textWidth,
  textHeight
}) {
  const { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } = useEditablePlainText(shapeId, type, plaintext);
  const finalPlainText = TextHelpers.normalizeTextForDom(plaintext || "");
  const hasText = finalPlainText.length > 0;
  const legacyAlign = isLegacyAlign(align);
  if (!isEditing && !hasText) {
    return null;
  }
  const cssPrefix = classNamePrefix || "tl-text";
  return (0, import_jsx_runtime125.jsx)(
    "div",
    {
      className: `${cssPrefix}-label tl-text-wrapper tl-plain-text-wrapper`,
      "data-font": font,
      "data-align": align,
      "data-hastext": !isEmpty,
      "data-isediting": isEditing,
      "data-is-ready-for-editing": isReadyForEditing,
      "data-textwrap": !!wrap3,
      "data-isselected": isSelected,
      style: {
        justifyContent: align === "middle" || legacyAlign ? "center" : align,
        alignItems: verticalAlign === "middle" ? "center" : verticalAlign,
        padding,
        ...style2
      },
      children: (0, import_jsx_runtime125.jsxs)(
        "div",
        {
          className: `${cssPrefix}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize,
            lineHeight: Math.floor(fontSize * lineHeight) + "px",
            minHeight: Math.floor(fontSize * lineHeight) + "px",
            minWidth: Math.ceil(textWidth || 0),
            color: labelColor,
            width: textWidth ? Math.ceil(textWidth) : void 0,
            height: textHeight ? Math.ceil(textHeight) : void 0
          },
          children: [
            (0, import_jsx_runtime125.jsx)("div", { className: `${cssPrefix} tl-text tl-text-content`, dir: "auto", children: finalPlainText.split("\n").map((lineOfText, index3) => (0, import_jsx_runtime125.jsx)("div", { dir: "auto", children: lineOfText }, index3)) }),
            (isReadyForEditing || isSelected) && (0, import_jsx_runtime125.jsx)(
              PlainTextArea,
              {
                ref: rInput,
                text: plaintext,
                isEditing,
                shapeId,
                ...editableTextRest,
                handleKeyDown: handleKeyDownCustom ?? editableTextRest.handleKeyDown
              }
            )
          ]
        }
      )
    }
  );
});
var TextLabel = PlainTextLabel;

// node_modules/tldraw/dist-esm/lib/shapes/shared/ShapeFill.mjs
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var import_react87 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/shared/defaultStyleDefs.mjs
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var import_react86 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/shared/useDefaultColorTheme.mjs
function useDefaultColorTheme() {
  return getDefaultColorTheme({ isDarkMode: useIsDarkMode() });
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/defaultStyleDefs.mjs
function getFillDefForExport(fill) {
  return {
    key: `${DefaultFontStyle.id}:${fill}`,
    async getElement() {
      if (fill !== "pattern")
        return null;
      return (0, import_jsx_runtime126.jsx)(HashPatternForExport, {});
    }
  };
}
function HashPatternForExport() {
  const getHashPatternZoomName = useGetHashPatternZoomName();
  const maskId = useUniqueSafeId();
  const theme = useDefaultColorTheme();
  const t2 = 8 / 12;
  return (0, import_jsx_runtime126.jsxs)(import_jsx_runtime126.Fragment, { children: [
    (0, import_jsx_runtime126.jsxs)("mask", { id: maskId, children: [
      (0, import_jsx_runtime126.jsx)("rect", { x: "0", y: "0", width: "8", height: "8", fill: "white" }),
      (0, import_jsx_runtime126.jsxs)("g", { strokeLinecap: "round", stroke: "black", children: [
        (0, import_jsx_runtime126.jsx)("line", { x1: t2 * 1, y1: t2 * 3, x2: t2 * 3, y2: t2 * 1 }),
        (0, import_jsx_runtime126.jsx)("line", { x1: t2 * 5, y1: t2 * 7, x2: t2 * 7, y2: t2 * 5 }),
        (0, import_jsx_runtime126.jsx)("line", { x1: t2 * 9, y1: t2 * 11, x2: t2 * 11, y2: t2 * 9 })
      ] })
    ] }),
    (0, import_jsx_runtime126.jsx)(
      "pattern",
      {
        id: getHashPatternZoomName(1, theme.id),
        width: "8",
        height: "8",
        patternUnits: "userSpaceOnUse",
        children: (0, import_jsx_runtime126.jsx)("rect", { x: "0", y: "0", width: "8", height: "8", fill: theme.solid, mask: `url(#${maskId})` })
      }
    )
  ] });
}
function getFillDefForCanvas() {
  return {
    key: `${DefaultFontStyle.id}:pattern`,
    component: PatternFillDefForCanvas
  };
}
var TILE_PATTERN_SIZE = 8;
var generateImage = (dpr, currentZoom, darkMode) => {
  return new Promise((resolve, reject) => {
    const size4 = TILE_PATTERN_SIZE * currentZoom * dpr;
    const canvasEl = document.createElement("canvas");
    canvasEl.width = size4;
    canvasEl.height = size4;
    const ctx = canvasEl.getContext("2d");
    if (!ctx)
      return;
    ctx.fillStyle = darkMode ? DefaultColorThemePalette.darkMode.solid : DefaultColorThemePalette.lightMode.solid;
    ctx.fillRect(0, 0, size4, size4);
    ctx.globalCompositeOperation = "destination-out";
    ctx.lineCap = "round";
    ctx.lineWidth = 1.25 * currentZoom * dpr;
    const t2 = 8 / 12;
    const s = (v) => v * currentZoom * dpr;
    ctx.beginPath();
    ctx.moveTo(s(t2 * 1), s(t2 * 3));
    ctx.lineTo(s(t2 * 3), s(t2 * 1));
    ctx.moveTo(s(t2 * 5), s(t2 * 7));
    ctx.lineTo(s(t2 * 7), s(t2 * 5));
    ctx.moveTo(s(t2 * 9), s(t2 * 11));
    ctx.lineTo(s(t2 * 11), s(t2 * 9));
    ctx.stroke();
    canvasEl.toBlob((blob) => {
      if (!blob || debugFlags.throwToBlob.get()) {
        reject();
      } else {
        resolve(blob);
      }
    });
  });
};
var canvasBlob = (size4, fn2) => {
  const canvas = document.createElement("canvas");
  canvas.width = size4[0];
  canvas.height = size4[1];
  const ctx = canvas.getContext("2d");
  if (!ctx)
    return "";
  fn2(ctx);
  return canvas.toDataURL();
};
var defaultPixels = null;
function getDefaultPixels() {
  if (!defaultPixels) {
    defaultPixels = {
      white: canvasBlob([1, 1], (ctx) => {
        ctx.fillStyle = "#f8f9fa";
        ctx.fillRect(0, 0, 1, 1);
      }),
      black: canvasBlob([1, 1], (ctx) => {
        ctx.fillStyle = "#212529";
        ctx.fillRect(0, 0, 1, 1);
      })
    };
  }
  return defaultPixels;
}
function getPatternLodForZoomLevel(zoom) {
  return Math.ceil(Math.log2(Math.max(1, zoom)));
}
function useGetHashPatternZoomName() {
  const id = useSharedSafeId("hash_pattern");
  return (0, import_react86.useCallback)(
    (zoom, theme) => {
      const lod = getPatternLodForZoomLevel(zoom);
      return suffixSafeId(id, `${theme}_${lod}`);
    },
    [id]
  );
}
function getPatternLodsToGenerate(maxZoom) {
  const levels = [];
  const minLod = 0;
  const maxLod = getPatternLodForZoomLevel(maxZoom);
  for (let i = minLod; i <= maxLod; i++) {
    levels.push(Math.pow(2, i));
  }
  return levels;
}
function getDefaultPatterns(maxZoom) {
  const defaultPixels2 = getDefaultPixels();
  return getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [
    { zoom, url: defaultPixels2.white, theme: "light" },
    { zoom, url: defaultPixels2.black, theme: "dark" }
  ]);
}
function usePattern() {
  const editor = useEditor();
  const dpr = useValue("devicePixelRatio", () => editor.getInstanceState().devicePixelRatio, [
    editor
  ]);
  const maxZoom = useValue("maxZoom", () => Math.ceil(last(editor.getCameraOptions().zoomSteps)), [
    editor
  ]);
  const [isReady, setIsReady] = (0, import_react86.useState)(false);
  const [backgroundUrls, setBackgroundUrls] = (0, import_react86.useState)(
    () => getDefaultPatterns(maxZoom)
  );
  const getHashPatternZoomName = useGetHashPatternZoomName();
  (0, import_react86.useEffect)(() => {
    if (false) {
      setIsReady(true);
      return;
    }
    const promise = Promise.all(
      getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [
        generateImage(dpr, zoom, false).then((blob) => ({
          zoom,
          theme: "light",
          url: URL.createObjectURL(blob)
        })),
        generateImage(dpr, zoom, true).then((blob) => ({
          zoom,
          theme: "dark",
          url: URL.createObjectURL(blob)
        }))
      ])
    );
    let isCancelled = false;
    promise.then((urls) => {
      if (isCancelled)
        return;
      setBackgroundUrls(urls);
      setIsReady(true);
    });
    return () => {
      isCancelled = true;
      setIsReady(false);
      promise.then((patterns) => {
        for (const { url } of patterns) {
          URL.revokeObjectURL(url);
        }
      });
    };
  }, [dpr, maxZoom]);
  const defs = (0, import_jsx_runtime126.jsx)(import_jsx_runtime126.Fragment, { children: backgroundUrls.map((item) => {
    const id = getHashPatternZoomName(item.zoom, item.theme);
    return (0, import_jsx_runtime126.jsx)(
      "pattern",
      {
        id,
        width: TILE_PATTERN_SIZE,
        height: TILE_PATTERN_SIZE,
        patternUnits: "userSpaceOnUse",
        children: (0, import_jsx_runtime126.jsx)("image", { href: item.url, width: TILE_PATTERN_SIZE, height: TILE_PATTERN_SIZE })
      },
      id
    );
  }) });
  return { defs, isReady };
}
function PatternFillDefForCanvas() {
  const editor = useEditor();
  const containerRef = (0, import_react86.useRef)(null);
  const { defs, isReady } = usePattern();
  (0, import_react86.useEffect)(() => {
    if (isReady && tlenv.isSafari) {
      const htmlLayer = findHtmlLayerParent(containerRef.current);
      if (htmlLayer) {
        editor.timers.requestAnimationFrame(() => {
          htmlLayer.style.display = "none";
          editor.timers.requestAnimationFrame(() => {
            htmlLayer.style.display = "";
          });
        });
      }
    }
  }, [editor, isReady]);
  return (0, import_jsx_runtime126.jsx)("g", { ref: containerRef, "data-testid": isReady ? "ready-pattern-fill-defs" : void 0, children: defs });
}
function findHtmlLayerParent(element) {
  if (element.classList.contains("tl-html-layer"))
    return element;
  if (element.parentElement)
    return findHtmlLayerParent(element.parentElement);
  return null;
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/ShapeFill.mjs
var ShapeFill = import_react87.default.memo(function ShapeFill2({
  theme,
  d,
  color,
  fill,
  scale
}) {
  switch (fill) {
    case "none": {
      return null;
    }
    case "solid": {
      return (0, import_jsx_runtime127.jsx)("path", { fill: theme[color].semi, d });
    }
    case "semi": {
      return (0, import_jsx_runtime127.jsx)("path", { fill: theme.solid, d });
    }
    case "fill": {
      return (0, import_jsx_runtime127.jsx)("path", { fill: theme[color].fill, d });
    }
    case "pattern": {
      return (0, import_jsx_runtime127.jsx)(PatternFill, { theme, color, fill, d, scale });
    }
  }
});
function PatternFill({ d, color, theme }) {
  const editor = useEditor();
  const svgExport = useSvgExportContext();
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const getHashPatternZoomName = useGetHashPatternZoomName();
  const teenyTiny = editor.getZoomLevel() <= 0.18;
  return (0, import_jsx_runtime127.jsxs)(import_jsx_runtime127.Fragment, { children: [
    (0, import_jsx_runtime127.jsx)("path", { fill: theme[color].pattern, d }),
    (0, import_jsx_runtime127.jsx)(
      "path",
      {
        fill: svgExport ? `url(#${getHashPatternZoomName(1, theme.id)})` : teenyTiny ? theme[color].semi : `url(#${getHashPatternZoomName(zoomLevel, theme.id)})`,
        d
      }
    )
  ] });
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/SvgTextLabel.mjs
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/shared/createTextJsxFromSpans.mjs
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
function correctSpacesToNbsp(input) {
  return input.replace(/\s/g, " ");
}
function createTextJsxFromSpans(editor, spans, opts) {
  const { padding = 0 } = opts;
  if (spans.length === 0)
    return null;
  const bounds = Box.From(spans[0].box);
  for (const { box } of spans) {
    bounds.union(box);
  }
  const offsetX = padding + (opts.offsetX ?? 0);
  const offsetY = (opts.offsetY ?? 0) + opts.fontSize / 2 + (opts.verticalTextAlign === "start" ? padding : opts.verticalTextAlign === "end" ? opts.height - padding - bounds.height : (Math.ceil(opts.height) - bounds.height) / 2);
  let currentLineTop = null;
  const children = [];
  for (const { text, box } of spans) {
    const didBreakLine = currentLineTop !== null && box.y > currentLineTop;
    if (didBreakLine) {
      children.push(
        (0, import_jsx_runtime128.jsx)(
          "tspan",
          {
            alignmentBaseline: "mathematical",
            x: offsetX,
            y: box.y + offsetY,
            children: "\n"
          },
          children.length
        )
      );
    }
    children.push(
      (0, import_jsx_runtime128.jsx)(
        "tspan",
        {
          alignmentBaseline: "mathematical",
          x: box.x + offsetX,
          y: box.y + offsetY,
          unicodeBidi: "plaintext",
          children: correctSpacesToNbsp(text)
        },
        children.length
      )
    );
    currentLineTop = box.y;
  }
  return (0, import_jsx_runtime128.jsx)(
    "text",
    {
      fontSize: opts.fontSize,
      fontFamily: opts.fontFamily,
      fontStyle: opts.fontStyle,
      fontWeight: opts.fontWeight,
      dominantBaseline: "mathematical",
      alignmentBaseline: "mathematical",
      stroke: opts.stroke,
      strokeWidth: opts.strokeWidth,
      fill: opts.fill,
      children
    }
  );
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/SvgTextLabel.mjs
function SvgTextLabel({
  fontSize,
  font,
  align,
  verticalAlign,
  text,
  labelColor,
  bounds,
  padding = 16,
  stroke = true
}) {
  const editor = useEditor();
  const theme = useDefaultColorTheme();
  const opts = {
    fontSize,
    fontFamily: DefaultFontFamilies[font],
    textAlign: align,
    verticalTextAlign: verticalAlign,
    width: Math.ceil(bounds.width),
    height: Math.ceil(bounds.height),
    padding,
    lineHeight: TEXT_PROPS.lineHeight,
    fontStyle: "normal",
    fontWeight: "normal",
    overflow: "wrap",
    offsetX: 0,
    offsetY: 0,
    fill: labelColor,
    stroke: void 0,
    strokeWidth: void 0
  };
  const spans = editor.textMeasure.measureTextSpans(text, opts);
  const offsetX = getLegacyOffsetX(align, padding, spans, bounds.width);
  if (offsetX) {
    opts.offsetX = offsetX;
  }
  opts.offsetX += bounds.x;
  opts.offsetY += bounds.y;
  const mainSpans = createTextJsxFromSpans(editor, spans, opts);
  let outlineSpans = null;
  if (stroke) {
    opts.fill = theme.background;
    opts.stroke = theme.background;
    opts.strokeWidth = 2;
    outlineSpans = createTextJsxFromSpans(editor, spans, opts);
  }
  return (0, import_jsx_runtime129.jsxs)(import_jsx_runtime129.Fragment, { children: [
    outlineSpans,
    mainSpans
  ] });
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/ArrowPath.mjs
function getArrowBodyPath(shape, info, opts) {
  switch (info.type) {
    case "straight":
      return new PathBuilder().moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 }).lineTo(info.end.point.x, info.end.point.y, { offset: 0, roundness: 0 }).toSvg(opts);
    case "arc":
      return new PathBuilder().moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 }).arcTo(
        info.bodyArc.radius,
        !!info.bodyArc.largeArcFlag,
        !!info.bodyArc.sweepFlag,
        info.end.point.x,
        info.end.point.y,
        { offset: 0, roundness: 0 }
      ).toSvg(opts);
    case "elbow": {
      const path = new PathBuilder();
      path.moveTo(info.start.point.x, info.start.point.y, {
        offset: 0
      });
      for (let i = 1; i < info.route.points.length; i++) {
        const point = info.route.points[i];
        if (info.route.skipPointsWhenDrawing.has(point)) {
          continue;
        }
        path.lineTo(point.x, point.y, {
          offset: i === info.route.points.length - 1 ? 0 : void 0
        });
      }
      return path.toSvg(opts);
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
}
function getArrowHandlePath(info, opts) {
  switch (info.type) {
    case "straight":
      return new PathBuilder().moveTo(info.start.handle.x, info.start.handle.y).lineTo(info.end.handle.x, info.end.handle.y).toSvg(opts);
    case "arc":
      return new PathBuilder().moveTo(info.start.handle.x, info.start.handle.y).arcTo(
        info.handleArc.radius,
        !!info.handleArc.largeArcFlag,
        !!info.handleArc.sweepFlag,
        info.end.handle.x,
        info.end.handle.y
      ).toSvg(opts);
    case "elbow": {
      const handleRoute = getRouteHandlePath(info.elbow, info.route);
      return PathBuilder.throughPoints(handleRoute.points).toSvg(opts);
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/arrowLabel.mjs
var arrowBodyGeometryCache = createComputedCache(
  "arrow body geometry",
  (editor, shape) => {
    const info = getArrowInfo(editor, shape);
    switch (info.type) {
      case "straight":
        return new Edge2d({
          start: Vec.From(info.start.point),
          end: Vec.From(info.end.point)
        });
      case "arc":
        return new Arc2d({
          center: Vec.Cast(info.handleArc.center),
          start: Vec.Cast(info.start.point),
          end: Vec.Cast(info.end.point),
          sweepFlag: info.bodyArc.sweepFlag,
          largeArcFlag: info.bodyArc.largeArcFlag
        });
      case "elbow":
        return new Polyline2d({ points: info.route.points });
      default:
        exhaustiveSwitchError(info, "type");
    }
  }
);
var labelSizeCache = createComputedCache(
  "arrow label size",
  (editor, shape) => {
    editor.fonts.trackFontsForShape(shape);
    let width = 0;
    let height = 0;
    const bodyGeom = arrowBodyGeometryCache.get(editor, shape.id);
    const text = shape.props.text || "i";
    const bodyBounds = bodyGeom.bounds;
    const fontSize = getArrowLabelFontSize(shape);
    const { w, h } = editor.textMeasure.measureText(text, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[shape.props.font],
      fontSize,
      maxWidth: null
    });
    width = w;
    height = h;
    let shouldSquish = false;
    const info = getArrowInfo(editor, shape);
    const labelToArrowPadding = getLabelToArrowPadding(shape);
    const margin = info.type === "elbow" ? Math.max(info.elbow.A.arrowheadOffset + labelToArrowPadding, 32) + Math.max(info.elbow.B.arrowheadOffset + labelToArrowPadding, 32) : 64;
    if (bodyBounds.width > bodyBounds.height) {
      width = Math.max(Math.min(w, margin), Math.min(bodyBounds.width - margin, w));
      shouldSquish = true;
    } else if (width > 16 * fontSize) {
      width = 16 * fontSize;
      shouldSquish = true;
    }
    if (shouldSquish) {
      const { w: squishedWidth, h: squishedHeight } = editor.textMeasure.measureText(text, {
        ...TEXT_PROPS,
        fontFamily: FONT_FAMILIES[shape.props.font],
        fontSize,
        maxWidth: width
      });
      width = squishedWidth;
      height = squishedHeight;
    }
    return new Vec(width, height).addScalar(ARROW_LABEL_PADDING * 2 * shape.props.scale);
  },
  { areRecordsEqual: (a, b) => a.props === b.props }
);
function getArrowLabelSize(editor, shape) {
  return labelSizeCache.get(editor, shape.id) ?? new Vec(0, 0);
}
function getLabelToArrowPadding(shape) {
  const strokeWidth = STROKE_SIZES2[shape.props.size];
  const labelToArrowPadding = (LABEL_TO_ARROW_PADDING + (strokeWidth - STROKE_SIZES2.s) * 2 + (strokeWidth === STROKE_SIZES2.xl ? 20 : 0)) * shape.props.scale;
  return labelToArrowPadding;
}
function getArrowLabelRange(editor, shape, info) {
  const bodyGeom = arrowBodyGeometryCache.get(editor, shape.id);
  const dbgPoints = [];
  const dbg = [new Group2d({ children: [bodyGeom], debugColor: "lime" })];
  const labelSize = getArrowLabelSize(editor, shape);
  const labelToArrowPadding = getLabelToArrowPadding(shape);
  const paddingRelative = labelToArrowPadding / bodyGeom.length;
  let startBox, endBox;
  if (info.type === "elbow") {
    dbgPoints.push(info.start.point, info.end.point);
    startBox = Box.FromCenter(info.start.point, labelSize).expandBy(labelToArrowPadding);
    endBox = Box.FromCenter(info.end.point, labelSize).expandBy(labelToArrowPadding);
  } else {
    const startPoint = bodyGeom.interpolateAlongEdge(paddingRelative);
    const endPoint = bodyGeom.interpolateAlongEdge(1 - paddingRelative);
    dbgPoints.push(startPoint, endPoint);
    startBox = Box.FromCenter(startPoint, labelSize);
    endBox = Box.FromCenter(endPoint, labelSize);
  }
  const startIntersections = bodyGeom.intersectPolygon(startBox.corners);
  const endIntersections = bodyGeom.intersectPolygon(endBox.corners);
  const startConstrained = furthest(info.start.point, startIntersections);
  const endConstrained = furthest(info.end.point, endIntersections);
  let startRelative = startConstrained ? bodyGeom.uninterpolateAlongEdge(startConstrained) : 0.5;
  let endRelative = endConstrained ? bodyGeom.uninterpolateAlongEdge(endConstrained) : 0.5;
  if (startRelative > endRelative) {
    startRelative = 0.5;
    endRelative = 0.5;
  }
  for (const pt of [...startIntersections, ...endIntersections, ...dbgPoints]) {
    dbg.push(
      new Circle2d({
        x: pt.x - 3,
        y: pt.y - 3,
        radius: 3,
        isFilled: false,
        debugColor: "magenta",
        ignore: true
      })
    );
  }
  dbg.push(
    new Polygon2d({
      points: startBox.corners,
      debugColor: "lime",
      isFilled: false,
      ignore: true
    }),
    new Polygon2d({
      points: endBox.corners,
      debugColor: "lime",
      isFilled: false,
      ignore: true
    })
  );
  return { start: startRelative, end: endRelative, dbg };
}
function getArrowLabelPosition(editor, shape) {
  const debugGeom = [];
  const info = getArrowInfo(editor, shape);
  const arrowheadInfo = {
    hasStartBinding: !!info.bindings.start,
    hasEndBinding: !!info.bindings.end,
    hasStartArrowhead: info.start.arrowhead !== "none",
    hasEndArrowhead: info.end.arrowhead !== "none"
  };
  const range = getArrowLabelRange(editor, shape, info);
  if (range.dbg)
    debugGeom.push(...range.dbg);
  const clampedPosition = getClampedPosition(shape, range, arrowheadInfo);
  const bodyGeom = arrowBodyGeometryCache.get(editor, shape.id);
  const labelCenter = bodyGeom.interpolateAlongEdge(clampedPosition);
  const labelSize = getArrowLabelSize(editor, shape);
  return { box: Box.FromCenter(labelCenter, labelSize), debugGeom };
}
function getClampedPosition(shape, range, arrowheadInfo) {
  const { hasEndArrowhead, hasEndBinding, hasStartBinding, hasStartArrowhead } = arrowheadInfo;
  const clampedPosition = clamp(
    shape.props.labelPosition,
    hasStartArrowhead || hasStartBinding ? range.start : 0,
    hasEndArrowhead || hasEndBinding ? range.end : 1
  );
  return clampedPosition;
}
function furthest(from2, candidates) {
  let furthest2 = null;
  let furthestDist = -Infinity;
  for (const candidate of candidates) {
    const dist = Vec.Dist2(from2, candidate);
    if (dist > furthestDist) {
      furthest2 = candidate;
      furthestDist = dist;
    }
  }
  return furthest2;
}
function getArrowLabelFontSize(shape) {
  return ARROW_LABEL_FONT_SIZES[shape.props.size] * shape.props.scale;
}
function getArrowLabelDefaultPosition(editor, shape) {
  const info = getArrowInfo(editor, shape);
  switch (info.type) {
    case "straight":
    case "arc":
      return 0.5;
    case "elbow": {
      const midpointHandle = info.route.midpointHandle;
      const bodyGeom = arrowBodyGeometryCache.get(editor, shape.id);
      if (midpointHandle && bodyGeom) {
        return bodyGeom.uninterpolateAlongEdge(midpointHandle.point);
      }
      return 0.5;
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/arrowheads.mjs
function getArrowPoints(info, side, strokeWidth) {
  const point = side === "end" ? info.end.point : info.start.point;
  let int;
  switch (info.type) {
    case "straight": {
      const opposite = side === "end" ? info.start.point : info.end.point;
      const compareLength = Vec.Dist(opposite, point);
      const length = clamp(compareLength / 5, strokeWidth, strokeWidth * 3);
      int = Vec.Nudge(point, opposite, length);
      break;
    }
    case "arc": {
      const compareLength = Math.abs(info.bodyArc.length);
      const length = clamp(compareLength / 5, strokeWidth, strokeWidth * 3);
      const intersections = intersectCircleCircle(
        point,
        length,
        info.handleArc.center,
        info.handleArc.radius
      );
      int = side === "end" ? info.handleArc.sweepFlag ? intersections[0] : intersections[1] : info.handleArc.sweepFlag ? intersections[1] : intersections[0];
      break;
    }
    case "elbow": {
      const previousPoint = side === "end" ? info.route.points[info.route.points.length - 2] : info.route.points[1];
      const previousSegmentLength = Vec.ManhattanDist(previousPoint, point);
      const length = clamp(previousSegmentLength / 2, strokeWidth, strokeWidth * 3);
      int = previousPoint ? Vec.Nudge(point, previousPoint, length) : point;
      break;
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
  if (Vec.IsNaN(int)) {
    int = point;
  }
  return { point, int };
}
function getArrowhead({ point, int }) {
  const PL = Vec.RotWith(int, point, PI / 6);
  const PR = Vec.RotWith(int, point, -PI / 6);
  return `M ${PL.x} ${PL.y} L ${point.x} ${point.y} L ${PR.x} ${PR.y}`;
}
function getTriangleHead({ point, int }) {
  const PL = Vec.RotWith(int, point, PI / 6);
  const PR = Vec.RotWith(int, point, -PI / 6);
  return `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y} L ${point.x} ${point.y} Z`;
}
function getInvertedTriangleHead({ point, int }) {
  const d = Vec.Sub(int, point).div(2);
  const PL = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  return `M ${PL.x} ${PL.y} L ${int.x} ${int.y} L ${PR.x} ${PR.y} Z`;
}
function getDotHead({ point, int }) {
  const A = Vec.Lrp(point, int, 0.45);
  const r = Vec.Dist(A, point);
  return `M ${A.x - r},${A.y}
  a ${r},${r} 0 1,0 ${r * 2},0
  a ${r},${r} 0 1,0 -${r * 2},0 `;
}
function getDiamondHead({ point, int }) {
  const PB = Vec.Lrp(point, int, 0.75);
  const PL = Vec.RotWith(PB, point, PI / 4);
  const PR = Vec.RotWith(PB, point, -PI / 4);
  const PQ = Vec.Lrp(PL, PR, 0.5);
  PQ.add(Vec.Sub(PQ, point));
  return `M ${PQ.x} ${PQ.y} L ${PR.x} ${PR.y} ${point.x} ${point.y} L ${PL.x} ${PL.y} Z`;
}
function getSquareHead({ int, point }) {
  const PB = Vec.Lrp(point, int, 0.85);
  const d = Vec.Sub(PB, point).div(2);
  const PL1 = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR1 = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  const PL2 = Vec.Add(PB, Vec.Rot(d, HALF_PI));
  const PR2 = Vec.Sub(PB, Vec.Rot(d, HALF_PI));
  return `M ${PL1.x} ${PL1.y} L ${PL2.x} ${PL2.y} L ${PR2.x} ${PR2.y} L ${PR1.x} ${PR1.y} Z`;
}
function getBarHead({ int, point }) {
  const d = Vec.Sub(int, point).div(2);
  const PL = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  return `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y}`;
}
function getArrowheadPathForType(info, side, strokeWidth) {
  const type = side === "end" ? info.end.arrowhead : info.start.arrowhead;
  if (type === "none")
    return;
  const points = getArrowPoints(info, side, strokeWidth);
  if (!points)
    return;
  switch (type) {
    case "bar":
      return getBarHead(points);
    case "square":
      return getSquareHead(points);
    case "diamond":
      return getDiamondHead(points);
    case "dot":
      return getDotHead(points);
    case "inverted":
      return getInvertedTriangleHead(points);
    case "arrow":
      return getArrowhead(points);
    case "triangle":
      return getTriangleHead(points);
  }
  return "";
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/ElbowArrowDebug.mjs
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
function ElbowArrowDebug({ arrow: arrow6 }) {
  var _a5, _b;
  const editor = useEditor();
  const info = useValue(
    "elbow arrow grid",
    () => {
      try {
        const info2 = getElbowArrowInfo(
          editor,
          editor.getShape(arrow6.id),
          getArrowBindings(editor, arrow6)
        );
        return info2;
      } catch (err) {
        console.error(err);
        return void 0;
      }
    },
    [editor, arrow6.id]
  );
  if (!info)
    return null;
  const fullBox = Box.Common([info.A.original, info.B.original]).expandBy(50);
  const label = ((_a5 = info.route) == null ? void 0 : _a5.name) ?? "";
  const midPoint2 = (_b = info.route) == null ? void 0 : _b.midpointHandle;
  return (0, import_jsx_runtime130.jsxs)(import_jsx_runtime130.Fragment, { children: [
    info.midX !== null && (0, import_jsx_runtime130.jsx)(
      DebugLine,
      {
        a: { x: info.midX, y: fullBox.minY },
        b: { x: info.midX, y: fullBox.maxY },
        stroke: "red"
      }
    ),
    info.midY !== null && (0, import_jsx_runtime130.jsx)(
      DebugLine,
      {
        a: { x: fullBox.minX, y: info.midY },
        b: { x: fullBox.maxX, y: info.midY },
        stroke: "blue"
      }
    ),
    (midPoint2 == null ? void 0 : midPoint2.axis) === "x" && info.midXRange && (0, import_jsx_runtime130.jsx)(
      DebugLine,
      {
        a: { x: info.midXRange.lo, y: midPoint2.point.y },
        b: { x: info.midXRange.hi, y: midPoint2.point.y },
        stroke: "red",
        strokeDasharray: "0 2"
      }
    ),
    (midPoint2 == null ? void 0 : midPoint2.axis) === "y" && info.midYRange && (0, import_jsx_runtime130.jsx)(
      DebugLine,
      {
        a: { x: midPoint2.point.x, y: info.midYRange.lo },
        b: { x: midPoint2.point.x, y: info.midYRange.hi },
        stroke: "blue",
        strokeDasharray: "0 2"
      }
    ),
    (0, import_jsx_runtime130.jsx)(DebugBox, { box: info.A.original, stroke: "orange" }),
    (0, import_jsx_runtime130.jsx)(DebugBox, { box: info.A.expanded, stroke: "orange", strokeWidth: 0.5 }),
    (0, import_jsx_runtime130.jsx)(
      DebugBox,
      {
        box: info.A.original.clone().expandBy(info.options.minElbowLegLength),
        stroke: "orange",
        strokeWidth: 0.5
      }
    ),
    (0, import_jsx_runtime130.jsx)(DebugBox, { box: info.B.original, stroke: "lightskyblue" }),
    (0, import_jsx_runtime130.jsx)(DebugBox, { box: info.B.expanded, stroke: "lightskyblue", strokeWidth: 0.5 }),
    (0, import_jsx_runtime130.jsx)(
      DebugBox,
      {
        box: info.B.original.clone().expandBy(info.options.minElbowLegLength),
        stroke: "lightskyblue",
        strokeWidth: 0.5
      }
    ),
    (0, import_jsx_runtime130.jsx)(DebugEdge, { edge: info.A.edges.top, axis: "x", stroke: "orange" }),
    (0, import_jsx_runtime130.jsx)(DebugEdge, { edge: info.B.edges.top, axis: "x", stroke: "lightskyblue" }),
    (0, import_jsx_runtime130.jsx)(DebugEdge, { edge: info.A.edges.right, axis: "y", stroke: "orange" }),
    (0, import_jsx_runtime130.jsx)(DebugEdge, { edge: info.B.edges.right, axis: "y", stroke: "lightskyblue" }),
    (0, import_jsx_runtime130.jsx)(DebugEdge, { edge: info.A.edges.bottom, axis: "x", stroke: "orange" }),
    (0, import_jsx_runtime130.jsx)(DebugEdge, { edge: info.B.edges.bottom, axis: "x", stroke: "lightskyblue" }),
    (0, import_jsx_runtime130.jsx)(DebugEdge, { edge: info.A.edges.left, axis: "y", stroke: "orange" }),
    (0, import_jsx_runtime130.jsx)(DebugEdge, { edge: info.B.edges.left, axis: "y", stroke: "lightskyblue" }),
    info.route && (0, import_jsx_runtime130.jsx)(DebugRoute, { route: info.route.points, strokeWidth: 10 }),
    (0, import_jsx_runtime130.jsx)(
      "text",
      {
        x: fullBox.minX + 5,
        y: fullBox.minY - 3,
        fontSize: 10,
        fill: "black",
        stroke: "var(--color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: label
      }
    ),
    (0, import_jsx_runtime130.jsxs)(
      "text",
      {
        x: info.A.expanded.x,
        y: info.A.expanded.y,
        fontSize: 10,
        fill: "black",
        stroke: "var(--color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: [
          "A",
          info.route && `, ${info.route.aEdgePicking}`,
          info.A.isPoint && `, point`
        ]
      }
    ),
    (0, import_jsx_runtime130.jsxs)(
      "text",
      {
        x: info.B.expanded.x,
        y: info.B.expanded.y,
        fontSize: 10,
        fill: "black",
        stroke: "var(--color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: [
          "B",
          info.route && `, ${info.route.bEdgePicking}`,
          info.B.isPoint && `, point`
        ]
      }
    )
  ] });
}
function DebugLine({ a, b, ...props }) {
  return (0, import_jsx_runtime130.jsx)(
    "line",
    {
      fill: "none",
      strokeWidth: 1,
      strokeDasharray: "4,4",
      stroke: "green",
      x1: a.x,
      y1: a.y,
      x2: b.x,
      y2: b.y,
      ...props
    }
  );
}
function DebugRoute({ route, ...props }) {
  return (0, import_jsx_runtime130.jsx)(
    "polyline",
    {
      fill: "none",
      stroke: "darkorchid",
      strokeWidth: 3,
      opacity: 0.5,
      points: route.map((r) => `${r.x},${r.y}`).join(" "),
      ...props
    }
  );
}
function DebugEdge({
  edge,
  axis,
  ...props
}) {
  if (!edge || edge.expanded === null)
    return null;
  const vec = (vec2) => axis === "x" ? { x: vec2.y, y: vec2.x } : vec2;
  return (0, import_jsx_runtime130.jsxs)("g", { children: [
    (0, import_jsx_runtime130.jsx)(
      DebugLine,
      {
        a: vec({ x: edge.expanded, y: edge.cross.min }),
        b: vec({ x: edge.expanded, y: edge.cross.max }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    ),
    (0, import_jsx_runtime130.jsx)(
      DebugLine,
      {
        a: vec({ x: edge.expanded - 4, y: edge.cross.min }),
        b: vec({ x: edge.expanded + 4, y: edge.cross.min }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    ),
    (0, import_jsx_runtime130.jsx)(
      DebugLine,
      {
        a: vec({ x: edge.expanded - 4, y: edge.cross.max }),
        b: vec({ x: edge.expanded + 4, y: edge.cross.max }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    )
  ] });
}
function DebugBox({ box, ...props }) {
  return (0, import_jsx_runtime130.jsx)(
    "rect",
    {
      x: box.minX,
      y: box.minY,
      width: box.width,
      height: box.height,
      strokeDasharray: "4,4",
      strokeWidth: 1,
      fill: "none",
      ...props
    }
  );
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/elbowArrowSnapLines.mjs
var snapLinesStore = new WeakCache();
function getElbowArrowSnapLines(editor) {
  return snapLinesStore.get(editor, (editor2) => {
    const currentSelectedArrowShape = computed("current selected arrow shape", () => {
      const shape = editor2.getOnlySelectedShape();
      if (!shape || !editor2.isShapeOfType(shape, "arrow"))
        return null;
      return shape.id;
    });
    const unselectedArrowShapeIds = editor2.store.query.ids("shape", () => {
      const activeArrowShapeId = currentSelectedArrowShape.get();
      if (!activeArrowShapeId)
        return { type: { eq: "arrow" } };
      return {
        type: { eq: "arrow" },
        id: { neq: activeArrowShapeId }
      };
    });
    return computed("elbow arrow snap lines", () => {
      var _a5, _b;
      const result = /* @__PURE__ */ new Map();
      const currentPageShapeIds = editor2.getCurrentPageShapeIds();
      const viewportBounds = editor2.getViewportPageBounds();
      for (const id of unselectedArrowShapeIds.get()) {
        if (!currentPageShapeIds.has(id))
          continue;
        const shape = editor2.getShape(id);
        if ((shape == null ? void 0 : shape.type) !== "arrow")
          continue;
        const shapeBounds = editor2.getShapePageBounds(id);
        if (!shapeBounds || !viewportBounds.includes(shapeBounds))
          continue;
        const bindings = getArrowBindings(editor2, shape);
        const geometry = editor2.getShapePageGeometry(id);
        const vertices = geometry.getVertices({ includeInternal: false, includeLabels: false });
        for (let i = 1; i < vertices.length; i++) {
          const prev = vertices[i - 1];
          const curr = vertices[i];
          let angle = Vec.Angle(prev, curr);
          if (angle < 0)
            angle += Math.PI;
          let set = result.get(angle);
          if (!set) {
            set = /* @__PURE__ */ new Set();
            result.set(angle, set);
          }
          const perpDistance = perpDistanceToLineAngle(prev, angle);
          set.add({
            perpDistance,
            startBoundShapeId: (_a5 = bindings.start) == null ? void 0 : _a5.toId,
            endBoundShapeId: (_b = bindings.end) == null ? void 0 : _b.toId
          });
        }
      }
      return result;
    });
  }).get();
}
function perpDistanceToLineAngle(pointOnLine, lineAngle) {
  const perpDir = Vec.FromAngle(lineAngle).per();
  return Vec.Dpr(pointOnLine, perpDir);
}

// node_modules/tldraw/dist-esm/lib/shapes/arrow/ArrowShapeUtil.mjs
var ArrowHandles = ((ArrowHandles2) => {
  ArrowHandles2["Start"] = "start";
  ArrowHandles2["Middle"] = "middle";
  ArrowHandles2["End"] = "end";
  return ArrowHandles2;
})(ArrowHandles || {});
var ArrowShapeUtil = class extends ShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      expandElbowLegLength: {
        s: 28,
        m: 36,
        l: 44,
        xl: 66
      },
      minElbowLegLength: {
        s: STROKE_SIZES2.s * 3,
        m: STROKE_SIZES2.m * 3,
        l: STROKE_SIZES2.l * 3,
        xl: STROKE_SIZES2.xl * 3
      },
      minElbowHandleDistance: 16,
      arcArrowCenterSnapDistance: 16,
      elbowArrowCenterSnapDistance: 24,
      elbowArrowEdgeSnapDistance: 20,
      elbowArrowPointSnapDistance: 24,
      elbowArrowAxisSnapDistance: 16,
      labelCenterSnapDistance: 10,
      elbowMidpointSnapDistance: 10,
      elbowMinSegmentLengthToShowMidpointHandle: 20,
      hoverPreciseTimeout: 600,
      pointingPreciseTimeout: 320
    });
    __publicField(this, "_resizeInitialBindings", new WeakCache());
  }
  canEdit() {
    return true;
  }
  canBind({ toShapeType }) {
    return toShapeType !== "arrow";
  }
  canSnap() {
    return false;
  }
  canTabTo(shape) {
    const bindings = getArrowBindings(this.editor, shape);
    return !!(bindings.start || bindings.end || shape.props.text);
  }
  hideResizeHandles() {
    return true;
  }
  hideRotateHandle() {
    return true;
  }
  hideSelectionBoundsBg() {
    return true;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  canBeLaidOut(shape, info) {
    if (info.type === "flip") {
      const bindings = getArrowBindings(this.editor, shape);
      const { start: start2, end: end2 } = bindings;
      const { shapes = [] } = info;
      if (start2 && !shapes.find((s) => s.id === start2.toId))
        return false;
      if (end2 && !shapes.find((s) => s.id === end2.toId))
        return false;
    }
    return true;
  }
  getFontFaces(shape) {
    if (!shape.props.text)
      return EMPTY_ARRAY;
    return [DefaultFontFaces[`tldraw_${shape.props.font}`].normal.normal];
  }
  getDefaultProps() {
    return {
      kind: "arc",
      elbowMidPoint: 0.5,
      dash: "draw",
      size: "m",
      fill: "none",
      color: "black",
      labelColor: "black",
      bend: 0,
      start: { x: 0, y: 0 },
      end: { x: 2, y: 0 },
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      text: "",
      labelPosition: 0.5,
      font: "draw",
      scale: 1
    };
  }
  getGeometry(shape) {
    const isEditing = this.editor.getEditingShapeId() === shape.id;
    const info = getArrowInfo(this.editor, shape);
    const debugGeom = [];
    const bodyGeom = info.type === "straight" ? new Edge2d({
      start: Vec.From(info.start.point),
      end: Vec.From(info.end.point)
    }) : info.type === "arc" ? new Arc2d({
      center: Vec.Cast(info.handleArc.center),
      start: Vec.Cast(info.start.point),
      end: Vec.Cast(info.end.point),
      sweepFlag: info.bodyArc.sweepFlag,
      largeArcFlag: info.bodyArc.largeArcFlag
    }) : new Polyline2d({ points: info.route.points });
    let labelGeom;
    if (isEditing || shape.props.text.trim()) {
      const labelPosition = getArrowLabelPosition(this.editor, shape);
      if (debugFlags.debugGeometry.get()) {
        debugGeom.push(...labelPosition.debugGeom);
      }
      labelGeom = new Rectangle2d({
        x: labelPosition.box.x,
        y: labelPosition.box.y,
        width: labelPosition.box.w,
        height: labelPosition.box.h,
        isFilled: true,
        isLabel: true
      });
    }
    return new Group2d({
      children: [...labelGeom ? [bodyGeom, labelGeom] : [bodyGeom], ...debugGeom]
    });
  }
  getHandles(shape) {
    const info = getArrowInfo(this.editor, shape);
    const handles = [
      {
        id: "start",
        type: "vertex",
        index: "a1",
        x: info.start.handle.x,
        y: info.start.handle.y
      },
      {
        id: "end",
        type: "vertex",
        index: "a3",
        x: info.end.handle.x,
        y: info.end.handle.y
      }
    ];
    if (shape.props.kind === "arc" && (info.type === "straight" || info.type === "arc")) {
      handles.push({
        id: "middle",
        type: "virtual",
        index: "a2",
        x: info.middle.x,
        y: info.middle.y
      });
    }
    if (shape.props.kind === "elbow" && info.type === "elbow" && info.route.midpointHandle) {
      const shapePageTransform = this.editor.getShapePageTransform(shape.id);
      const segmentStart = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentStart);
      const segmentEnd = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentEnd);
      const segmentLength = Vec.Dist(segmentStart, segmentEnd) * this.editor.getZoomLevel();
      if (segmentLength > this.options.elbowMinSegmentLengthToShowMidpointHandle) {
        handles.push({
          id: "middle",
          type: "vertex",
          index: "a2",
          x: info.route.midpointHandle.point.x,
          y: info.route.midpointHandle.point.y
        });
      }
    }
    return handles;
  }
  getText(shape) {
    return shape.props.text;
  }
  onHandleDrag(shape, info) {
    const handleId = info.handle.id;
    switch (handleId) {
      case "middle":
        switch (shape.props.kind) {
          case "arc":
            return this.onArcMidpointHandleDrag(shape, info);
          case "elbow":
            return this.onElbowMidpointHandleDrag(shape, info);
          default:
            exhaustiveSwitchError(shape.props.kind);
        }
      case "start":
      case "end":
        return this.onTerminalHandleDrag(shape, info, handleId);
      default:
        exhaustiveSwitchError(handleId);
    }
  }
  onArcMidpointHandleDrag(shape, { handle }) {
    const bindings = getArrowBindings(this.editor, shape);
    const { start: start2, end: end2 } = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const delta = Vec.Sub(end2, start2);
    const v = Vec.Per(delta);
    const med = Vec.Med(end2, start2);
    const A = Vec.Sub(med, v);
    const B = Vec.Add(med, v);
    const point = Vec.NearestPointOnLineSegment(A, B, handle, false);
    let bend = Vec.Dist(point, med);
    if (Vec.Clockwise(point, end2, med))
      bend *= -1;
    return { id: shape.id, type: shape.type, props: { bend } };
  }
  onElbowMidpointHandleDrag(shape, { handle }) {
    var _a5, _b, _c, _d, _e;
    const info = getArrowInfo(this.editor, shape);
    if ((info == null ? void 0 : info.type) !== "elbow")
      return;
    const shapeToPageTransform = this.editor.getShapePageTransform(shape.id);
    const handlePagePoint = shapeToPageTransform.applyToPoint(handle);
    const axisName = (_a5 = info.route.midpointHandle) == null ? void 0 : _a5.axis;
    if (!axisName)
      return;
    const axis = ElbowArrowAxes[axisName];
    const midRange = info.elbow[axis.midRange];
    if (!midRange)
      return;
    let angle = Vec.Angle(
      shapeToPageTransform.applyToPoint(axis.v(0, 0)),
      shapeToPageTransform.applyToPoint(axis.v(0, 1))
    );
    if (angle < 0)
      angle += Math.PI;
    const handlePoint = perpDistanceToLineAngle(handlePagePoint, angle);
    const loPoint = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(midRange.lo, 0)),
      angle
    );
    const hiPoint = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(midRange.hi, 0)),
      angle
    );
    const maxSnapDistance = this.options.elbowMidpointSnapDistance / this.editor.getZoomLevel();
    const midPoint2 = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(lerp(midRange.lo, midRange.hi, 0.5), 0)),
      angle
    );
    let snapPoint = midPoint2;
    let snapDistance = Math.abs(midPoint2 - handlePoint);
    for (const [snapAngle2, snapLines] of getElbowArrowSnapLines(this.editor)) {
      const { isParallel, isFlippedParallel } = anglesAreApproximatelyParallel(angle, snapAngle2);
      if (isParallel || isFlippedParallel) {
        for (const snapLine of snapLines) {
          const doesShareStartIntersection = snapLine.startBoundShapeId && (snapLine.startBoundShapeId === ((_b = info.bindings.start) == null ? void 0 : _b.toId) || snapLine.startBoundShapeId === ((_c = info.bindings.end) == null ? void 0 : _c.toId));
          const doesShareEndIntersection = snapLine.endBoundShapeId && (snapLine.endBoundShapeId === ((_d = info.bindings.start) == null ? void 0 : _d.toId) || snapLine.endBoundShapeId === ((_e = info.bindings.end) == null ? void 0 : _e.toId));
          if (!doesShareStartIntersection && !doesShareEndIntersection)
            continue;
          const point = isFlippedParallel ? -snapLine.perpDistance : snapLine.perpDistance;
          const distance = Math.abs(point - handlePoint);
          if (distance < snapDistance) {
            snapPoint = point;
            snapDistance = distance;
          }
        }
      }
    }
    if (snapDistance > maxSnapDistance) {
      snapPoint = handlePoint;
    }
    const newMid = clamp(invLerp(loPoint, hiPoint, snapPoint), 0, 1);
    return {
      id: shape.id,
      type: shape.type,
      props: {
        elbowMidPoint: newMid
      }
    };
  }
  onTerminalHandleDrag(shape, { handle, isPrecise }, handleId) {
    const bindings = getArrowBindings(this.editor, shape);
    const update = { id: shape.id, type: "arrow", props: {} };
    const currentBinding = bindings[handleId];
    const oppositeHandleId = handleId === "start" ? "end" : "start";
    const oppositeBinding = bindings[oppositeHandleId];
    const targetInfo = updateArrowTargetState({
      editor: this.editor,
      pointInPageSpace: this.editor.getShapePageTransform(shape.id).applyToPoint(handle),
      arrow: shape,
      isPrecise,
      isExact: this.editor.inputs.altKey,
      currentBinding,
      oppositeBinding
    });
    if (!targetInfo) {
      removeArrowBinding(this.editor, shape, handleId);
      const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor);
      update.props[handleId] = {
        x: newPoint.x,
        y: newPoint.y
      };
      return update;
    }
    const bindingProps = {
      terminal: handleId,
      normalizedAnchor: targetInfo.normalizedAnchor,
      isPrecise: targetInfo.isPrecise,
      isExact: this.editor.inputs.altKey,
      snap: targetInfo.snap
    };
    createOrUpdateArrowBinding(this.editor, shape, targetInfo.target.id, bindingProps);
    const newBindings = getArrowBindings(this.editor, shape);
    if (newBindings.start && newBindings.end && newBindings.start.toId === newBindings.end.toId) {
      if (Vec.Equals(newBindings.start.props.normalizedAnchor, newBindings.end.props.normalizedAnchor)) {
        createOrUpdateArrowBinding(this.editor, shape, newBindings.end.toId, {
          ...newBindings.end.props,
          normalizedAnchor: {
            x: newBindings.end.props.normalizedAnchor.x + 0.05,
            y: newBindings.end.props.normalizedAnchor.y
          }
        });
      }
    }
    return update;
  }
  onTranslateStart(shape) {
    const bindings = getArrowBindings(this.editor, shape);
    if (shape.props.kind === "elbow" && this.editor.getOnlySelectedShapeId() === shape.id) {
      const info = getArrowInfo(this.editor, shape);
      if (!info)
        return;
      const update = { id: shape.id, type: "arrow", props: {} };
      if (bindings.start) {
        update.props.start = { x: info.start.point.x, y: info.start.point.y };
        removeArrowBinding(this.editor, shape, "start");
      }
      if (bindings.end) {
        update.props.end = { x: info.end.point.x, y: info.end.point.y };
        removeArrowBinding(this.editor, shape, "end");
      }
      return update;
    }
    const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const shapePageTransform = this.editor.getShapePageTransform(shape.id);
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    if (bindings.start && (selectedShapeIds.includes(bindings.start.toId) || this.editor.isAncestorSelected(bindings.start.toId)) || bindings.end && (selectedShapeIds.includes(bindings.end.toId) || this.editor.isAncestorSelected(bindings.end.toId))) {
      return;
    }
    shapeAtTranslationStart.set(shape, {
      pagePosition: shapePageTransform.applyToPoint(shape),
      terminalBindings: mapObjectMapValues(terminalsInArrowSpace, (terminalName, point) => {
        const binding = bindings[terminalName];
        if (!binding)
          return null;
        return {
          binding,
          shapePosition: point,
          pagePosition: shapePageTransform.applyToPoint(point)
        };
      })
    });
    if (bindings.start) {
      updateArrowTerminal({
        editor: this.editor,
        arrow: shape,
        terminal: "start",
        useHandle: true
      });
      shape = this.editor.getShape(shape.id);
    }
    if (bindings.end) {
      updateArrowTerminal({
        editor: this.editor,
        arrow: shape,
        terminal: "end",
        useHandle: true
      });
    }
    for (const handleName of [
      "start",
      "end"
      /* End */
    ]) {
      const binding = bindings[handleName];
      if (!binding)
        continue;
      this.editor.updateBinding({
        ...binding,
        props: { ...binding.props, isPrecise: true }
      });
    }
    return;
  }
  onTranslate(initialShape, shape) {
    const atTranslationStart = shapeAtTranslationStart.get(initialShape);
    if (!atTranslationStart)
      return;
    const shapePageTransform = this.editor.getShapePageTransform(shape.id);
    const pageDelta = Vec.Sub(
      shapePageTransform.applyToPoint(shape),
      atTranslationStart.pagePosition
    );
    for (const terminalBinding of Object.values(atTranslationStart.terminalBindings)) {
      if (!terminalBinding)
        continue;
      const newPagePoint = Vec.Add(terminalBinding.pagePosition, Vec.Mul(pageDelta, 0.5));
      const newTarget = this.editor.getShapeAtPoint(newPagePoint, {
        hitInside: true,
        hitFrameInside: true,
        margin: 0,
        filter: (targetShape) => {
          return !targetShape.isLocked && this.editor.canBindShapes({ fromShape: shape, toShape: targetShape, binding: "arrow" });
        }
      });
      if ((newTarget == null ? void 0 : newTarget.id) === terminalBinding.binding.toId) {
        const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(newTarget).bounds);
        const pointInTargetSpace = this.editor.getPointInShapeSpace(newTarget, newPagePoint);
        const normalizedAnchor = {
          x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
          y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height
        };
        createOrUpdateArrowBinding(this.editor, shape, newTarget.id, {
          ...terminalBinding.binding.props,
          normalizedAnchor,
          isPrecise: true
        });
      } else {
        removeArrowBinding(this.editor, shape, terminalBinding.binding.props.terminal);
      }
    }
  }
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    const bindings = this._resizeInitialBindings.get(
      shape,
      () => getArrowBindings(this.editor, shape)
    );
    const terminals = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const { start: start2, end: end2 } = structuredClone(shape.props);
    let { bend } = shape.props;
    if (!bindings.start) {
      start2.x = terminals.start.x * scaleX;
      start2.y = terminals.start.y * scaleY;
    }
    if (!bindings.end) {
      end2.x = terminals.end.x * scaleX;
      end2.y = terminals.end.y * scaleY;
    }
    const mx = Math.abs(scaleX);
    const my = Math.abs(scaleY);
    const startNormalizedAnchor = (bindings == null ? void 0 : bindings.start) ? Vec.From(bindings.start.props.normalizedAnchor) : null;
    const endNormalizedAnchor = (bindings == null ? void 0 : bindings.end) ? Vec.From(bindings.end.props.normalizedAnchor) : null;
    if (scaleX < 0 && scaleY >= 0) {
      if (bend !== 0) {
        bend *= -1;
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.x = 1 - startNormalizedAnchor.x;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.x = 1 - endNormalizedAnchor.x;
      }
    } else if (scaleX >= 0 && scaleY < 0) {
      if (bend !== 0) {
        bend *= -1;
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.y = 1 - startNormalizedAnchor.y;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.y = 1 - endNormalizedAnchor.y;
      }
    } else if (scaleX >= 0 && scaleY >= 0) {
      if (bend !== 0) {
        bend *= Math.max(mx, my);
      }
    } else if (scaleX < 0 && scaleY < 0) {
      if (bend !== 0) {
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.x = 1 - startNormalizedAnchor.x;
        startNormalizedAnchor.y = 1 - startNormalizedAnchor.y;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.x = 1 - endNormalizedAnchor.x;
        endNormalizedAnchor.y = 1 - endNormalizedAnchor.y;
      }
    }
    if (bindings.start && startNormalizedAnchor) {
      createOrUpdateArrowBinding(this.editor, shape, bindings.start.toId, {
        ...bindings.start.props,
        normalizedAnchor: startNormalizedAnchor.toJson()
      });
    }
    if (bindings.end && endNormalizedAnchor) {
      createOrUpdateArrowBinding(this.editor, shape, bindings.end.toId, {
        ...bindings.end.props,
        normalizedAnchor: endNormalizedAnchor.toJson()
      });
    }
    const next = {
      props: {
        start: start2,
        end: end2,
        bend
      }
    };
    return next;
  }
  onDoubleClickHandle(shape, handle) {
    switch (handle.id) {
      case "start": {
        return {
          id: shape.id,
          type: shape.type,
          props: {
            ...shape.props,
            arrowheadStart: shape.props.arrowheadStart === "none" ? "arrow" : "none"
          }
        };
      }
      case "end": {
        return {
          id: shape.id,
          type: shape.type,
          props: {
            ...shape.props,
            arrowheadEnd: shape.props.arrowheadEnd === "none" ? "arrow" : "none"
          }
        };
      }
    }
  }
  component(shape) {
    const theme = useDefaultColorTheme();
    const onlySelectedShape = this.editor.getOnlySelectedShape();
    const shouldDisplayHandles = this.editor.isInAny(
      "select.idle",
      "select.pointing_handle",
      "select.dragging_handle",
      "select.translating",
      "arrow.dragging"
    ) && !this.editor.getIsReadonly();
    const info = getArrowInfo(this.editor, shape);
    if (!(info == null ? void 0 : info.isValid))
      return null;
    const labelPosition = getArrowLabelPosition(this.editor, shape);
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const isEditing = this.editor.getEditingShapeId() === shape.id;
    const showArrowLabel = isEditing || shape.props.text;
    return (0, import_jsx_runtime131.jsxs)(import_jsx_runtime131.Fragment, { children: [
      (0, import_jsx_runtime131.jsxs)(SVGContainer, { style: { minWidth: 50, minHeight: 50 }, children: [
        (0, import_jsx_runtime131.jsx)(
          ArrowSvg,
          {
            shape,
            shouldDisplayHandles: shouldDisplayHandles && (onlySelectedShape == null ? void 0 : onlySelectedShape.id) === shape.id
          }
        ),
        shape.props.kind === "elbow" && debugFlags.debugElbowArrows.get() && (0, import_jsx_runtime131.jsx)(ElbowArrowDebug, { arrow: shape })
      ] }),
      showArrowLabel && (0, import_jsx_runtime131.jsx)(
        PlainTextLabel,
        {
          shapeId: shape.id,
          classNamePrefix: "tl-arrow",
          type: "arrow",
          font: shape.props.font,
          fontSize: getArrowLabelFontSize(shape),
          lineHeight: TEXT_PROPS.lineHeight,
          align: "middle",
          verticalAlign: "middle",
          text: shape.props.text,
          labelColor: theme[shape.props.labelColor].solid,
          textWidth: labelPosition.box.w - ARROW_LABEL_PADDING * 2 * shape.props.scale,
          isSelected,
          padding: 0,
          style: {
            transform: `translate(${labelPosition.box.center.x}px, ${labelPosition.box.center.y}px)`
          }
        }
      )
    ] });
  }
  indicator(shape) {
    const isEditing = useIsEditing(shape.id);
    const clipPathId = useSharedSafeId(shape.id + "_clip");
    const info = getArrowInfo(this.editor, shape);
    if (!info)
      return null;
    const { start: start2, end: end2 } = getArrowTerminalsInArrowSpace(this.editor, shape, info == null ? void 0 : info.bindings);
    const geometry = this.editor.getShapeGeometry(shape);
    const bounds = geometry.bounds;
    const labelGeometry = isEditing || shape.props.text.trim() ? geometry.children[1] : null;
    if (Vec.Equals(start2, end2))
      return null;
    const strokeWidth = STROKE_SIZES2[shape.props.size] * shape.props.scale;
    const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
    const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
    const includeClipPath = as && info.start.arrowhead !== "arrow" || ae && info.end.arrowhead !== "arrow" || !!labelGeometry;
    if (isEditing && labelGeometry) {
      return (0, import_jsx_runtime131.jsx)(
        "rect",
        {
          x: toDomPrecision(labelGeometry.x),
          y: toDomPrecision(labelGeometry.y),
          width: labelGeometry.w,
          height: labelGeometry.h,
          rx: 3.5 * shape.props.scale,
          ry: 3.5 * shape.props.scale
        }
      );
    }
    const clipStartArrowhead = !(info.start.arrowhead === "none" || info.start.arrowhead === "arrow");
    const clipEndArrowhead = !(info.end.arrowhead === "none" || info.end.arrowhead === "arrow");
    return (0, import_jsx_runtime131.jsxs)("g", { children: [
      includeClipPath && (0, import_jsx_runtime131.jsx)("defs", { children: (0, import_jsx_runtime131.jsx)(
        ArrowClipPath,
        {
          radius: 3.5 * shape.props.scale,
          hasText: shape.props.text.trim().length > 0,
          bounds,
          labelBounds: labelGeometry ? labelGeometry.getBounds() : new Box(0, 0, 0, 0),
          as: clipStartArrowhead && as ? as : "",
          ae: clipEndArrowhead && ae ? ae : ""
        }
      ) }),
      (0, import_jsx_runtime131.jsxs)(
        "g",
        {
          style: {
            clipPath: includeClipPath ? `url(#${clipPathId})` : void 0,
            WebkitClipPath: includeClipPath ? `url(#${clipPathId})` : void 0
          },
          children: [
            includeClipPath && (0, import_jsx_runtime131.jsx)(
              "rect",
              {
                x: bounds.minX - 100,
                y: bounds.minY - 100,
                width: bounds.width + 200,
                height: bounds.height + 200,
                opacity: 0
              }
            ),
            getArrowBodyPath(
              shape,
              info,
              shape.props.dash === "draw" ? {
                style: "draw",
                randomSeed: shape.id,
                strokeWidth: 1,
                passes: 1,
                offset: 0,
                roundness: strokeWidth * 2,
                props: { strokeWidth: void 0 }
              } : { style: "solid", strokeWidth: 1, props: { strokeWidth: void 0 } }
            )
          ]
        }
      ),
      as && (0, import_jsx_runtime131.jsx)("path", { d: as }),
      ae && (0, import_jsx_runtime131.jsx)("path", { d: ae }),
      labelGeometry && (0, import_jsx_runtime131.jsx)(
        "rect",
        {
          x: toDomPrecision(labelGeometry.x),
          y: toDomPrecision(labelGeometry.y),
          width: labelGeometry.w,
          height: labelGeometry.h,
          rx: 3.5,
          ry: 3.5
        }
      )
    ] });
  }
  onEditStart(shape) {
    if (shape.props.text.trim() === "") {
      const labelPosition = getArrowLabelDefaultPosition(this.editor, shape);
      this.editor.updateShape({
        id: shape.id,
        type: shape.type,
        props: { labelPosition }
      });
    }
  }
  onEditEnd(shape) {
    const {
      id,
      type,
      props: { text }
    } = shape;
    if (text.trimEnd() !== shape.props.text) {
      this.editor.updateShapes([
        {
          id,
          type,
          props: {
            text: text.trimEnd()
          }
        }
      ]);
    }
  }
  toSvg(shape, ctx) {
    ctx.addExportDef(getFillDefForExport(shape.props.fill));
    const theme = getDefaultColorTheme(ctx);
    const scaleFactor = 1 / shape.props.scale;
    return (0, import_jsx_runtime131.jsxs)("g", { transform: `scale(${scaleFactor})`, children: [
      (0, import_jsx_runtime131.jsx)(ArrowSvg, { shape, shouldDisplayHandles: false }),
      (0, import_jsx_runtime131.jsx)(
        SvgTextLabel,
        {
          fontSize: getArrowLabelFontSize(shape),
          font: shape.props.font,
          align: "middle",
          verticalAlign: "middle",
          text: shape.props.text,
          labelColor: theme[shape.props.labelColor].solid,
          bounds: getArrowLabelPosition(this.editor, shape).box.clone().expandBy(-ARROW_LABEL_PADDING * shape.props.scale),
          padding: 0
        }
      )
    ] });
  }
  getCanvasSvgDefs() {
    return [
      getFillDefForCanvas(),
      {
        key: `arrow:dot`,
        component: ArrowheadDotDef
      },
      {
        key: `arrow:cross`,
        component: ArrowheadCrossDef
      }
    ];
  }
  getInterpolatedProps(startShape, endShape, progress) {
    return {
      ...progress > 0.5 ? endShape.props : startShape.props,
      scale: lerp(startShape.props.scale, endShape.props.scale, progress),
      start: {
        x: lerp(startShape.props.start.x, endShape.props.start.x, progress),
        y: lerp(startShape.props.start.y, endShape.props.start.y, progress)
      },
      end: {
        x: lerp(startShape.props.end.x, endShape.props.end.x, progress),
        y: lerp(startShape.props.end.y, endShape.props.end.y, progress)
      },
      bend: lerp(startShape.props.bend, endShape.props.bend, progress),
      labelPosition: lerp(startShape.props.labelPosition, endShape.props.labelPosition, progress)
    };
  }
};
__publicField(ArrowShapeUtil, "type", "arrow");
__publicField(ArrowShapeUtil, "props", arrowShapeProps);
__publicField(ArrowShapeUtil, "migrations", arrowShapeMigrations);
var ArrowSvg = track(function ArrowSvg2({
  shape,
  shouldDisplayHandles
}) {
  const editor = useEditor();
  const theme = useDefaultColorTheme();
  const info = getArrowInfo(editor, shape);
  const isForceSolid = useValue(
    "force solid",
    () => {
      return editor.getZoomLevel() < 0.2;
    },
    [editor]
  );
  const clipPathId = useSharedSafeId(shape.id + "_clip");
  const arrowheadDotId = useSharedSafeId("arrowhead-dot");
  const arrowheadCrossId = useSharedSafeId("arrowhead-cross");
  const isEditing = useIsEditing(shape.id);
  const geometry = editor.getShapeGeometry(shape);
  if (!geometry)
    return null;
  const bounds = Box.ZeroFix(geometry.bounds);
  const bindings = getArrowBindings(editor, shape);
  if (!(info == null ? void 0 : info.isValid))
    return null;
  const strokeWidth = STROKE_SIZES2[shape.props.size] * shape.props.scale;
  const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
  const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
  let handlePath = null;
  if (shouldDisplayHandles && (bindings.start || bindings.end)) {
    handlePath = getArrowHandlePath(info, {
      style: "dashed",
      start: "skip",
      end: "skip",
      lengthRatio: 2.5,
      strokeWidth: 2 / editor.getZoomLevel(),
      props: {
        className: "tl-arrow-hint",
        markerStart: bindings.start ? bindings.start.props.isExact ? "" : bindings.start.props.isPrecise ? `url(#${arrowheadCrossId})` : `url(#${arrowheadDotId})` : "",
        markerEnd: bindings.end ? bindings.end.props.isExact ? "" : bindings.end.props.isPrecise ? `url(#${arrowheadCrossId})` : `url(#${arrowheadDotId})` : "",
        opacity: 0.16
      }
    });
  }
  const labelPosition = getArrowLabelPosition(editor, shape);
  const clipStartArrowhead = !(info.start.arrowhead === "none" || info.start.arrowhead === "arrow");
  const clipEndArrowhead = !(info.end.arrowhead === "none" || info.end.arrowhead === "arrow");
  return (0, import_jsx_runtime131.jsxs)(import_jsx_runtime131.Fragment, { children: [
    (0, import_jsx_runtime131.jsx)("defs", { children: (0, import_jsx_runtime131.jsx)("clipPath", { id: clipPathId, children: (0, import_jsx_runtime131.jsx)(
      ArrowClipPath,
      {
        radius: 3.5 * shape.props.scale,
        hasText: isEditing || shape.props.text.trim().length > 0,
        bounds,
        labelBounds: labelPosition.box,
        as: clipStartArrowhead && as ? as : "",
        ae: clipEndArrowhead && ae ? ae : ""
      }
    ) }) }),
    (0, import_jsx_runtime131.jsxs)(
      "g",
      {
        fill: "none",
        stroke: theme[shape.props.color].solid,
        strokeWidth,
        strokeLinejoin: "round",
        strokeLinecap: "round",
        pointerEvents: "none",
        children: [
          handlePath,
          (0, import_jsx_runtime131.jsxs)(
            "g",
            {
              style: {
                clipPath: `url(#${clipPathId})`,
                WebkitClipPath: `url(#${clipPathId})`
              },
              children: [
                (0, import_jsx_runtime131.jsx)(
                  "rect",
                  {
                    x: toDomPrecision(bounds.minX - 100),
                    y: toDomPrecision(bounds.minY - 100),
                    width: toDomPrecision(bounds.width + 200),
                    height: toDomPrecision(bounds.height + 200),
                    opacity: 0
                  }
                ),
                getArrowBodyPath(shape, info, {
                  style: shape.props.dash,
                  strokeWidth,
                  forceSolid: isForceSolid,
                  randomSeed: shape.id
                })
              ]
            }
          ),
          as && clipStartArrowhead && shape.props.fill !== "none" && (0, import_jsx_runtime131.jsx)(
            ShapeFill,
            {
              theme,
              d: as,
              color: shape.props.color,
              fill: shape.props.fill,
              scale: shape.props.scale
            }
          ),
          ae && clipEndArrowhead && shape.props.fill !== "none" && (0, import_jsx_runtime131.jsx)(
            ShapeFill,
            {
              theme,
              d: ae,
              color: shape.props.color,
              fill: shape.props.fill,
              scale: shape.props.scale
            }
          ),
          as && (0, import_jsx_runtime131.jsx)("path", { d: as }),
          ae && (0, import_jsx_runtime131.jsx)("path", { d: ae })
        ]
      }
    )
  ] });
});
function ArrowClipPath({
  radius,
  hasText,
  bounds,
  labelBounds,
  as,
  ae
}) {
  const path = (0, import_react88.useMemo)(() => {
    const path2 = new PathBuilder();
    path2.moveTo(bounds.left - 100, bounds.top - 100).lineTo(bounds.right + 100, bounds.top - 100).lineTo(bounds.right + 100, bounds.bottom + 100).lineTo(bounds.left - 100, bounds.bottom + 100).close();
    if (hasText) {
      path2.moveTo(labelBounds.left, labelBounds.top + radius).lineTo(labelBounds.left, labelBounds.bottom - radius).arcTo(radius, false, false, labelBounds.left + radius, labelBounds.bottom).lineTo(labelBounds.right - radius, labelBounds.bottom).arcTo(radius, false, false, labelBounds.right, labelBounds.bottom - radius).lineTo(labelBounds.right, labelBounds.top + radius).arcTo(radius, false, false, labelBounds.right - radius, labelBounds.top).lineTo(labelBounds.left + radius, labelBounds.top).arcTo(radius, false, false, labelBounds.left, labelBounds.top + radius).close();
    }
    return path2.toD();
  }, [
    radius,
    hasText,
    bounds.bottom,
    bounds.left,
    bounds.right,
    bounds.top,
    labelBounds.bottom,
    labelBounds.left,
    labelBounds.right,
    labelBounds.top
  ]);
  return (0, import_jsx_runtime131.jsx)("path", { d: `${path}${as}${ae}` });
}
var shapeAtTranslationStart = /* @__PURE__ */ new WeakMap();
function ArrowheadDotDef() {
  const id = useSharedSafeId("arrowhead-dot");
  return (0, import_jsx_runtime131.jsx)("marker", { id, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "0", children: (0, import_jsx_runtime131.jsx)("circle", { cx: "3", cy: "3", r: "2", strokeDasharray: "100%" }) });
}
function ArrowheadCrossDef() {
  const id = useSharedSafeId("arrowhead-cross");
  return (0, import_jsx_runtime131.jsxs)("marker", { id, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "auto", children: [
    (0, import_jsx_runtime131.jsx)("line", { x1: "1.5", y1: "1.5", x2: "4.5", y2: "4.5", strokeDasharray: "100%" }),
    (0, import_jsx_runtime131.jsx)("line", { x1: "1.5", y1: "4.5", x2: "4.5", y2: "1.5", strokeDasharray: "100%" })
  ] });
}
function anglesAreApproximatelyParallel(a, b, tolerance = 1e-4) {
  const diff = Math.abs(a - b);
  const isParallel = diff < tolerance;
  const isFlippedParallel = Math.abs(diff - Math.PI) < tolerance;
  const is360Parallel = Math.abs(diff - PI2) < tolerance;
  return { isParallel: isParallel || is360Parallel, isFlippedParallel };
}

// node_modules/tldraw/dist-esm/lib/shapes/bookmark/BookmarkShapeUtil.mjs
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
var import_classnames24 = __toESM(require_classnames(), 1);
var import_react89 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/shared/HyperlinkButton.mjs
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var import_classnames23 = __toESM(require_classnames(), 1);
var LINK_ICON = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
function HyperlinkButton({ url }) {
  const editor = useEditor();
  const hideButton = useValue("zoomLevel", () => editor.getZoomLevel() < 0.32, [editor]);
  return (0, import_jsx_runtime132.jsx)(
    "a",
    {
      className: (0, import_classnames23.default)("tl-hyperlink-button", {
        "tl-hyperlink-button__hidden": hideButton
      }),
      href: url,
      target: "_blank",
      rel: "noopener noreferrer",
      onPointerDown: stopEventPropagation,
      onPointerUp: stopEventPropagation,
      title: url,
      draggable: false,
      children: (0, import_jsx_runtime132.jsx)(
        "div",
        {
          className: "tl-hyperlink__icon",
          style: {
            mask: `url("${LINK_ICON}") center 100% / 100% no-repeat`,
            WebkitMask: `url("${LINK_ICON}") center 100% / 100% no-repeat`
          }
        }
      )
    }
  );
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/icons-editor.mjs
var LINK_ICON2 = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";

// node_modules/tldraw/dist-esm/lib/shapes/shared/rotated-box-shadow.mjs
var ROTATING_BOX_SHADOWS = [
  {
    offsetX: 0,
    offsetY: 2,
    blur: 4,
    spread: 0,
    color: "#00000029"
  },
  {
    offsetX: 0,
    offsetY: 3,
    blur: 6,
    spread: 0,
    color: "#0000001f"
  }
];
function getRotatedBoxShadow(rotation) {
  const cssStrings = ROTATING_BOX_SHADOWS.map((shadow) => {
    const { offsetX, offsetY, blur: blur2, spread, color } = shadow;
    const vec = new Vec(offsetX, offsetY);
    const { x, y } = vec.rot(-rotation);
    return `${x}px ${y}px ${blur2}px ${spread}px ${color}`;
  });
  return cssStrings.join(", ");
}

// node_modules/tldraw/dist-esm/lib/shapes/bookmark/BookmarkShapeUtil.mjs
var BOOKMARK_WIDTH = 300;
var BOOKMARK_HEIGHT = 320;
var BOOKMARK_JUST_URL_HEIGHT = 46;
var SHORT_BOOKMARK_HEIGHT = 101;
var BookmarkShapeUtil = class extends BaseBoxShapeUtil {
  canResize() {
    return false;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  getText(shape) {
    return shape.props.url;
  }
  getAriaDescriptor(shape) {
    const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : null;
    if (!(asset == null ? void 0 : asset.props.title))
      return void 0;
    return convertCommonTitleHTMLEntities(asset.props.title) + (asset.props.description ? ", " + asset.props.description : "");
  }
  getDefaultProps() {
    return {
      url: "",
      w: BOOKMARK_WIDTH,
      h: BOOKMARK_HEIGHT,
      assetId: null
    };
  }
  component(shape) {
    return (0, import_jsx_runtime133.jsx)(BookmarkShapeComponent, { shape, util: this });
  }
  indicator(shape) {
    return (0, import_jsx_runtime133.jsx)(
      "rect",
      {
        width: toDomPrecision(shape.props.w),
        height: toDomPrecision(shape.props.h),
        rx: "6",
        ry: "6"
      }
    );
  }
  onBeforeCreate(next) {
    return getBookmarkSize(this.editor, next);
  }
  onBeforeUpdate(prev, shape) {
    if (prev.props.url !== shape.props.url) {
      if (!validation_exports.linkUrl.isValid(shape.props.url)) {
        return { ...shape, props: { ...shape.props, url: prev.props.url } };
      } else {
        updateBookmarkAssetOnUrlChange(this.editor, shape);
      }
    }
    if (prev.props.assetId !== shape.props.assetId) {
      return getBookmarkSize(this.editor, shape);
    }
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
};
__publicField(BookmarkShapeUtil, "type", "bookmark");
__publicField(BookmarkShapeUtil, "props", bookmarkShapeProps);
__publicField(BookmarkShapeUtil, "migrations", bookmarkShapeMigrations);
function BookmarkShapeComponent({
  shape,
  util
}) {
  const asset = shape.props.assetId ? util.editor.getAsset(shape.props.assetId) : null;
  const isSafariExport = !!useSvgExportContext() && tlenv.isSafari;
  const pageRotation = util.editor.getShapePageTransform(shape).rotation();
  const address = getHumanReadableAddress(shape);
  const [isFaviconValid, setIsFaviconValid] = (0, import_react89.useState)(true);
  const onFaviconError = () => setIsFaviconValid(false);
  return (0, import_jsx_runtime133.jsx)(HTMLContainer, { children: (0, import_jsx_runtime133.jsxs)(
    "div",
    {
      className: (0, import_classnames24.default)(
        "tl-bookmark__container",
        isSafariExport && "tl-bookmark__container--safariExport"
      ),
      style: {
        boxShadow: isSafariExport ? void 0 : getRotatedBoxShadow(pageRotation),
        maxHeight: shape.props.h
      },
      children: [
        (!asset || asset.props.image) && (0, import_jsx_runtime133.jsxs)("div", { className: "tl-bookmark__image_container", children: [
          asset ? (0, import_jsx_runtime133.jsx)(
            "img",
            {
              className: "tl-bookmark__image",
              draggable: false,
              referrerPolicy: "strict-origin-when-cross-origin",
              src: asset == null ? void 0 : asset.props.image,
              alt: (asset == null ? void 0 : asset.props.title) || ""
            }
          ) : (0, import_jsx_runtime133.jsx)("div", { className: "tl-bookmark__placeholder" }),
          (asset == null ? void 0 : asset.props.image) && (0, import_jsx_runtime133.jsx)(HyperlinkButton, { url: shape.props.url })
        ] }),
        (0, import_jsx_runtime133.jsxs)("div", { className: "tl-bookmark__copy_container", children: [
          (asset == null ? void 0 : asset.props.title) ? (0, import_jsx_runtime133.jsx)("h2", { className: "tl-bookmark__heading", children: convertCommonTitleHTMLEntities(asset.props.title) }) : null,
          (asset == null ? void 0 : asset.props.description) && (asset == null ? void 0 : asset.props.image) ? (0, import_jsx_runtime133.jsx)("p", { className: "tl-bookmark__description", children: asset.props.description }) : null,
          (0, import_jsx_runtime133.jsxs)(
            "a",
            {
              className: "tl-bookmark__link",
              href: shape.props.url || "",
              target: "_blank",
              rel: "noopener noreferrer",
              onPointerDown: stopEventPropagation,
              onPointerUp: stopEventPropagation,
              onClick: stopEventPropagation,
              children: [
                isFaviconValid && (asset == null ? void 0 : asset.props.favicon) ? (0, import_jsx_runtime133.jsx)(
                  "img",
                  {
                    className: "tl-bookmark__favicon",
                    src: asset == null ? void 0 : asset.props.favicon,
                    referrerPolicy: "strict-origin-when-cross-origin",
                    onError: onFaviconError,
                    alt: `favicon of ${address}`
                  }
                ) : (0, import_jsx_runtime133.jsx)(
                  "div",
                  {
                    className: "tl-hyperlink__icon",
                    style: {
                      mask: `url("${LINK_ICON2}") center 100% / 100% no-repeat`,
                      WebkitMask: `url("${LINK_ICON2}") center 100% / 100% no-repeat`
                    }
                  }
                ),
                (0, import_jsx_runtime133.jsx)("span", { children: address })
              ]
            }
          )
        ] })
      ]
    }
  ) });
}
function getBookmarkSize(editor, shape) {
  const asset = shape.props.assetId ? editor.getAsset(shape.props.assetId) : null;
  let h = BOOKMARK_HEIGHT;
  if (asset) {
    if (!asset.props.image) {
      if (!asset.props.title) {
        h = BOOKMARK_JUST_URL_HEIGHT;
      } else {
        h = SHORT_BOOKMARK_HEIGHT;
      }
    }
  }
  return {
    ...shape,
    props: {
      ...shape.props,
      h
    }
  };
}
var getHumanReadableAddress = (shape) => {
  try {
    const url = new URL(shape.props.url);
    return url.hostname.replace(/^www\./, "");
  } catch {
    return shape.props.url;
  }
};
function updateBookmarkAssetOnUrlChange(editor, shape) {
  const { url } = shape.props;
  const assetId = AssetRecordType.createId(getHashForString(url));
  if (editor.getAsset(assetId)) {
    if (shape.props.assetId !== assetId) {
      editor.updateShapes([
        {
          id: shape.id,
          type: shape.type,
          props: { assetId }
        }
      ]);
    }
  } else {
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: { assetId: null }
      }
    ]);
    createBookmarkAssetOnUrlChange(editor, shape);
  }
}
var createBookmarkAssetOnUrlChange = debounce(async (editor, shape) => {
  if (editor.isDisposed)
    return;
  const { url } = shape.props;
  const asset = await editor.getAssetForExternalContent({ type: "url", url });
  if (!asset) {
    return;
  }
  editor.run(() => {
    editor.createAssets([asset]);
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: { assetId: asset.id }
      }
    ]);
  });
}, 500);

// node_modules/tldraw/dist-esm/lib/shapes/draw/DrawShapeUtil.mjs
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/svg.mjs
function getSvgPathFromStrokePoints(points, closed = false) {
  const len = points.length;
  if (len < 2) {
    return "";
  }
  let a = points[0].point;
  let b = points[1].point;
  if (len === 2) {
    return `M${precise(a)}L${precise(b)}`;
  }
  let result = "";
  for (let i = 2, max3 = len - 1; i < max3; i++) {
    a = points[i].point;
    b = points[i + 1].point;
    result += average(a, b);
  }
  if (closed) {
    return `M${average(points[0].point, points[1].point)}Q${precise(points[1].point)}${average(
      points[1].point,
      points[2].point
    )}T${result}${average(points[len - 1].point, points[0].point)}${average(
      points[0].point,
      points[1].point
    )}Z`;
  } else {
    return `M${precise(points[0].point)}Q${precise(points[1].point)}${average(
      points[1].point,
      points[2].point
    )}${points.length > 3 ? "T" : ""}${result}L${precise(points[len - 1].point)}`;
  }
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/svgInk.mjs
function svgInk(rawInputPoints, options2 = {}) {
  const { start: start2 = {}, end: end2 = {} } = options2;
  const { cap: capStart = true } = start2;
  const { cap: capEnd = true } = end2;
  assert(!start2.taper && !end2.taper, "cap taper not supported here");
  assert(!start2.easing && !end2.easing, "cap easing not supported here");
  assert(capStart && capEnd, "cap must be true");
  const points = getStrokePoints(rawInputPoints, options2);
  setStrokePointRadii(points, options2);
  const partitions = partitionAtElbows(points);
  let svg = "";
  for (const partition2 of partitions) {
    svg += renderPartition(partition2, options2);
  }
  return svg;
}
function partitionAtElbows(points) {
  if (points.length <= 2)
    return [points];
  const result = [];
  let currentPartition = [points[0]];
  let prevV = Vec.Sub(points[1].point, points[0].point).uni();
  let nextV;
  let dpr;
  let prevPoint, thisPoint, nextPoint;
  for (let i = 1, n = points.length; i < n - 1; i++) {
    prevPoint = points[i - 1];
    thisPoint = points[i];
    nextPoint = points[i + 1];
    nextV = Vec.Sub(nextPoint.point, thisPoint.point).uni();
    dpr = Vec.Dpr(prevV, nextV);
    prevV = nextV;
    if (dpr < -0.8) {
      const elbowPoint = {
        ...thisPoint,
        point: thisPoint.input
      };
      currentPartition.push(elbowPoint);
      result.push(cleanUpPartition(currentPartition));
      currentPartition = [elbowPoint];
      continue;
    }
    currentPartition.push(thisPoint);
    if (dpr > 0.7) {
      continue;
    }
    if ((Vec.Dist2(prevPoint.point, thisPoint.point) + Vec.Dist2(thisPoint.point, nextPoint.point)) / ((prevPoint.radius + thisPoint.radius + nextPoint.radius) / 3) ** 2 < 1.5) {
      currentPartition.push(thisPoint);
      result.push(cleanUpPartition(currentPartition));
      currentPartition = [thisPoint];
      continue;
    }
  }
  currentPartition.push(points[points.length - 1]);
  result.push(cleanUpPartition(currentPartition));
  return result;
}
function cleanUpPartition(partition2) {
  const startPoint = partition2[0];
  let nextPoint;
  while (partition2.length > 2) {
    nextPoint = partition2[1];
    if (Vec.Dist2(startPoint.point, nextPoint.point) < ((startPoint.radius + nextPoint.radius) / 2 * 0.5) ** 2) {
      partition2.splice(1, 1);
    } else {
      break;
    }
  }
  const endPoint = partition2[partition2.length - 1];
  let prevPoint;
  while (partition2.length > 2) {
    prevPoint = partition2[partition2.length - 2];
    if (Vec.Dist2(endPoint.point, prevPoint.point) < ((endPoint.radius + prevPoint.radius) / 2 * 0.5) ** 2) {
      partition2.splice(partition2.length - 2, 1);
    } else {
      break;
    }
  }
  if (partition2.length > 1) {
    partition2[0] = {
      ...partition2[0],
      vector: Vec.Sub(partition2[0].point, partition2[1].point).uni()
    };
    partition2[partition2.length - 1] = {
      ...partition2[partition2.length - 1],
      vector: Vec.Sub(
        partition2[partition2.length - 2].point,
        partition2[partition2.length - 1].point
      ).uni()
    };
  }
  return partition2;
}
function circlePath(cx, cy, r) {
  return "M " + cx + " " + cy + " m -" + r + ", 0 a " + r + "," + r + " 0 1,1 " + r * 2 + ",0 a " + r + "," + r + " 0 1,1 -" + r * 2 + ",0";
}
function renderPartition(strokePoints, options2 = {}) {
  if (strokePoints.length === 0)
    return "";
  if (strokePoints.length === 1) {
    return circlePath(strokePoints[0].point.x, strokePoints[0].point.y, strokePoints[0].radius);
  }
  const { left: left2, right: right2 } = getStrokeOutlineTracks(strokePoints, options2);
  right2.reverse();
  let svg = `M${precise(left2[0])}T`;
  for (let i = 1; i < left2.length; i++) {
    svg += average(left2[i - 1], left2[i]);
  }
  {
    const point = strokePoints[strokePoints.length - 1];
    const radius = point.radius;
    const direction = point.vector.clone().per().neg();
    const arcStart = Vec.Add(point.point, Vec.Mul(direction, radius));
    const arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius));
    svg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(
      radius
    )} 0 0 1 ${precise(arcEnd)}T`;
  }
  for (let i = 1; i < right2.length; i++) {
    svg += average(right2[i - 1], right2[i]);
  }
  {
    const point = strokePoints[0];
    const radius = point.radius;
    const direction = point.vector.clone().per();
    const arcStart = Vec.Add(point.point, Vec.Mul(direction, radius));
    const arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius));
    svg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(
      radius
    )} 0 0 1 ${precise(arcEnd)}Z`;
  }
  return svg;
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/interpolate-props.mjs
var interpolateSegments = (startSegments, endSegments, progress) => {
  const startPoints = [];
  const endPoints = [];
  startSegments.forEach((segment) => startPoints.push(...segment.points));
  endSegments.forEach((segment) => endPoints.push(...segment.points));
  const maxLength = Math.max(startPoints.length, endPoints.length);
  const pointsToUseStart = [];
  const pointsToUseEnd = [];
  for (let i = 0; i < maxLength; i++) {
    pointsToUseStart.push(startPoints[i] || startPoints[startPoints.length - 1]);
    pointsToUseEnd.push(endPoints[i] || endPoints[endPoints.length - 1]);
  }
  const interpolatedPoints = pointsToUseStart.map((point, k) => {
    let z = 0.5;
    if (pointsToUseEnd[k].z !== void 0 && point.z !== void 0) {
      z = lerp(point.z, pointsToUseEnd[k].z, progress);
    }
    return {
      x: lerp(point.x, pointsToUseEnd[k].x, progress),
      y: lerp(point.y, pointsToUseEnd[k].y, progress),
      z
    };
  });
  return [
    {
      type: "free",
      points: interpolatedPoints
    }
  ];
};

// node_modules/tldraw/dist-esm/lib/shapes/draw/getPath.mjs
var PEN_EASING = (t2) => t2 * 0.65 + SIN(t2 * PI / 2) * 0.35;
var simulatePressureSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0.5,
    streamline: modulate(strokeWidth, [9, 16], [0.64, 0.74], true),
    // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
    smoothing: 0.62,
    easing: EASINGS.easeOutSine,
    simulatePressure: true
  };
};
var realPressureSettings = (strokeWidth) => {
  return {
    size: 1 + strokeWidth * 1.2,
    thinning: 0.62,
    streamline: 0.62,
    smoothing: 0.62,
    simulatePressure: false,
    easing: PEN_EASING
  };
};
var solidSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0,
    streamline: modulate(strokeWidth, [9, 16], [0.64, 0.74], true),
    // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
    smoothing: 0.62,
    simulatePressure: false,
    easing: EASINGS.linear
  };
};
var solidRealPressureSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0,
    streamline: 0.62,
    smoothing: 0.62,
    simulatePressure: false,
    easing: EASINGS.linear
  };
};
function getHighlightFreehandSettings({
  strokeWidth,
  showAsComplete
}) {
  return {
    size: 1 + strokeWidth,
    thinning: 0,
    streamline: 0.5,
    smoothing: 0.5,
    simulatePressure: false,
    easing: EASINGS.easeOutSine,
    last: showAsComplete
  };
}
function getFreehandOptions(shapeProps, strokeWidth, forceComplete, forceSolid) {
  const last3 = shapeProps.isComplete || forceComplete;
  if (forceSolid) {
    if (shapeProps.isPen) {
      return { ...solidRealPressureSettings(strokeWidth), last: last3 };
    } else {
      return { ...solidSettings(strokeWidth), last: last3 };
    }
  }
  if (shapeProps.dash === "draw") {
    if (shapeProps.isPen) {
      return { ...realPressureSettings(strokeWidth), last: last3 };
    } else {
      return { ...simulatePressureSettings(strokeWidth), last: last3 };
    }
  }
  return { ...solidSettings(strokeWidth), last: last3 };
}
function getPointsFromSegments(segments) {
  const points = [];
  for (const segment of segments) {
    if (segment.type === "free" || segment.points.length < 2) {
      points.push(...segment.points.map(Vec.Cast));
    } else {
      const pointsToInterpolate = Math.max(
        4,
        Math.floor(Vec.Dist(segment.points[0], segment.points[1]) / 16)
      );
      points.push(...Vec.PointsBetween(segment.points[0], segment.points[1], pointsToInterpolate));
    }
  }
  return points;
}
function getDrawShapeStrokeDashArray(shape, strokeWidth, dotAdjustment) {
  return {
    draw: "none",
    solid: `none`,
    dotted: `${dotAdjustment} ${strokeWidth * 2}`,
    dashed: `${strokeWidth * 2} ${strokeWidth * 2}`
  }[shape.props.dash];
}

// node_modules/tldraw/dist-esm/lib/shapes/draw/DrawShapeUtil.mjs
var DrawShapeUtil = class extends ShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      maxPointsPerShape: 600
    });
  }
  canTabTo() {
    return false;
  }
  hideResizeHandles(shape) {
    return getIsDot(shape);
  }
  hideRotateHandle(shape) {
    return getIsDot(shape);
  }
  hideSelectionBoundsFg(shape) {
    return getIsDot(shape);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      isComplete: false,
      isClosed: false,
      isPen: false,
      scale: 1
    };
  }
  getGeometry(shape) {
    const points = getPointsFromSegments(shape.props.segments);
    const sw = (STROKE_SIZES2[shape.props.size] + 1) * shape.props.scale;
    if (shape.props.segments.length === 1) {
      const box = Box.FromPoints(points);
      if (box.width < sw * 2 && box.height < sw * 2) {
        return new Circle2d({
          x: -sw,
          y: -sw,
          radius: sw,
          isFilled: true
        });
      }
    }
    const strokePoints = getStrokePoints(
      points,
      getFreehandOptions(shape.props, sw, shape.props.isPen, true)
    ).map((p) => p.point);
    if (shape.props.isClosed) {
      return new Polygon2d({
        points: strokePoints,
        isFilled: shape.props.fill !== "none"
      });
    }
    return new Polyline2d({
      points: strokePoints
    });
  }
  component(shape) {
    return (0, import_jsx_runtime134.jsx)(SVGContainer, { children: (0, import_jsx_runtime134.jsx)(DrawShapeSvg, { shape }) });
  }
  indicator(shape) {
    var _a5;
    const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
    let sw = (STROKE_SIZES2[shape.props.size] + 1) * shape.props.scale;
    const forceSolid = useValue(
      "force solid",
      () => {
        const zoomLevel = this.editor.getZoomLevel();
        return zoomLevel < 0.5 && zoomLevel < 1.5 / sw;
      },
      [this.editor, sw]
    );
    if (!forceSolid && !shape.props.isPen && shape.props.dash === "draw" && allPointsFromSegments.length === 1) {
      sw += rng(shape.id)() * (sw / 6);
    }
    const showAsComplete = shape.props.isComplete || ((_a5 = last(shape.props.segments)) == null ? void 0 : _a5.type) === "straight";
    const options2 = getFreehandOptions(shape.props, sw, showAsComplete, true);
    const strokePoints = getStrokePoints(allPointsFromSegments, options2);
    const solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed) : getDot(allPointsFromSegments[0], sw);
    return (0, import_jsx_runtime134.jsx)("path", { d: solidStrokePath });
  }
  toSvg(shape, ctx) {
    ctx.addExportDef(getFillDefForExport(shape.props.fill));
    const scaleFactor = 1 / shape.props.scale;
    return (0, import_jsx_runtime134.jsx)("g", { transform: `scale(${scaleFactor})`, children: (0, import_jsx_runtime134.jsx)(DrawShapeSvg, { shape, zoomOverride: 1 }) });
  }
  getCanvasSvgDefs() {
    return [getFillDefForCanvas()];
  }
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    const newSegments = [];
    for (const segment of shape.props.segments) {
      newSegments.push({
        ...segment,
        points: segment.points.map(({ x, y, z }) => {
          return {
            x: toFixed(scaleX * x),
            y: toFixed(scaleY * y),
            z
          };
        })
      });
    }
    return {
      props: {
        segments: newSegments
      }
    };
  }
  expandSelectionOutlinePx(shape) {
    const multiplier = shape.props.dash === "draw" ? 1.6 : 1;
    return STROKE_SIZES2[shape.props.size] * multiplier / 2 * shape.props.scale;
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      segments: interpolateSegments(startShape.props.segments, endShape.props.segments, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
};
__publicField(DrawShapeUtil, "type", "draw");
__publicField(DrawShapeUtil, "props", drawShapeProps);
__publicField(DrawShapeUtil, "migrations", drawShapeMigrations);
function getDot(point, sw) {
  const r = (sw + 1) * 0.5;
  return `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0`;
}
function getIsDot(shape) {
  return shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2;
}
function DrawShapeSvg({ shape, zoomOverride }) {
  var _a5;
  const theme = useDefaultColorTheme();
  const editor = useEditor();
  const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
  const showAsComplete = shape.props.isComplete || ((_a5 = last(shape.props.segments)) == null ? void 0 : _a5.type) === "straight";
  let sw = (STROKE_SIZES2[shape.props.size] + 1) * shape.props.scale;
  const forceSolid = useValue(
    "force solid",
    () => {
      const zoomLevel = zoomOverride ?? editor.getZoomLevel();
      return zoomLevel < 0.5 && zoomLevel < 1.5 / sw;
    },
    [editor, sw, zoomOverride]
  );
  const dotAdjustment = useValue(
    "dot adjustment",
    () => {
      const zoomLevel = zoomOverride ?? editor.getZoomLevel();
      return zoomLevel < 0.2 ? 0 : 0.1;
    },
    [editor, zoomOverride]
  );
  if (!forceSolid && !shape.props.isPen && shape.props.dash === "draw" && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (sw / 6);
  }
  const options2 = getFreehandOptions(shape.props, sw, showAsComplete, forceSolid);
  if (!forceSolid && shape.props.dash === "draw") {
    return (0, import_jsx_runtime134.jsxs)(import_jsx_runtime134.Fragment, { children: [
      shape.props.isClosed && shape.props.fill && allPointsFromSegments.length > 1 ? (0, import_jsx_runtime134.jsx)(
        ShapeFill,
        {
          d: getSvgPathFromStrokePoints(
            getStrokePoints(allPointsFromSegments, options2),
            shape.props.isClosed
          ),
          theme,
          color: shape.props.color,
          fill: shape.props.isClosed ? shape.props.fill : "none",
          scale: shape.props.scale
        }
      ) : null,
      (0, import_jsx_runtime134.jsx)(
        "path",
        {
          d: svgInk(allPointsFromSegments, options2),
          strokeLinecap: "round",
          fill: theme[shape.props.color].solid
        }
      )
    ] });
  }
  const strokePoints = getStrokePoints(allPointsFromSegments, options2);
  const isDot = strokePoints.length < 2;
  const solidStrokePath = isDot ? getDot(allPointsFromSegments[0], 0) : getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed);
  return (0, import_jsx_runtime134.jsxs)(import_jsx_runtime134.Fragment, { children: [
    (0, import_jsx_runtime134.jsx)(
      ShapeFill,
      {
        d: solidStrokePath,
        theme,
        color: shape.props.color,
        fill: isDot || shape.props.isClosed ? shape.props.fill : "none",
        scale: shape.props.scale
      }
    ),
    (0, import_jsx_runtime134.jsx)(
      "path",
      {
        d: solidStrokePath,
        strokeLinecap: "round",
        fill: isDot ? theme[shape.props.color].solid : "none",
        stroke: theme[shape.props.color].solid,
        strokeWidth: sw,
        strokeDasharray: isDot ? "none" : getDrawShapeStrokeDashArray(shape, sw, dotAdjustment),
        strokeDashoffset: "0"
      }
    )
  ] });
}

// node_modules/tldraw/dist-esm/lib/shapes/embed/EmbedShapeUtil.mjs
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/utils/embeds/embeds.mjs
function escapeStringRegexp(string2) {
  if (typeof string2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function matchEmbedUrl(definitions, url) {
  const parsed = safeParseUrl(url);
  if (!parsed)
    return;
  const host = parsed.host.replace("www.", "");
  for (const localEmbedDef of definitions) {
    if (checkHostnames(localEmbedDef.hostnames, host)) {
      const originalUrl = localEmbedDef.fromEmbedUrl(url);
      if (originalUrl) {
        return {
          definition: localEmbedDef,
          url: originalUrl,
          embedUrl: url
        };
      }
    }
  }
}
var globlikeRegExp = (input) => {
  return input.split("*").map((str) => escapeStringRegexp(str)).join(".+");
};
var checkHostnames = (hostnames, targetHostname) => {
  return !!hostnames.find((hostname) => {
    const re = new RegExp(globlikeRegExp(hostname));
    return targetHostname.match(re);
  });
};
function matchUrl(definitions, url) {
  const parsed = safeParseUrl(url);
  if (!parsed)
    return;
  const host = parsed.host.replace("www.", "");
  for (const localEmbedDef of definitions) {
    if (checkHostnames(localEmbedDef.hostnames, host)) {
      const embedUrl = localEmbedDef.toEmbedUrl(url);
      if (embedUrl) {
        return {
          definition: localEmbedDef,
          embedUrl,
          url
        };
      }
    }
  }
}
function getEmbedInfo(definitions, inputUrl) {
  try {
    return matchUrl(definitions, inputUrl) ?? matchEmbedUrl(definitions, inputUrl);
  } catch {
    return void 0;
  }
}

// node_modules/tldraw/dist-esm/lib/shapes/embed/EmbedShapeUtil.mjs
var getSandboxPermissions = (permissions) => {
  return Object.entries(permissions).filter(([_perm, isEnabled]) => isEnabled).map(([perm]) => perm).join(" ");
};
var _EmbedShapeUtil = class _EmbedShapeUtil extends BaseBoxShapeUtil {
  static setEmbedDefinitions(embedDefinitions) {
    _EmbedShapeUtil.embedDefinitions = embedDefinitions;
  }
  getEmbedDefinitions() {
    return _EmbedShapeUtil.embedDefinitions;
  }
  getEmbedDefinition(url) {
    return getEmbedInfo(_EmbedShapeUtil.embedDefinitions, url);
  }
  getText(shape) {
    return shape.props.url;
  }
  getAriaDescriptor(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return embedInfo == null ? void 0 : embedInfo.definition.title;
  }
  hideSelectionBoundsFg(shape) {
    return !this.canResize(shape);
  }
  canEdit() {
    return true;
  }
  canResize(shape) {
    var _a5, _b;
    return !!((_b = (_a5 = this.getEmbedDefinition(shape.props.url)) == null ? void 0 : _a5.definition) == null ? void 0 : _b.doesResize);
  }
  canEditInReadonly() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 300,
      h: 300,
      url: ""
    };
  }
  isAspectRatioLocked(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return (embedInfo == null ? void 0 : embedInfo.definition.isAspectRatioLocked) ?? false;
  }
  onResize(shape, info) {
    const isAspectRatioLocked = this.isAspectRatioLocked(shape);
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    let minWidth = (embedInfo == null ? void 0 : embedInfo.definition.minWidth) ?? 200;
    let minHeight = (embedInfo == null ? void 0 : embedInfo.definition.minHeight) ?? 200;
    if (isAspectRatioLocked) {
      const aspectRatio = shape.props.w / shape.props.h;
      if (aspectRatio > 1) {
        minWidth *= aspectRatio;
      } else {
        minHeight /= aspectRatio;
      }
    }
    return resizeBox(shape, info, { minWidth, minHeight });
  }
  component(shape) {
    const svgExport = useSvgExportContext();
    const { w, h, url } = shape.props;
    const isEditing = useIsEditing(shape.id);
    const embedInfo = this.getEmbedDefinition(url);
    const isHoveringWhileEditingSameShape = useValue(
      "is hovering",
      () => {
        const { editingShapeId, hoveredShapeId } = this.editor.getCurrentPageState();
        if (editingShapeId && hoveredShapeId !== editingShapeId) {
          const editingShape = this.editor.getShape(editingShapeId);
          if (editingShape && this.editor.isShapeOfType(editingShape, "embed")) {
            return true;
          }
        }
        return false;
      },
      []
    );
    const pageRotation = this.editor.getShapePageTransform(shape).rotation();
    if (svgExport) {
      return (0, import_jsx_runtime135.jsx)(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: (0, import_jsx_runtime135.jsx)(
        "div",
        {
          className: "tl-embed",
          style: {
            border: 0,
            boxShadow: getRotatedBoxShadow(pageRotation),
            borderRadius: (embedInfo == null ? void 0 : embedInfo.definition.overrideOutlineRadius) ?? 8,
            background: (embedInfo == null ? void 0 : embedInfo.definition.backgroundColor) ?? "var(--color-background)",
            width: w,
            height: h
          }
        }
      ) });
    }
    const isInteractive = isEditing || isHoveringWhileEditingSameShape;
    const isIframe = typeof window !== "undefined" && (window !== window.top || window.self !== window.parent);
    if (isIframe && (embedInfo == null ? void 0 : embedInfo.definition.type) === "tldraw")
      return null;
    if ((embedInfo == null ? void 0 : embedInfo.definition.type) === "github_gist") {
      const idFromGistUrl = embedInfo.url.split("/").pop();
      if (!idFromGistUrl)
        throw Error("No gist id!");
      return (0, import_jsx_runtime135.jsx)(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: (0, import_jsx_runtime135.jsx)(
        Gist,
        {
          id: idFromGistUrl,
          width: toDomPrecision(w),
          height: toDomPrecision(h),
          isInteractive,
          pageRotation
        }
      ) });
    }
    const sandbox = getSandboxPermissions({
      ...embedShapePermissionDefaults,
      ...(embedInfo == null ? void 0 : embedInfo.definition.overridePermissions) ?? {}
    });
    return (0, import_jsx_runtime135.jsx)(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: (embedInfo == null ? void 0 : embedInfo.definition) ? (0, import_jsx_runtime135.jsx)(
      "iframe",
      {
        className: "tl-embed",
        sandbox,
        src: embedInfo.embedUrl,
        width: toDomPrecision(w),
        height: toDomPrecision(h),
        draggable: false,
        frameBorder: "0",
        referrerPolicy: "no-referrer-when-downgrade",
        tabIndex: isEditing ? 0 : -1,
        style: {
          border: 0,
          pointerEvents: isInteractive ? "auto" : "none",
          // Fix for safari <https://stackoverflow.com/a/49150908>
          zIndex: isInteractive ? "" : "-1",
          boxShadow: getRotatedBoxShadow(pageRotation),
          borderRadius: (embedInfo == null ? void 0 : embedInfo.definition.overrideOutlineRadius) ?? 8,
          background: embedInfo == null ? void 0 : embedInfo.definition.backgroundColor
        }
      }
    ) : null });
  }
  indicator(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return (0, import_jsx_runtime135.jsx)(
      "rect",
      {
        width: toDomPrecision(shape.props.w),
        height: toDomPrecision(shape.props.h),
        rx: (embedInfo == null ? void 0 : embedInfo.definition.overrideOutlineRadius) ?? 8,
        ry: (embedInfo == null ? void 0 : embedInfo.definition.overrideOutlineRadius) ?? 8
      }
    );
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
};
__publicField(_EmbedShapeUtil, "type", "embed");
__publicField(_EmbedShapeUtil, "props", embedShapeProps);
__publicField(_EmbedShapeUtil, "migrations", embedShapeMigrations);
__publicField(_EmbedShapeUtil, "embedDefinitions", DEFAULT_EMBED_DEFINITIONS);
var EmbedShapeUtil = _EmbedShapeUtil;
function Gist({
  id,
  isInteractive,
  width,
  height,
  style: style2,
  pageRotation
}) {
  if (!id.match(/^[0-9a-f]+$/))
    throw Error("No gist id!");
  return (0, import_jsx_runtime135.jsx)(
    "iframe",
    {
      className: "tl-embed",
      draggable: false,
      width: toDomPrecision(width),
      height: toDomPrecision(height),
      frameBorder: "0",
      scrolling: "no",
      referrerPolicy: "no-referrer-when-downgrade",
      tabIndex: isInteractive ? 0 : -1,
      style: {
        ...style2,
        pointerEvents: isInteractive ? "all" : "none",
        // Fix for safari <https://stackoverflow.com/a/49150908>
        zIndex: isInteractive ? "" : "-1",
        boxShadow: getRotatedBoxShadow(pageRotation)
      },
      srcDoc: `
			<html>
				<head>
					<base target="_blank">
				</head>
				<body>
					<script src=${`https://gist.github.com/${id}.js`}><\/script>
					<style type="text/css">
						* { margin: 0px; }
						table { height: 100%; background-color: red; }
						.gist { background-color: none; height: 100%;  }
						.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
					</style>
				</body>
			</html>`
    }
  );
}

// node_modules/tldraw/dist-esm/lib/shapes/frame/FrameShapeUtil.mjs
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var import_classnames25 = __toESM(require_classnames(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/frame/components/FrameHeading.mjs
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var import_react91 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/frame/frameHelpers.mjs
function getFrameHeadingSide(editor, shape) {
  const pageRotation = canonicalizeRotation(editor.getShapePageTransform(shape.id).rotation());
  const offsetRotation = pageRotation + Math.PI / 4;
  const scaledRotation = (offsetRotation * (2 / Math.PI) + 4) % 4;
  return Math.floor(scaledRotation);
}
var measurementWeakmap = /* @__PURE__ */ new WeakMap();
function getFrameHeadingSize(editor, shape, opts) {
  if (false) {
    return new Box(0, -opts.height, shape.props.w, opts.height);
  }
  let width = measurementWeakmap.get(shape.props);
  if (!width) {
    const frameTitle = defaultEmptyAs(shape.props.name, "Frame") + String.fromCharCode(8203);
    const spans = editor.textMeasure.measureTextSpans(frameTitle, opts);
    const firstSpan = spans[0];
    const lastSpan = last(spans);
    width = lastSpan.box.w + lastSpan.box.x - firstSpan.box.x;
    measurementWeakmap.set(shape.props, width);
  }
  return new Box(0, -opts.height, width, opts.height);
}
function getFrameHeadingOpts(width, isSvg) {
  return {
    fontSize: 12,
    fontFamily: isSvg ? "Arial" : "Inter, sans-serif",
    textAlign: "start",
    width,
    height: 24,
    // --frame-height
    padding: 0,
    lineHeight: 1,
    fontStyle: "normal",
    fontWeight: "normal",
    overflow: "truncate-ellipsis",
    verticalTextAlign: "middle",
    offsetY: -(32 + 2),
    // --frame-minimum-height + (border width * 2)
    offsetX: 0
  };
}
function getFrameHeadingTranslation(shape, side, isSvg) {
  const u = isSvg ? "" : "px";
  const r = isSvg ? "" : "deg";
  let labelTranslate;
  switch (side) {
    case 0:
      labelTranslate = ``;
      break;
    case 3:
      labelTranslate = `translate(${toDomPrecision(shape.props.w)}${u}, 0${u}) rotate(90${r})`;
      break;
    case 2:
      labelTranslate = `translate(${toDomPrecision(shape.props.w)}${u}, ${toDomPrecision(
        shape.props.h
      )}${u}) rotate(180${r})`;
      break;
    case 1:
      labelTranslate = `translate(0${u}, ${toDomPrecision(shape.props.h)}${u}) rotate(270${r})`;
      break;
    default:
      throw Error("labelSide out of bounds");
  }
  return labelTranslate;
}

// node_modules/tldraw/dist-esm/lib/shapes/frame/components/FrameLabelInput.mjs
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var import_react90 = __toESM(require_react(), 1);
var FrameLabelInput = (0, import_react90.forwardRef)(({ id, name, isEditing }, ref) => {
  const editor = useEditor();
  const handleKeyDown2 = (0, import_react90.useCallback)(
    (e) => {
      if (e.key === "Enter" && !e.nativeEvent.isComposing) {
        stopEventPropagation(e);
        e.currentTarget.blur();
        editor.setEditingShape(null);
      }
    },
    [editor]
  );
  const handleBlur = (0, import_react90.useCallback)(
    (e) => {
      const shape = editor.getShape(id);
      if (!shape)
        return;
      const name2 = shape.props.name;
      const value = e.currentTarget.value.trim();
      if (name2 === value)
        return;
      editor.updateShapes([
        {
          id,
          type: "frame",
          props: { name: value }
        }
      ]);
    },
    [id, editor]
  );
  const handleChange = (0, import_react90.useCallback)(
    (e) => {
      const shape = editor.getShape(id);
      if (!shape)
        return;
      const name2 = shape.props.name;
      const value = e.currentTarget.value;
      if (name2 === value)
        return;
      editor.updateShapes([
        {
          id,
          type: "frame",
          props: { name: value }
        }
      ]);
    },
    [id, editor]
  );
  return (0, import_jsx_runtime136.jsxs)("div", { className: `tl-frame-label ${isEditing ? "tl-frame-label__editing" : ""}`, children: [
    (0, import_jsx_runtime136.jsx)(
      "input",
      {
        className: "tl-frame-name-input",
        ref,
        disabled: !isEditing,
        readOnly: !isEditing,
        style: { display: isEditing ? void 0 : "none" },
        value: name,
        autoFocus: true,
        onKeyDown: handleKeyDown2,
        onBlur: handleBlur,
        onChange: handleChange,
        onPointerDown: isEditing ? stopEventPropagation : void 0,
        draggable: false
      }
    ),
    defaultEmptyAs(name, "Frame") + String.fromCharCode(8203)
  ] });
});

// node_modules/tldraw/dist-esm/lib/shapes/frame/components/FrameHeading.mjs
var FrameHeading = (0, import_react91.memo)(function FrameHeading2({
  id,
  name,
  width,
  height,
  fill,
  stroke,
  color,
  offsetX,
  showColors
}) {
  const editor = useEditor();
  const { side, translation } = useValue(
    "shape rotation",
    () => {
      const shape = editor.getShape(id);
      if (!shape) {
        return {
          side: 0,
          translation: "translate(0, 0)"
        };
      }
      const labelSide = getFrameHeadingSide(editor, shape);
      return {
        side: labelSide,
        translation: getFrameHeadingTranslation(shape, labelSide, false)
      };
    },
    [editor, offsetX, id]
  );
  const rInput = (0, import_react91.useRef)(null);
  const isEditing = useIsEditing(id);
  (0, import_react91.useEffect)(() => {
    const el = rInput.current;
    if (el && isEditing) {
      el.focus();
      el.select();
    }
  }, [rInput, isEditing]);
  return (0, import_jsx_runtime137.jsx)(
    "div",
    {
      className: "tl-frame-heading",
      style: {
        overflow: isEditing ? "visible" : "hidden",
        maxWidth: `calc(var(--tl-zoom) * ${side === 0 || side === 2 ? Math.ceil(width) : Math.ceil(height)}px + ${showColors ? "0px" : "var(--frame-offset-width)"})`,
        bottom: "100%",
        transform: `${translation} scale(var(--tl-scale)) translateX(${offsetX}px)`
      },
      children: (0, import_jsx_runtime137.jsx)(
        "div",
        {
          className: "tl-frame-heading-hit-area",
          style: { color, backgroundColor: fill, boxShadow: `inset 0px 0px 0px 1px ${stroke}` },
          children: (0, import_jsx_runtime137.jsx)(FrameLabelInput, { ref: rInput, id, name, isEditing })
        }
      )
    }
  );
});

// node_modules/tldraw/dist-esm/lib/shapes/frame/FrameShapeUtil.mjs
var FRAME_HEADING_EXTRA_WIDTH = 12;
var FRAME_HEADING_MIN_WIDTH = 32;
var FRAME_HEADING_NOCOLORS_OFFSET_X = -7;
var FRAME_HEADING_OFFSET_Y = 4;
function defaultEmptyAs(str, dflt) {
  if (str.match(/^\s*$/)) {
    return dflt;
  }
  return str;
}
var FrameShapeUtil = class extends BaseBoxShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      showColors: false
    });
  }
  // evil crimes :)
  // By default, showColors is off. Because they use style props, which are picked up
  // automatically, we don't have DefaultColorStyle in the props in the schema by default.
  // Instead, when someone calls .configure to turn the option on, we manually add in the color
  // style here so it plays nicely with the other editor APIs.
  static configure(options2) {
    const withOptions = super.configure.call(this, options2);
    if (options2.showColors) {
      ;
      withOptions.props = { ...withOptions.props, color: DefaultColorStyle };
    }
    return withOptions;
  }
  canEdit() {
    return true;
  }
  getDefaultProps() {
    return { w: 160 * 2, h: 90 * 2, name: "", color: "black" };
  }
  getAriaDescriptor(shape) {
    return shape.props.name;
  }
  getGeometry(shape) {
    const { editor } = this;
    const z = editor.getZoomLevel();
    const labelSide = getFrameHeadingSide(editor, shape);
    const isVertical = labelSide % 2 === 1;
    const rotatedTopEdgeWidth = isVertical ? shape.props.h : shape.props.w;
    const opts = getFrameHeadingOpts(rotatedTopEdgeWidth, false);
    const headingSize = getFrameHeadingSize(editor, shape, opts);
    const isShowingFrameColors = this.options.showColors;
    const extraWidth = FRAME_HEADING_EXTRA_WIDTH / z;
    const minWidth = FRAME_HEADING_MIN_WIDTH / z;
    const maxWidth = rotatedTopEdgeWidth + (isShowingFrameColors ? 1 : extraWidth);
    const labelWidth = headingSize.w / z;
    const labelHeight = headingSize.h / z;
    const clampedLabelWidth = clamp(labelWidth + extraWidth, minWidth, maxWidth);
    const offsetX = (isShowingFrameColors ? -1 : FRAME_HEADING_NOCOLORS_OFFSET_X) / z;
    const offsetY = FRAME_HEADING_OFFSET_Y / z;
    const width = isVertical ? labelHeight : clampedLabelWidth;
    const height = isVertical ? clampedLabelWidth : labelHeight;
    let x, y;
    switch (labelSide) {
      case 0: {
        x = offsetX;
        y = -(labelHeight + offsetY);
        break;
      }
      case 1: {
        x = -(labelHeight + offsetY);
        y = shape.props.h - (offsetX + clampedLabelWidth);
        break;
      }
      case 2: {
        x = shape.props.w - (offsetX + clampedLabelWidth);
        y = shape.props.h + offsetY;
        break;
      }
      case 3: {
        x = shape.props.w + offsetY;
        y = offsetX;
        break;
      }
    }
    return new Group2d({
      children: [
        new Rectangle2d({
          width: shape.props.w,
          height: shape.props.h,
          isFilled: false
        }),
        new Rectangle2d({
          x,
          y,
          width,
          height,
          isFilled: true,
          isLabel: true
        })
      ]
    });
  }
  getText(shape) {
    return shape.props.name;
  }
  component(shape) {
    const theme = useDefaultColorTheme();
    const isCreating = useValue(
      "is creating this shape",
      () => {
        const resizingState = this.editor.getStateDescendant("select.resizing");
        if (!resizingState)
          return false;
        if (!resizingState.getIsActive())
          return false;
        const info = resizingState == null ? void 0 : resizingState.info;
        if (!info)
          return false;
        return info.isCreating && this.editor.getOnlySelectedShapeId() === shape.id;
      },
      [shape.id]
    );
    const zoomLevel = useValue("zoom level", () => this.editor.getZoomLevel(), [this.editor]);
    const showFrameColors = this.options.showColors;
    const color = theme[shape.props.color];
    const frameFill = showFrameColors ? color.frame.fill : theme.black.frame.fill;
    const frameStroke = showFrameColors ? color.frame.stroke : theme.black.frame.stroke;
    const frameHeadingStroke = showFrameColors ? color.frame.headingStroke : theme.background;
    const frameHeadingFill = showFrameColors ? color.frame.headingFill : theme.background;
    const frameHeadingText = showFrameColors ? color.frame.text : theme.text;
    return (0, import_jsx_runtime138.jsxs)(import_jsx_runtime138.Fragment, { children: [
      (0, import_jsx_runtime138.jsx)(SVGContainer, { children: (0, import_jsx_runtime138.jsx)(
        "rect",
        {
          className: (0, import_classnames25.default)("tl-frame__body", { "tl-frame__creating": isCreating }),
          width: shape.props.w + 1 / zoomLevel,
          height: shape.props.h + 1 / zoomLevel,
          fill: frameFill,
          stroke: frameStroke,
          y: -0.5 / zoomLevel,
          x: -0.5 / zoomLevel
        }
      ) }),
      isCreating ? null : (0, import_jsx_runtime138.jsx)(
        FrameHeading,
        {
          id: shape.id,
          name: shape.props.name,
          fill: frameHeadingFill,
          stroke: frameHeadingStroke,
          color: frameHeadingText,
          width: shape.props.w,
          height: shape.props.h,
          offsetX: showFrameColors ? -1 : -7,
          showColors: this.options.showColors
        }
      )
    ] });
  }
  toSvg(shape, ctx) {
    const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode });
    const labelSide = getFrameHeadingSide(this.editor, shape);
    const isVertical = labelSide % 2 === 1;
    const rotatedTopEdgeWidth = isVertical ? shape.props.h : shape.props.w;
    const labelTranslate = getFrameHeadingTranslation(shape, labelSide, true);
    const opts = getFrameHeadingOpts(rotatedTopEdgeWidth - 12, true);
    const frameTitle = defaultEmptyAs(shape.props.name, "Frame") + String.fromCharCode(8203);
    const labelBounds = getFrameHeadingSize(this.editor, shape, opts);
    const spans = this.editor.textMeasure.measureTextSpans(frameTitle, opts);
    const text = createTextJsxFromSpans(this.editor, spans, opts);
    const showFrameColors = this.options.showColors;
    const color = theme[shape.props.color];
    const frameFill = showFrameColors ? color.frame.fill : theme.black.frame.fill;
    const frameStroke = showFrameColors ? color.frame.stroke : theme.black.frame.stroke;
    const frameHeadingStroke = showFrameColors ? color.frame.headingStroke : theme.background;
    const frameHeadingFill = showFrameColors ? color.frame.headingFill : theme.background;
    const frameHeadingText = showFrameColors ? color.frame.text : theme.text;
    return (0, import_jsx_runtime138.jsxs)(import_jsx_runtime138.Fragment, { children: [
      (0, import_jsx_runtime138.jsx)(
        "rect",
        {
          width: shape.props.w,
          height: shape.props.h,
          fill: frameFill,
          stroke: frameStroke,
          strokeWidth: 1,
          x: 0,
          rx: 0,
          ry: 0
        }
      ),
      (0, import_jsx_runtime138.jsxs)("g", { fill: frameHeadingText, transform: labelTranslate, children: [
        (0, import_jsx_runtime138.jsx)(
          "rect",
          {
            x: labelBounds.x - (showFrameColors ? 0 : 6),
            y: labelBounds.y - 6,
            width: Math.min(rotatedTopEdgeWidth, labelBounds.width + 12),
            height: labelBounds.height,
            fill: frameHeadingFill,
            stroke: frameHeadingStroke,
            rx: 4,
            ry: 4
          }
        ),
        (0, import_jsx_runtime138.jsx)("g", { transform: `translate(${showFrameColors ? 8 : 0}, 4)`, children: text })
      ] })
    ] });
  }
  indicator(shape) {
    return (0, import_jsx_runtime138.jsx)(
      "rect",
      {
        width: toDomPrecision(shape.props.w),
        height: toDomPrecision(shape.props.h),
        className: `tl-frame-indicator`
      }
    );
  }
  canReceiveNewChildrenOfType(shape, _type) {
    return !shape.isLocked;
  }
  providesBackgroundForChildren() {
    return true;
  }
  canDropShapes(shape, _shapes) {
    return !shape.isLocked;
  }
  onDragShapesOver(frame2, shapes) {
    if (!shapes.every((child) => child.parentId === frame2.id)) {
      this.editor.reparentShapes(shapes, frame2.id);
    }
  }
  onDragShapesOut(_shape, shapes) {
    const parent = this.editor.getShape(_shape.parentId);
    const isInGroup = parent && this.editor.isShapeOfType(parent, "group");
    if (isInGroup) {
      this.editor.reparentShapes(shapes, parent.id);
    } else {
      this.editor.reparentShapes(shapes, this.editor.getCurrentPageId());
    }
  }
  onResize(shape, info) {
    return resizeBox(shape, info);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
  onDoubleClickEdge(shape, info) {
    if (info.target !== "selection")
      return;
    const { handle } = info;
    if (!handle)
      return;
    const isHorizontalEdge = handle === "left" || handle === "right";
    const isVerticalEdge = handle === "top" || handle === "bottom";
    const childIds = this.editor.getSortedChildIdsForParent(shape.id);
    const children = compact(childIds.map((id) => this.editor.getShape(id)));
    if (!children.length)
      return;
    const { dx, dy, w, h } = getFrameChildrenBounds(children, this.editor, { padding: 10 });
    this.editor.run(() => {
      const changes = childIds.map((childId) => {
        const childShape = this.editor.getShape(childId);
        return {
          id: childShape.id,
          type: childShape.type,
          x: isHorizontalEdge ? childShape.x + dx : childShape.x,
          y: isVerticalEdge ? childShape.y + dy : childShape.y
        };
      });
      this.editor.updateShapes(changes);
    });
    return {
      id: shape.id,
      type: shape.type,
      props: {
        w: isHorizontalEdge ? w : shape.props.w,
        h: isVerticalEdge ? h : shape.props.h
      }
    };
  }
  onDoubleClickCorner(shape) {
    fitFrameToContent(this.editor, shape.id, { padding: 10 });
    return {
      id: shape.id,
      type: shape.type
    };
  }
};
__publicField(FrameShapeUtil, "type", "frame");
__publicField(FrameShapeUtil, "props", frameShapeProps);
__publicField(FrameShapeUtil, "migrations", frameShapeMigrations);

// node_modules/tldraw/dist-esm/lib/shapes/geo/GeoShapeUtil.mjs
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var import_lodash6 = __toESM(require_lodash3(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/shared/RichTextLabel.mjs
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);
var import_react96 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/text/RichTextArea.mjs
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements2 = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName2(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow3(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement3(node) {
  var OwnElement = getWindow3(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement4(node) {
  var OwnElement = getWindow3(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot3(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow3(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement4(element) || !getNodeName2(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement4(element) || !getNodeName2(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max2 = Math.max;
var min3 = Math.min;
var round3 = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect2(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect2 = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement4(element)) {
    scaleX = element.offsetWidth > 0 ? round3(clientRect2.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round3(clientRect2.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement3(element) ? getWindow3(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect2.width / scaleX;
  var height = clientRect2.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect2(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot3(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle4(element) {
  return getWindow3(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement2(element) {
  return ["table", "td", "th"].indexOf(getNodeName2(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement2(element) {
  return ((isElement3(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode2(element) {
  if (getNodeName2(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot3(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement2(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent2(element) {
  if (!isHTMLElement4(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle4(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock2(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement4(element)) {
    var elementCss = getComputedStyle4(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode2(element);
  if (isShadowRoot3(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement4(currentNode) && ["html", "body"].indexOf(getNodeName2(currentNode)) < 0) {
    var css = getComputedStyle4(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent2(element) {
  var window3 = getWindow3(element);
  var offsetParent = getTrueOffsetParent2(element);
  while (offsetParent && isTableElement2(offsetParent) && getComputedStyle4(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent2(offsetParent);
  }
  if (offsetParent && (getNodeName2(offsetParent) === "html" || getNodeName2(offsetParent) === "body" && getComputedStyle4(offsetParent).position === "static")) {
    return window3;
  }
  return offsetParent || getContainingBlock2(element) || window3;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min4, value, max3) {
  return max2(min4, min3(value, max3));
}
function withinMaxClamp(min4, value, max3) {
  var v = within(min4, value, max3);
  return v > max3 ? max3 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow5(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options2 = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent2(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min4 = paddingObject[minProp];
  var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset5 = within(min4, center, max3);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset5, _state$modifiersData$.centerOffset = offset5 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options2 = _ref2.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow5,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round3(x * dpr) / dpr || 0,
    y: round3(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent2(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow3(popper2)) {
      offsetParent = getDocumentElement2(popper2);
      if (getComputedStyle4(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow3(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options2 = _ref5.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options2 = _ref.options;
  var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window3 = getWindow3(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window3.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window3.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash2 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement2(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash3 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash3[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow3(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX2(element) {
  return getBoundingClientRect2(getDocumentElement2(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect2(element, strategy) {
  var win = getWindow3(element);
  var html = getDocumentElement2(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX2(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect2(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement2(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX2(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle4(body || html).direction === "rtl") {
    x += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle4(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName2(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement4(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode2(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow3(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode2(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect2(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect2(element, strategy) {
  var rect = getBoundingClientRect2(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect2(getViewportRect2(element, strategy)) : isElement3(clippingParent) ? getInnerBoundingClientRect2(clippingParent, strategy) : rectToClientRect2(getDocumentRect2(getDocumentElement2(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode2(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle4(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement4(element) ? getOffsetParent2(element) : element;
  if (!isElement3(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement3(clippingParent) && contains(clippingParent, clipperElement) && getNodeName2(clippingParent) !== "body";
  });
}
function getClippingRect2(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min3(rect.right, accRect.right);
    accRect.bottom = min3(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow3(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect2(isElement3(element) ? element : element.contextElement || getDocumentElement2(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect2(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect2(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset5 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset5[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements2 : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements3 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements3.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements3;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow3(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement2(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip4(_ref) {
  var state = _ref.state, options2 = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement2(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements3 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements3[0];
  for (var i = 0; i < placements3.length; i++) {
    var placement = placements3[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow3(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement2(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement2(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements3.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip4,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets2(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped2(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide4(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow3(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow3(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets2(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets2(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped2(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped2(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide4
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset5) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset5 === "function" ? offset5(Object.assign({}, rects, {
    placement
  })) : offset5, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset4(_ref2) {
  var state = _ref2.state, options2 = _ref2.options, name = _ref2.name;
  var _options$offset = options2.offset, offset5 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements2.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset5);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset4
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options2 = _ref.options, name = _ref.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow3(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset5 = popperOffsets2[mainAxis];
    var min4 = offset5 + overflow[mainSide];
    var max3 = offset5 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent2(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset5 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset5 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min3(min4, tetherMin) : min4, offset5, tether ? max2(max3, tetherMax) : max3);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset5;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll2(node) {
  if (node === getWindow3(node) || !isHTMLElement4(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round3(rect.width) / element.offsetWidth || 1;
  var scaleY = round3(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement4(offsetParent);
  var offsetParentIsScaled = isHTMLElement4(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement2(offsetParent);
  var rect = getBoundingClientRect2(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll2(offsetParent);
    }
    if (isHTMLElement4(offsetParent)) {
      offsets = getBoundingClientRect2(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX2(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers2) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce2(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options3);
        state.scrollParents = {
          reference: isElement3(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent2(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index3 = 0; index3 < state.orderedModifiers.length; index3++) {
          if (state.reset === true) {
            state.reset = false;
            index3 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index3], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce2(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options2).then(function(state2) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options3 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
        if (typeof effect5 === "function") {
          var cleanupFn = effect5({
            state,
            name,
            instance,
            options: options3
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/tippy.js/dist/tippy.esm.js
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function hasOwnProperty2(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index3, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index3];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index3] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce3(fn2, ms) {
  if (ms === 0) {
    return fn2;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn2(arg);
    }, ms);
  };
}
function removeProperties(obj, keys2) {
  var clone = Object.assign({}, obj);
  keys2.forEach(function(key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index3) {
    return arr.indexOf(item) === index3;
  });
}
function getBasePlacement2(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement4(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement4(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement2(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser2 = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser2 ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c👷‍ This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
  return [
    getDevMessage(message),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var visitedMessages;
if (true) {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = /* @__PURE__ */ new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  if (true) {
    validateProps(partialProps, []);
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty2(nonPluginProps, prop);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function(plugin) {
        return plugin.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow6 = div();
  if (value === true) {
    arrow6.className = ARROW_CLASS;
  } else {
    arrow6.className = SVG_ARROW_CLASS;
    if (isElement4(value)) {
      arrow6.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow6, value);
    }
  }
  return arrow6;
}
function setContent2(content, props) {
  if (isElement4(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent2(content, instance.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow6 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent2(content2, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow6) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow6);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow6) {
      box2.removeChild(arrow6);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render.$$tippy = true;
var idCounter3 = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce3(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter3++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent3,
    show,
    hide: hide5,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy
  };
  if (!props.render) {
    if (true) {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance;
  }
  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      if (instance.props.interactive) {
        node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc3 = getDocument();
    doc3.addEventListener("mousedown", onDocumentPress, true);
    doc3.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc3.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc3.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc3 = getDocument();
    doc3.removeEventListener("mousedown", onDocumentPress, true);
    doc3.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc3.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc3.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options2) {
    if (options2 === void 0) {
      options2 = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options2);
      listeners.push({
        node,
        eventType,
        handler,
        options: options2
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on("touchstart", onTrigger2, {
        passive: true
      });
      on("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on("mouseleave", onMouseLeave);
          break;
        case "focus":
          on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options2 = _ref.options;
      node.removeEventListener(eventType, handler, options2);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance2 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset5 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow6 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn2(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset5
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow6) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow6,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper3(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode2;
    var node = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
    if (true) {
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce3(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent3(content) {
    instance.setProps({
      content
    });
  }
  function show() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount();
  }
  function hide5() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  if (true) {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  if (true) {
    var isSingleContentElement = isElement4(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement4(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var applyStylesModifier = Object.assign({}, applyStyles_default, {
  effect: function effect4(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render
});
var tippy_esm_default = tippy;

// node_modules/@tiptap/extension-bubble-menu/dist/index.js
var BubbleMenuView = class {
  constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state, from: from2, to }) => {
      const { doc: doc3, selection } = state;
      const { empty: empty2 } = selection;
      const isEmptyTextBlock = !doc3.textBetween(from2, to).length && isTextSelection(state.selection);
      const isChildOfMenu = this.element.contains(document.activeElement);
      const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty2 || isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a5;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a5 = this.element.parentNode) === null || _a5 === void 0 ? void 0 : _a5.contains(event.relatedTarget))) {
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.handleDebouncedUpdate = (view2, oldState) => {
      const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view2.state.selection));
      const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view2.state.doc));
      if (!selectionChanged && !docChanged) {
        return;
      }
      if (this.updateDebounceTimer) {
        clearTimeout(this.updateDebounceTimer);
      }
      this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(view2, selectionChanged, docChanged, oldState);
      }, this.updateDelay);
    };
    this.updateHandler = (view2, selectionChanged, docChanged, oldState) => {
      var _a5, _b, _c;
      const { state, composing } = view2;
      const { selection } = state;
      const isSame = !selectionChanged && !docChanged;
      if (composing || isSame) {
        return;
      }
      this.createTooltip();
      const { ranges } = selection;
      const from2 = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const shouldShow2 = (_a5 = this.shouldShow) === null || _a5 === void 0 ? void 0 : _a5.call(this, {
        editor: this.editor,
        element: this.element,
        view: view2,
        state,
        oldState,
        from: from2,
        to
      });
      if (!shouldShow2) {
        this.hide();
        return;
      }
      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
        getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
          if (isNodeSelection(state.selection)) {
            let node = view2.nodeDOM(from2);
            if (node) {
              const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector("[data-node-view-wrapper]");
              if (nodeViewWrapper) {
                node = nodeViewWrapper.firstChild;
              }
              if (node) {
                return node.getBoundingClientRect();
              }
            }
          }
          return posToDOMRect(view2, from2, to);
        })
      });
      this.show();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    this.updateDelay = updateDelay;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy_esm_default(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    const { state } = view;
    const hasValidSelection = state.selection.from !== state.selection.to;
    if (this.updateDelay > 0 && hasValidSelection) {
      this.handleDebouncedUpdate(view, oldState);
      return;
    }
    const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));
    const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));
    this.updateHandler(view, selectionChanged, docChanged, oldState);
  }
  show() {
    var _a5;
    (_a5 = this.tippy) === null || _a5 === void 0 ? void 0 : _a5.show();
  }
  hide() {
    var _a5;
    (_a5 = this.tippy) === null || _a5 === void 0 ? void 0 : _a5.hide();
  }
  destroy() {
    var _a5, _b;
    if ((_a5 = this.tippy) === null || _a5 === void 0 ? void 0 : _a5.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var BubbleMenuPlugin = (options2) => {
  return new Plugin({
    key: typeof options2.pluginKey === "string" ? new PluginKey(options2.pluginKey) : options2.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options2 })
  });
};
var BubbleMenu = Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// node_modules/@tiptap/react/dist/index.js
var import_react92 = __toESM(require_react());
var import_react_dom8 = __toESM(require_react_dom());

// node_modules/@tiptap/extension-floating-menu/dist/index.js
var FloatingMenuView = class {
  getTextContent(node) {
    return getText2(node, { textSerializers: getTextSerializersFromSchema(this.editor.schema) });
  }
  constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state }) => {
      const { selection } = state;
      const { $anchor, empty: empty2 } = selection;
      const isRootDepth = $anchor.depth === 1;
      const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent && $anchor.parent.childCount === 0 && !this.getTextContent($anchor.parent);
      if (!view2.hasFocus() || !empty2 || !isRootDepth || !isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a5;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a5 = this.element.parentNode) === null || _a5 === void 0 ? void 0 : _a5.contains(event.relatedTarget))) {
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy_esm_default(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    var _a5, _b, _c;
    const { state } = view;
    const { doc: doc3, selection } = state;
    const { from: from2, to } = selection;
    const isSame = oldState && oldState.doc.eq(doc3) && oldState.selection.eq(selection);
    if (isSame) {
      return;
    }
    this.createTooltip();
    const shouldShow = (_a5 = this.shouldShow) === null || _a5 === void 0 ? void 0 : _a5.call(this, {
      editor: this.editor,
      view,
      state,
      oldState
    });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
      getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => posToDOMRect(view, from2, to))
    });
    this.show();
  }
  show() {
    var _a5;
    (_a5 = this.tippy) === null || _a5 === void 0 ? void 0 : _a5.show();
  }
  hide() {
    var _a5;
    (_a5 = this.tippy) === null || _a5 === void 0 ? void 0 : _a5.hide();
  }
  destroy() {
    var _a5, _b;
    if ((_a5 = this.tippy) === null || _a5 === void 0 ? void 0 : _a5.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var FloatingMenuPlugin = (options2) => {
  return new Plugin({
    key: typeof options2.pluginKey === "string" ? new PluginKey(options2.pluginKey) : options2.pluginKey,
    view: (view) => new FloatingMenuView({ view, ...options2 })
  });
};
var FloatingMenu = Extension.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      FloatingMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// node_modules/@tiptap/react/dist/index.js
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var shim = { exports: {} };
var useSyncExternalStoreShim_development = {};
var hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  if (hasRequiredUseSyncExternalStoreShim_development)
    return useSyncExternalStoreShim_development;
  hasRequiredUseSyncExternalStoreShim_development = 1;
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React$1 = import_react92.default;
      var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format2) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack2 = ReactDebugCurrentFrame.getStackAddendum();
          if (stack2 !== "") {
            format2 += "%s";
            args = args.concat([stack2]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format2);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function is2(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is2;
      var useState76 = React$1.useState, useEffect89 = React$1.useEffect, useLayoutEffect25 = React$1.useLayoutEffect, useDebugValue3 = React$1.useDebugValue;
      var didWarnOld18Alpha = false;
      var didWarnUncachedGetSnapshot = false;
      function useSyncExternalStore4(subscribe2, getSnapshot2, getServerSnapshot) {
        {
          if (!didWarnOld18Alpha) {
            if (React$1.startTransition !== void 0) {
              didWarnOld18Alpha = true;
              error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
            }
          }
        }
        var value = getSnapshot2();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot2();
            if (!objectIs(value, cachedValue)) {
              error("The result of getSnapshot should be cached to avoid an infinite loop");
              didWarnUncachedGetSnapshot = true;
            }
          }
        }
        var _useState = useState76({
          inst: {
            value,
            getSnapshot: getSnapshot2
          }
        }), inst3 = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect25(function() {
          inst3.value = value;
          inst3.getSnapshot = getSnapshot2;
          if (checkIfSnapshotChanged(inst3)) {
            forceUpdate({
              inst: inst3
            });
          }
        }, [subscribe2, value, getSnapshot2]);
        useEffect89(function() {
          if (checkIfSnapshotChanged(inst3)) {
            forceUpdate({
              inst: inst3
            });
          }
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst3)) {
              forceUpdate({
                inst: inst3
              });
            }
          };
          return subscribe2(handleStoreChange);
        }, [subscribe2]);
        useDebugValue3(value);
        return value;
      }
      function checkIfSnapshotChanged(inst3) {
        var latestGetSnapshot = inst3.getSnapshot;
        var prevValue = inst3.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe2, getSnapshot2, getServerSnapshot) {
        return getSnapshot2();
      }
      var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
      var isServerEnvironment = !canUseDOM;
      var shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore4;
      var useSyncExternalStore$2 = React$1.useSyncExternalStore !== void 0 ? React$1.useSyncExternalStore : shim2;
      useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return useSyncExternalStoreShim_development;
}
if (false) {
  shim.exports = requireUseSyncExternalStoreShim_production_min();
} else {
  shim.exports = requireUseSyncExternalStoreShim_development();
}
var shimExports = shim.exports;
var mergeRefs2 = (...refs) => {
  return (node) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
    });
  };
};
var Portals = ({ contentComponent }) => {
  const renderers = shimExports.useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);
  return import_react92.default.createElement(import_react92.default.Fragment, null, Object.values(renderers));
};
function getInstance() {
  const subscribers = /* @__PURE__ */ new Set();
  let renderers = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(callback) {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
      };
    },
    getSnapshot() {
      return renderers;
    },
    getServerSnapshot() {
      return renderers;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(id, renderer) {
      renderers = {
        ...renderers,
        [id]: import_react_dom8.default.createPortal(renderer.reactElement, renderer.element, id)
      };
      subscribers.forEach((subscriber) => subscriber());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(id) {
      const nextRenderers = { ...renderers };
      delete nextRenderers[id];
      renderers = nextRenderers;
      subscribers.forEach((subscriber) => subscriber());
    }
  };
}
var PureEditorContent = class extends import_react92.default.Component {
  constructor(props) {
    var _a5;
    super(props);
    this.editorContentRef = import_react92.default.createRef();
    this.initialized = false;
    this.state = {
      hasContentComponentInitialized: Boolean((_a5 = props.editor) === null || _a5 === void 0 ? void 0 : _a5.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const editor = this.props.editor;
    if (editor && !editor.isDestroyed && editor.options.element) {
      if (editor.contentComponent) {
        return;
      }
      const element = this.editorContentRef.current;
      element.append(...editor.options.element.childNodes);
      editor.setOptions({
        element
      });
      editor.contentComponent = getInstance();
      if (!this.state.hasContentComponentInitialized) {
        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {
          this.setState((prevState) => {
            if (!prevState.hasContentComponentInitialized) {
              return {
                hasContentComponentInitialized: true
              };
            }
            return prevState;
          });
          if (this.unsubscribeToContentComponent) {
            this.unsubscribeToContentComponent();
          }
        });
      }
      editor.createNodeViews();
      this.initialized = true;
    }
  }
  componentWillUnmount() {
    const editor = this.props.editor;
    if (!editor) {
      return;
    }
    this.initialized = false;
    if (!editor.isDestroyed) {
      editor.view.setProps({
        nodeViews: {}
      });
    }
    if (this.unsubscribeToContentComponent) {
      this.unsubscribeToContentComponent();
    }
    editor.contentComponent = null;
    if (!editor.options.element.firstChild) {
      return;
    }
    const newElement = document.createElement("div");
    newElement.append(...editor.options.element.childNodes);
    editor.setOptions({
      element: newElement
    });
  }
  render() {
    const { editor, innerRef, ...rest } = this.props;
    return import_react92.default.createElement(
      import_react92.default.Fragment,
      null,
      import_react92.default.createElement("div", { ref: mergeRefs2(innerRef, this.editorContentRef), ...rest }),
      (editor === null || editor === void 0 ? void 0 : editor.contentComponent) && import_react92.default.createElement(Portals, { contentComponent: editor.contentComponent })
    );
  }
};
var EditorContentWithKey = (0, import_react92.forwardRef)((props, ref) => {
  const key = import_react92.default.useMemo(() => {
    return Math.floor(Math.random() * 4294967295).toString();
  }, [props.editor]);
  return import_react92.default.createElement(PureEditorContent, {
    key,
    innerRef: ref,
    ...props
  });
});
var EditorContent = import_react92.default.memo(EditorContentWithKey);
var react2 = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys2;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a instanceof Map && b instanceof Map) {
      if (a.size !== b.size)
        return false;
      for (i of a.entries())
        if (!b.has(i[0]))
          return false;
      for (i of a.entries())
        if (!equal(i[1], b.get(i[0])))
          return false;
      return true;
    }
    if (a instanceof Set && b instanceof Set) {
      if (a.size !== b.size)
        return false;
      for (i of a.entries())
        if (!b.has(i[0]))
          return false;
      return true;
    }
    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (a[i] !== b[i])
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys2 = Object.keys(a);
    length = keys2.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys2[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys2[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var deepEqual2 = getDefaultExportFromCjs(react2);
var withSelector = { exports: {} };
var withSelector_development = {};
var hasRequiredWithSelector_development;
function requireWithSelector_development() {
  if (hasRequiredWithSelector_development)
    return withSelector_development;
  hasRequiredWithSelector_development = 1;
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React$1 = import_react92.default;
      var shim2 = shimExports;
      function is2(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is2;
      var useSyncExternalStore4 = shim2.useSyncExternalStore;
      var useRef97 = React$1.useRef, useEffect89 = React$1.useEffect, useMemo43 = React$1.useMemo, useDebugValue3 = React$1.useDebugValue;
      function useSyncExternalStoreWithSelector(subscribe2, getSnapshot2, getServerSnapshot, selector, isEqual7) {
        var instRef = useRef97(null);
        var inst3;
        if (instRef.current === null) {
          inst3 = {
            hasValue: false,
            value: null
          };
          instRef.current = inst3;
        } else {
          inst3 = instRef.current;
        }
        var _useMemo = useMemo43(function() {
          var hasMemo = false;
          var memoizedSnapshot;
          var memoizedSelection;
          var memoizedSelector = function(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              var _nextSelection = selector(nextSnapshot);
              if (isEqual7 !== void 0) {
                if (inst3.hasValue) {
                  var currentSelection = inst3.value;
                  if (isEqual7(currentSelection, _nextSelection)) {
                    memoizedSelection = currentSelection;
                    return currentSelection;
                  }
                }
              }
              memoizedSelection = _nextSelection;
              return _nextSelection;
            }
            var prevSnapshot = memoizedSnapshot;
            var prevSelection = memoizedSelection;
            if (objectIs(prevSnapshot, nextSnapshot)) {
              return prevSelection;
            }
            var nextSelection = selector(nextSnapshot);
            if (isEqual7 !== void 0 && isEqual7(prevSelection, nextSelection)) {
              return prevSelection;
            }
            memoizedSnapshot = nextSnapshot;
            memoizedSelection = nextSelection;
            return nextSelection;
          };
          var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
          var getSnapshotWithSelector = function() {
            return memoizedSelector(getSnapshot2());
          };
          var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          };
          return [getSnapshotWithSelector, getServerSnapshotWithSelector];
        }, [getSnapshot2, getServerSnapshot, selector, isEqual7]), getSelection2 = _useMemo[0], getServerSelection = _useMemo[1];
        var value = useSyncExternalStore4(subscribe2, getSelection2, getServerSelection);
        useEffect89(function() {
          inst3.hasValue = true;
          inst3.value = value;
        }, [value]);
        useDebugValue3(value);
        return value;
      }
      withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return withSelector_development;
}
if (false) {
  withSelector.exports = requireWithSelector_production_min();
} else {
  withSelector.exports = requireWithSelector_development();
}
var withSelectorExports = withSelector.exports;
var isSSR = typeof window === "undefined";
var isNext = isSSR || Boolean(typeof window !== "undefined" && window.next);
var EditorContext2 = (0, import_react92.createContext)({
  editor: null
});
var EditorConsumer = EditorContext2.Consumer;
var ReactNodeViewContext = (0, import_react92.createContext)({
  onDragStart: void 0
});
var useReactNodeView = () => (0, import_react92.useContext)(ReactNodeViewContext);
var NodeViewWrapper = import_react92.default.forwardRef((props, ref) => {
  const { onDragStart } = useReactNodeView();
  const Tag = props.as || "div";
  return (
    // @ts-ignore
    import_react92.default.createElement(Tag, { ...props, ref, "data-node-view-wrapper": "", onDragStart, style: {
      whiteSpace: "normal",
      ...props.style
    } })
  );
});

// node_modules/tldraw/dist-esm/lib/shapes/text/RichTextArea.mjs
var import_react94 = __toESM(require_react(), 1);
var RichTextArea = import_react94.default.forwardRef(function RichTextArea2({
  shapeId,
  isEditing,
  richText,
  handleFocus,
  handleChange,
  handleBlur,
  handleKeyDown: handleKeyDown2,
  handleDoubleClick: handleDoubleClick2,
  hasCustomTabBehavior
}, ref) {
  const editor = useEditor();
  const tipTapId = useUniqueSafeId("tip-tap-editor");
  const tipTapConfig = editor.getTextOptions().tipTapConfig;
  const rInitialRichText = (0, import_react94.useRef)(richText);
  const rTextEditor = (0, import_react94.useRef)(null);
  const rTextEditorEl = (0, import_react94.useRef)(null);
  (0, import_react94.useLayoutEffect)(() => {
    if (!rTextEditor.current) {
      rInitialRichText.current = richText;
    } else if (rInitialRichText.current !== richText) {
      rTextEditor.current.commands.setContent(richText);
    }
  }, [richText]);
  const rCreateInfo = (0, import_react94.useRef)({
    selectAll: false,
    caretPosition: null
  });
  (0, import_react94.useLayoutEffect)(() => {
    function selectAllIfEditing(event) {
      if (event.shapeId === editor.getEditingShapeId()) {
        rCreateInfo.current.selectAll = true;
      }
    }
    function placeCaret(event) {
      if (event.shapeId === editor.getEditingShapeId()) {
        rCreateInfo.current.caretPosition = event.point;
      }
    }
    editor.on("select-all-text", selectAllIfEditing);
    editor.on("place-caret", placeCaret);
    return () => {
      editor.off("select-all-text", selectAllIfEditing);
      editor.off("place-caret", placeCaret);
    };
  }, [editor, isEditing]);
  const onChange = useEvent(handleChange);
  const onKeyDown = useEvent(handleKeyDown2);
  const onFocus = useEvent(handleFocus);
  const onBlur = useEvent(handleBlur);
  const onDoubleClick = useEvent(handleDoubleClick2);
  (0, import_react94.useLayoutEffect)(() => {
    if (!isEditing || !tipTapConfig || !rTextEditorEl.current)
      return;
    const { editorProps, ...restOfTipTapConfig } = tipTapConfig;
    const textEditorInstance = new Editor2({
      element: rTextEditorEl.current,
      autofocus: true,
      editable: isEditing,
      onUpdate: (props) => {
        const content = props.editor.state.doc.toJSON();
        rInitialRichText.current = content;
        onChange({ richText: content });
      },
      onFocus,
      onBlur,
      // onCreate is called after a `setTimeout(0)`
      onCreate: (props) => {
        var _a5;
        if (editor.getEditingShapeId() !== shapeId)
          return;
        const textEditor = props.editor;
        editor.setRichTextEditor(textEditor);
        const { selectAll: selectAll3, caretPosition } = rCreateInfo.current;
        if (selectAll3) {
          textEditor.chain().focus().selectAll().run();
        } else if (caretPosition) {
          const pos = (_a5 = textEditor.view.posAtCoords({
            left: caretPosition.x,
            top: caretPosition.y
          })) == null ? void 0 : _a5.pos;
          if (pos) {
            textEditor.chain().focus().setTextSelection(pos).run();
          } else {
            textEditor.chain().focus().selectAll().run();
          }
        }
      },
      editorProps: {
        handleKeyDown: (view, event) => {
          if (!hasCustomTabBehavior && event.key === "Tab") {
            handleTab(editor, view, event);
          }
          onKeyDown(event);
        },
        handleDoubleClick: (view, pos, event) => onDoubleClick(event),
        ...editorProps
      },
      coreExtensionOptions: {
        clipboardTextSerializer: {
          blockSeparator: "\n"
        }
      },
      ...restOfTipTapConfig,
      content: rInitialRichText.current
    });
    const timeout = editor.timers.setTimeout(() => {
      if (rCreateInfo.current.caretPosition || rCreateInfo.current.selectAll) {
        textEditorInstance.commands.focus();
      } else {
        textEditorInstance.commands.focus("end");
      }
      rCreateInfo.current.selectAll = false;
      rCreateInfo.current.caretPosition = null;
    }, 100);
    rTextEditor.current = textEditorInstance;
    return () => {
      rTextEditor.current = null;
      clearTimeout(timeout);
      textEditorInstance.destroy();
    };
  }, [
    isEditing,
    tipTapConfig,
    onFocus,
    onBlur,
    onDoubleClick,
    onChange,
    onKeyDown,
    editor,
    shapeId,
    hasCustomTabBehavior
  ]);
  if (!isEditing || !tipTapConfig) {
    return null;
  }
  return (0, import_jsx_runtime139.jsx)(
    "div",
    {
      id: tipTapId,
      ref,
      tabIndex: -1,
      "data-testid": "rich-text-area",
      className: "tl-rich-text tl-text tl-text-input",
      onContextMenu: isEditing ? stopEventPropagation : void 0,
      onPointerDownCapture: stopEventPropagation,
      onTouchEnd: stopEventPropagation,
      onDragStart: preventDefault,
      children: (0, import_jsx_runtime139.jsx)("div", { className: "tl-rich-text", ref: rTextEditorEl })
    }
  );
});
function handleTab(editor, view, event) {
  event.preventDefault();
  const textEditor = editor.getRichTextEditor();
  if ((textEditor == null ? void 0 : textEditor.isActive("bulletList")) || (textEditor == null ? void 0 : textEditor.isActive("orderedList")))
    return;
  const { state, dispatch: dispatch2 } = view;
  const { $from, $to } = state.selection;
  const isShift = event.shiftKey;
  let tr2 = state.tr;
  let pos = $to.end();
  while (pos >= $from.start()) {
    const line = state.doc.resolve(pos).blockRange();
    if (!line)
      break;
    const lineStart = line.start;
    const lineEnd = line.end;
    const lineText = state.doc.textBetween(lineStart, lineEnd, "\n");
    let isInList = false;
    state.doc.nodesBetween(lineStart, lineEnd, (node) => {
      if (node.type.name === "bulletList" || node.type.name === "orderedList") {
        isInList = true;
        return false;
      }
    });
    if (!isInList) {
      if (!isShift) {
        tr2 = tr2.insertText("	", lineStart + 1);
      } else {
        if (lineText.startsWith("	")) {
          tr2 = tr2.delete(lineStart + 1, lineStart + 2);
        }
      }
    }
    pos = lineStart - 1;
  }
  const mappedSelection = state.selection.map(tr2.doc, tr2.mapping);
  tr2.setSelection(mappedSelection);
  if (tr2.docChanged) {
    dispatch2(tr2);
  }
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/useEditableRichText.mjs
var import_react95 = __toESM(require_react(), 1);
function useEditableRichText(shapeId, type, richText) {
  const commonUseEditableTextHandlers = useEditableTextCommon(shapeId);
  const isEditing = commonUseEditableTextHandlers.isEditing;
  const editor = useEditor();
  const rInput = (0, import_react95.useRef)(null);
  const isEmpty = richText && isEmptyRichText(richText);
  (0, import_react95.useEffect)(() => {
    var _a5;
    if (!isEditing)
      return;
    const contentEditable = (_a5 = rInput.current) == null ? void 0 : _a5.querySelector("[contenteditable]");
    if (contentEditable && document.activeElement !== rInput.current) {
      ;
      contentEditable.focus();
    }
  }, [editor, isEditing]);
  const handleKeyDown2 = (0, import_react95.useCallback)(
    (e) => {
      if (editor.getEditingShapeId() !== shapeId)
        return;
      switch (e.key) {
        case "Enter": {
          if (e.ctrlKey || e.metaKey) {
            editor.complete();
          }
          break;
        }
      }
    },
    [editor, shapeId]
  );
  const handleChange = (0, import_react95.useCallback)(
    ({ richText: richText2 }) => {
      if (editor.getEditingShapeId() !== shapeId)
        return;
      editor.updateShape({
        id: shapeId,
        type,
        props: { richText: richText2 }
      });
    },
    [editor, shapeId, type]
  );
  return {
    rInput,
    handleKeyDown: handleKeyDown2,
    handleChange,
    isEmpty,
    ...commonUseEditableTextHandlers
  };
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/RichTextLabel.mjs
var RichTextLabel = import_react96.default.memo(function RichTextLabel2({
  shapeId,
  type,
  richText,
  labelColor,
  font,
  fontSize,
  lineHeight,
  align,
  verticalAlign,
  wrap: wrap3,
  isSelected,
  padding = 0,
  onKeyDown: handleKeyDownCustom,
  classNamePrefix,
  style: style2,
  textWidth,
  textHeight,
  hasCustomTabBehavior
}) {
  const editor = useEditor();
  const isDragging = import_react96.default.useRef(false);
  const { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } = useEditableRichText(shapeId, type, richText);
  const html = (0, import_react96.useMemo)(() => {
    if (richText) {
      return renderHtmlFromRichText(editor, richText);
    }
  }, [editor, richText]);
  const selectToolActive = useValue(
    "isSelectToolActive",
    () => editor.getCurrentToolId() === "select",
    [editor]
  );
  useReactor(
    "isDragging",
    () => {
      editor.getInstanceState();
      isDragging.current = editor.inputs.isDragging;
    },
    [editor]
  );
  const legacyAlign = isLegacyAlign(align);
  const handlePointerDown = (e) => {
    var _a5;
    if (e.target instanceof HTMLElement && (e.target.tagName === "A" || e.target.closest("a"))) {
      preventDefault(e);
      if (!selectToolActive)
        return;
      const link = ((_a5 = e.target.closest("a")) == null ? void 0 : _a5.getAttribute("href")) ?? "";
      const handlePointerUp = (e2) => {
        if (e2.name !== "pointer_up")
          return;
        if (!isDragging.current) {
          window.open(link, "_blank", "noopener, noreferrer");
        }
        editor.off("event", handlePointerUp);
      };
      editor.on("event", handlePointerUp);
    }
  };
  if (!isEditing && isEmpty)
    return null;
  const cssPrefix = classNamePrefix || "tl-text";
  return (0, import_jsx_runtime140.jsx)(
    "div",
    {
      className: `${cssPrefix}-label tl-text-wrapper tl-rich-text-wrapper`,
      "data-font": font,
      "data-align": align,
      "data-hastext": !isEmpty,
      "data-isediting": isEditing,
      "data-textwrap": !!wrap3,
      "data-isselected": isSelected,
      style: {
        justifyContent: align === "middle" || legacyAlign ? "center" : align,
        alignItems: verticalAlign === "middle" ? "center" : verticalAlign,
        padding,
        ...style2
      },
      children: (0, import_jsx_runtime140.jsxs)(
        "div",
        {
          className: `${cssPrefix}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize,
            lineHeight: Math.floor(fontSize * lineHeight) + "px",
            minHeight: Math.floor(fontSize * lineHeight) + "px",
            minWidth: Math.ceil(textWidth || 0),
            color: labelColor,
            width: textWidth ? Math.ceil(textWidth) : void 0,
            height: textHeight ? Math.ceil(textHeight) : void 0
          },
          children: [
            (0, import_jsx_runtime140.jsx)("div", { className: `${cssPrefix} tl-text tl-text-content`, dir: "auto", children: richText && (0, import_jsx_runtime140.jsx)(
              "div",
              {
                className: "tl-rich-text",
                "data-is-select-tool-active": selectToolActive,
                dangerouslySetInnerHTML: { __html: html || "" },
                onPointerDown: handlePointerDown,
                "data-is-ready-for-editing": isReadyForEditing
              }
            ) }),
            (isReadyForEditing || isSelected) && (0, import_jsx_runtime140.jsx)(
              RichTextArea,
              {
                ref: rInput,
                richText,
                isEditing,
                shapeId,
                ...editableTextRest,
                hasCustomTabBehavior,
                handleKeyDown: handleKeyDownCustom ?? editableTextRest.handleKeyDown
              }
            )
          ]
        }
      )
    }
  );
});
function RichTextSVG({
  bounds,
  richText,
  fontSize,
  font,
  align,
  verticalAlign,
  wrap: wrap3,
  labelColor,
  padding
}) {
  const editor = useEditor();
  const html = renderHtmlFromRichText(editor, richText);
  const textAlign = align === "middle" ? "center" : align === "start" ? "start" : "end";
  const justifyContent = align === "middle" ? "center" : align === "start" ? "flex-start" : "flex-end";
  const alignItems = verticalAlign === "middle" ? "center" : verticalAlign === "start" ? "flex-start" : "flex-end";
  const wrapperStyle = {
    display: "flex",
    fontFamily: DefaultFontFamilies[font],
    height: `100%`,
    justifyContent,
    alignItems,
    padding: `${padding}px`
  };
  const style2 = {
    fontSize: `${fontSize}px`,
    wrap: wrap3 ? "wrap" : "nowrap",
    color: labelColor,
    lineHeight: TEXT_PROPS.lineHeight,
    textAlign,
    width: "100%",
    wordWrap: "break-word",
    overflowWrap: "break-word",
    whiteSpace: "pre-wrap"
  };
  return (0, import_jsx_runtime140.jsx)(
    "foreignObject",
    {
      x: bounds.minX,
      y: bounds.minY,
      width: bounds.w,
      height: bounds.h,
      className: "tl-export-embed-styles tl-rich-text tl-rich-text-svg",
      children: (0, import_jsx_runtime140.jsx)("div", { style: wrapperStyle, children: (0, import_jsx_runtime140.jsx)("div", { dangerouslySetInnerHTML: { __html: html }, style: style2 }) })
    }
  );
}

// node_modules/tldraw/dist-esm/lib/shapes/geo/components/GeoShapeBody.mjs
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/geo/geo-shape-helpers.mjs
function getOvalPerimeter(h, w) {
  if (h > w)
    return (PI * (w / 2) + (h - w)) * 2;
  else
    return (PI * (h / 2) + (w - h)) * 2;
}
function getHeartPath(w, h) {
  return getHeartParts(w, h).map((c, i) => c.getSvgPathData(i === 0)).join(" ") + " Z";
}
function getDrawHeartPath(w, h, sw, id) {
  const o = w / 4;
  const k = h / 4;
  const random = rng(id);
  const mutDistance = sw * 0.75;
  const mut = (v) => v.addXY(random() * mutDistance, random() * mutDistance);
  const A = new Vec(w / 2, h);
  const B = new Vec(0, k * 1.2);
  const C = new Vec(w / 2, k * 0.9);
  const D = new Vec(w, k * 1.2);
  const Am = mut(new Vec(w / 2, h));
  const Bm = mut(new Vec(0, k * 1.2));
  const Cm = mut(new Vec(w / 2, k * 0.9));
  const Dm = mut(new Vec(w, k * 1.2));
  const parts = [
    new CubicBezier2d({
      start: A,
      cp1: new Vec(o * 1.5, k * 3),
      cp2: new Vec(0, k * 2.5),
      end: B
    }),
    new CubicBezier2d({
      start: B,
      cp1: new Vec(0, -k * 0.32),
      cp2: new Vec(o * 1.85, -k * 0.32),
      end: C
    }),
    new CubicBezier2d({
      start: C,
      cp1: new Vec(o * 2.15, -k * 0.32),
      cp2: new Vec(w, -k * 0.32),
      end: D
    }),
    new CubicBezier2d({
      start: D,
      cp1: new Vec(w, k * 2.5),
      cp2: new Vec(o * 2.5, k * 3),
      end: Am
    }),
    new CubicBezier2d({
      start: Am,
      cp1: new Vec(o * 1.5, k * 3),
      cp2: new Vec(0, k * 2.5),
      end: Bm
    }),
    new CubicBezier2d({
      start: Bm,
      cp1: new Vec(0, -k * 0.32),
      cp2: new Vec(o * 1.85, -k * 0.32),
      end: Cm
    }),
    new CubicBezier2d({
      start: Cm,
      cp1: new Vec(o * 2.15, -k * 0.32),
      cp2: new Vec(w, -k * 0.32),
      end: Dm
    }),
    new CubicBezier2d({
      start: Dm,
      cp1: new Vec(w, k * 2.5),
      cp2: new Vec(o * 2.5, k * 3),
      end: A
    })
  ];
  return parts.map((c, i) => c.getSvgPathData(i === 0)).join(" ") + " Z";
}
function getHeartParts(w, h) {
  const o = w / 4;
  const k = h / 4;
  return [
    new CubicBezier2d({
      start: new Vec(w / 2, h),
      cp1: new Vec(o * 1.5, k * 3),
      cp2: new Vec(0, k * 2.5),
      end: new Vec(0, k * 1.2)
    }),
    new CubicBezier2d({
      start: new Vec(0, k * 1.2),
      cp1: new Vec(0, -k * 0.32),
      cp2: new Vec(o * 1.85, -k * 0.32),
      end: new Vec(w / 2, k * 0.9)
    }),
    new CubicBezier2d({
      start: new Vec(w / 2, k * 0.9),
      cp1: new Vec(o * 2.15, -k * 0.32),
      cp2: new Vec(w, -k * 0.32),
      end: new Vec(w, k * 1.2)
    }),
    new CubicBezier2d({
      start: new Vec(w, k * 1.2),
      cp1: new Vec(w, k * 2.5),
      cp2: new Vec(o * 2.5, k * 3),
      end: new Vec(w / 2, h)
    })
  ];
}
function getEllipseStrokeOptions(strokeWidth) {
  return {
    size: 1 + strokeWidth,
    thinning: 0.25,
    end: { taper: strokeWidth },
    start: { taper: strokeWidth },
    streamline: 0,
    smoothing: 1,
    simulatePressure: false
  };
}
function getEllipseStrokePoints(id, width, height, strokeWidth) {
  const getRandom = rng(id);
  const rx = width / 2;
  const ry = height / 2;
  const perimeter = perimeterOfEllipse(rx, ry);
  const points = [];
  const start2 = PI2 * getRandom();
  const length = PI2 + HALF_PI / 2 + Math.abs(getRandom()) * HALF_PI;
  const count3 = Math.max(16, perimeter / 10);
  for (let i = 0; i < count3; i++) {
    const t2 = i / (count3 - 1);
    const r = start2 + t2 * length;
    const c = Math.cos(r);
    const s = Math.sin(r);
    points.push(
      new Vec(
        rx * c + width * 0.5 + 0.05 * getRandom(),
        ry * s + height / 2 + 0.05 * getRandom(),
        Math.min(
          1,
          0.5 + Math.abs(0.5 - (getRandom() > 0 ? EASINGS.easeInOutSine(t2) : EASINGS.easeInExpo(t2))) / 2
        )
      )
    );
  }
  return getStrokePoints(points, getEllipseStrokeOptions(strokeWidth));
}
function getEllipseDrawIndicatorPath(id, width, height, strokeWidth) {
  return getSvgPathFromStrokePoints(getEllipseStrokePoints(id, width, height, strokeWidth));
}
function getRoundedInkyPolygonPath(points) {
  let polylineA = `M`;
  const len = points.length;
  let p0;
  let p1;
  let p2;
  for (let i = 0, n = len; i < n; i += 3) {
    p0 = points[i];
    p1 = points[i + 1];
    p2 = points[i + 2];
    polylineA += `${precise(p0)}L${precise(p1)}Q${precise(p2)}`;
  }
  polylineA += `${precise(points[0])}`;
  return polylineA;
}
function getRoundedPolygonPoints(id, outline, offset5, roundness, passes) {
  const results = [];
  const random = rng(id);
  let p0 = outline[0];
  let p1;
  const len = outline.length;
  for (let i = 0, n = len * passes; i < n; i++) {
    p1 = Vec.AddXY(outline[(i + 1) % len], random() * offset5, random() * offset5);
    const delta = Vec.Sub(p1, p0);
    const distance = Vec.Len(delta);
    const vector = Vec.Div(delta, distance).mul(Math.min(distance / 4, roundness));
    results.push(Vec.Add(p0, vector), Vec.Add(p1, vector.neg()), p1);
    p0 = p1;
  }
  return results;
}
function getPillPoints(width, height, numPoints) {
  const radius = Math.min(width, height) / 2;
  const longSide = Math.max(width, height) - radius * 2;
  const circumference = Math.PI * (radius * 2) + 2 * longSide;
  const spacing = circumference / numPoints;
  const sections = width > height ? [
    {
      type: "straight",
      start: new Vec(radius, 0),
      delta: new Vec(1, 0)
    },
    {
      type: "arc",
      center: new Vec(width - radius, radius),
      startAngle: -PI / 2
    },
    {
      type: "straight",
      start: new Vec(width - radius, height),
      delta: new Vec(-1, 0)
    },
    {
      type: "arc",
      center: new Vec(radius, radius),
      startAngle: PI / 2
    }
  ] : [
    {
      type: "straight",
      start: new Vec(width, radius),
      delta: new Vec(0, 1)
    },
    {
      type: "arc",
      center: new Vec(radius, height - radius),
      startAngle: 0
    },
    {
      type: "straight",
      start: new Vec(0, height - radius),
      delta: new Vec(0, -1)
    },
    {
      type: "arc",
      center: new Vec(radius, radius),
      startAngle: PI
    }
  ];
  let sectionOffset = 0;
  const points = [];
  for (let i = 0; i < numPoints; i++) {
    const section = sections[0];
    if (section.type === "straight") {
      points.push(Vec.Add(section.start, Vec.Mul(section.delta, sectionOffset)));
    } else {
      points.push(
        getPointOnCircle(section.center, radius, section.startAngle + sectionOffset / radius)
      );
    }
    sectionOffset += spacing;
    let sectionLength = section.type === "straight" ? longSide : PI * radius;
    while (sectionOffset > sectionLength) {
      sectionOffset -= sectionLength;
      sections.push(sections.shift());
      sectionLength = sections[0].type === "straight" ? longSide : PI * radius;
    }
  }
  return points;
}
var SIZES = {
  s: 50,
  m: 70,
  l: 100,
  xl: 130
};
var BUMP_PROTRUSION = 0.2;
function getCloudArcs(width, height, seed, size4, scale) {
  const getRandom = rng(seed);
  const pillCircumference = getOvalPerimeter(width, height);
  const numBumps = Math.max(
    Math.ceil(pillCircumference / SIZES[size4]),
    6,
    Math.ceil(pillCircumference / Math.min(width, height))
  );
  const targetBumpProtrusion = pillCircumference / numBumps * BUMP_PROTRUSION;
  const innerWidth = Math.max(width - targetBumpProtrusion * 2, 1);
  const innerHeight2 = Math.max(height - targetBumpProtrusion * 2, 1);
  const innerCircumference = getOvalPerimeter(innerWidth, innerHeight2);
  const distanceBetweenPointsOnPerimeter = innerCircumference / numBumps;
  const paddingX = (width - innerWidth) / 2;
  const paddingY = (height - innerHeight2) / 2;
  const bumpPoints = getPillPoints(innerWidth, innerHeight2, numBumps).map((p) => {
    return p.addXY(paddingX, paddingY);
  });
  const maxWiggleX = width < 20 ? 0 : targetBumpProtrusion * 0.3;
  const maxWiggleY = height < 20 ? 0 : targetBumpProtrusion * 0.3;
  const wiggledPoints = bumpPoints.slice(0);
  for (let i = 0; i < Math.floor(numBumps / 2); i++) {
    wiggledPoints[i] = Vec.AddXY(
      wiggledPoints[i],
      getRandom() * maxWiggleX * scale,
      getRandom() * maxWiggleY * scale
    );
    wiggledPoints[numBumps - i - 1] = Vec.AddXY(
      wiggledPoints[numBumps - i - 1],
      getRandom() * maxWiggleX * scale,
      getRandom() * maxWiggleY * scale
    );
  }
  const arcs = [];
  for (let i = 0; i < wiggledPoints.length; i++) {
    const j = i === wiggledPoints.length - 1 ? 0 : i + 1;
    const leftWigglePoint = wiggledPoints[i];
    const rightWigglePoint = wiggledPoints[j];
    const leftPoint = bumpPoints[i];
    const rightPoint = bumpPoints[j];
    const distanceBetweenOriginalPoints = Vec.Dist(leftPoint, rightPoint);
    const curvatureOffset = distanceBetweenPointsOnPerimeter - distanceBetweenOriginalPoints;
    const distanceBetweenWigglePoints = Vec.Dist(leftWigglePoint, rightWigglePoint);
    const relativeSize = distanceBetweenWigglePoints / distanceBetweenOriginalPoints;
    const finalDistance = (Math.max(paddingX, paddingY) + curvatureOffset) * relativeSize;
    const arcPoint = Vec.Lrp(leftPoint, rightPoint, 0.5).add(
      Vec.Sub(rightPoint, leftPoint).uni().per().mul(finalDistance)
    );
    if (arcPoint.x < 0) {
      arcPoint.x = 0;
    } else if (arcPoint.x > width) {
      arcPoint.x = width;
    }
    if (arcPoint.y < 0) {
      arcPoint.y = 0;
    } else if (arcPoint.y > height) {
      arcPoint.y = height;
    }
    const center = centerOfCircleFromThreePoints(leftWigglePoint, rightWigglePoint, arcPoint);
    const radius = Vec.Dist(
      center ? center : Vec.Average([leftWigglePoint, rightWigglePoint]),
      leftWigglePoint
    );
    arcs.push({
      leftPoint: leftWigglePoint,
      rightPoint: rightWigglePoint,
      arcPoint,
      center,
      radius
    });
  }
  return arcs;
}
function cloudOutline(width, height, seed, size4, scale) {
  const path = [];
  const arcs = getCloudArcs(width, height, seed, size4, scale);
  for (const { center, radius, leftPoint, rightPoint } of arcs) {
    path.push(...getPointsOnArc(leftPoint, rightPoint, center, radius, 10));
  }
  return path;
}
function getCloudPath(width, height, seed, size4, scale) {
  const arcs = getCloudArcs(width, height, seed, size4, scale);
  let path = `M${arcs[0].leftPoint.toFixed()}`;
  for (const { leftPoint, rightPoint, radius, center } of arcs) {
    if (center === null) {
      path += ` L${rightPoint.toFixed()}`;
      continue;
    }
    const arc = Vec.Clockwise(leftPoint, rightPoint, center) ? "0" : "1";
    path += ` A${toDomPrecision(radius)},${toDomPrecision(radius)} 0 ${arc},1 ${rightPoint.toFixed()}`;
  }
  path += " Z";
  return path;
}
var DRAW_OFFSETS = {
  s: 0.5,
  m: 0.7,
  l: 0.9,
  xl: 1.6
};
function inkyCloudSvgPath(width, height, seed, size4, scale) {
  const getRandom = rng(seed);
  const mutMultiplier = DRAW_OFFSETS[size4] * scale;
  const arcs = getCloudArcs(width, height, seed, size4, scale);
  const avgArcLengthSquared = arcs.reduce((sum, arc) => sum + Vec.Dist2(arc.leftPoint, arc.rightPoint), 0) / arcs.length;
  const shouldMutatePoints = avgArcLengthSquared > (mutMultiplier * 15) ** 2;
  const mutPoint = shouldMutatePoints ? (p) => Vec.AddXY(p, getRandom() * mutMultiplier * 2, getRandom() * mutMultiplier * 2) : (p) => p;
  let pathA = `M${arcs[0].leftPoint.toFixed()}`;
  let leftMutPoint = mutPoint(arcs[0].leftPoint);
  let pathB = `M${leftMutPoint.toFixed()}`;
  for (const { leftPoint, center, rightPoint, radius, arcPoint } of arcs) {
    if (center === null) {
      pathA += ` L${rightPoint.toFixed()}`;
      const rightMutPoint2 = mutPoint(rightPoint);
      pathB += ` L${rightMutPoint2.toFixed()}`;
      leftMutPoint = rightMutPoint2;
      continue;
    }
    const arc = Vec.Clockwise(leftPoint, rightPoint, center) ? "0" : "1";
    pathA += ` A${toDomPrecision(radius)},${toDomPrecision(radius)} 0 ${arc},1 ${rightPoint.toFixed()}`;
    const rightMutPoint = mutPoint(rightPoint);
    const mutArcPoint = mutPoint(arcPoint);
    const mutCenter = centerOfCircleFromThreePoints(leftMutPoint, rightMutPoint, mutArcPoint);
    if (!mutCenter) {
      pathB += ` L${rightMutPoint.toFixed()}`;
      leftMutPoint = rightMutPoint;
      continue;
    }
    const mutRadius = Math.abs(Vec.Dist(mutCenter, leftMutPoint));
    pathB += ` A${toDomPrecision(mutRadius)},${toDomPrecision(
      mutRadius
    )} 0 ${arc},1 ${rightMutPoint.toFixed()}`;
    leftMutPoint = rightMutPoint;
  }
  return pathA + pathB + " Z";
}

// node_modules/tldraw/dist-esm/lib/shapes/geo/getLines.mjs
function getLines(props, sw) {
  switch (props.geo) {
    case "x-box": {
      return getXBoxLines(props.w, props.h, sw, props.dash);
    }
    case "check-box": {
      return getCheckBoxLines(props.w, props.h);
    }
    default: {
      return void 0;
    }
  }
}
function getXBoxLines(w, h, sw, dash) {
  const inset = dash === "draw" ? 0.62 : 0;
  if (dash === "dashed") {
    return [
      [new Vec(0, 0), new Vec(w / 2, h / 2)],
      [new Vec(w, h), new Vec(w / 2, h / 2)],
      [new Vec(0, h), new Vec(w / 2, h / 2)],
      [new Vec(w, 0), new Vec(w / 2, h / 2)]
    ];
  }
  const clampX = (x) => Math.max(0, Math.min(w, x));
  const clampY = (y) => Math.max(0, Math.min(h, y));
  return [
    [
      new Vec(clampX(sw * inset), clampY(sw * inset)),
      new Vec(clampX(w - sw * inset), clampY(h - sw * inset))
    ],
    [
      new Vec(clampX(sw * inset), clampY(h - sw * inset)),
      new Vec(clampX(w - sw * inset), clampY(sw * inset))
    ]
  ];
}
function getCheckBoxLines(w, h) {
  const size4 = Math.min(w, h) * 0.82;
  const ox = (w - size4) / 2;
  const oy = (h - size4) / 2;
  const clampX = (x) => Math.max(0, Math.min(w, x));
  const clampY = (y) => Math.max(0, Math.min(h, y));
  return [
    [
      new Vec(clampX(ox + size4 * 0.25), clampY(oy + size4 * 0.52)),
      new Vec(clampX(ox + size4 * 0.45), clampY(oy + size4 * 0.82))
    ],
    [
      new Vec(clampX(ox + size4 * 0.45), clampY(oy + size4 * 0.82)),
      new Vec(clampX(ox + size4 * 0.82), clampY(oy + size4 * 0.22))
    ]
  ];
}

// node_modules/tldraw/dist-esm/lib/shapes/geo/components/GeoShapeBody.mjs
function GeoShapeBody({
  shape,
  shouldScale,
  forceSolid
}) {
  const scaleToUse = shouldScale ? shape.props.scale : 1;
  const editor = useEditor();
  const theme = useDefaultColorTheme();
  const { id, props } = shape;
  const { w, color, fill, dash, growY, size: size4, scale } = props;
  const strokeWidth = STROKE_SIZES2[size4] * scaleToUse;
  const h = props.h + growY;
  switch (props.geo) {
    case "cloud": {
      if (dash === "solid") {
        const d = getCloudPath(w, h, id, size4, scale);
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          (0, import_jsx_runtime141.jsx)("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      } else if (dash === "draw") {
        const d = inkyCloudSvgPath(w, h, id, size4, scale);
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          (0, import_jsx_runtime141.jsx)("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      } else {
        const d = getCloudPath(w, h, id, size4, scale);
        const arcs = getCloudArcs(w, h, id, size4, scale);
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          (0, import_jsx_runtime141.jsx)(
            "g",
            {
              strokeWidth,
              stroke: theme[color].solid,
              fill: "none",
              pointerEvents: "all",
              children: arcs.map(({ leftPoint, rightPoint, center, radius }, i) => {
                const arcLength = center ? radius * canonicalizeRotation(
                  canonicalizeRotation(Vec.Angle(center, rightPoint)) - canonicalizeRotation(Vec.Angle(center, leftPoint))
                ) : Vec.Dist(leftPoint, rightPoint);
                const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
                  arcLength,
                  strokeWidth,
                  {
                    style: dash,
                    start: "outset",
                    end: "outset",
                    forceSolid
                  }
                );
                return (0, import_jsx_runtime141.jsx)(
                  "path",
                  {
                    d: center ? `M${leftPoint.x},${leftPoint.y}A${radius},${radius},0,0,1,${rightPoint.x},${rightPoint.y}` : `M${leftPoint.x},${leftPoint.y}L${rightPoint.x},${rightPoint.y}`,
                    strokeDasharray,
                    strokeDashoffset
                  },
                  i
                );
              })
            }
          )
        ] });
      }
    }
    case "ellipse": {
      const geometry = shouldScale ? (
        // cached
        editor.getShapeGeometry(shape)
      ) : (
        // not cached
        editor.getShapeUtil(shape).getGeometry(shape)
      );
      const d = geometry.getSvgPathData(true);
      if (dash === "dashed" || dash === "dotted") {
        const perimeter = geometry.length;
        const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
          perimeter < 64 ? perimeter * 2 : perimeter,
          strokeWidth,
          {
            style: dash,
            snap: 4,
            closed: true,
            forceSolid
          }
        );
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          (0, import_jsx_runtime141.jsx)(
            "path",
            {
              d,
              strokeWidth,
              fill: "none",
              stroke: theme[color].solid,
              strokeDasharray,
              strokeDashoffset
            }
          )
        ] });
      } else {
        const geometry2 = shouldScale ? (
          // cached
          editor.getShapeGeometry(shape)
        ) : (
          // not cached
          editor.getShapeUtil(shape).getGeometry(shape)
        );
        const d2 = geometry2.getSvgPathData(true);
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(ShapeFill, { theme, d: d2, color, fill, scale: scaleToUse }),
          (0, import_jsx_runtime141.jsx)("path", { d: d2, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      }
    }
    case "oval": {
      const geometry = shouldScale ? (
        // cached
        editor.getShapeGeometry(shape)
      ) : (
        // not cached
        editor.getShapeUtil(shape).getGeometry(shape)
      );
      const d = geometry.getSvgPathData(true);
      if (dash === "dashed" || dash === "dotted") {
        const perimeter = geometry.getLength();
        const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
          perimeter < 64 ? perimeter * 2 : perimeter,
          strokeWidth,
          {
            style: dash,
            snap: 4,
            start: "outset",
            end: "outset",
            closed: true,
            forceSolid
          }
        );
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          (0, import_jsx_runtime141.jsx)(
            "path",
            {
              d,
              strokeWidth,
              fill: "none",
              stroke: theme[color].solid,
              strokeDasharray,
              strokeDashoffset
            }
          )
        ] });
      } else {
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          (0, import_jsx_runtime141.jsx)("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      }
    }
    case "heart": {
      if (dash === "dashed" || dash === "dotted" || dash === "solid") {
        const d = getHeartPath(w, h);
        const curves = getHeartParts(w, h);
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          curves.map((c, i) => {
            const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
              c.length,
              strokeWidth,
              {
                style: dash,
                snap: 1,
                start: "outset",
                end: "outset",
                closed: true,
                forceSolid
              }
            );
            return (0, import_jsx_runtime141.jsx)(
              "path",
              {
                d: c.getSvgPathData(),
                strokeWidth,
                fill: "none",
                stroke: theme[color].solid,
                strokeDasharray,
                strokeDashoffset,
                pointerEvents: "all"
              },
              `curve_${i}`
            );
          })
        ] });
      } else {
        const d = getDrawHeartPath(w, h, strokeWidth, shape.id);
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          (0, import_jsx_runtime141.jsx)("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      }
    }
    default: {
      const geometry = shouldScale ? (
        // cached
        editor.getShapeGeometry(shape)
      ) : (
        // not cached
        editor.getShapeUtil(shape).getGeometry(shape)
      );
      const outline = geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices;
      const lines = getLines(shape.props, strokeWidth);
      if (dash === "solid") {
        let d = "M" + outline[0] + "L" + outline.slice(1) + "Z";
        if (lines) {
          for (const [A, B] of lines) {
            d += `M${A.x},${A.y}L${B.x},${B.y}`;
          }
        }
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          (0, import_jsx_runtime141.jsx)("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      } else if (dash === "dashed" || dash === "dotted") {
        const d = "M" + outline[0] + "L" + outline.slice(1) + "Z";
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          (0, import_jsx_runtime141.jsxs)(
            "g",
            {
              strokeWidth,
              stroke: theme[color].solid,
              fill: "none",
              pointerEvents: "all",
              children: [
                Array.from(Array(outline.length)).map((_, i) => {
                  const A = Vec.ToFixed(outline[i]);
                  const B = Vec.ToFixed(outline[(i + 1) % outline.length]);
                  const dist = Vec.Dist(A, B);
                  const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
                    dist,
                    strokeWidth,
                    {
                      style: dash,
                      start: "outset",
                      end: "outset",
                      forceSolid
                    }
                  );
                  return (0, import_jsx_runtime141.jsx)(
                    "line",
                    {
                      x1: A.x,
                      y1: A.y,
                      x2: B.x,
                      y2: B.y,
                      strokeDasharray,
                      strokeDashoffset
                    },
                    i
                  );
                }),
                lines && lines.map(([A, B], i) => {
                  const dist = Vec.Dist(A, B);
                  const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
                    dist,
                    strokeWidth,
                    {
                      style: dash,
                      start: "skip",
                      end: "skip",
                      snap: dash === "dotted" ? 4 : void 0,
                      forceSolid
                    }
                  );
                  return (0, import_jsx_runtime141.jsx)(
                    "path",
                    {
                      d: `M${A.x},${A.y}L${B.x},${B.y}`,
                      stroke: theme[color].solid,
                      strokeWidth,
                      fill: "none",
                      strokeDasharray,
                      strokeDashoffset
                    },
                    `line_fg_${i}`
                  );
                })
              ]
            }
          )
        ] });
      } else if (dash === "draw") {
        let d = getRoundedInkyPolygonPath(
          getRoundedPolygonPoints(id, outline, strokeWidth / 3, strokeWidth * 2, 2)
        );
        if (lines) {
          for (const [A, B] of lines) {
            d += `M${A.toFixed()}L${B.toFixed()}`;
          }
        }
        const innerPathData = getRoundedInkyPolygonPath(
          getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1)
        );
        return (0, import_jsx_runtime141.jsxs)(import_jsx_runtime141.Fragment, { children: [
          (0, import_jsx_runtime141.jsx)(
            ShapeFill,
            {
              theme,
              d: innerPathData,
              color,
              fill,
              scale: scaleToUse
            }
          ),
          (0, import_jsx_runtime141.jsx)("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      }
    }
  }
}

// node_modules/tldraw/dist-esm/lib/shapes/geo/GeoShapeUtil.mjs
var MIN_SIZE_WITH_LABEL = 17 * 3;
var GeoShapeUtil = class extends BaseBoxShapeUtil {
  canEdit() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      geo: "rectangle",
      color: "black",
      labelColor: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      growY: 0,
      url: "",
      scale: 1,
      richText: toRichText("")
    };
  }
  getGeometry(shape) {
    const w = Math.max(1, shape.props.w);
    const h = Math.max(1, shape.props.h + shape.props.growY);
    const cx = w / 2;
    const cy = h / 2;
    const isFilled = shape.props.fill !== "none";
    let body;
    switch (shape.props.geo) {
      case "cloud": {
        body = new Polygon2d({
          points: cloudOutline(w, h, shape.id, shape.props.size, shape.props.scale),
          isFilled
        });
        break;
      }
      case "triangle": {
        body = new Polygon2d({
          points: [new Vec(cx, 0), new Vec(w, h), new Vec(0, h)],
          isFilled
        });
        break;
      }
      case "diamond": {
        body = new Polygon2d({
          points: [new Vec(cx, 0), new Vec(w, cy), new Vec(cx, h), new Vec(0, cy)],
          isFilled
        });
        break;
      }
      case "pentagon": {
        body = new Polygon2d({
          points: getPolygonVertices(w, h, 5),
          isFilled
        });
        break;
      }
      case "hexagon": {
        body = new Polygon2d({
          points: getPolygonVertices(w, h, 6),
          isFilled
        });
        break;
      }
      case "octagon": {
        body = new Polygon2d({
          points: getPolygonVertices(w, h, 8),
          isFilled
        });
        break;
      }
      case "ellipse": {
        body = new Ellipse2d({
          width: w,
          height: h,
          isFilled
        });
        break;
      }
      case "oval": {
        body = new Stadium2d({
          width: w,
          height: h,
          isFilled
        });
        break;
      }
      case "star": {
        const sides2 = 5;
        const step = PI2 / sides2 / 2;
        const rightMostIndex = Math.floor(sides2 / 4) * 2;
        const leftMostIndex = sides2 * 2 - rightMostIndex;
        const topMostIndex = 0;
        const bottomMostIndex = Math.floor(sides2 / 2) * 2;
        const maxX = Math.cos(-HALF_PI + rightMostIndex * step) * w / 2;
        const minX = Math.cos(-HALF_PI + leftMostIndex * step) * w / 2;
        const minY = Math.sin(-HALF_PI + topMostIndex * step) * h / 2;
        const maxY = Math.sin(-HALF_PI + bottomMostIndex * step) * h / 2;
        const diffX = w - Math.abs(maxX - minX);
        const diffY = h - Math.abs(maxY - minY);
        const offsetX = w / 2 + minX - (w / 2 - maxX);
        const offsetY = h / 2 + minY - (h / 2 - maxY);
        const ratio = 1;
        const cx2 = (w - offsetX) / 2;
        const cy2 = (h - offsetY) / 2;
        const ox = (w + diffX) / 2;
        const oy = (h + diffY) / 2;
        const ix = ox * ratio / 2;
        const iy = oy * ratio / 2;
        body = new Polygon2d({
          points: Array.from(Array(sides2 * 2)).map((_, i) => {
            const theta = -HALF_PI + i * step;
            return new Vec(
              cx2 + (i % 2 ? ix : ox) * Math.cos(theta),
              cy2 + (i % 2 ? iy : oy) * Math.sin(theta)
            );
          }),
          isFilled
        });
        break;
      }
      case "rhombus": {
        const offset5 = Math.min(w * 0.38, h * 0.38);
        body = new Polygon2d({
          points: [new Vec(offset5, 0), new Vec(w, 0), new Vec(w - offset5, h), new Vec(0, h)],
          isFilled
        });
        break;
      }
      case "rhombus-2": {
        const offset5 = Math.min(w * 0.38, h * 0.38);
        body = new Polygon2d({
          points: [new Vec(0, 0), new Vec(w - offset5, 0), new Vec(w, h), new Vec(offset5, h)],
          isFilled
        });
        break;
      }
      case "trapezoid": {
        const offset5 = Math.min(w * 0.38, h * 0.38);
        body = new Polygon2d({
          points: [new Vec(offset5, 0), new Vec(w - offset5, 0), new Vec(w, h), new Vec(0, h)],
          isFilled
        });
        break;
      }
      case "arrow-right": {
        const ox = Math.min(w, h) * 0.38;
        const oy = h * 0.16;
        body = new Polygon2d({
          points: [
            new Vec(0, oy),
            new Vec(w - ox, oy),
            new Vec(w - ox, 0),
            new Vec(w, h / 2),
            new Vec(w - ox, h),
            new Vec(w - ox, h - oy),
            new Vec(0, h - oy)
          ],
          isFilled
        });
        break;
      }
      case "arrow-left": {
        const ox = Math.min(w, h) * 0.38;
        const oy = h * 0.16;
        body = new Polygon2d({
          points: [
            new Vec(ox, 0),
            new Vec(ox, oy),
            new Vec(w, oy),
            new Vec(w, h - oy),
            new Vec(ox, h - oy),
            new Vec(ox, h),
            new Vec(0, h / 2)
          ],
          isFilled
        });
        break;
      }
      case "arrow-up": {
        const ox = w * 0.16;
        const oy = Math.min(w, h) * 0.38;
        body = new Polygon2d({
          points: [
            new Vec(w / 2, 0),
            new Vec(w, oy),
            new Vec(w - ox, oy),
            new Vec(w - ox, h),
            new Vec(ox, h),
            new Vec(ox, oy),
            new Vec(0, oy)
          ],
          isFilled
        });
        break;
      }
      case "arrow-down": {
        const ox = w * 0.16;
        const oy = Math.min(w, h) * 0.38;
        body = new Polygon2d({
          points: [
            new Vec(ox, 0),
            new Vec(w - ox, 0),
            new Vec(w - ox, h - oy),
            new Vec(w, h - oy),
            new Vec(w / 2, h),
            new Vec(0, h - oy),
            new Vec(ox, h - oy)
          ],
          isFilled
        });
        break;
      }
      case "check-box":
      case "x-box":
      case "rectangle": {
        body = new Rectangle2d({
          width: w,
          height: h,
          isFilled
        });
        break;
      }
      case "heart": {
        const parts = getHeartParts(w, h);
        const points = parts.reduce((acc, part) => {
          acc.push(...part.vertices);
          return acc;
        }, []);
        body = new Polygon2d({
          points,
          isFilled
        });
        break;
      }
      default: {
        exhaustiveSwitchError(shape.props.geo);
      }
    }
    const unscaledlabelSize = getUnscaledLabelSize(this.editor, shape);
    const unscaledW = w / shape.props.scale;
    const unscaledH = h / shape.props.scale;
    const unscaledminWidth = Math.min(100, unscaledW / 2);
    const unscaledMinHeight = Math.min(
      LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2,
      unscaledH / 2
    );
    const unscaledLabelWidth = Math.min(
      unscaledW,
      Math.max(unscaledlabelSize.w, Math.min(unscaledminWidth, Math.max(1, unscaledW - 8)))
    );
    const unscaledLabelHeight = Math.min(
      unscaledH,
      Math.max(unscaledlabelSize.h, Math.min(unscaledMinHeight, Math.max(1, unscaledH - 8)))
    );
    const lines = getLines(shape.props, STROKE_SIZES2[shape.props.size] * shape.props.scale);
    const edges = lines ? lines.map((line) => new Polyline2d({ points: line, isInternal: true })) : [];
    return new Group2d({
      children: [
        body,
        new Rectangle2d({
          x: shape.props.align === "start" ? 0 : shape.props.align === "end" ? (unscaledW - unscaledLabelWidth) * shape.props.scale : (unscaledW - unscaledLabelWidth) / 2 * shape.props.scale,
          y: shape.props.verticalAlign === "start" ? 0 : shape.props.verticalAlign === "end" ? (unscaledH - unscaledLabelHeight) * shape.props.scale : (unscaledH - unscaledLabelHeight) / 2 * shape.props.scale,
          width: unscaledLabelWidth * shape.props.scale,
          height: unscaledLabelHeight * shape.props.scale,
          isFilled: true,
          isLabel: true
        }),
        ...edges
      ]
    });
  }
  getHandleSnapGeometry(shape) {
    const geometry = this.getGeometry(shape);
    const outline = geometry.children[0];
    switch (shape.props.geo) {
      case "arrow-down":
      case "arrow-left":
      case "arrow-right":
      case "arrow-up":
      case "check-box":
      case "diamond":
      case "hexagon":
      case "octagon":
      case "pentagon":
      case "rectangle":
      case "rhombus":
      case "rhombus-2":
      case "star":
      case "trapezoid":
      case "triangle":
      case "x-box":
        return { outline, points: [...outline.vertices, geometry.bounds.center] };
      case "cloud":
      case "ellipse":
      case "heart":
      case "oval":
        return { outline, points: [geometry.bounds.center] };
      default:
        exhaustiveSwitchError(shape.props.geo);
    }
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  getFontFaces(shape) {
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  component(shape) {
    const { id, type, props } = shape;
    const { fill, font, align, verticalAlign, size: size4, richText } = props;
    const theme = useDefaultColorTheme();
    const { editor } = this;
    const isOnlySelected = useValue(
      "isGeoOnlySelected",
      () => shape.id === editor.getOnlySelectedShapeId(),
      [editor]
    );
    const isReadyForEditing = useIsReadyForEditing(editor, shape.id);
    const isEmpty = isEmptyRichText(shape.props.richText);
    const showHtmlContainer = isReadyForEditing || !isEmpty;
    const isForceSolid = useValue("force solid", () => editor.getZoomLevel() < 0.2, [editor]);
    return (0, import_jsx_runtime142.jsxs)(import_jsx_runtime142.Fragment, { children: [
      (0, import_jsx_runtime142.jsx)(SVGContainer, { children: (0, import_jsx_runtime142.jsx)(GeoShapeBody, { shape, shouldScale: true, forceSolid: isForceSolid }) }),
      showHtmlContainer && (0, import_jsx_runtime142.jsx)(
        HTMLContainer,
        {
          style: {
            overflow: "hidden",
            width: shape.props.w,
            height: shape.props.h + props.growY
          },
          children: (0, import_jsx_runtime142.jsx)(
            RichTextLabel,
            {
              shapeId: id,
              type,
              font,
              fontSize: LABEL_FONT_SIZES[size4] * shape.props.scale,
              lineHeight: TEXT_PROPS.lineHeight,
              padding: LABEL_PADDING * shape.props.scale,
              fill,
              align,
              verticalAlign,
              richText,
              isSelected: isOnlySelected,
              labelColor: theme[props.labelColor].solid,
              wrap: true
            }
          )
        }
      ),
      shape.props.url && (0, import_jsx_runtime142.jsx)(HyperlinkButton, { url: shape.props.url })
    ] });
  }
  indicator(shape) {
    const geometry = this.editor.getShapeGeometry(shape);
    const isZoomedOut = useValue("isZoomedOut", () => this.editor.getZoomLevel() < 0.25, [
      this.editor
    ]);
    const path = getIndicatorPath(shape, geometry, isZoomedOut);
    return (0, import_jsx_runtime142.jsx)("path", { d: path });
  }
  toSvg(shape, ctx) {
    const newShape = {
      ...shape,
      props: {
        ...shape.props,
        w: shape.props.w / shape.props.scale,
        h: shape.props.h / shape.props.scale
      }
    };
    const props = newShape.props;
    ctx.addExportDef(getFillDefForExport(props.fill));
    let textEl;
    if (!isEmptyRichText(props.richText)) {
      const theme = getDefaultColorTheme(ctx);
      const bounds = new Box(0, 0, props.w, props.h + props.growY);
      textEl = (0, import_jsx_runtime142.jsx)(
        RichTextSVG,
        {
          fontSize: LABEL_FONT_SIZES[props.size],
          font: props.font,
          align: props.align,
          verticalAlign: props.verticalAlign,
          richText: props.richText,
          labelColor: theme[props.labelColor].solid,
          bounds,
          padding: LABEL_PADDING * shape.props.scale
        }
      );
    }
    return (0, import_jsx_runtime142.jsxs)(import_jsx_runtime142.Fragment, { children: [
      (0, import_jsx_runtime142.jsx)(GeoShapeBody, { shouldScale: false, shape: newShape, forceSolid: false }),
      textEl
    ] });
  }
  getCanvasSvgDefs() {
    return [getFillDefForCanvas()];
  }
  onResize(shape, { handle, newPoint, scaleX, scaleY, initialShape }) {
    const unscaledInitialW = initialShape.props.w / initialShape.props.scale;
    const unscaledInitialH = initialShape.props.h / initialShape.props.scale;
    const unscaledGrowY = initialShape.props.growY / initialShape.props.scale;
    let unscaledW = unscaledInitialW * scaleX;
    let unscaledH = (unscaledInitialH + unscaledGrowY) * scaleY;
    let overShrinkX = 0;
    let overShrinkY = 0;
    const min4 = MIN_SIZE_WITH_LABEL;
    if (!isEmptyRichText(shape.props.richText)) {
      let newW = Math.max(Math.abs(unscaledW), min4);
      let newH = Math.max(Math.abs(unscaledH), min4);
      if (newW < min4 && newH === min4)
        newW = min4;
      if (newW === min4 && newH < min4)
        newH = min4;
      const unscaledLabelSize = getUnscaledLabelSize(this.editor, {
        ...shape,
        props: {
          ...shape.props,
          w: newW * shape.props.scale,
          h: newH * shape.props.scale
        }
      });
      const nextW = Math.max(Math.abs(unscaledW), unscaledLabelSize.w) * Math.sign(unscaledW);
      const nextH = Math.max(Math.abs(unscaledH), unscaledLabelSize.h) * Math.sign(unscaledH);
      overShrinkX = Math.abs(nextW) - Math.abs(unscaledW);
      overShrinkY = Math.abs(nextH) - Math.abs(unscaledH);
      unscaledW = nextW;
      unscaledH = nextH;
    }
    const scaledW = unscaledW * shape.props.scale;
    const scaledH = unscaledH * shape.props.scale;
    const offset5 = new Vec(0, 0);
    if (scaleX < 0) {
      offset5.x += scaledW;
    }
    if (handle === "left" || handle === "top_left" || handle === "bottom_left") {
      offset5.x += scaleX < 0 ? overShrinkX : -overShrinkX;
    }
    if (scaleY < 0) {
      offset5.y += scaledH;
    }
    if (handle === "top" || handle === "top_left" || handle === "top_right") {
      offset5.y += scaleY < 0 ? overShrinkY : -overShrinkY;
    }
    const { x, y } = offset5.rot(shape.rotation).add(newPoint);
    return {
      x,
      y,
      props: {
        w: Math.max(Math.abs(scaledW), 1),
        h: Math.max(Math.abs(scaledH), 1),
        growY: 0
      }
    };
  }
  onBeforeCreate(shape) {
    if (isEmptyRichText(shape.props.richText)) {
      if (shape.props.growY) {
        return {
          ...shape,
          props: {
            ...shape.props,
            growY: 0
          }
        };
      } else {
        return;
      }
    }
    const unscaledPrevHeight = shape.props.h / shape.props.scale;
    const unscaledNextHeight = getUnscaledLabelSize(this.editor, shape).h;
    let growY = null;
    if (unscaledNextHeight > unscaledPrevHeight) {
      growY = unscaledNextHeight - unscaledPrevHeight;
    } else {
      if (shape.props.growY) {
        growY = 0;
      }
    }
    if (growY !== null) {
      return {
        ...shape,
        props: {
          ...shape.props,
          // scale the growY
          growY: growY * shape.props.scale
        }
      };
    }
  }
  onBeforeUpdate(prev, next) {
    if ((0, import_lodash6.default)(prev.props.richText, next.props.richText) && prev.props.font === next.props.font && prev.props.size === next.props.size) {
      return;
    }
    const wasEmpty = isEmptyRichText(prev.props.richText);
    const isEmpty = isEmptyRichText(next.props.richText);
    if (!wasEmpty && isEmpty) {
      return {
        ...next,
        props: {
          ...next.props,
          growY: 0
        }
      };
    }
    const unscaledPrevWidth = prev.props.w / prev.props.scale;
    const unscaledPrevHeight = prev.props.h / prev.props.scale;
    const unscaledPrevGrowY = prev.props.growY / prev.props.scale;
    const unscaledNextLabelSize = getUnscaledLabelSize(this.editor, next);
    if (wasEmpty && !isEmpty && renderPlaintextFromRichText(this.editor, next.props.richText)) {
      let unscaledW = Math.max(unscaledPrevWidth, unscaledNextLabelSize.w);
      let unscaledH = Math.max(unscaledPrevHeight, unscaledNextLabelSize.h);
      const min4 = MIN_SIZE_WITH_LABEL;
      if (unscaledPrevWidth < min4 && unscaledPrevHeight < min4) {
        unscaledW = Math.max(unscaledW, min4);
        unscaledH = Math.max(unscaledH, min4);
        unscaledW = Math.max(unscaledW, unscaledH);
        unscaledH = Math.max(unscaledW, unscaledH);
      }
      return {
        ...next,
        props: {
          ...next.props,
          // Scale the results
          w: unscaledW * next.props.scale,
          h: unscaledH * next.props.scale,
          growY: 0
        }
      };
    }
    let growY = null;
    if (unscaledNextLabelSize.h > unscaledPrevHeight) {
      growY = unscaledNextLabelSize.h - unscaledPrevHeight;
    } else {
      if (unscaledPrevGrowY) {
        growY = 0;
      }
    }
    if (growY !== null) {
      const unscaledNextWidth = next.props.w / next.props.scale;
      return {
        ...next,
        props: {
          ...next.props,
          // Scale the results
          growY: growY * next.props.scale,
          w: Math.max(unscaledNextWidth, unscaledNextLabelSize.w) * next.props.scale
        }
      };
    }
    if (unscaledNextLabelSize.w > unscaledPrevWidth) {
      return {
        ...next,
        props: {
          ...next.props,
          // Scale the results
          w: unscaledNextLabelSize.w * next.props.scale
        }
      };
    }
  }
  onDoubleClick(shape) {
    if (this.editor.inputs.altKey) {
      switch (shape.props.geo) {
        case "rectangle": {
          return {
            ...shape,
            props: {
              geo: "check-box"
            }
          };
        }
        case "check-box": {
          return {
            ...shape,
            props: {
              geo: "rectangle"
            }
          };
        }
      }
    }
    return;
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
};
__publicField(GeoShapeUtil, "type", "geo");
__publicField(GeoShapeUtil, "props", geoShapeProps);
__publicField(GeoShapeUtil, "migrations", geoShapeMigrations);
function getUnscaledLabelSize(editor, shape) {
  const { richText, font, size: size4, w } = shape.props;
  if (!richText || isEmptyRichText(richText)) {
    return { w: 0, h: 0 };
  }
  const minSize = editor.textMeasure.measureText("w", {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[font],
    fontSize: LABEL_FONT_SIZES[size4],
    maxWidth: 100
    // ?
  });
  const sizes = {
    s: 2,
    m: 3.5,
    l: 5,
    xl: 10
  };
  const html = renderHtmlFromRichTextForMeasurement(editor, richText);
  const textSize = editor.textMeasure.measureHtml(html, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[font],
    fontSize: LABEL_FONT_SIZES[size4],
    minWidth: minSize.w,
    maxWidth: Math.max(
      // Guard because a DOM nodes can't be less 0
      0,
      // A 'w' width that we're setting as the min-width
      Math.ceil(minSize.w + sizes[size4]),
      // The actual text size
      Math.ceil(w / shape.props.scale - LABEL_PADDING * 2)
    )
  });
  return {
    w: textSize.w + LABEL_PADDING * 2,
    h: textSize.h + LABEL_PADDING * 2
  };
}
function getIndicatorPath(shape, geometry, isZoomedOut) {
  const { id } = shape;
  const { w, size: size4, geo, dash, scale, growY } = shape.props;
  const strokeWidth = STROKE_SIZES2[size4];
  const h = shape.props.h + growY;
  switch (geo) {
    case "ellipse": {
      if (dash === "draw") {
        return getEllipseDrawIndicatorPath(id, w, h, strokeWidth);
      }
      return geometry.getSvgPathData(true);
    }
    case "heart": {
      return getHeartPath(w, h);
    }
    case "oval": {
      return geometry.getSvgPathData(true);
    }
    case "cloud": {
      return getCloudPath(w, h, id, size4, shape.props.scale);
    }
    default: {
      const outline = geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices;
      let path;
      if (dash === "draw" && !isZoomedOut) {
        const polygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2 * scale, 1);
        path = getRoundedInkyPolygonPath(polygonPoints);
      } else {
        path = "M" + outline[0] + "L" + outline.slice(1) + "Z";
      }
      const lines = getLines(shape.props, strokeWidth);
      if (lines) {
        for (const [A, B] of lines) {
          path += `M${A.x},${A.y}L${B.x},${B.y}`;
        }
      }
      return path;
    }
  }
}

// node_modules/tldraw/dist-esm/lib/shapes/highlight/HighlightShapeUtil.mjs
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/shared/useColorSpace.mjs
var import_react97 = __toESM(require_react(), 1);
function useColorSpace() {
  const [supportsP3, setSupportsP3] = (0, import_react97.useState)(false);
  (0, import_react97.useEffect)(() => {
    const supportsSyntax = CSS.supports("color", "color(display-p3 1 1 1)");
    const query = matchMedia("(color-gamut: p3)");
    setSupportsP3(supportsSyntax && query.matches);
    const onChange = () => setSupportsP3(supportsSyntax && query.matches);
    query.addEventListener("change", onChange);
    return () => query.removeEventListener("change", onChange);
  }, []);
  const forceSrgb = useValue(debugFlags.forceSrgb);
  return forceSrgb || !supportsP3 ? "srgb" : "p3";
}

// node_modules/tldraw/dist-esm/lib/shapes/highlight/HighlightShapeUtil.mjs
var HighlightShapeUtil = class extends ShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      maxPointsPerShape: 600,
      underlayOpacity: 0.82,
      overlayOpacity: 0.35
    });
  }
  canTabTo() {
    return false;
  }
  hideResizeHandles(shape) {
    return getIsDot2(shape);
  }
  hideRotateHandle(shape) {
    return getIsDot2(shape);
  }
  hideSelectionBoundsFg(shape) {
    return getIsDot2(shape);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      size: "m",
      isComplete: false,
      isPen: false,
      scale: 1
    };
  }
  getGeometry(shape) {
    const strokeWidth = getStrokeWidth(shape);
    if (getIsDot2(shape)) {
      return new Circle2d({
        x: -strokeWidth / 2,
        y: -strokeWidth / 2,
        radius: strokeWidth / 2,
        isFilled: true
      });
    }
    const { strokePoints, sw } = getHighlightStrokePoints(shape, strokeWidth, true);
    const opts = getHighlightFreehandSettings({ strokeWidth: sw, showAsComplete: true });
    setStrokePointRadii(strokePoints, opts);
    return new Polygon2d({
      points: getStrokeOutlinePoints(strokePoints, opts),
      isFilled: true
    });
  }
  component(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    return (0, import_jsx_runtime143.jsx)(SVGContainer, { children: (0, import_jsx_runtime143.jsx)(
      HighlightRenderer,
      {
        shape,
        forceSolid,
        strokeWidth,
        opacity: this.options.overlayOpacity
      }
    ) });
  }
  backgroundComponent(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    return (0, import_jsx_runtime143.jsx)(SVGContainer, { children: (0, import_jsx_runtime143.jsx)(
      HighlightRenderer,
      {
        shape,
        forceSolid,
        strokeWidth,
        opacity: this.options.underlayOpacity
      }
    ) });
  }
  indicator(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    const { strokePoints, sw } = getHighlightStrokePoints(shape, strokeWidth, forceSolid);
    const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
    let strokePath;
    if (strokePoints.length < 2) {
      strokePath = getIndicatorDot(allPointsFromSegments[0], sw);
    } else {
      strokePath = getSvgPathFromStrokePoints(strokePoints, false);
    }
    return (0, import_jsx_runtime143.jsx)("path", { d: strokePath });
  }
  toSvg(shape) {
    const strokeWidth = getStrokeWidth(shape);
    const forceSolid = strokeWidth < 1.5;
    const scaleFactor = 1 / shape.props.scale;
    return (0, import_jsx_runtime143.jsx)("g", { transform: `scale(${scaleFactor})`, children: (0, import_jsx_runtime143.jsx)(
      HighlightRenderer,
      {
        forceSolid,
        strokeWidth,
        shape,
        opacity: this.options.overlayOpacity
      }
    ) });
  }
  toBackgroundSvg(shape) {
    const strokeWidth = getStrokeWidth(shape);
    const forceSolid = strokeWidth < 1.5;
    const scaleFactor = 1 / shape.props.scale;
    return (0, import_jsx_runtime143.jsx)("g", { transform: `scale(${scaleFactor})`, children: (0, import_jsx_runtime143.jsx)(
      HighlightRenderer,
      {
        forceSolid,
        strokeWidth,
        shape,
        opacity: this.options.underlayOpacity
      }
    ) });
  }
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    const newSegments = [];
    for (const segment of shape.props.segments) {
      newSegments.push({
        ...segment,
        points: segment.points.map(({ x, y, z }) => {
          return {
            x: scaleX * x,
            y: scaleY * y,
            z
          };
        })
      });
    }
    return {
      props: {
        segments: newSegments
      }
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      ...endShape.props,
      segments: interpolateSegments(startShape.props.segments, endShape.props.segments, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
};
__publicField(HighlightShapeUtil, "type", "highlight");
__publicField(HighlightShapeUtil, "props", highlightShapeProps);
__publicField(HighlightShapeUtil, "migrations", highlightShapeMigrations);
function getShapeDot(point) {
  const r = 0.1;
  return `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0`;
}
function getIndicatorDot(point, sw) {
  const r = sw / 2;
  return `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0`;
}
function getHighlightStrokePoints(shape, strokeWidth, forceSolid) {
  var _a5;
  const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
  const showAsComplete = shape.props.isComplete || ((_a5 = last(shape.props.segments)) == null ? void 0 : _a5.type) === "straight";
  let sw = strokeWidth;
  if (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (strokeWidth / 6);
  }
  const options2 = getHighlightFreehandSettings({
    strokeWidth: sw,
    showAsComplete
  });
  const strokePoints = getStrokePoints(allPointsFromSegments, options2);
  return { strokePoints, sw };
}
function getStrokeWidth(shape) {
  return FONT_SIZES[shape.props.size] * 1.12 * shape.props.scale;
}
function getIsDot2(shape) {
  return shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2;
}
function HighlightRenderer({
  strokeWidth,
  forceSolid,
  shape,
  opacity
}) {
  var _a5;
  const theme = useDefaultColorTheme();
  const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
  let sw = strokeWidth;
  if (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (sw / 6);
  }
  const options2 = getHighlightFreehandSettings({
    strokeWidth: sw,
    showAsComplete: shape.props.isComplete || ((_a5 = last(shape.props.segments)) == null ? void 0 : _a5.type) === "straight"
  });
  const strokePoints = getStrokePoints(allPointsFromSegments, options2);
  const solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, false) : getShapeDot(shape.props.segments[0].points[0]);
  const colorSpace = useColorSpace();
  const color = theme[shape.props.color].highlight[colorSpace];
  return (0, import_jsx_runtime143.jsx)(
    "path",
    {
      d: solidStrokePath,
      strokeLinecap: "round",
      fill: "none",
      pointerEvents: "all",
      stroke: color,
      strokeWidth: sw,
      opacity
    }
  );
}
function useHighlightForceSolid(editor, shape) {
  return useValue(
    "forceSolid",
    () => {
      const sw = getStrokeWidth(shape);
      const zoomLevel = editor.getZoomLevel();
      if (sw / zoomLevel < 1.5) {
        return true;
      }
      return false;
    },
    [editor]
  );
}

// node_modules/tldraw/dist-esm/lib/shapes/image/ImageShapeUtil.mjs
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var import_classnames26 = __toESM(require_classnames(), 1);
var import_react99 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/shared/BrokenAssetIcon.mjs
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
function BrokenAssetIcon() {
  return (0, import_jsx_runtime144.jsxs)(
    "svg",
    {
      width: "15",
      height: "15",
      viewBox: "0 0 30 30",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        (0, import_jsx_runtime144.jsx)("path", { d: "M3,11 L3,3 11,3", strokeWidth: "2" }),
        (0, import_jsx_runtime144.jsx)("path", { d: "M19,27 L27,27 L27,19", strokeWidth: "2" }),
        (0, import_jsx_runtime144.jsx)("path", { d: "M27,3 L3,27", strokeWidth: "2" })
      ]
    }
  );
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/crop.mjs
var MIN_CROP_SIZE = 8;
function getDefaultCrop() {
  return {
    topLeft: { x: 0, y: 0 },
    bottomRight: { x: 1, y: 1 }
  };
}
function getUncroppedSize(shapeSize, crop) {
  if (!crop)
    return { w: shapeSize.w, h: shapeSize.h };
  const w = shapeSize.w / (crop.bottomRight.x - crop.topLeft.x);
  const h = shapeSize.h / (crop.bottomRight.y - crop.topLeft.y);
  return { w, h };
}
function getCropBox(shape, info, opts = {}) {
  const { handle, change, crop } = info;
  const { w, h } = info.uncroppedSize;
  const { minWidth = MIN_CROP_SIZE, minHeight = MIN_CROP_SIZE } = opts;
  const newCrop = structuredClone(crop);
  const newPoint = new Vec(shape.x, shape.y);
  const pointDelta = new Vec(0, 0);
  let hasCropChanged = false;
  switch (handle) {
    case "top":
    case "top_left":
    case "top_right": {
      if (h < minHeight)
        break;
      hasCropChanged = true;
      newCrop.topLeft.y = newCrop.topLeft.y + change.y / h;
      const heightAfterCrop = h * (newCrop.bottomRight.y - newCrop.topLeft.y);
      if (heightAfterCrop < minHeight) {
        newCrop.topLeft.y = newCrop.bottomRight.y - minHeight / h;
        pointDelta.y = (newCrop.topLeft.y - crop.topLeft.y) * h;
      } else {
        if (newCrop.topLeft.y <= 0) {
          newCrop.topLeft.y = 0;
          pointDelta.y = (newCrop.topLeft.y - crop.topLeft.y) * h;
        } else {
          pointDelta.y = change.y;
        }
      }
      break;
    }
    case "bottom":
    case "bottom_left":
    case "bottom_right": {
      if (h < minHeight)
        break;
      hasCropChanged = true;
      newCrop.bottomRight.y = Math.min(1, newCrop.bottomRight.y + change.y / h);
      const heightAfterCrop = h * (newCrop.bottomRight.y - newCrop.topLeft.y);
      if (heightAfterCrop < minHeight) {
        newCrop.bottomRight.y = newCrop.topLeft.y + minHeight / h;
      }
      break;
    }
  }
  switch (handle) {
    case "left":
    case "top_left":
    case "bottom_left": {
      if (w < minWidth)
        break;
      hasCropChanged = true;
      newCrop.topLeft.x = newCrop.topLeft.x + change.x / w;
      const widthAfterCrop = w * (newCrop.bottomRight.x - newCrop.topLeft.x);
      if (widthAfterCrop < minWidth) {
        newCrop.topLeft.x = newCrop.bottomRight.x - minWidth / w;
        pointDelta.x = (newCrop.topLeft.x - crop.topLeft.x) * w;
      } else {
        if (newCrop.topLeft.x <= 0) {
          newCrop.topLeft.x = 0;
          pointDelta.x = (newCrop.topLeft.x - crop.topLeft.x) * w;
        } else {
          pointDelta.x = change.x;
        }
      }
      break;
    }
    case "right":
    case "top_right":
    case "bottom_right": {
      if (w < minWidth)
        break;
      hasCropChanged = true;
      newCrop.bottomRight.x = Math.min(1, newCrop.bottomRight.x + change.x / w);
      const widthAfterCrop = w * (newCrop.bottomRight.x - newCrop.topLeft.x);
      if (widthAfterCrop < minWidth) {
        newCrop.bottomRight.x = newCrop.topLeft.x + minWidth / w;
      }
      break;
    }
  }
  if (!hasCropChanged)
    return void 0;
  newPoint.add(pointDelta.rot(shape.rotation));
  return {
    id: shape.id,
    type: shape.type,
    x: newPoint.x,
    y: newPoint.y,
    props: {
      w: (newCrop.bottomRight.x - newCrop.topLeft.x) * w,
      h: (newCrop.bottomRight.y - newCrop.topLeft.y) * h,
      crop: newCrop
    }
  };
}

// node_modules/tldraw/dist-esm/lib/shapes/shared/useImageOrVideoAsset.mjs
var import_react98 = __toESM(require_react(), 1);
function useImageOrVideoAsset({ shapeId, assetId, width }) {
  const editor = useEditor();
  const exportInfo = useSvgExportContext();
  const exportIsReady = useDelaySvgExport();
  const [result, setResult] = (0, import_react98.useState)(() => ({
    asset: assetId ? editor.getAsset(assetId) ?? null : null,
    url: null
  }));
  const didAlreadyResolve = (0, import_react98.useRef)(false);
  const previousUrl = (0, import_react98.useRef)(null);
  (0, import_react98.useEffect)(() => {
    if (!assetId)
      return;
    let isCancelled = false;
    let cancelDebounceFn;
    const cleanupEffectScheduler = react("update state", () => {
      if (!exportInfo && shapeId && editor.getCulledShapes().has(shapeId))
        return;
      const asset = editor.getAsset(assetId);
      if (!asset) {
        setResult((prev) => ({ ...prev, asset: null, url: null }));
        return;
      }
      if (!asset.props.src) {
        const preview = editor.getTemporaryAssetPreview(asset.id);
        if (preview) {
          if (previousUrl.current !== preview) {
            previousUrl.current = preview;
            setResult((prev) => ({ ...prev, isPlaceholder: true, url: preview }));
            exportIsReady();
          }
          return;
        }
      }
      const screenScale = exportInfo ? exportInfo.scale * (width / asset.props.w) : editor.getZoomLevel() * (width / asset.props.w);
      function resolve(asset2, url) {
        if (isCancelled)
          return;
        if (previousUrl.current === url)
          return;
        didAlreadyResolve.current = true;
        previousUrl.current = url;
        setResult({ asset: asset2, url });
        exportIsReady();
      }
      if (didAlreadyResolve.current) {
        let tick2 = 0;
        const resolveAssetAfterAWhile = () => {
          tick2++;
          if (tick2 > 500 / 16) {
            resolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url));
            cancelDebounceFn == null ? void 0 : cancelDebounceFn();
          }
        };
        cancelDebounceFn == null ? void 0 : cancelDebounceFn();
        editor.on("tick", resolveAssetAfterAWhile);
        cancelDebounceFn = () => editor.off("tick", resolveAssetAfterAWhile);
      } else {
        resolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url));
      }
    });
    return () => {
      cleanupEffectScheduler();
      cancelDebounceFn == null ? void 0 : cancelDebounceFn();
      isCancelled = true;
    };
  }, [editor, assetId, exportInfo, exportIsReady, shapeId, width]);
  return result;
}
function resolveAssetUrl(editor, assetId, screenScale, exportInfo, callback) {
  editor.resolveAssetUrl(assetId, {
    screenScale,
    shouldResolveToOriginal: exportInfo ? exportInfo.pixelRatio === null : false,
    dpr: (exportInfo == null ? void 0 : exportInfo.pixelRatio) ?? void 0
  }).then((url) => {
    callback(url);
  });
}
var useAsset = useImageOrVideoAsset;

// node_modules/tldraw/dist-esm/lib/shapes/image/ImageShapeUtil.mjs
async function getDataURIFromURL(url) {
  const response = await fetch(url);
  const blob = await response.blob();
  return FileHelpers.blobToDataUrl(blob);
}
var imageSvgExportCache = new WeakCache();
var ImageShapeUtil = class extends BaseBoxShapeUtil {
  isAspectRatioLocked() {
    return true;
  }
  canCrop() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      playing: true,
      url: "",
      crop: null,
      flipX: false,
      flipY: false,
      altText: ""
    };
  }
  getAriaDescriptor(shape) {
    return shape.props.altText;
  }
  onResize(shape, info) {
    let resized = resizeBox(shape, info);
    const { flipX, flipY } = info.initialShape.props;
    const { scaleX, scaleY, mode } = info;
    resized = {
      ...resized,
      props: {
        ...resized.props,
        flipX: scaleX < 0 !== flipX,
        flipY: scaleY < 0 !== flipY
      }
    };
    if (!shape.props.crop)
      return resized;
    const flipCropHorizontally = (
      // We used the flip horizontally feature
      // We resized the shape past it's bounds, so it flipped
      mode === "scale_shape" && scaleX === -1 || mode === "resize_bounds" && flipX !== resized.props.flipX
    );
    const flipCropVertically = (
      // We used the flip vertically feature
      // We resized the shape past it's bounds, so it flipped
      mode === "scale_shape" && scaleY === -1 || mode === "resize_bounds" && flipY !== resized.props.flipY
    );
    const { topLeft, bottomRight } = shape.props.crop;
    resized.props.crop = {
      topLeft: {
        x: flipCropHorizontally ? 1 - bottomRight.x : topLeft.x,
        y: flipCropVertically ? 1 - bottomRight.y : topLeft.y
      },
      bottomRight: {
        x: flipCropHorizontally ? 1 - topLeft.x : bottomRight.x,
        y: flipCropVertically ? 1 - topLeft.y : bottomRight.y
      }
    };
    return resized;
  }
  component(shape) {
    return (0, import_jsx_runtime145.jsx)(ImageShape, { shape });
  }
  indicator(shape) {
    const isCropping = this.editor.getCroppingShapeId() === shape.id;
    if (isCropping)
      return null;
    return (0, import_jsx_runtime145.jsx)("rect", { width: toDomPrecision(shape.props.w), height: toDomPrecision(shape.props.h) });
  }
  async toSvg(shape, ctx) {
    if (!shape.props.assetId)
      return null;
    const asset = this.editor.getAsset(shape.props.assetId);
    if (!asset)
      return null;
    const { w } = getUncroppedSize(shape.props, shape.props.crop);
    const src = await imageSvgExportCache.get(asset, async () => {
      let src2 = await ctx.resolveAssetUrl(asset.id, w);
      if (!src2)
        return null;
      if (src2.startsWith("blob:") || src2.startsWith("http") || src2.startsWith("/") || src2.startsWith("./")) {
        src2 = await getDataURIFromURL(src2) || "";
      }
      if (getIsAnimated(this.editor, asset.id)) {
        const { promise } = getFirstFrameOfAnimatedImage(src2);
        src2 = await promise;
      }
      return src2;
    });
    if (!src)
      return null;
    return (0, import_jsx_runtime145.jsx)(SvgImage, { shape, src });
  }
  onDoubleClickEdge(shape) {
    const props = shape.props;
    if (!props)
      return;
    if (this.editor.getCroppingShapeId() !== shape.id) {
      return;
    }
    const crop = structuredClone(props.crop) || {
      topLeft: { x: 0, y: 0 },
      bottomRight: { x: 1, y: 1 }
    };
    const { w, h } = getUncroppedSize(shape.props, crop);
    const pointDelta = new Vec(crop.topLeft.x * w, crop.topLeft.y * h).rot(shape.rotation);
    const partial = {
      id: shape.id,
      type: shape.type,
      x: shape.x - pointDelta.x,
      y: shape.y - pointDelta.y,
      props: {
        crop: {
          topLeft: { x: 0, y: 0 },
          bottomRight: { x: 1, y: 1 }
        },
        w,
        h
      }
    };
    this.editor.updateShapes([partial]);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    function interpolateCrop(startShape2, endShape2) {
      var _a5, _b, _c, _d;
      if (startShape2.props.crop === null && endShape2.props.crop === null)
        return null;
      const startTL = ((_a5 = startShape2.props.crop) == null ? void 0 : _a5.topLeft) || { x: 0, y: 0 };
      const startBR = ((_b = startShape2.props.crop) == null ? void 0 : _b.bottomRight) || { x: 1, y: 1 };
      const endTL = ((_c = endShape2.props.crop) == null ? void 0 : _c.topLeft) || { x: 0, y: 0 };
      const endBR = ((_d = endShape2.props.crop) == null ? void 0 : _d.bottomRight) || { x: 1, y: 1 };
      return {
        topLeft: { x: lerp(startTL.x, endTL.x, t2), y: lerp(startTL.y, endTL.y, t2) },
        bottomRight: { x: lerp(startBR.x, endBR.x, t2), y: lerp(startBR.y, endBR.y, t2) }
      };
    }
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2),
      crop: interpolateCrop(startShape, endShape)
    };
  }
};
__publicField(ImageShapeUtil, "type", "image");
__publicField(ImageShapeUtil, "props", imageShapeProps);
__publicField(ImageShapeUtil, "migrations", imageShapeMigrations);
var ImageShape = (0, import_react99.memo)(function ImageShape2({ shape }) {
  var _a5;
  const editor = useEditor();
  const { w } = getUncroppedSize(shape.props, shape.props.crop);
  const { asset, url } = useImageOrVideoAsset({
    shapeId: shape.id,
    assetId: shape.props.assetId,
    width: w
  });
  const prefersReducedMotion = usePrefersReducedMotion();
  const [staticFrameSrc, setStaticFrameSrc] = (0, import_react99.useState)("");
  const [loadedUrl, setLoadedUrl] = (0, import_react99.useState)(null);
  const isAnimated = asset && getIsAnimated(editor, asset.id);
  (0, import_react99.useEffect)(() => {
    if (url && isAnimated) {
      const { promise, cancel } = getFirstFrameOfAnimatedImage(url);
      promise.then((dataUrl) => {
        setStaticFrameSrc(dataUrl);
        setLoadedUrl(url);
      });
      return () => {
        cancel();
      };
    }
  }, [editor, isAnimated, prefersReducedMotion, url]);
  const showCropPreview = useValue(
    "show crop preview",
    () => shape.id === editor.getOnlySelectedShapeId() && editor.getCroppingShapeId() === shape.id && editor.isIn("select.crop"),
    [editor, shape.id]
  );
  const reduceMotion = prefersReducedMotion && (((_a5 = asset == null ? void 0 : asset.props.mimeType) == null ? void 0 : _a5.includes("video")) || isAnimated);
  const containerStyle = getCroppedContainerStyle(shape);
  const nextSrc = url === loadedUrl ? null : url;
  const loadedSrc = reduceMotion ? staticFrameSrc : loadedUrl;
  if (!url && !(asset == null ? void 0 : asset.props.src)) {
    return (0, import_jsx_runtime145.jsxs)(
      HTMLContainer,
      {
        id: shape.id,
        style: {
          overflow: "hidden",
          width: shape.props.w,
          height: shape.props.h,
          color: "var(--color-text-3)",
          backgroundColor: "var(--color-low)",
          border: "1px solid var(--color-low-border)"
        },
        children: [
          (0, import_jsx_runtime145.jsx)(
            "div",
            {
              className: (0, import_classnames26.default)("tl-image-container", asset && "tl-image-container-loading"),
              style: containerStyle,
              children: asset ? null : (0, import_jsx_runtime145.jsx)(BrokenAssetIcon, {})
            }
          ),
          "url" in shape.props && shape.props.url && (0, import_jsx_runtime145.jsx)(HyperlinkButton, { url: shape.props.url })
        ]
      }
    );
  }
  const crossOrigin = isAnimated ? "anonymous" : void 0;
  return (0, import_jsx_runtime145.jsxs)(import_jsx_runtime145.Fragment, { children: [
    showCropPreview && loadedSrc && (0, import_jsx_runtime145.jsx)("div", { style: containerStyle, children: (0, import_jsx_runtime145.jsx)(
      "img",
      {
        className: "tl-image",
        style: { ...getFlipStyle(shape), opacity: 0.1 },
        crossOrigin,
        src: loadedSrc,
        referrerPolicy: "strict-origin-when-cross-origin",
        draggable: false
      }
    ) }),
    (0, import_jsx_runtime145.jsxs)(
      HTMLContainer,
      {
        id: shape.id,
        style: { overflow: "hidden", width: shape.props.w, height: shape.props.h },
        children: [
          (0, import_jsx_runtime145.jsxs)("div", { className: (0, import_classnames26.default)("tl-image-container"), style: containerStyle, children: [
            loadedSrc && (0, import_jsx_runtime145.jsx)(
              "img",
              {
                className: "tl-image",
                style: getFlipStyle(shape),
                crossOrigin,
                src: loadedSrc,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: false
              },
              loadedSrc
            ),
            nextSrc && (0, import_jsx_runtime145.jsx)(
              "img",
              {
                className: "tl-image",
                style: getFlipStyle(shape),
                crossOrigin,
                src: nextSrc,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: false,
                onLoad: () => setLoadedUrl(nextSrc)
              },
              nextSrc
            )
          ] }),
          shape.props.url && (0, import_jsx_runtime145.jsx)(HyperlinkButton, { url: shape.props.url })
        ]
      }
    )
  ] });
});
function getIsAnimated(editor, assetId) {
  const asset = assetId ? editor.getAsset(assetId) : void 0;
  if (!asset)
    return false;
  return "mimeType" in asset.props && MediaHelpers.isAnimatedImageType(asset == null ? void 0 : asset.props.mimeType) || "isAnimated" in asset.props && asset.props.isAnimated;
}
function getCroppedContainerStyle(shape) {
  const crop = shape.props.crop;
  const topLeft = crop == null ? void 0 : crop.topLeft;
  if (!topLeft) {
    return {
      width: shape.props.w,
      height: shape.props.h
    };
  }
  const { w, h } = getUncroppedSize(shape.props, crop);
  const offsetX = -topLeft.x * w;
  const offsetY = -topLeft.y * h;
  return {
    transform: `translate(${offsetX}px, ${offsetY}px)`,
    width: w,
    height: h
  };
}
function getFlipStyle(shape, size4) {
  const { flipX, flipY } = shape.props;
  if (!flipX && !flipY)
    return void 0;
  const scale = `scale(${flipX ? -1 : 1}, ${flipY ? -1 : 1})`;
  const translate = size4 ? `translate(${flipX ? size4.width : 0}px, ${flipY ? size4.height : 0}px)` : "";
  return {
    transform: `${translate} ${scale}`,
    // in SVG, flipping around the center doesn't work so we use explicit width/height
    transformOrigin: size4 ? "0 0" : "center center"
  };
}
function SvgImage({ shape, src }) {
  const cropClipId = useUniqueSafeId();
  const containerStyle = getCroppedContainerStyle(shape);
  const crop = shape.props.crop;
  if (containerStyle.transform && crop) {
    const { transform: cropTransform, width, height } = containerStyle;
    const croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width;
    const croppedHeight = (crop.bottomRight.y - crop.topLeft.y) * height;
    const points = [
      new Vec(0, 0),
      new Vec(croppedWidth, 0),
      new Vec(croppedWidth, croppedHeight),
      new Vec(0, croppedHeight)
    ];
    const flip5 = getFlipStyle(shape, { width, height });
    return (0, import_jsx_runtime145.jsxs)(import_jsx_runtime145.Fragment, { children: [
      (0, import_jsx_runtime145.jsx)("defs", { children: (0, import_jsx_runtime145.jsx)("clipPath", { id: cropClipId, children: (0, import_jsx_runtime145.jsx)("polygon", { points: points.map((p) => `${p.x},${p.y}`).join(" ") }) }) }),
      (0, import_jsx_runtime145.jsx)("g", { clipPath: `url(#${cropClipId})`, children: (0, import_jsx_runtime145.jsx)(
        "image",
        {
          href: src,
          width,
          height,
          style: flip5 ? { ...flip5, transform: `${cropTransform} ${flip5.transform}` } : { transform: cropTransform }
        }
      ) })
    ] });
  } else {
    return (0, import_jsx_runtime145.jsx)(
      "image",
      {
        href: src,
        width: shape.props.w,
        height: shape.props.h,
        style: getFlipStyle(shape, { width: shape.props.w, height: shape.props.h })
      }
    );
  }
}
function getFirstFrameOfAnimatedImage(url) {
  let cancelled = false;
  const promise = new Promise((resolve) => {
    const image = Image();
    image.onload = () => {
      if (cancelled)
        return;
      const canvas = document.createElement("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const ctx = canvas.getContext("2d");
      if (!ctx)
        return;
      ctx.drawImage(image, 0, 0);
      resolve(canvas.toDataURL());
    };
    image.crossOrigin = "anonymous";
    image.src = url;
  });
  return { promise, cancel: () => cancelled = true };
}

// node_modules/tldraw/dist-esm/lib/shapes/line/LineShapeUtil.mjs
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/shapes/line/components/getLinePath.mjs
function getLineDrawFreehandOptions(strokeWidth) {
  return {
    size: strokeWidth,
    thinning: 0.4,
    streamline: 0,
    smoothing: 0.5,
    simulatePressure: true,
    last: true
  };
}
function getLineStrokePoints(shape, spline, strokeWidth) {
  const points = spline.vertices;
  const options2 = getLineDrawFreehandOptions(strokeWidth);
  return getStrokePoints(points, options2);
}
function getLineDrawStrokeOutlinePoints(shape, spline, strokeWidth) {
  const options2 = getLineDrawFreehandOptions(strokeWidth);
  return getStrokeOutlinePoints(
    setStrokePointRadii(getLineStrokePoints(shape, spline, strokeWidth), options2),
    options2
  );
}
function getLineDrawPath(shape, spline, strokeWidth) {
  const stroke = getLineDrawStrokeOutlinePoints(shape, spline, strokeWidth);
  return getSvgPathFromPoints(stroke);
}
function getLineIndicatorPath(shape, spline, strokeWidth) {
  if (shape.props.dash === "draw") {
    const strokePoints = getLineStrokePoints(shape, spline, strokeWidth);
    return getSvgPathFromStrokePoints(strokePoints);
  }
  return spline.getSvgPathData();
}

// node_modules/tldraw/dist-esm/lib/shapes/line/line-helpers.mjs
function getDrawLinePathData(id, outline, strokeWidth) {
  let innerPathData = `M ${precise(outline[0])}L`;
  let outerPathData2 = `M ${precise(outline[0])}L`;
  const offset5 = strokeWidth / 3;
  const roundness = strokeWidth * 2;
  const random = rng(id);
  let p0 = outline[0];
  let p1;
  let s0 = outline[0];
  let s1;
  const len = outline.length;
  for (let i = 0, n = len - 1; i < n; i++) {
    p1 = outline[i + 1];
    s1 = Vec.AddXY(outline[i + 1], random() * offset5, random() * offset5);
    const delta = Vec.Sub(p1, p0);
    const distance = Vec.Len(delta);
    const vector = Vec.Div(delta, distance).mul(Math.min(distance / 4, roundness));
    const q0 = Vec.Add(p0, vector);
    const q1 = Vec.Add(p1, vector.neg());
    const sDelta = Vec.Sub(s1, s0);
    const sDistance = Vec.Len(sDelta);
    const sVector = Vec.Div(sDelta, sDistance).mul(Math.min(sDistance / 4, roundness));
    const sq0 = Vec.Add(s0, sVector);
    const sq1 = Vec.Add(s1, sVector.neg());
    if (i === n - 1) {
      innerPathData += `${precise(q0)}L ${precise(p1)}`;
      outerPathData2 += `${precise(sq0)}L ${precise(s1)}`;
    } else {
      innerPathData += `${precise(q0)}L ${precise(q1)}Q ${precise(p1)}`;
      outerPathData2 += `${precise(sq0)}L ${precise(sq1)}Q ${precise(s1)}`;
      p0 = p1;
      s0 = s1;
    }
  }
  return [innerPathData, innerPathData + outerPathData2];
}

// node_modules/tldraw/dist-esm/lib/shapes/line/LineShapeUtil.mjs
var handlesCache = new WeakCache();
var LineShapeUtil = class extends ShapeUtil {
  canTabTo() {
    return false;
  }
  hideResizeHandles() {
    return true;
  }
  hideRotateHandle() {
    return true;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  hideSelectionBoundsBg() {
    return true;
  }
  getDefaultProps() {
    const [start2, end2] = getIndices(2);
    return {
      dash: "draw",
      size: "m",
      color: "black",
      spline: "line",
      points: {
        [start2]: { id: start2, index: start2, x: 0, y: 0 },
        [end2]: { id: end2, index: end2, x: 0.1, y: 0.1 }
      },
      scale: 1
    };
  }
  getGeometry(shape) {
    return getGeometryForLineShape(shape);
  }
  getHandles(shape) {
    return handlesCache.get(shape.props, () => {
      const spline = getGeometryForLineShape(shape);
      const points = linePointsToArray(shape);
      const results = points.map((point) => ({
        ...point,
        id: point.index,
        type: "vertex",
        canSnap: true
      }));
      for (let i = 0; i < points.length - 1; i++) {
        const index3 = getIndexBetween(points[i].index, points[i + 1].index);
        const segment = spline.segments[i];
        const point = segment.midPoint();
        results.push({
          id: index3,
          type: "create",
          index: index3,
          x: point.x,
          y: point.y,
          canSnap: true
        });
      }
      return results.sort(sortByIndex);
    });
  }
  //   Events
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    return {
      props: {
        points: mapObjectMapValues(shape.props.points, (_, { id, index: index3, x, y }) => ({
          id,
          index: index3,
          x: x * scaleX,
          y: y * scaleY
        }))
      }
    };
  }
  onBeforeCreate(next) {
    const {
      props: { points }
    } = next;
    const pointKeys = Object.keys(points);
    if (pointKeys.length < 2) {
      return;
    }
    const firstPoint = points[pointKeys[0]];
    const allSame = pointKeys.every((key) => {
      const point = points[key];
      return point.x === firstPoint.x && point.y === firstPoint.y;
    });
    if (allSame) {
      const lastKey = pointKeys[pointKeys.length - 1];
      points[lastKey] = {
        ...points[lastKey],
        x: points[lastKey].x + 0.1,
        y: points[lastKey].y + 0.1
      };
      return next;
    }
    return;
  }
  onHandleDrag(shape, { handle }) {
    if (handle.type !== "vertex")
      return;
    const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor);
    return {
      ...shape,
      props: {
        ...shape.props,
        points: {
          ...shape.props.points,
          [handle.id]: { id: handle.id, index: handle.index, x: newPoint.x, y: newPoint.y }
        }
      }
    };
  }
  component(shape) {
    return (0, import_jsx_runtime146.jsx)(SVGContainer, { style: { minWidth: 50, minHeight: 50 }, children: (0, import_jsx_runtime146.jsx)(LineShapeSvg, { shape }) });
  }
  indicator(shape) {
    const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale;
    const spline = getGeometryForLineShape(shape);
    const { dash } = shape.props;
    let path;
    if (shape.props.spline === "line") {
      const outline = spline.points;
      if (dash === "solid" || dash === "dotted" || dash === "dashed") {
        path = "M" + outline[0] + "L" + outline.slice(1);
      } else {
        const [innerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth);
        path = innerPathData;
      }
    } else {
      path = getLineIndicatorPath(shape, spline, strokeWidth);
    }
    return (0, import_jsx_runtime146.jsx)("path", { d: path });
  }
  toSvg(shape) {
    return (0, import_jsx_runtime146.jsx)(LineShapeSvg, { shouldScale: true, shape });
  }
  getHandleSnapGeometry(shape) {
    const points = linePointsToArray(shape);
    return {
      points,
      getSelfSnapPoints: (handle) => {
        const index3 = this.getHandles(shape).filter((h) => h.type === "vertex").findIndex((h) => h.id === handle.id);
        return points.filter((_, i) => Math.abs(i - index3) > 1).map(Vec.From);
      },
      getSelfSnapOutline: (handle) => {
        const index3 = this.getHandles(shape).filter((h) => h.type === "vertex").findIndex((h) => h.id === handle.id);
        const segments = getGeometryForLineShape(shape).segments.filter(
          (_, i) => i !== index3 - 1 && i !== index3
        );
        if (!segments.length)
          return null;
        return new Group2d({ children: segments });
      }
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    const startPoints = linePointsToArray(startShape);
    const endPoints = linePointsToArray(endShape);
    const pointsToUseStart = [];
    const pointsToUseEnd = [];
    let index3 = ZERO_INDEX_KEY;
    if (startPoints.length > endPoints.length) {
      for (let i = 0; i < startPoints.length; i++) {
        pointsToUseStart[i] = { ...startPoints[i] };
        if (endPoints[i] === void 0) {
          pointsToUseEnd[i] = { ...endPoints[endPoints.length - 1], id: index3 };
        } else {
          pointsToUseEnd[i] = { ...endPoints[i], id: index3 };
        }
        index3 = getIndexAbove(index3);
      }
    } else if (endPoints.length > startPoints.length) {
      for (let i = 0; i < endPoints.length; i++) {
        pointsToUseEnd[i] = { ...endPoints[i] };
        if (startPoints[i] === void 0) {
          pointsToUseStart[i] = {
            ...startPoints[startPoints.length - 1],
            id: index3
          };
        } else {
          pointsToUseStart[i] = { ...startPoints[i], id: index3 };
        }
        index3 = getIndexAbove(index3);
      }
    } else {
      for (let i = 0; i < endPoints.length; i++) {
        pointsToUseStart[i] = startPoints[i];
        pointsToUseEnd[i] = endPoints[i];
      }
    }
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      points: Object.fromEntries(
        pointsToUseStart.map((point, i) => {
          const endPoint = pointsToUseEnd[i];
          return [
            point.id,
            {
              ...point,
              x: lerp(point.x, endPoint.x, t2),
              y: lerp(point.y, endPoint.y, t2)
            }
          ];
        })
      ),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
};
__publicField(LineShapeUtil, "type", "line");
__publicField(LineShapeUtil, "props", lineShapeProps);
__publicField(LineShapeUtil, "migrations", lineShapeMigrations);
function linePointsToArray(shape) {
  return Object.values(shape.props.points).sort(sortByIndex);
}
function getGeometryForLineShape(shape) {
  const points = linePointsToArray(shape).map(Vec.From);
  switch (shape.props.spline) {
    case "cubic": {
      return new CubicSpline2d({ points });
    }
    case "line": {
      return new Polyline2d({ points });
    }
  }
}
function LineShapeSvg({
  shape,
  shouldScale = false,
  forceSolid = false
}) {
  const theme = useDefaultColorTheme();
  const spline = getGeometryForLineShape(shape);
  const { dash, color, size: size4 } = shape.props;
  const scaleFactor = 1 / shape.props.scale;
  const scale = shouldScale ? scaleFactor : 1;
  const strokeWidth = STROKE_SIZES[size4] * shape.props.scale;
  if (shape.props.spline === "line") {
    if (dash === "solid") {
      const outline = spline.points;
      const pathData = "M" + outline[0] + "L" + outline.slice(1);
      return (0, import_jsx_runtime146.jsx)(
        "path",
        {
          d: pathData,
          stroke: theme[color].solid,
          strokeWidth,
          fill: "none",
          transform: `scale(${scale})`
        }
      );
    }
    if (dash === "dashed" || dash === "dotted") {
      return (0, import_jsx_runtime146.jsx)("g", { stroke: theme[color].solid, strokeWidth, transform: `scale(${scale})`, children: spline.segments.map((segment, i) => {
        const { strokeDasharray, strokeDashoffset } = forceSolid ? { strokeDasharray: "none", strokeDashoffset: "none" } : getPerfectDashProps(segment.length, strokeWidth, {
          style: dash,
          start: i > 0 ? "outset" : "none",
          end: i < spline.segments.length - 1 ? "outset" : "none"
        });
        return (0, import_jsx_runtime146.jsx)(
          "path",
          {
            strokeDasharray,
            strokeDashoffset,
            d: segment.getSvgPathData(true),
            fill: "none"
          },
          i
        );
      }) });
    }
    if (dash === "draw") {
      const outline = spline.points;
      const [_, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth);
      return (0, import_jsx_runtime146.jsx)(
        "path",
        {
          d: outerPathData,
          stroke: theme[color].solid,
          strokeWidth,
          fill: "none",
          transform: `scale(${scale})`
        }
      );
    }
  }
  if (shape.props.spline === "cubic") {
    const splinePath = spline.getSvgPathData();
    if (dash === "solid") {
      return (0, import_jsx_runtime146.jsx)(
        "path",
        {
          strokeWidth,
          stroke: theme[color].solid,
          fill: "none",
          d: splinePath,
          transform: `scale(${scale})`
        }
      );
    }
    if (dash === "dashed" || dash === "dotted") {
      return (0, import_jsx_runtime146.jsx)("g", { stroke: theme[color].solid, strokeWidth, transform: `scale(${scale})`, children: spline.segments.map((segment, i) => {
        const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
          segment.length,
          strokeWidth,
          {
            style: dash,
            start: i > 0 ? "outset" : "none",
            end: i < spline.segments.length - 1 ? "outset" : "none",
            forceSolid
          }
        );
        return (0, import_jsx_runtime146.jsx)(
          "path",
          {
            strokeDasharray,
            strokeDashoffset,
            d: segment.getSvgPathData(),
            fill: "none"
          },
          i
        );
      }) });
    }
    if (dash === "draw") {
      return (0, import_jsx_runtime146.jsx)(
        "path",
        {
          d: getLineDrawPath(shape, spline, strokeWidth),
          strokeWidth: 1,
          stroke: theme[color].solid,
          fill: theme[color].solid,
          transform: `scale(${scale})`
        }
      );
    }
  }
}

// node_modules/tldraw/dist-esm/lib/shapes/note/NoteShapeUtil.mjs
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
var import_react100 = __toESM(require_react(), 1);
var import_lodash7 = __toESM(require_lodash3(), 1);
var NoteShapeUtil = class extends ShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      resizeMode: "none"
    });
  }
  canEdit() {
    return true;
  }
  hideResizeHandles() {
    const { resizeMode } = this.options;
    switch (resizeMode) {
      case "none": {
        return true;
      }
      case "scale": {
        return false;
      }
      default: {
        throw exhaustiveSwitchError(resizeMode);
      }
    }
  }
  isAspectRatioLocked() {
    return this.options.resizeMode === "scale";
  }
  hideSelectionBoundsFg() {
    return false;
  }
  getDefaultProps() {
    return {
      color: "black",
      richText: toRichText(""),
      size: "m",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      labelColor: "black",
      growY: 0,
      fontSizeAdjustment: 0,
      url: "",
      scale: 1
    };
  }
  getGeometry(shape) {
    const { labelHeight, labelWidth } = getLabelSize(this.editor, shape);
    const { scale } = shape.props;
    const lh = labelHeight * scale;
    const lw = labelWidth * scale;
    const nw = NOTE_SIZE * scale;
    const nh = getNoteHeight(shape);
    return new Group2d({
      children: [
        new Rectangle2d({ width: nw, height: nh, isFilled: true }),
        new Rectangle2d({
          x: shape.props.align === "start" ? 0 : shape.props.align === "end" ? nw - lw : (nw - lw) / 2,
          y: shape.props.verticalAlign === "start" ? 0 : shape.props.verticalAlign === "end" ? nh - lh : (nh - lh) / 2,
          width: lw,
          height: lh,
          isFilled: true,
          isLabel: true
        })
      ]
    });
  }
  getHandles(shape) {
    const { scale } = shape.props;
    const isCoarsePointer = this.editor.getInstanceState().isCoarsePointer;
    if (isCoarsePointer)
      return [];
    const zoom = this.editor.getZoomLevel();
    if (zoom * scale < 0.25)
      return [];
    const nh = getNoteHeight(shape);
    const nw = NOTE_SIZE * scale;
    const offset5 = CLONE_HANDLE_MARGIN / zoom * scale;
    if (zoom * scale < 0.5) {
      return [
        {
          id: "bottom",
          index: "a3",
          type: "clone",
          x: nw / 2,
          y: nh + offset5
        }
      ];
    }
    return [
      {
        id: "top",
        index: "a1",
        type: "clone",
        x: nw / 2,
        y: -offset5
      },
      {
        id: "right",
        index: "a2",
        type: "clone",
        x: nw + offset5,
        y: nh / 2
      },
      {
        id: "bottom",
        index: "a3",
        type: "clone",
        x: nw / 2,
        y: nh + offset5
      },
      {
        id: "left",
        index: "a4",
        type: "clone",
        x: -offset5,
        y: nh / 2
      }
    ];
  }
  onResize(shape, info) {
    const { resizeMode } = this.options;
    switch (resizeMode) {
      case "none": {
        return void 0;
      }
      case "scale": {
        return resizeScaled(shape, info);
      }
      default: {
        throw exhaustiveSwitchError(resizeMode);
      }
    }
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  getFontFaces(shape) {
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  component(shape) {
    const {
      id,
      type,
      props: {
        labelColor,
        scale,
        color,
        font,
        size: size4,
        align,
        richText,
        verticalAlign,
        fontSizeAdjustment
      }
    } = shape;
    const handleKeyDown2 = useNoteKeydownHandler(id);
    const theme = useDefaultColorTheme();
    const nw = NOTE_SIZE * scale;
    const nh = getNoteHeight(shape);
    const rotation = useValue(
      "shape rotation",
      () => {
        var _a5;
        return ((_a5 = this.editor.getShapePageTransform(id)) == null ? void 0 : _a5.rotation()) ?? 0;
      },
      [this.editor]
    );
    const hideShadows = useValue("zoom", () => this.editor.getZoomLevel() < 0.35 / scale, [
      scale,
      this.editor
    ]);
    const isDarkMode = useValue("dark mode", () => this.editor.user.getIsDarkMode(), [this.editor]);
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const isReadyForEditing = useIsReadyForEditing(this.editor, shape.id);
    const isEmpty = isEmptyRichText(richText);
    return (0, import_jsx_runtime147.jsxs)(import_jsx_runtime147.Fragment, { children: [
      (0, import_jsx_runtime147.jsx)(
        "div",
        {
          id,
          className: "tl-note__container",
          style: {
            width: nw,
            height: nh,
            backgroundColor: theme[color].note.fill,
            borderBottom: hideShadows ? isDarkMode ? `${2 * scale}px solid rgb(20, 20, 20)` : `${2 * scale}px solid rgb(144, 144, 144)` : "none",
            boxShadow: hideShadows ? "none" : getNoteShadow(shape.id, rotation, scale)
          },
          children: (isSelected || isReadyForEditing || !isEmpty) && (0, import_jsx_runtime147.jsx)(
            RichTextLabel,
            {
              shapeId: id,
              type,
              font,
              fontSize: (fontSizeAdjustment || LABEL_FONT_SIZES[size4]) * scale,
              lineHeight: TEXT_PROPS.lineHeight,
              align,
              verticalAlign,
              richText,
              isSelected,
              labelColor: labelColor === "black" ? theme[color].note.text : theme[labelColor].fill,
              wrap: true,
              padding: LABEL_PADDING * scale,
              hasCustomTabBehavior: true,
              onKeyDown: handleKeyDown2
            }
          )
        }
      ),
      "url" in shape.props && shape.props.url && (0, import_jsx_runtime147.jsx)(HyperlinkButton, { url: shape.props.url })
    ] });
  }
  indicator(shape) {
    const { scale } = shape.props;
    return (0, import_jsx_runtime147.jsx)(
      "rect",
      {
        rx: scale,
        width: toDomPrecision(NOTE_SIZE * scale),
        height: toDomPrecision(getNoteHeight(shape))
      }
    );
  }
  toSvg(shape, ctx) {
    const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode });
    const bounds = getBoundsForSVG(shape);
    const textLabel = (0, import_jsx_runtime147.jsx)(
      RichTextSVG,
      {
        fontSize: shape.props.fontSizeAdjustment || LABEL_FONT_SIZES[shape.props.size],
        font: shape.props.font,
        align: shape.props.align,
        verticalAlign: shape.props.verticalAlign,
        richText: shape.props.richText,
        labelColor: theme[shape.props.color].note.text,
        bounds,
        padding: LABEL_PADDING * shape.props.scale
      }
    );
    return (0, import_jsx_runtime147.jsxs)(import_jsx_runtime147.Fragment, { children: [
      (0, import_jsx_runtime147.jsx)("rect", { x: 5, y: 5, rx: 1, width: NOTE_SIZE - 10, height: bounds.h, fill: "rgba(0,0,0,.1)" }),
      (0, import_jsx_runtime147.jsx)(
        "rect",
        {
          rx: 1,
          width: NOTE_SIZE,
          height: bounds.h,
          fill: theme[shape.props.color].note.fill
        }
      ),
      textLabel
    ] });
  }
  onBeforeCreate(next) {
    return getNoteSizeAdjustments(this.editor, next);
  }
  onBeforeUpdate(prev, next) {
    if ((0, import_lodash7.default)(prev.props.richText, next.props.richText) && prev.props.font === next.props.font && prev.props.size === next.props.size) {
      return;
    }
    return getNoteSizeAdjustments(this.editor, next);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
};
__publicField(NoteShapeUtil, "type", "note");
__publicField(NoteShapeUtil, "props", noteShapeProps);
__publicField(NoteShapeUtil, "migrations", noteShapeMigrations);
function getNoteSizeAdjustments(editor, shape) {
  const { labelHeight, fontSizeAdjustment } = getLabelSize(editor, shape);
  const growY = Math.max(0, labelHeight - NOTE_SIZE);
  if (growY !== shape.props.growY || fontSizeAdjustment !== shape.props.fontSizeAdjustment) {
    return {
      ...shape,
      props: {
        ...shape.props,
        growY,
        fontSizeAdjustment
      }
    };
  }
}
function getNoteLabelSize(editor, shape) {
  const { richText } = shape.props;
  if (isEmptyRichText(richText)) {
    const minHeight = LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2;
    return { labelHeight: minHeight, labelWidth: 100, fontSizeAdjustment: 0 };
  }
  const unadjustedFontSize = LABEL_FONT_SIZES[shape.props.size];
  let fontSizeAdjustment = 0;
  let iterations = 0;
  let labelHeight = NOTE_SIZE;
  let labelWidth = NOTE_SIZE;
  const FUZZ = 1;
  do {
    fontSizeAdjustment = Math.min(unadjustedFontSize, unadjustedFontSize - iterations);
    const html = renderHtmlFromRichTextForMeasurement(editor, richText);
    const nextTextSize = editor.textMeasure.measureHtml(html, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[shape.props.font],
      fontSize: fontSizeAdjustment,
      maxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ,
      disableOverflowWrapBreaking: true
    });
    labelHeight = nextTextSize.h + LABEL_PADDING * 2;
    labelWidth = nextTextSize.w + LABEL_PADDING * 2;
    if (fontSizeAdjustment <= 14) {
      const html2 = renderHtmlFromRichTextForMeasurement(editor, richText);
      const nextTextSizeWithOverflowBreak = editor.textMeasure.measureHtml(html2, {
        ...TEXT_PROPS,
        fontFamily: FONT_FAMILIES[shape.props.font],
        fontSize: fontSizeAdjustment,
        maxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ
      });
      labelHeight = nextTextSizeWithOverflowBreak.h + LABEL_PADDING * 2;
      labelWidth = nextTextSizeWithOverflowBreak.w + LABEL_PADDING * 2;
      break;
    }
    if (nextTextSize.scrollWidth.toFixed(0) === nextTextSize.w.toFixed(0)) {
      break;
    }
  } while (iterations++ < 50);
  return {
    labelHeight,
    labelWidth,
    fontSizeAdjustment
  };
}
var labelSizesForNote = new WeakCache();
function getLabelSize(editor, shape) {
  return labelSizesForNote.get(shape, () => getNoteLabelSize(editor, shape));
}
function useNoteKeydownHandler(id) {
  const editor = useEditor();
  const translation = useCurrentTranslation();
  return (0, import_react100.useCallback)(
    (e) => {
      const shape = editor.getShape(id);
      if (!shape)
        return;
      const isTab = e.key === "Tab";
      const isCmdEnter = (e.metaKey || e.ctrlKey) && e.key === "Enter";
      if (isTab || isCmdEnter) {
        e.preventDefault();
        const pageTransform = editor.getShapePageTransform(id);
        const pageRotation = pageTransform.rotation();
        const isRTL2 = !!(translation.dir === "rtl" || // todo: can we check a partial of the text, so that we don't have to render the whole thing?
        isRightToLeftLanguage(renderPlaintextFromRichText(editor, shape.props.richText)));
        const offsetLength = (NOTE_SIZE + editor.options.adjacentShapeMargin + // If we're growing down, we need to account for the current shape's growY
        (isCmdEnter && !e.shiftKey ? shape.props.growY : 0)) * shape.props.scale;
        const adjacentCenter = new Vec(
          isTab ? e.shiftKey != isRTL2 ? -1 : 1 : 0,
          isCmdEnter ? e.shiftKey ? -1 : 1 : 0
        ).mul(offsetLength).add(NOTE_CENTER_OFFSET.clone().mul(shape.props.scale)).rot(pageRotation).add(pageTransform.point());
        const newNote = getNoteShapeForAdjacentPosition(editor, shape, adjacentCenter, pageRotation);
        if (newNote) {
          editor.markHistoryStoppingPoint("editing adjacent shape");
          startEditingShapeWithLabel(
            editor,
            newNote,
            true
            /* selectAll */
          );
        }
      }
    },
    [id, editor, translation.dir]
  );
}
function getNoteHeight(shape) {
  return (NOTE_SIZE + shape.props.growY) * shape.props.scale;
}
function getNoteShadow(id, rotation, scale) {
  const random = rng(id);
  const lift4 = Math.abs(random()) + 0.5;
  const oy = Math.cos(rotation);
  const a = 5 * scale;
  const b = 4 * scale;
  const c = 6 * scale;
  const d = 7 * scale;
  return `0px ${a - lift4}px ${a}px -${a}px rgba(15, 23, 31, .6),
	0px ${(b + lift4 * d) * Math.max(0, oy)}px ${c + lift4 * d}px -${b + lift4 * c}px rgba(15, 23, 31, ${(0.3 + lift4 * 0.1).toFixed(2)}), 
	0px ${48 * scale}px ${10 * scale}px -${10 * scale}px inset rgba(15, 23, 44, ${((0.022 + random() * 5e-3) * ((1 + oy) / 2)).toFixed(2)})`;
}
function getBoundsForSVG(shape) {
  return new Box(0, 0, NOTE_SIZE, NOTE_SIZE + shape.props.growY);
}

// node_modules/tldraw/dist-esm/lib/shapes/text/TextShapeUtil.mjs
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var import_lodash8 = __toESM(require_lodash3(), 1);
var import_react101 = __toESM(require_react(), 1);
var sizeCache = createComputedCache(
  "text size",
  (editor, shape) => {
    editor.fonts.trackFontsForShape(shape);
    return getTextSize(editor, shape.props);
  },
  { areRecordsEqual: (a, b) => a.props === b.props }
);
var TextShapeUtil = class extends ShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      extraArrowHorizontalPadding: 10
    });
  }
  getDefaultProps() {
    return {
      color: "black",
      size: "m",
      w: 8,
      font: "draw",
      textAlign: "start",
      autoSize: true,
      scale: 1,
      richText: toRichText("")
    };
  }
  getMinDimensions(shape) {
    return sizeCache.get(this.editor, shape.id);
  }
  getGeometry(shape, opts) {
    const { scale } = shape.props;
    const { width, height } = this.getMinDimensions(shape);
    const context = (opts == null ? void 0 : opts.context) ?? "none";
    return new Rectangle2d({
      x: (context === "@tldraw/arrow-without-arrowhead" ? -this.options.extraArrowHorizontalPadding : 0) * scale,
      width: (width + (context === "@tldraw/arrow-without-arrowhead" ? this.options.extraArrowHorizontalPadding * 2 : 0)) * scale,
      height: height * scale,
      isFilled: true,
      isLabel: true
    });
  }
  getFontFaces(shape) {
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  canEdit() {
    return true;
  }
  isAspectRatioLocked() {
    return true;
  }
  // WAIT NO THIS IS HARD CODED IN THE RESIZE HANDLER
  component(shape) {
    const {
      id,
      props: { font, size: size4, richText, color, scale, textAlign }
    } = shape;
    const { width, height } = this.getMinDimensions(shape);
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const theme = useDefaultColorTheme();
    const handleKeyDown2 = useTextShapeKeydownHandler(id);
    return (0, import_jsx_runtime148.jsx)(
      RichTextLabel,
      {
        shapeId: id,
        classNamePrefix: "tl-text-shape",
        type: "text",
        font,
        fontSize: FONT_SIZES[size4],
        lineHeight: TEXT_PROPS.lineHeight,
        align: textAlign,
        verticalAlign: "middle",
        richText,
        labelColor: theme[color].solid,
        isSelected,
        textWidth: width,
        textHeight: height,
        style: {
          transform: `scale(${scale})`,
          transformOrigin: "top left"
        },
        wrap: true,
        onKeyDown: handleKeyDown2
      }
    );
  }
  indicator(shape) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    const editor = useEditor();
    if (shape.props.autoSize && editor.getEditingShapeId() === shape.id)
      return null;
    return (0, import_jsx_runtime148.jsx)("rect", { width: toDomPrecision(bounds.width), height: toDomPrecision(bounds.height) });
  }
  toSvg(shape, ctx) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    const width = bounds.width / (shape.props.scale ?? 1);
    const height = bounds.height / (shape.props.scale ?? 1);
    const theme = getDefaultColorTheme(ctx);
    const exportBounds = new Box(0, 0, width, height);
    return (0, import_jsx_runtime148.jsx)(
      RichTextSVG,
      {
        fontSize: FONT_SIZES[shape.props.size],
        font: shape.props.font,
        align: shape.props.textAlign,
        verticalAlign: "middle",
        richText: shape.props.richText,
        labelColor: theme[shape.props.color].solid,
        bounds: exportBounds,
        padding: 0
      }
    );
  }
  onResize(shape, info) {
    const { newPoint, initialBounds, initialShape, scaleX, handle } = info;
    if (info.mode === "scale_shape" || handle !== "right" && handle !== "left") {
      return {
        id: shape.id,
        type: shape.type,
        ...resizeScaled(shape, info)
      };
    } else {
      const nextWidth = Math.max(1, Math.abs(initialBounds.width * scaleX));
      const { x, y } = scaleX < 0 ? Vec.Sub(newPoint, Vec.FromAngle(shape.rotation).mul(nextWidth)) : newPoint;
      return {
        id: shape.id,
        type: shape.type,
        x,
        y,
        props: {
          w: nextWidth / initialShape.props.scale,
          autoSize: false
        }
      };
    }
  }
  onEditEnd(shape) {
    const trimmedText = renderPlaintextFromRichText(this.editor, shape.props.richText).trimEnd();
    if (trimmedText.length === 0) {
      this.editor.deleteShapes([shape.id]);
    }
  }
  onBeforeUpdate(prev, next) {
    if (!next.props.autoSize)
      return;
    const styleDidChange = prev.props.size !== next.props.size || prev.props.textAlign !== next.props.textAlign || prev.props.font !== next.props.font || prev.props.scale !== 1 && next.props.scale === 1;
    const textDidChange = !(0, import_lodash8.default)(prev.props.richText, next.props.richText);
    if (!styleDidChange && !textDidChange)
      return;
    const boundsA = this.getMinDimensions(prev);
    const boundsB = getTextSize(this.editor, next.props);
    const wA = boundsA.width * prev.props.scale;
    const hA = boundsA.height * prev.props.scale;
    const wB = boundsB.width * next.props.scale;
    const hB = boundsB.height * next.props.scale;
    let delta;
    switch (next.props.textAlign) {
      case "middle": {
        delta = new Vec((wB - wA) / 2, textDidChange ? 0 : (hB - hA) / 2);
        break;
      }
      case "end": {
        delta = new Vec(wB - wA, textDidChange ? 0 : (hB - hA) / 2);
        break;
      }
      default: {
        if (textDidChange)
          break;
        delta = new Vec(0, (hB - hA) / 2);
        break;
      }
    }
    if (delta) {
      delta.rot(next.rotation);
      const { x, y } = next;
      return {
        ...next,
        x: x - delta.x,
        y: y - delta.y,
        props: { ...next.props, w: wB }
      };
    } else {
      return {
        ...next,
        props: { ...next.props, w: wB }
      };
    }
  }
  // 	todo: The edge doubleclicking feels like a mistake more often than
  //  not, especially on multiline text. Removed June 16 2024
  // override onDoubleClickEdge = (shape: TLTextShape) => {
  // 	// If the shape has a fixed width, set it to autoSize.
  // 	if (!shape.props.autoSize) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				autoSize: true,
  // 			},
  // 		}
  // 	}
  // 	// If the shape is scaled, reset the scale to 1.
  // 	if (shape.props.scale !== 1) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				scale: 1,
  // 			},
  // 		}
  // 	}
  // }
};
__publicField(TextShapeUtil, "type", "text");
__publicField(TextShapeUtil, "props", textShapeProps);
__publicField(TextShapeUtil, "migrations", textShapeMigrations);
function getTextSize(editor, props) {
  const { font, richText, autoSize, size: size4, w } = props;
  const minWidth = autoSize ? 16 : Math.max(16, w);
  const fontSize = FONT_SIZES[size4];
  const cw = autoSize ? null : (
    // `measureText` floors the number so we need to do the same here to avoid issues.
    Math.floor(Math.max(minWidth, w))
  );
  const html = renderHtmlFromRichTextForMeasurement(editor, richText);
  const result = editor.textMeasure.measureHtml(html, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[font],
    fontSize,
    maxWidth: cw
  });
  if (autoSize) {
    result.w += 1;
  }
  return {
    width: Math.max(minWidth, result.w),
    height: Math.max(fontSize, result.h)
  };
}
function useTextShapeKeydownHandler(id) {
  const editor = useEditor();
  return (0, import_react101.useCallback)(
    (e) => {
      if (editor.getEditingShapeId() !== id)
        return;
      switch (e.key) {
        case "Enter": {
          if (e.ctrlKey || e.metaKey) {
            editor.complete();
          }
          break;
        }
      }
    },
    [editor, id]
  );
}

// node_modules/tldraw/dist-esm/lib/shapes/video/VideoShapeUtil.mjs
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);
var import_classnames27 = __toESM(require_classnames(), 1);
var import_react102 = __toESM(require_react(), 1);
var videoSvgExportCache = new WeakCache();
var VideoShapeUtil = class extends BaseBoxShapeUtil {
  canEdit() {
    return true;
  }
  isAspectRatioLocked() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      time: 0,
      playing: true,
      url: "",
      altText: ""
    };
  }
  getAriaDescriptor(shape) {
    return shape.props.altText;
  }
  component(shape) {
    return (0, import_jsx_runtime149.jsx)(VideoShape, { shape });
  }
  indicator(shape) {
    return (0, import_jsx_runtime149.jsx)("rect", { width: toDomPrecision(shape.props.w), height: toDomPrecision(shape.props.h) });
  }
  async toSvg(shape, ctx) {
    if (!shape.props.assetId)
      return null;
    const asset = this.editor.getAsset(shape.props.assetId);
    if (!asset)
      return null;
    const src = await videoSvgExportCache.get(asset, async () => {
      const assetUrl = await ctx.resolveAssetUrl(asset.id, shape.props.w);
      if (!assetUrl)
        return null;
      const video = await MediaHelpers.loadVideo(assetUrl);
      return await MediaHelpers.getVideoFrameAsDataUrl(video, 0);
    });
    if (!src)
      return null;
    return (0, import_jsx_runtime149.jsx)("image", { href: src, width: shape.props.w, height: shape.props.h });
  }
};
__publicField(VideoShapeUtil, "type", "video");
__publicField(VideoShapeUtil, "props", videoShapeProps);
__publicField(VideoShapeUtil, "migrations", videoShapeMigrations);
var VideoShape = (0, import_react102.memo)(function VideoShape2({ shape }) {
  const editor = useEditor();
  const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110;
  const isEditing = useIsEditing(shape.id);
  const prefersReducedMotion = usePrefersReducedMotion();
  const { Spinner: Spinner2 } = useEditorComponents();
  const { asset, url } = useImageOrVideoAsset({
    shapeId: shape.id,
    assetId: shape.props.assetId,
    width: shape.props.w
  });
  const rVideo = (0, import_react102.useRef)(null);
  const [isLoaded, setIsLoaded] = (0, import_react102.useState)(false);
  const [isFullscreen, setIsFullscreen] = (0, import_react102.useState)(false);
  (0, import_react102.useEffect)(() => {
    const fullscreenChange = () => setIsFullscreen(document.fullscreenElement === rVideo.current);
    document.addEventListener("fullscreenchange", fullscreenChange);
    return () => document.removeEventListener("fullscreenchange", fullscreenChange);
  });
  const handleLoadedData = (0, import_react102.useCallback)((e) => {
    const video = e.currentTarget;
    if (!video)
      return;
    setIsLoaded(true);
  }, []);
  (0, import_react102.useEffect)(() => {
    const video = rVideo.current;
    if (!video)
      return;
    if (isEditing) {
      if (document.activeElement !== video) {
        video.focus();
      }
    }
  }, [isEditing, isLoaded]);
  (0, import_react102.useEffect)(() => {
    if (prefersReducedMotion) {
      const video = rVideo.current;
      if (!video)
        return;
      video.pause();
      video.currentTime = 0;
    }
  }, [rVideo, prefersReducedMotion]);
  return (0, import_jsx_runtime149.jsxs)(import_jsx_runtime149.Fragment, { children: [
    (0, import_jsx_runtime149.jsx)(
      HTMLContainer,
      {
        id: shape.id,
        style: {
          color: "var(--color-text-3)",
          backgroundColor: asset ? "transparent" : "var(--color-low)",
          border: asset ? "none" : "1px solid var(--color-low-border)"
        },
        children: (0, import_jsx_runtime149.jsx)("div", { className: "tl-counter-scaled", children: (0, import_jsx_runtime149.jsx)("div", { className: "tl-video-container", children: !asset ? (0, import_jsx_runtime149.jsx)(BrokenAssetIcon, {}) : Spinner2 && !asset.props.src ? (0, import_jsx_runtime149.jsx)(Spinner2, {}) : url ? (0, import_jsx_runtime149.jsxs)(import_jsx_runtime149.Fragment, { children: [
          (0, import_jsx_runtime149.jsx)(
            "video",
            {
              ref: rVideo,
              style: isEditing ? { pointerEvents: "all" } : !isLoaded ? { display: "none" } : void 0,
              className: (0, import_classnames27.default)("tl-video", `tl-video-shape-${shape.id.split(":")[1]}`, {
                "tl-video-is-fullscreen": isFullscreen
              }),
              width: "100%",
              height: "100%",
              draggable: false,
              playsInline: true,
              autoPlay: true,
              muted: true,
              loop: true,
              disableRemotePlayback: true,
              disablePictureInPicture: true,
              controls: isEditing && showControls,
              onLoadedData: handleLoadedData,
              hidden: !isLoaded,
              children: (0, import_jsx_runtime149.jsx)("source", { src: url })
            }
          ),
          !isLoaded && Spinner2 && (0, import_jsx_runtime149.jsx)(Spinner2, {})
        ] }) : null }) })
      }
    ),
    "url" in shape.props && shape.props.url && (0, import_jsx_runtime149.jsx)(HyperlinkButton, { url: shape.props.url })
  ] });
});

// node_modules/tldraw/dist-esm/lib/defaultShapeUtils.mjs
var defaultShapeUtils = [
  TextShapeUtil,
  BookmarkShapeUtil,
  DrawShapeUtil,
  GeoShapeUtil,
  NoteShapeUtil,
  LineShapeUtil,
  FrameShapeUtil,
  ArrowShapeUtil,
  HighlightShapeUtil,
  EmbedShapeUtil,
  ImageShapeUtil,
  VideoShapeUtil
];

// node_modules/tldraw/dist-esm/lib/defaultSideEffects.mjs
function registerDefaultSideEffects(editor) {
  return editor.sideEffects.register({
    instance_page_state: {
      afterChange: (prev, next) => {
        if (prev.croppingShapeId !== next.croppingShapeId) {
          const isInCroppingState = editor.isIn("select.crop");
          if (!prev.croppingShapeId && next.croppingShapeId) {
            if (!isInCroppingState) {
              editor.setCurrentTool("select.crop.idle");
            }
          } else if (prev.croppingShapeId && !next.croppingShapeId) {
            if (isInCroppingState) {
              editor.setCurrentTool("select.idle");
            }
          }
        }
        if (prev.editingShapeId !== next.editingShapeId) {
          if (!prev.editingShapeId && next.editingShapeId) {
            if (!editor.isIn("select.editing_shape")) {
              const shape = editor.getEditingShape();
              if (shape && shape.type === "text" && editor.isInAny("text.pointing", "select.resizing") && editor.getInstanceState().isToolLocked) {
                editor.setCurrentTool("select.editing_shape", {
                  isCreatingTextWhileToolLocked: true
                });
              } else {
                editor.setCurrentTool("select.editing_shape");
              }
            }
          } else if (prev.editingShapeId && !next.editingShapeId) {
            if (editor.isIn("select.editing_shape")) {
              editor.setCurrentTool("select.idle");
            }
          }
        }
      }
    }
  });
}

// node_modules/tldraw/dist-esm/lib/tools/EraserTool/childStates/Erasing.mjs
var Erasing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "scribbleId", "id");
    __publicField(this, "markId", "");
    __publicField(this, "excludedShapeIds", /* @__PURE__ */ new Set());
  }
  onEnter(info) {
    this.markId = this.editor.markHistoryStoppingPoint("erase scribble begin");
    this.info = info;
    const { originPagePoint } = this.editor.inputs;
    this.excludedShapeIds = new Set(
      this.editor.getCurrentPageShapes().filter((shape) => {
        if (this.editor.isShapeOrAncestorLocked(shape))
          return true;
        if (this.editor.isShapeOfType(shape, "group") || this.editor.isShapeOfType(shape, "frame")) {
          const pointInShapeShape = this.editor.getPointInShapeSpace(shape, originPagePoint);
          const geometry = this.editor.getShapeGeometry(shape);
          return geometry.bounds.containsPoint(pointInShapeShape);
        }
        return false;
      }).map((shape) => shape.id)
    );
    const scribble = this.editor.scribbles.addScribble({
      color: "muted-1",
      size: 12
    });
    this.scribbleId = scribble.id;
    this.update();
  }
  pushPointToScribble() {
    const { x, y } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, x, y);
  }
  onExit() {
    this.editor.setErasingShapes([]);
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  update() {
    const { editor, excludedShapeIds } = this;
    const erasingShapeIds = editor.getErasingShapeIds();
    const zoomLevel = editor.getZoomLevel();
    const currentPageShapes = editor.getCurrentPageRenderingShapesSorted();
    const {
      inputs: { currentPagePoint, previousPagePoint }
    } = editor;
    this.pushPointToScribble();
    const erasing = new Set(erasingShapeIds);
    const minDist = this.editor.options.hitTestMargin / zoomLevel;
    for (const shape of currentPageShapes) {
      if (editor.isShapeOfType(shape, "group"))
        continue;
      const pageMask = editor.getShapeMask(shape.id);
      if (pageMask && !pointInPolygon(currentPagePoint, pageMask)) {
        continue;
      }
      const geometry = editor.getShapeGeometry(shape);
      const pageTransform = editor.getShapePageTransform(shape);
      if (!geometry || !pageTransform)
        continue;
      const pt = pageTransform.clone().invert();
      const A = pt.applyToPoint(previousPagePoint);
      const B = pt.applyToPoint(currentPagePoint);
      const { bounds } = geometry;
      if (bounds.minX - minDist > Math.max(A.x, B.x) || bounds.minY - minDist > Math.max(A.y, B.y) || bounds.maxX + minDist < Math.min(A.x, B.x) || bounds.maxY + minDist < Math.min(A.y, B.y)) {
        continue;
      }
      if (geometry.hitTestLineSegment(A, B, minDist)) {
        erasing.add(editor.getOutermostSelectableShape(shape).id);
      }
    }
    this.editor.setErasingShapes([...erasing].filter((id) => !excludedShapeIds.has(id)));
  }
  complete() {
    const { editor } = this;
    editor.deleteShapes(editor.getCurrentPageState().erasingShapeIds);
    this.parent.transition("idle");
  }
  cancel() {
    const { editor } = this;
    editor.bailToMark(this.markId);
    this.parent.transition("idle", this.info);
  }
};
__publicField(Erasing, "id", "erasing");

// node_modules/tldraw/dist-esm/lib/tools/EraserTool/childStates/Idle.mjs
var Idle8 = class extends StateNode {
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle8, "id", "idle");

// node_modules/tldraw/dist-esm/lib/tools/EraserTool/childStates/Pointing.mjs
var Pointing7 = class extends StateNode {
  onEnter() {
    const zoomLevel = this.editor.getZoomLevel();
    const currentPageShapesSorted = this.editor.getCurrentPageRenderingShapesSorted();
    const {
      inputs: { currentPagePoint }
    } = this.editor;
    const erasing = /* @__PURE__ */ new Set();
    const initialSize = erasing.size;
    for (let n = currentPageShapesSorted.length, i = n - 1; i >= 0; i--) {
      const shape = currentPageShapesSorted[i];
      if (this.editor.isShapeOrAncestorLocked(shape) || this.editor.isShapeOfType(shape, "group")) {
        continue;
      }
      if (this.editor.isPointInShape(shape, currentPagePoint, {
        hitInside: false,
        margin: this.editor.options.hitTestMargin / zoomLevel
      })) {
        const hitShape = this.editor.getOutermostSelectableShape(shape);
        if (this.editor.isShapeOfType(hitShape, "frame") && erasing.size > initialSize) {
          break;
        }
        erasing.add(hitShape.id);
      }
    }
    this.editor.setErasingShapes([...erasing]);
  }
  onLongPress(info) {
    this.startErasing(info);
  }
  onExit(_info, to) {
    if (to !== "erasing") {
      this.editor.setErasingShapes([]);
    }
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      this.startErasing(info);
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  startErasing(info) {
    this.parent.transition("erasing", info);
  }
  complete() {
    const erasingShapeIds = this.editor.getErasingShapeIds();
    if (erasingShapeIds.length) {
      this.editor.markHistoryStoppingPoint("erase end");
      this.editor.deleteShapes(erasingShapeIds);
    }
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(Pointing7, "id", "pointing");

// node_modules/tldraw/dist-esm/lib/tools/EraserTool/EraserTool.mjs
var EraserTool = class extends StateNode {
  static children() {
    return [Idle8, Pointing7, Erasing];
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
};
__publicField(EraserTool, "id", "eraser");
__publicField(EraserTool, "initial", "idle");
__publicField(EraserTool, "isLockable", false);

// node_modules/tldraw/dist-esm/lib/tools/HandTool/childStates/Dragging.mjs
var Dragging2 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "initialCamera", new Vec());
  }
  onEnter() {
    this.initialCamera = Vec.From(this.editor.getCamera());
    this.update();
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.parent.transition("idle");
  }
  onComplete() {
    this.complete();
  }
  update() {
    const { initialCamera, editor } = this;
    const { currentScreenPoint, originScreenPoint } = editor.inputs;
    const delta = Vec.Sub(currentScreenPoint, originScreenPoint).div(editor.getZoomLevel());
    if (delta.len2() === 0)
      return;
    editor.setCamera(initialCamera.clone().add(delta));
  }
  complete() {
    const { editor } = this;
    const { pointerVelocity } = editor.inputs;
    const velocityAtPointerUp = Math.min(pointerVelocity.len(), 2);
    if (velocityAtPointerUp > 0.1) {
      this.editor.slideCamera({ speed: velocityAtPointerUp, direction: pointerVelocity });
    }
    this.parent.transition("idle");
  }
};
__publicField(Dragging2, "id", "dragging");

// node_modules/tldraw/dist-esm/lib/tools/HandTool/childStates/Idle.mjs
var Idle9 = class extends StateNode {
  onEnter() {
    this.editor.setCursor({ type: "grab", rotation: 0 });
  }
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle9, "id", "idle");

// node_modules/tldraw/dist-esm/lib/tools/HandTool/childStates/Pointing.mjs
var Pointing8 = class extends StateNode {
  onEnter() {
    this.editor.stopCameraAnimation();
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onLongPress() {
    this.startDragging();
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      this.startDragging();
    }
  }
  startDragging() {
    this.parent.transition("dragging");
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.complete();
  }
  complete() {
    this.parent.transition("idle");
  }
};
__publicField(Pointing8, "id", "pointing");

// node_modules/tldraw/dist-esm/lib/tools/HandTool/HandTool.mjs
var HandTool = class extends StateNode {
  static children() {
    return [Idle9, Pointing8, Dragging2];
  }
  onDoubleClick(info) {
    if (info.phase === "settle") {
      const { currentScreenPoint } = this.editor.inputs;
      this.editor.zoomIn(currentScreenPoint, {
        animation: { duration: 220, easing: EASINGS.easeOutQuint }
      });
    }
  }
  onTripleClick(info) {
    if (info.phase === "settle") {
      const { currentScreenPoint } = this.editor.inputs;
      this.editor.zoomOut(currentScreenPoint, {
        animation: { duration: 320, easing: EASINGS.easeOutQuint }
      });
    }
  }
  onQuadrupleClick(info) {
    if (info.phase === "settle") {
      const zoomLevel = this.editor.getZoomLevel();
      const {
        inputs: { currentScreenPoint }
      } = this.editor;
      if (zoomLevel === 1) {
        this.editor.zoomToFit({ animation: { duration: 400, easing: EASINGS.easeOutQuint } });
      } else {
        this.editor.resetZoom(currentScreenPoint, {
          animation: { duration: 320, easing: EASINGS.easeOutQuint }
        });
      }
    }
  }
};
__publicField(HandTool, "id", "hand");
__publicField(HandTool, "initial", "idle");
__publicField(HandTool, "isLockable", false);

// node_modules/tldraw/dist-esm/lib/tools/LaserTool/childStates/Idle.mjs
var Idle10 = class extends StateNode {
  onCancel() {
    this.editor.setCurrentTool("select");
  }
  onPointerDown(info) {
    this.parent.transition("lasering", info);
  }
};
__publicField(Idle10, "id", "idle");

// node_modules/tldraw/dist-esm/lib/tools/LaserTool/childStates/Lasering.mjs
var Lasering = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "scribbleId", "id");
  }
  onEnter() {
    const scribble = this.editor.scribbles.addScribble({
      color: "laser",
      opacity: 0.7,
      size: 4,
      delay: this.editor.options.laserDelayMs,
      shrink: 0.05,
      taper: true
    });
    this.scribbleId = scribble.id;
    this.pushPointToScribble();
  }
  onExit() {
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.pushPointToScribble();
  }
  onPointerUp() {
    this.complete();
  }
  pushPointToScribble() {
    const { x, y } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, x, y);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  complete() {
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(Lasering, "id", "lasering");

// node_modules/tldraw/dist-esm/lib/tools/LaserTool/LaserTool.mjs
var LaserTool = class extends StateNode {
  static children() {
    return [Idle10, Lasering];
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
};
__publicField(LaserTool, "id", "laser");
__publicField(LaserTool, "initial", "idle");
__publicField(LaserTool, "isLockable", false);

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Brushing.mjs
var Brushing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "initialSelectedShapeIds", []);
    __publicField(this, "excludedShapeIds", /* @__PURE__ */ new Set());
    __publicField(this, "isWrapMode", false);
    __publicField(this, "viewportDidChange", false);
    // cleanup function for the viewport reactor
    // The shape that the brush started on
    __publicField(this, "initialStartShape", null);
  }
  cleanupViewportChangeReactor() {
  }
  onEnter(info) {
    const { editor } = this;
    const { altKey: altKey2, currentPagePoint } = editor.inputs;
    this.isWrapMode = editor.user.getIsWrapMode();
    this.viewportDidChange = false;
    let isInitialCheck = true;
    this.cleanupViewportChangeReactor = react("viewport change while brushing", () => {
      editor.getViewportPageBounds();
      if (!isInitialCheck && !this.viewportDidChange) {
        this.viewportDidChange = true;
      }
    });
    if (altKey2) {
      this.parent.transition("scribble_brushing", info);
      return;
    }
    this.excludedShapeIds = new Set(
      editor.getCurrentPageShapes().filter(
        (shape) => editor.isShapeOfType(shape, "group") || editor.isShapeOrAncestorLocked(shape)
      ).map((shape) => shape.id)
    );
    this.info = info;
    this.initialSelectedShapeIds = editor.getSelectedShapeIds().slice();
    this.initialStartShape = editor.getShapesAtPoint(currentPagePoint)[0];
    this.hitTestShapes();
    isInitialCheck = false;
  }
  onExit() {
    this.initialSelectedShapeIds = [];
    this.editor.updateInstanceState({ brush: null });
    this.cleanupViewportChangeReactor();
  }
  onTick({ elapsed }) {
    const { editor } = this;
    editor.edgeScrollManager.updateEdgeScrolling(elapsed);
  }
  onPointerMove() {
    this.hitTestShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel(info) {
    this.editor.setSelectedShapes(this.initialSelectedShapeIds);
    this.parent.transition("idle", info);
  }
  onKeyDown(info) {
    if (this.editor.inputs.altKey) {
      this.parent.transition("scribble_brushing", info);
    } else {
      this.hitTestShapes();
    }
  }
  onKeyUp() {
    this.hitTestShapes();
  }
  complete() {
    this.hitTestShapes();
    this.parent.transition("idle");
  }
  hitTestShapes() {
    const { editor, excludedShapeIds, isWrapMode } = this;
    const {
      inputs: { originPagePoint, currentPagePoint, shiftKey, ctrlKey }
    } = editor;
    const results = new Set(shiftKey ? this.initialSelectedShapeIds : []);
    const isWrapping = isWrapMode ? !ctrlKey : ctrlKey;
    const brush = Box.FromPoints([originPagePoint, currentPagePoint]);
    const { corners } = brush;
    let A, B, shape, pageBounds, pageTransform, localCorners;
    const brushBoxIsInsideViewport = editor.getViewportPageBounds().contains(brush);
    const shapesToHitTest = brushBoxIsInsideViewport && !this.viewportDidChange ? editor.getCurrentPageRenderingShapesSorted() : editor.getCurrentPageShapesSorted();
    const currentPageId = editor.getCurrentPageId();
    testAllShapes:
      for (let i = 0, n = shapesToHitTest.length; i < n; i++) {
        shape = shapesToHitTest[i];
        if (excludedShapeIds.has(shape.id) || results.has(shape.id))
          continue testAllShapes;
        pageBounds = editor.getShapePageBounds(shape);
        if (!pageBounds)
          continue testAllShapes;
        if (brush.contains(pageBounds)) {
          this.handleHit(shape, currentPagePoint, currentPageId, results, corners);
          continue testAllShapes;
        }
        if (isWrapping || editor.isShapeOfType(shape, "frame")) {
          continue testAllShapes;
        }
        if (brush.collides(pageBounds)) {
          pageTransform = editor.getShapePageTransform(shape);
          if (!pageTransform)
            continue testAllShapes;
          localCorners = pageTransform.clone().invert().applyToPoints(corners);
          const geometry = editor.getShapeGeometry(shape);
          hitTestBrushEdges:
            for (let i2 = 0; i2 < 4; i2++) {
              A = localCorners[i2];
              B = localCorners[(i2 + 1) % 4];
              if (geometry.hitTestLineSegment(A, B, 0)) {
                this.handleHit(shape, currentPagePoint, currentPageId, results, corners);
                break hitTestBrushEdges;
              }
            }
        }
      }
    const currentBrush = editor.getInstanceState().brush;
    if (!currentBrush || !brush.equals(currentBrush)) {
      editor.updateInstanceState({ brush: { ...brush.toJson() } });
    }
    const current = editor.getSelectedShapeIds();
    if (current.length !== results.size || current.some((id) => !results.has(id))) {
      editor.setSelectedShapes(Array.from(results));
    }
  }
  onInterrupt() {
    this.editor.updateInstanceState({ brush: null });
  }
  handleHit(shape, currentPagePoint, currentPageId, results, corners) {
    if (shape.parentId === currentPageId) {
      results.add(shape.id);
      return;
    }
    const selectedShape = this.editor.getOutermostSelectableShape(shape);
    const pageMask = this.editor.getShapeMask(selectedShape.id);
    if (pageMask && !polygonsIntersect(pageMask, corners) && !pointInPolygon(currentPagePoint, pageMask)) {
      return;
    }
    results.add(selectedShape.id);
  }
};
__publicField(Brushing, "id", "brushing");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingResizeHandle.mjs
var CursorTypeMap = {
  bottom: "ns-resize",
  top: "ns-resize",
  left: "ew-resize",
  right: "ew-resize",
  bottom_left: "nesw-resize",
  bottom_right: "nwse-resize",
  top_left: "nwse-resize",
  top_right: "nesw-resize",
  bottom_left_rotate: "swne-rotate",
  bottom_right_rotate: "senw-rotate",
  top_left_rotate: "nwse-rotate",
  top_right_rotate: "nesw-rotate",
  mobile_rotate: "grabbing"
};
var PointingResizeHandle = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  updateCursor() {
    const selected = this.editor.getSelectedShapes();
    const cursorType = CursorTypeMap[this.info.handle];
    this.editor.setCursor({
      type: cursorType,
      rotation: selected.length === 1 ? this.editor.getSelectionRotation() : 0
    });
  }
  onEnter(info) {
    this.info = info;
    this.updateCursor();
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      this.startResizing();
    }
  }
  onLongPress() {
    this.startResizing();
  }
  startResizing() {
    if (this.editor.getIsReadonly())
      return;
    this.parent.transition("resizing", this.info);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, {});
    } else {
      this.parent.transition("idle");
    }
  }
  cancel() {
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, {});
    } else {
      this.parent.transition("idle");
    }
  }
};
__publicField(PointingResizeHandle, "id", "pointing_resize_handle");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/Cropping.mjs
var Cropping = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "markId", "");
    __publicField(this, "snapshot", {});
  }
  onEnter(info) {
    this.info = info;
    this.markId = this.editor.markHistoryStoppingPoint("cropping");
    this.snapshot = this.createSnapshot();
    this.updateShapes();
  }
  onPointerMove() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  updateCursor() {
    const selectedShape = this.editor.getSelectedShapes()[0];
    if (!selectedShape)
      return;
    const cursorType = CursorTypeMap[this.info.handle];
    this.editor.setCursor({ type: cursorType, rotation: this.editor.getSelectionRotation() });
  }
  updateShapes() {
    var _a5;
    const { shape, cursorHandleOffset } = this.snapshot;
    if (!shape)
      return;
    const util = this.editor.getShapeUtil(shape.type);
    if (!util)
      return;
    const currentPagePoint = this.editor.inputs.currentPagePoint.clone().sub(cursorHandleOffset);
    const originPagePoint = this.editor.inputs.originPagePoint.clone().sub(cursorHandleOffset);
    const change = currentPagePoint.clone().sub(originPagePoint).rot(-shape.rotation);
    const crop = shape.props.crop ?? getDefaultCrop();
    const uncroppedSize = {
      w: 1 / (crop.bottomRight.x - crop.topLeft.x) * shape.props.w,
      h: 1 / (crop.bottomRight.y - crop.topLeft.y) * shape.props.h
    };
    const cropFn = ((_a5 = util.onCrop) == null ? void 0 : _a5.bind(util)) ?? getCropBox;
    const partial = cropFn(shape, {
      handle: this.info.handle,
      change,
      crop,
      uncroppedSize,
      initialShape: this.snapshot.shape
    });
    if (!partial)
      return;
    this.editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        ...partial
      }
    ]);
    this.updateCursor();
  }
  complete() {
    this.updateShapes();
    kickoutOccludedShapes(this.editor, [this.snapshot.shape.id]);
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, this.info);
    } else {
      this.editor.setCroppingShape(null);
      this.editor.setCurrentTool("select.idle");
    }
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, this.info);
    } else {
      this.editor.setCroppingShape(null);
      this.editor.setCurrentTool("select.idle");
    }
  }
  createSnapshot() {
    const selectionRotation = this.editor.getSelectionRotation();
    const {
      inputs: { originPagePoint }
    } = this.editor;
    const shape = this.editor.getOnlySelectedShape();
    const selectionBounds = this.editor.getSelectionRotatedPageBounds();
    const dragHandlePoint = Vec.RotWith(
      selectionBounds.getHandlePoint(this.info.handle),
      selectionBounds.point,
      selectionRotation
    );
    const cursorHandleOffset = Vec.Sub(originPagePoint, dragHandlePoint);
    return {
      shape,
      cursorHandleOffset
    };
  }
};
__publicField(Cropping, "id", "cropping");

// node_modules/tldraw/dist-esm/lib/tools/selection-logic/getHitShapeOnCanvasPointerDown.mjs
function getHitShapeOnCanvasPointerDown(editor, hitLabels = false) {
  const zoomLevel = editor.getZoomLevel();
  const {
    inputs: { currentPagePoint }
  } = editor;
  return (
    // hovered shape at point
    // selected shape at point
    editor.getShapeAtPoint(currentPagePoint, {
      hitInside: false,
      hitLabels,
      margin: editor.options.hitTestMargin / zoomLevel,
      renderingOnly: true
    }) ?? editor.getSelectedShapeAtPoint(currentPagePoint)
  );
}

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/crop_helpers.mjs
function getTranslateCroppedImageChange(editor, shape, delta) {
  if (!shape) {
    throw Error("Needs to translate a cropped shape!");
  }
  const { crop: oldCrop } = shape.props;
  if (!oldCrop) {
    return;
  }
  const flatten = editor.inputs.shiftKey ? Math.abs(delta.x) < Math.abs(delta.y) ? "x" : "y" : null;
  if (flatten === "x") {
    delta.x = 0;
  } else if (flatten === "y") {
    delta.y = 0;
  }
  delta.rot(-shape.rotation);
  const { w, h } = getUncroppedSize(shape.props, oldCrop);
  const yCrop = oldCrop.bottomRight.y - oldCrop.topLeft.y;
  const xCrop = oldCrop.bottomRight.x - oldCrop.topLeft.x;
  const newCrop = structuredClone(oldCrop);
  newCrop.topLeft.x = Math.min(1 - xCrop, Math.max(0, newCrop.topLeft.x - delta.x / w));
  newCrop.topLeft.y = Math.min(1 - yCrop, Math.max(0, newCrop.topLeft.y - delta.y / h));
  newCrop.bottomRight.x = newCrop.topLeft.x + xCrop;
  newCrop.bottomRight.y = newCrop.topLeft.y + yCrop;
  const partial = {
    id: shape.id,
    type: shape.type,
    props: {
      crop: newCrop
    }
  };
  return partial;
}

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/Idle.mjs
var Idle11 = class extends StateNode {
  onEnter() {
    this.editor.setCursor({ type: "default", rotation: 0 });
    const onlySelectedShape = this.editor.getOnlySelectedShape();
    if (onlySelectedShape) {
      this.editor.setCroppingShape(onlySelectedShape.id);
    }
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onCancel() {
    this.editor.setCroppingShape(null);
    this.editor.setCurrentTool("select.idle", {});
  }
  onPointerDown(info) {
    var _a5;
    if (info.accelKey) {
      this.cancel();
      this.editor.root.handleEvent(info);
      return;
    }
    switch (info.target) {
      case "canvas": {
        const hitShape = getHitShapeOnCanvasPointerDown(this.editor);
        if (hitShape && !this.editor.isShapeOfType(hitShape, "group")) {
          this.onPointerDown({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        this.cancel();
        this.editor.root.handleEvent(info);
        break;
      }
      case "shape": {
        if (info.shape.id === this.editor.getCroppingShapeId()) {
          this.editor.setCurrentTool("select.crop.pointing_crop", info);
          return;
        } else {
          if ((_a5 = this.editor.getShapeUtil(info.shape)) == null ? void 0 : _a5.canCrop(info.shape)) {
            this.editor.setCroppingShape(info.shape.id);
            this.editor.setSelectedShapes([info.shape.id]);
            this.editor.setCurrentTool("select.crop.pointing_crop", info);
          } else {
            this.cancel();
            this.editor.root.handleEvent(info);
          }
        }
        break;
      }
      case "selection": {
        switch (info.handle) {
          case "mobile_rotate":
          case "top_left_rotate":
          case "top_right_rotate":
          case "bottom_left_rotate":
          case "bottom_right_rotate": {
            this.editor.setCurrentTool("select.pointing_rotate_handle", {
              ...info,
              onInteractionEnd: "select.crop.idle"
            });
            break;
          }
          case "top":
          case "right":
          case "bottom":
          case "left":
          case "top_left":
          case "top_right":
          case "bottom_left":
          case "bottom_right": {
            this.editor.setCurrentTool("select.crop.pointing_crop_handle", {
              ...info,
              onInteractionEnd: "select.crop.idle"
            });
            break;
          }
          default: {
            this.cancel();
          }
        }
        break;
      }
    }
  }
  onDoubleClick(info) {
    var _a5;
    if (this.editor.inputs.shiftKey || info.phase !== "up")
      return;
    const croppingShapeId = this.editor.getCroppingShapeId();
    if (!croppingShapeId)
      return;
    const shape = this.editor.getShape(croppingShapeId);
    if (!shape)
      return;
    const util = this.editor.getShapeUtil(shape);
    if (!util)
      return;
    if (info.target === "selection") {
      (_a5 = util.onDoubleClickEdge) == null ? void 0 : _a5.call(util, shape, info);
      return;
    }
    this.cancel();
    this.editor.root.handleEvent(info);
  }
  onKeyDown() {
    this.nudgeCroppingImage(false);
  }
  onKeyRepeat() {
    this.nudgeCroppingImage(true);
  }
  onKeyUp(info) {
    switch (info.code) {
      case "Enter": {
        this.editor.setCroppingShape(null);
        this.editor.setCurrentTool("select.idle", {});
        break;
      }
    }
  }
  cancel() {
    this.editor.setCroppingShape(null);
    this.editor.setCurrentTool("select.idle", {});
  }
  nudgeCroppingImage(ephemeral = false) {
    const {
      editor: {
        inputs: { keys: keys2 }
      }
    } = this;
    const shiftKey = keys2.has("ShiftLeft");
    const delta = new Vec(0, 0);
    if (keys2.has("ArrowLeft"))
      delta.x += 1;
    if (keys2.has("ArrowRight"))
      delta.x -= 1;
    if (keys2.has("ArrowUp"))
      delta.y += 1;
    if (keys2.has("ArrowDown"))
      delta.y -= 1;
    if (delta.equals(new Vec(0, 0)))
      return;
    if (shiftKey)
      delta.mul(10);
    const shape = this.editor.getShape(this.editor.getCroppingShapeId());
    if (!shape)
      return;
    const partial = getTranslateCroppedImageChange(this.editor, shape, delta);
    if (partial) {
      if (!ephemeral) {
        this.editor.markHistoryStoppingPoint("translate crop");
      }
      this.editor.updateShapes([partial]);
    }
  }
};
__publicField(Idle11, "id", "idle");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/PointingCrop.mjs
var PointingCrop = class extends StateNode {
  onCancel() {
    this.editor.setCurrentTool("select.crop.idle", {});
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      this.editor.setCurrentTool("select.crop.translating_crop", info);
    }
  }
  onPointerUp(info) {
    this.editor.setCurrentTool("select.crop.idle", info);
  }
};
__publicField(PointingCrop, "id", "pointing_crop");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/PointingCropHandle.mjs
var PointingCropHandle = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  onEnter(info) {
    this.info = info;
    this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    const selectedShape = this.editor.getSelectedShapes()[0];
    if (!selectedShape)
      return;
    const cursorType = CursorTypeMap[this.info.handle];
    this.editor.setCursor({ type: cursorType, rotation: this.editor.getSelectionRotation() });
    this.editor.setCroppingShape(selectedShape.id);
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.parent.setCurrentToolIdMask(void 0);
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      this.startCropping();
    }
  }
  onLongPress() {
    this.startCropping();
  }
  startCropping() {
    if (this.editor.getIsReadonly())
      return;
    this.parent.transition("cropping", {
      ...this.info,
      onInteractionEnd: this.info.onInteractionEnd
    });
  }
  onPointerUp() {
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, this.info);
    } else {
      this.editor.setCroppingShape(null);
      this.editor.setCurrentTool("select.idle");
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, this.info);
    } else {
      this.editor.setCroppingShape(null);
      this.editor.setCurrentTool("select.idle");
    }
  }
};
__publicField(PointingCropHandle, "id", "pointing_crop_handle");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/TranslatingCrop.mjs
var TranslatingCrop = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "markId", "");
    __publicField(this, "snapshot", {});
  }
  onEnter(info) {
    this.info = info;
    this.snapshot = this.createSnapshot();
    this.markId = this.editor.markHistoryStoppingPoint("translating_crop");
    this.editor.setCursor({ type: "move", rotation: 0 });
    this.updateShapes();
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onKeyDown(info) {
    switch (info.key) {
      case "Alt":
      case "Shift": {
        this.updateShapes();
        return;
      }
    }
  }
  onKeyUp(info) {
    switch (info.key) {
      case "Enter": {
        this.complete();
        return;
      }
      case "Alt":
      case "Shift": {
        this.updateShapes();
      }
    }
  }
  complete() {
    this.updateShapes();
    this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  createSnapshot() {
    const shape = this.editor.getOnlySelectedShape();
    return { shape };
  }
  updateShapes() {
    const shape = this.snapshot.shape;
    if (!shape)
      return;
    const { originPagePoint, currentPagePoint } = this.editor.inputs;
    const delta = currentPagePoint.clone().sub(originPagePoint);
    const partial = getTranslateCroppedImageChange(this.editor, shape, delta);
    if (partial) {
      this.editor.updateShapes([partial]);
    }
  }
};
__publicField(TranslatingCrop, "id", "translating_crop");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/Crop.mjs
var Crop = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "markId", "");
    __publicField(this, "didExit", false);
  }
  static children() {
    return [Idle11, TranslatingCrop, PointingCrop, PointingCropHandle, Cropping];
  }
  onEnter() {
    this.didExit = false;
    this.markId = this.editor.markHistoryStoppingPoint("crop");
  }
  onExit() {
    if (!this.didExit) {
      this.didExit = true;
      this.editor.squashToMark(this.markId);
    }
  }
  onCancel() {
    if (!this.didExit) {
      this.didExit = true;
      this.editor.bailToMark(this.markId);
    }
  }
};
__publicField(Crop, "id", "crop");
__publicField(Crop, "initial", "idle");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/DraggingHandle.mjs
var DraggingHandle = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeId", "");
    __publicField(this, "initialHandle", {});
    __publicField(this, "initialAdjacentHandle", null);
    __publicField(this, "initialPagePoint", {});
    __publicField(this, "markId", "");
    __publicField(this, "initialPageTransform");
    __publicField(this, "initialPageRotation");
    __publicField(this, "info", {});
    __publicField(this, "isPrecise", false);
    __publicField(this, "isPreciseId", null);
    __publicField(this, "pointingId", null);
    // Only relevant to arrows
    __publicField(this, "exactTimeout", -1);
  }
  onEnter(info) {
    const { shape, isCreating, creatingMarkId, handle } = info;
    this.info = info;
    this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    this.shapeId = shape.id;
    this.markId = "";
    if (isCreating) {
      if (creatingMarkId) {
        this.markId = creatingMarkId;
      } else {
        const markId = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        if (markId) {
          this.markId = markId;
        }
      }
    } else {
      this.markId = this.editor.markHistoryStoppingPoint("dragging handle");
    }
    this.initialHandle = structuredClone(handle);
    if (this.editor.isShapeOfType(shape, "line")) {
      if (this.initialHandle.type === "create") {
        this.editor.updateShape({
          ...shape,
          props: {
            points: {
              ...shape.props.points,
              [handle.index]: { id: handle.index, index: handle.index, x: handle.x, y: handle.y }
            }
          }
        });
        const handlesAfter = this.editor.getShapeHandles(shape);
        const handleAfter = handlesAfter.find((h) => h.index === handle.index);
        this.initialHandle = structuredClone(handleAfter);
      }
    }
    this.initialPageTransform = this.editor.getShapePageTransform(shape);
    this.initialPageRotation = this.initialPageTransform.rotation();
    this.initialPagePoint = this.editor.inputs.originPagePoint.clone();
    this.editor.setCursor({ type: isCreating ? "cross" : "grabbing", rotation: 0 });
    const handles = this.editor.getShapeHandles(shape).sort(sortByIndex);
    const index3 = handles.findIndex((h) => h.id === info.handle.id);
    this.initialAdjacentHandle = null;
    for (let i = index3 + 1; i < handles.length; i++) {
      const handle2 = handles[i];
      if (handle2.type === "vertex" && handle2.id !== "middle" && handle2.id !== info.handle.id) {
        this.initialAdjacentHandle = handle2;
        break;
      }
    }
    if (!this.initialAdjacentHandle) {
      for (let i = handles.length - 1; i >= 0; i--) {
        const handle2 = handles[i];
        if (handle2.type === "vertex" && handle2.id !== "middle" && handle2.id !== info.handle.id) {
          this.initialAdjacentHandle = handle2;
          break;
        }
      }
    }
    if (this.editor.isShapeOfType(shape, "arrow")) {
      const initialBinding = getArrowBindings(this.editor, shape)[info.handle.id];
      this.isPrecise = false;
      if (initialBinding) {
        this.isPrecise = initialBinding.props.isPrecise;
        if (this.isPrecise) {
          this.isPreciseId = initialBinding.toId;
        } else {
          this.resetExactTimeout();
        }
      }
    }
    this.update();
    this.editor.select(this.shapeId);
  }
  // Only relevant to arrows
  resetExactTimeout() {
    if (this.exactTimeout !== -1) {
      this.clearExactTimeout();
    }
    this.exactTimeout = this.editor.timers.setTimeout(() => {
      if (this.getIsActive() && !this.isPrecise) {
        this.isPrecise = true;
        this.isPreciseId = this.pointingId;
        this.update();
      }
      this.exactTimeout = -1;
    }, 750);
  }
  // Only relevant to arrows
  clearExactTimeout() {
    if (this.exactTimeout !== -1) {
      clearTimeout(this.exactTimeout);
      this.exactTimeout = -1;
    }
  }
  onPointerMove() {
    this.update();
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.update();
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    clearArrowTargetState(this.editor);
    this.editor.snaps.clearIndicators();
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  complete() {
    this.editor.snaps.clearIndicators();
    kickoutOccludedShapes(this.editor, [this.shapeId]);
    const { onInteractionEnd } = this.info;
    if (this.editor.getInstanceState().isToolLocked && onInteractionEnd) {
      this.editor.setCurrentTool(onInteractionEnd, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle");
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    this.editor.snaps.clearIndicators();
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      this.editor.setCurrentTool(onInteractionEnd, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle");
  }
  update() {
    var _a5;
    const { editor, shapeId, initialPagePoint } = this;
    const { initialHandle, initialPageRotation, initialAdjacentHandle } = this;
    const isSnapMode = this.editor.user.getIsSnapMode();
    const {
      snaps,
      inputs: { currentPagePoint, shiftKey, ctrlKey, altKey: altKey2, pointerVelocity }
    } = editor;
    const initial = this.info.shape;
    const shape = editor.getShape(shapeId);
    if (!shape)
      return;
    const util = editor.getShapeUtil(shape);
    const initialBinding = editor.isShapeOfType(shape, "arrow") ? getArrowBindings(editor, shape)[initialHandle.id] : void 0;
    let point = currentPagePoint.clone().sub(initialPagePoint).rot(-initialPageRotation).add(initialHandle);
    if (shiftKey && initialAdjacentHandle && initialHandle.id !== "middle") {
      const angle = Vec.Angle(initialAdjacentHandle, point);
      const snappedAngle = snapAngle(angle, 24);
      const angleDifference = snappedAngle - angle;
      point = Vec.RotWith(point, initialAdjacentHandle, angleDifference);
    }
    editor.snaps.clearIndicators();
    let nextHandle = { ...initialHandle, x: point.x, y: point.y };
    if (initialHandle.canSnap && (isSnapMode ? !ctrlKey : ctrlKey)) {
      const pageTransform = editor.getShapePageTransform(shape.id);
      if (!pageTransform)
        throw Error("Expected a page transform");
      const snap = snaps.handles.snapHandle({ currentShapeId: shapeId, handle: nextHandle });
      if (snap) {
        snap.nudge.rot(-editor.getShapeParentTransform(shape).rotation());
        point.add(snap.nudge);
        nextHandle = { ...initialHandle, x: point.x, y: point.y };
      }
    }
    const changes = (_a5 = util.onHandleDrag) == null ? void 0 : _a5.call(util, shape, {
      handle: nextHandle,
      isPrecise: this.isPrecise || altKey2,
      initial
    });
    const next = { id: shape.id, type: shape.type, ...changes };
    if (initialHandle.type === "vertex" && this.editor.isShapeOfType(shape, "arrow")) {
      const bindingAfter = getArrowBindings(editor, shape)[initialHandle.id];
      if (bindingAfter) {
        if ((initialBinding == null ? void 0 : initialBinding.toId) !== bindingAfter.toId) {
          this.pointingId = bindingAfter.toId;
          this.isPrecise = pointerVelocity.len() < 0.5 || altKey2;
          this.isPreciseId = this.isPrecise ? bindingAfter.toId : null;
          this.resetExactTimeout();
        }
      } else {
        if (initialBinding) {
          this.pointingId = null;
          this.isPrecise = false;
          this.isPreciseId = null;
          this.resetExactTimeout();
        }
      }
    }
    if (changes) {
      editor.updateShapes([next]);
    }
  }
};
__publicField(DraggingHandle, "id", "dragging_handle");

// node_modules/tldraw/dist-esm/lib/utils/shapes/shapes.mjs
function getTextLabels(geometry) {
  if (geometry.isLabel) {
    return [geometry];
  }
  if (geometry instanceof Group2d) {
    return geometry.children.filter((child) => child.isLabel);
  }
  return [];
}

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/EditingShape.mjs
var EditingShape = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "hitShapeForPointerUp", null);
    __publicField(this, "info", {});
  }
  onEnter(info) {
    const editingShape = this.editor.getEditingShape();
    if (!editingShape)
      throw Error("Entered editing state without an editing shape");
    this.hitShapeForPointerUp = null;
    this.info = info;
    if (info.isCreatingTextWhileToolLocked) {
      this.parent.setCurrentToolIdMask("text");
    }
    updateHoveredShapeId(this.editor);
    this.editor.select(editingShape);
  }
  onExit() {
    const { editingShapeId } = this.editor.getCurrentPageState();
    if (!editingShapeId)
      return;
    this.editor.setEditingShape(null);
    updateHoveredShapeId.cancel();
    if (this.info.isCreatingTextWhileToolLocked) {
      this.parent.setCurrentToolIdMask(void 0);
      this.editor.setCurrentTool("text", {});
    }
  }
  onPointerMove(info) {
    if (this.hitShapeForPointerUp && this.editor.inputs.isDragging) {
      if (this.editor.getIsReadonly())
        return;
      if (this.hitShapeForPointerUp.isLocked)
        return;
      this.editor.select(this.hitShapeForPointerUp);
      this.parent.transition("translating", info);
      this.hitShapeForPointerUp = null;
      return;
    }
    switch (info.target) {
      case "shape":
      case "canvas": {
        updateHoveredShapeId(this.editor);
        return;
      }
    }
  }
  onPointerDown(info) {
    this.hitShapeForPointerUp = null;
    switch (info.target) {
      case "canvas": {
        const hitShape = getHitShapeOnCanvasPointerDown(
          this.editor,
          true
          /* hitLabels */
        );
        if (hitShape) {
          this.onPointerDown({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        break;
      }
      case "shape": {
        const { shape: selectingShape } = info;
        const editingShape = this.editor.getEditingShape();
        if (!editingShape) {
          throw Error("Expected an editing shape!");
        }
        const geometry = this.editor.getShapeUtil(selectingShape).getGeometry(selectingShape);
        const textLabels = getTextLabels(geometry);
        const textLabel = textLabels.length === 1 ? textLabels[0] : void 0;
        const isEmptyTextShape = this.editor.isShapeOfType(editingShape, "text") && renderPlaintextFromRichText(this.editor, editingShape.props.richText).trim() === "";
        if (textLabel && !isEmptyTextShape) {
          const pointInShapeSpace = this.editor.getPointInShapeSpace(
            selectingShape,
            this.editor.inputs.currentPagePoint
          );
          if (textLabel.bounds.containsPoint(pointInShapeSpace, 0) && textLabel.hitTestPoint(pointInShapeSpace)) {
            if (selectingShape.id === editingShape.id) {
              return;
            } else {
              this.hitShapeForPointerUp = selectingShape;
              this.editor.markHistoryStoppingPoint("editing on pointer up");
              this.editor.select(selectingShape.id);
              return;
            }
          }
        } else {
          if (selectingShape.id === editingShape.id) {
            if (this.editor.isShapeOfType(selectingShape, "frame")) {
              this.editor.setEditingShape(null);
              this.parent.transition("idle", info);
            }
          } else {
            this.parent.transition("pointing_shape", info);
            return;
          }
          return;
        }
        break;
      }
    }
    this.parent.transition("idle", info);
    this.editor.root.handleEvent(info);
  }
  onPointerUp(info) {
    const hitShape = this.hitShapeForPointerUp;
    if (!hitShape)
      return;
    this.hitShapeForPointerUp = null;
    const util = this.editor.getShapeUtil(hitShape);
    if (hitShape.isLocked)
      return;
    if (this.editor.getIsReadonly()) {
      if (!util.canEditInReadonly(hitShape)) {
        this.parent.transition("pointing_shape", info);
        return;
      }
    }
    this.editor.select(hitShape.id);
    const currentEditingShape = this.editor.getEditingShape();
    const isEditToEditAction = currentEditingShape && currentEditingShape.id !== hitShape.id;
    this.editor.setEditingShape(hitShape.id);
    const isMobile = tlenv.isIos || tlenv.isAndroid;
    if (!isMobile || !isEditToEditAction) {
      this.editor.emit("place-caret", { shapeId: hitShape.id, point: info.point });
    } else if (isMobile && isEditToEditAction) {
      this.editor.emit("select-all-text", { shapeId: hitShape.id });
    }
    updateHoveredShapeId(this.editor);
  }
  onComplete(info) {
    this.parent.transition("idle", info);
  }
  onCancel(info) {
    this.parent.transition("idle", info);
  }
};
__publicField(EditingShape, "id", "editing_shape");

// node_modules/tldraw/dist-esm/lib/tools/selection-logic/getShouldEnterCropModeOnPointerDown.mjs
function getShouldEnterCropMode(editor) {
  const onlySelectedShape = editor.getOnlySelectedShape();
  return !!(onlySelectedShape && !editor.isShapeOrAncestorLocked(onlySelectedShape) && editor.getShapeUtil(onlySelectedShape).canCrop(onlySelectedShape));
}

// node_modules/tldraw/dist-esm/lib/tools/selection-logic/selectOnCanvasPointerUp.mjs
function selectOnCanvasPointerUp(editor, info) {
  const selectedShapeIds = editor.getSelectedShapeIds();
  const { currentPagePoint } = editor.inputs;
  const { shiftKey, altKey: altKey2, accelKey } = info;
  const additiveSelectionKey = shiftKey || accelKey;
  const hitShape = editor.getShapeAtPoint(currentPagePoint, {
    hitInside: false,
    margin: editor.options.hitTestMargin / editor.getZoomLevel(),
    hitLabels: true,
    renderingOnly: true,
    filter: (shape) => !shape.isLocked
  });
  if (hitShape) {
    const outermostSelectableShape = editor.getOutermostSelectableShape(hitShape);
    if (additiveSelectionKey && !altKey2) {
      editor.cancelDoubleClick();
      if (selectedShapeIds.includes(outermostSelectableShape.id)) {
        editor.markHistoryStoppingPoint("deselecting shape");
        editor.deselect(outermostSelectableShape);
      } else {
        editor.markHistoryStoppingPoint("shift selecting shape");
        editor.setSelectedShapes([...selectedShapeIds, outermostSelectableShape.id]);
      }
    } else {
      let shapeToSelect = void 0;
      if (outermostSelectableShape === hitShape) {
        shapeToSelect = hitShape;
      } else {
        if (outermostSelectableShape.id === editor.getFocusedGroupId() || selectedShapeIds.includes(outermostSelectableShape.id)) {
          shapeToSelect = hitShape;
        } else {
          shapeToSelect = outermostSelectableShape;
        }
      }
      if (shapeToSelect && !selectedShapeIds.includes(shapeToSelect.id)) {
        editor.markHistoryStoppingPoint("selecting shape");
        editor.select(shapeToSelect.id);
      }
    }
  } else {
    if (additiveSelectionKey) {
      return;
    } else {
      if (selectedShapeIds.length > 0) {
        editor.markHistoryStoppingPoint("selecting none");
        editor.selectNone();
      }
      const focusedGroupId = editor.getFocusedGroupId();
      if (isShapeId(focusedGroupId)) {
        const groupShape = editor.getShape(focusedGroupId);
        if (!editor.isPointInShape(groupShape, currentPagePoint, { margin: 0, hitInside: true })) {
          editor.setFocusedGroup(null);
        }
      }
    }
  }
}

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Idle.mjs
var SKIPPED_KEYS_FOR_AUTO_EDITING = [
  "Delete",
  "Backspace",
  "[",
  "]",
  "Enter",
  " ",
  "Shift",
  "Tab"
];
var Idle12 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "selectedShapesOnKeyDown", []);
  }
  onEnter() {
    this.parent.setCurrentToolIdMask(void 0);
    updateHoveredShapeId(this.editor);
    this.selectedShapesOnKeyDown = [];
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onExit() {
    updateHoveredShapeId.cancel();
  }
  onPointerMove() {
    updateHoveredShapeId(this.editor);
  }
  onPointerDown(info) {
    const shouldEnterCropMode = info.ctrlKey && getShouldEnterCropMode(this.editor);
    switch (info.target) {
      case "canvas": {
        const hitShape = getHitShapeOnCanvasPointerDown(this.editor);
        if (hitShape && !hitShape.isLocked) {
          this.onPointerDown({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        const selectedShapeIds = this.editor.getSelectedShapeIds();
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        const {
          inputs: { currentPagePoint }
        } = this.editor;
        if (selectedShapeIds.length > 1 || onlySelectedShape && !this.editor.getShapeUtil(onlySelectedShape).hideSelectionBoundsBg(onlySelectedShape)) {
          if (isPointInRotatedSelectionBounds(this.editor, currentPagePoint)) {
            this.onPointerDown({
              ...info,
              target: "selection"
            });
            return;
          }
        }
        this.parent.transition("pointing_canvas", info);
        break;
      }
      case "shape": {
        const { shape } = info;
        if (this.isOverArrowLabelTest(shape)) {
          this.parent.transition("pointing_arrow_label", info);
          break;
        }
        if (this.editor.isShapeOrAncestorLocked(shape)) {
          this.parent.transition("pointing_canvas", info);
          break;
        }
        this.parent.transition("pointing_shape", info);
        break;
      }
      case "handle": {
        if (this.editor.getIsReadonly())
          break;
        if (this.editor.inputs.altKey) {
          this.parent.transition("pointing_shape", info);
        } else {
          this.parent.transition("pointing_handle", info);
        }
        break;
      }
      case "selection": {
        switch (info.handle) {
          case "mobile_rotate":
          case "top_left_rotate":
          case "top_right_rotate":
          case "bottom_left_rotate":
          case "bottom_right_rotate": {
            if (info.accelKey) {
              this.parent.transition("brushing", info);
              break;
            }
            this.parent.transition("pointing_rotate_handle", info);
            break;
          }
          case "top":
          case "right":
          case "bottom":
          case "left":
          case "top_left":
          case "top_right":
          case "bottom_left":
          case "bottom_right": {
            if (shouldEnterCropMode) {
              this.parent.transition("crop.pointing_crop_handle", info);
            } else {
              if (info.accelKey) {
                this.parent.transition("brushing", info);
                break;
              }
              this.parent.transition("pointing_resize_handle", info);
            }
            break;
          }
          default: {
            const hoveredShape = this.editor.getHoveredShape();
            if (hoveredShape && !this.editor.getSelectedShapeIds().includes(hoveredShape.id) && !hoveredShape.isLocked) {
              this.onPointerDown({
                ...info,
                shape: hoveredShape,
                target: "shape"
              });
              return;
            }
            this.parent.transition("pointing_selection", info);
          }
        }
        break;
      }
    }
  }
  onDoubleClick(info) {
    var _a5, _b, _c, _d, _e;
    if (this.editor.inputs.shiftKey || info.phase !== "up")
      return;
    if (info.ctrlKey || info.shiftKey)
      return;
    switch (info.target) {
      case "canvas": {
        const hoveredShape = this.editor.getHoveredShape();
        const hitShape = hoveredShape && !this.editor.isShapeOfType(hoveredShape, "group") ? hoveredShape : this.editor.getSelectedShapeAtPoint(this.editor.inputs.currentPagePoint) ?? this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
          margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
          hitInside: false
        });
        const focusedGroupId = this.editor.getFocusedGroupId();
        if (hitShape) {
          if (this.editor.isShapeOfType(hitShape, "group")) {
            selectOnCanvasPointerUp(this.editor, info);
            return;
          } else {
            const parent = this.editor.getShape(hitShape.parentId);
            if (parent && this.editor.isShapeOfType(parent, "group")) {
              if (focusedGroupId && parent.id === focusedGroupId) {
              } else {
                selectOnCanvasPointerUp(this.editor, info);
                return;
              }
            }
          }
          this.onDoubleClick({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        if (!this.editor.inputs.shiftKey) {
          this.handleDoubleClickOnCanvas(info);
        }
        break;
      }
      case "selection": {
        if (this.editor.getIsReadonly())
          break;
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        if (onlySelectedShape) {
          const util = this.editor.getShapeUtil(onlySelectedShape);
          if (!this.canInteractWithShapeInReadOnly(onlySelectedShape)) {
            return;
          }
          if (info.handle === "right" || info.handle === "left" || info.handle === "top" || info.handle === "bottom") {
            const change = (_a5 = util.onDoubleClickEdge) == null ? void 0 : _a5.call(util, onlySelectedShape, info);
            if (change) {
              this.editor.markHistoryStoppingPoint("double click edge");
              this.editor.updateShapes([change]);
              kickoutOccludedShapes(this.editor, [onlySelectedShape.id]);
              return;
            }
          }
          if (info.handle === "top_left" || info.handle === "top_right" || info.handle === "bottom_right" || info.handle === "bottom_left") {
            const change = (_b = util.onDoubleClickCorner) == null ? void 0 : _b.call(util, onlySelectedShape, info);
            if (change) {
              this.editor.markHistoryStoppingPoint("double click corner");
              this.editor.updateShapes([change]);
              kickoutOccludedShapes(this.editor, [onlySelectedShape.id]);
              return;
            }
          }
          if (util.canCrop(onlySelectedShape) && !this.editor.isShapeOrAncestorLocked(onlySelectedShape)) {
            this.parent.transition("crop", info);
            return;
          }
          if (this.shouldStartEditingShape(onlySelectedShape)) {
            this.startEditingShape(
              onlySelectedShape,
              info,
              true
              /* select all */
            );
          }
        }
        break;
      }
      case "shape": {
        const { shape } = info;
        const util = this.editor.getShapeUtil(shape);
        if (shape.type !== "video" && shape.type !== "embed" && this.editor.getIsReadonly())
          break;
        if (util.onDoubleClick) {
          const change = (_c = util.onDoubleClick) == null ? void 0 : _c.call(util, shape);
          if (change) {
            this.editor.updateShapes([change]);
            return;
          }
        }
        if (util.canCrop(shape) && !this.editor.isShapeOrAncestorLocked(shape)) {
          this.editor.markHistoryStoppingPoint("select and crop");
          this.editor.select((_d = info.shape) == null ? void 0 : _d.id);
          this.parent.transition("crop", info);
          return;
        }
        if (this.shouldStartEditingShape(shape)) {
          this.startEditingShape(
            shape,
            info,
            true
            /* select all */
          );
        } else {
          this.handleDoubleClickOnCanvas(info);
        }
        break;
      }
      case "handle": {
        if (this.editor.getIsReadonly())
          break;
        const { shape, handle } = info;
        const util = this.editor.getShapeUtil(shape);
        const changes = (_e = util.onDoubleClickHandle) == null ? void 0 : _e.call(util, shape, handle);
        if (changes) {
          this.editor.updateShapes([changes]);
        } else {
          if (this.shouldStartEditingShape(shape)) {
            this.startEditingShape(
              shape,
              info,
              true
              /* select all */
            );
          }
        }
      }
    }
  }
  onRightClick(info) {
    switch (info.target) {
      case "canvas": {
        const hoveredShape = this.editor.getHoveredShape();
        const hitShape = hoveredShape && !this.editor.isShapeOfType(hoveredShape, "group") ? hoveredShape : this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
          margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
          hitInside: false,
          hitLabels: true,
          hitLocked: true,
          hitFrameInside: true,
          renderingOnly: true
        });
        if (hitShape) {
          this.onRightClick({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        const selectedShapeIds = this.editor.getSelectedShapeIds();
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        const {
          inputs: { currentPagePoint }
        } = this.editor;
        if (selectedShapeIds.length > 1 || onlySelectedShape && !this.editor.getShapeUtil(onlySelectedShape).hideSelectionBoundsBg(onlySelectedShape)) {
          if (isPointInRotatedSelectionBounds(this.editor, currentPagePoint)) {
            this.onRightClick({
              ...info,
              target: "selection"
            });
            return;
          }
        }
        this.editor.selectNone();
        break;
      }
      case "shape": {
        const { selectedShapeIds } = this.editor.getCurrentPageState();
        const { shape } = info;
        const targetShape = this.editor.getOutermostSelectableShape(
          shape,
          (parent) => !selectedShapeIds.includes(parent.id)
        );
        if (!selectedShapeIds.includes(targetShape.id) && !this.editor.findShapeAncestor(
          targetShape,
          (shape2) => selectedShapeIds.includes(shape2.id)
        )) {
          this.editor.markHistoryStoppingPoint("selecting shape");
          this.editor.setSelectedShapes([targetShape.id]);
        }
        break;
      }
    }
  }
  onCancel() {
    if (this.editor.getFocusedGroupId() !== this.editor.getCurrentPageId() && this.editor.getSelectedShapeIds().length > 0) {
      this.editor.popFocusedGroupId();
    } else {
      this.editor.markHistoryStoppingPoint("clearing selection");
      this.editor.selectNone();
    }
  }
  onKeyDown(info) {
    this.selectedShapesOnKeyDown = this.editor.getSelectedShapes();
    switch (info.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown": {
        if (info.accelKey) {
          if (info.shiftKey) {
            if (info.code === "ArrowDown") {
              this.editor.selectFirstChildShape();
            } else if (info.code === "ArrowUp") {
              this.editor.selectParentShape();
            }
          } else {
            this.editor.selectAdjacentShape(
              info.code.replace("Arrow", "").toLowerCase()
            );
          }
          return;
        }
        this.nudgeSelectedShapes(false);
        return;
      }
    }
    if (debugFlags["editOnType"].get()) {
      if (!SKIPPED_KEYS_FOR_AUTO_EDITING.includes(info.key) && !info.altKey && !info.ctrlKey) {
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        if (onlySelectedShape && // If it's a note shape, then edit on type
        this.editor.isShapeOfType(onlySelectedShape, "note") && // If it's not locked or anything
        this.shouldStartEditingShape(onlySelectedShape)) {
          this.startEditingShape(
            onlySelectedShape,
            {
              ...info,
              target: "shape",
              shape: onlySelectedShape
            },
            true
            /* select all */
          );
          return;
        }
      }
    }
  }
  onKeyRepeat(info) {
    switch (info.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown": {
        if (info.accelKey) {
          this.editor.selectAdjacentShape(
            info.code.replace("Arrow", "").toLowerCase()
          );
          return;
        }
        this.nudgeSelectedShapes(true);
        break;
      }
      case "Tab": {
        const selectedShapes = this.editor.getSelectedShapes();
        if (selectedShapes.length) {
          this.editor.selectAdjacentShape(info.shiftKey ? "prev" : "next");
        }
        break;
      }
    }
  }
  onKeyUp(info) {
    switch (info.code) {
      case "Enter": {
        if (!this.selectedShapesOnKeyDown.length)
          return;
        const selectedShapes = this.editor.getSelectedShapes();
        if (selectedShapes.every((shape) => this.editor.isShapeOfType(shape, "group"))) {
          this.editor.setSelectedShapes(
            selectedShapes.flatMap((shape) => this.editor.getSortedChildIdsForParent(shape.id))
          );
          return;
        }
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        if (onlySelectedShape && this.shouldStartEditingShape(onlySelectedShape)) {
          this.startEditingShape(
            onlySelectedShape,
            {
              ...info,
              target: "shape",
              shape: onlySelectedShape
            },
            true
            /* select all */
          );
          return;
        }
        if (getShouldEnterCropMode(this.editor)) {
          this.parent.transition("crop", info);
        }
        break;
      }
      case "Tab": {
        const selectedShapes = this.editor.getSelectedShapes();
        if (selectedShapes.length) {
          this.editor.selectAdjacentShape(info.shiftKey ? "prev" : "next");
        }
        break;
      }
    }
  }
  shouldStartEditingShape(shape = this.editor.getOnlySelectedShape()) {
    if (!shape)
      return false;
    if (this.editor.isShapeOrAncestorLocked(shape) && shape.type !== "embed")
      return false;
    if (!this.canInteractWithShapeInReadOnly(shape))
      return false;
    return this.editor.getShapeUtil(shape).canEdit(shape);
  }
  startEditingShape(shape, info, shouldSelectAll) {
    if (this.editor.isShapeOrAncestorLocked(shape) && shape.type !== "embed")
      return;
    this.editor.markHistoryStoppingPoint("editing shape");
    startEditingShapeWithLabel(this.editor, shape, shouldSelectAll);
    this.parent.transition("editing_shape", info);
  }
  isOverArrowLabelTest(shape) {
    if (!shape)
      return false;
    const pointInShapeSpace = this.editor.getPointInShapeSpace(
      shape,
      this.editor.inputs.currentPagePoint
    );
    if (this.editor.isShapeOfType(shape, "arrow")) {
      const labelGeometry = this.editor.getShapeGeometry(shape).children[1];
      if (labelGeometry && pointInPolygon(pointInShapeSpace, labelGeometry.vertices)) {
        return true;
      }
    }
    return false;
  }
  handleDoubleClickOnCanvas(info) {
    if (this.editor.getIsReadonly())
      return;
    if (!this.editor.options.createTextOnCanvasDoubleClick)
      return;
    this.editor.markHistoryStoppingPoint("creating text shape");
    const id = createShapeId();
    const { x, y } = this.editor.inputs.currentPagePoint;
    this.editor.createShapes([
      {
        id,
        type: "text",
        x,
        y,
        props: {
          richText: toRichText(""),
          autoSize: true
        }
      }
    ]);
    const shape = this.editor.getShape(id);
    if (!shape)
      return;
    const util = this.editor.getShapeUtil(shape);
    if (this.editor.getIsReadonly()) {
      if (!util.canEditInReadonly(shape)) {
        return;
      }
    }
    this.editor.setEditingShape(id);
    this.editor.select(id);
    this.parent.transition("editing_shape", info);
  }
  nudgeSelectedShapes(ephemeral = false) {
    const {
      editor: {
        inputs: { keys: keys2 }
      }
    } = this;
    const shiftKey = keys2.has("ShiftLeft");
    const delta = new Vec(0, 0);
    if (keys2.has("ArrowLeft"))
      delta.x -= 1;
    if (keys2.has("ArrowRight"))
      delta.x += 1;
    if (keys2.has("ArrowUp"))
      delta.y -= 1;
    if (keys2.has("ArrowDown"))
      delta.y += 1;
    if (delta.equals(new Vec(0, 0)))
      return;
    if (!ephemeral)
      this.editor.markHistoryStoppingPoint("nudge shapes");
    const { gridSize } = this.editor.getDocumentSettings();
    const step = this.editor.getInstanceState().isGridMode ? shiftKey ? gridSize * GRID_INCREMENT : gridSize : shiftKey ? MAJOR_NUDGE_FACTOR : MINOR_NUDGE_FACTOR;
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    this.editor.nudgeShapes(selectedShapeIds, delta.mul(step));
    kickoutOccludedShapes(this.editor, selectedShapeIds);
  }
  canInteractWithShapeInReadOnly(shape) {
    if (!this.editor.getIsReadonly())
      return true;
    const util = this.editor.getShapeUtil(shape);
    if (util.canEditInReadonly(shape))
      return true;
    return false;
  }
};
__publicField(Idle12, "id", "idle");
var MAJOR_NUDGE_FACTOR = 10;
var MINOR_NUDGE_FACTOR = 1;
var GRID_INCREMENT = 5;
function isPointInRotatedSelectionBounds(editor, point) {
  const selectionBounds = editor.getSelectionRotatedPageBounds();
  if (!selectionBounds)
    return false;
  const selectionRotation = editor.getSelectionRotation();
  if (!selectionRotation)
    return selectionBounds.containsPoint(point);
  return pointInPolygon(
    point,
    selectionBounds.corners.map((c) => Vec.RotWith(c, selectionBounds.point, selectionRotation))
  );
}

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingArrowLabel.mjs
var PointingArrowLabel = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeId", "");
    __publicField(this, "markId", "");
    __publicField(this, "wasAlreadySelected", false);
    __publicField(this, "didDrag", false);
    __publicField(this, "didCtrlOnEnter", false);
    __publicField(this, "info", {});
    __publicField(this, "_labelDragOffset", new Vec(0, 0));
  }
  updateCursor() {
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onEnter(info) {
    const { shape } = info;
    this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    this.info = info;
    this.shapeId = shape.id;
    this.didDrag = false;
    this.didCtrlOnEnter = info.accelKey;
    this.wasAlreadySelected = this.editor.getOnlySelectedShapeId() === shape.id;
    this.updateCursor();
    const geometry = this.editor.getShapeGeometry(shape);
    const labelGeometry = geometry.children[1];
    if (!labelGeometry) {
      throw Error(`Expected to find an arrow label geometry for shape: ${shape.id}`);
    }
    const { currentPagePoint } = this.editor.inputs;
    const pointInShapeSpace = this.editor.getPointInShapeSpace(shape, currentPagePoint);
    this._labelDragOffset = Vec.Sub(labelGeometry.center, pointInShapeSpace);
    this.markId = this.editor.markHistoryStoppingPoint("label-drag start");
    const additiveSelectionKey = info.shiftKey || info.accelKey;
    if (additiveSelectionKey) {
      const selectedShapeIds = this.editor.getSelectedShapeIds();
      this.editor.setSelectedShapes([...selectedShapeIds, this.shapeId]);
      return;
    }
    this.editor.setSelectedShapes([this.shapeId]);
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    const { isDragging } = this.editor.inputs;
    if (!isDragging)
      return;
    if (this.didCtrlOnEnter) {
      this.parent.transition("brushing", this.info);
      return;
    }
    const shape = this.editor.getShape(this.shapeId);
    if (!shape)
      return;
    const options2 = this.editor.getShapeUtil("arrow").options;
    const geometry = arrowBodyGeometryCache.get(this.editor, shape.id);
    const transform = this.editor.getShapePageTransform(shape.id);
    const pointInShapeSpace = this.editor.getPointInShapeSpace(shape, this.editor.inputs.currentPagePoint).add(this._labelDragOffset);
    const defaultLabelPosition = getArrowLabelDefaultPosition(this.editor, shape);
    let nextLabelPosition = arrowBodyGeometryCache.get(this.editor, shape.id).uninterpolateAlongEdge(pointInShapeSpace);
    if (isNaN(nextLabelPosition)) {
      nextLabelPosition = defaultLabelPosition;
    }
    const nextLabelPoint = transform.applyToPoint(geometry.interpolateAlongEdge(nextLabelPosition));
    const labelDefaultPoint = transform.applyToPoint(
      geometry.interpolateAlongEdge(defaultLabelPosition)
    );
    if (Vec.DistMin(
      nextLabelPoint,
      labelDefaultPoint,
      options2.labelCenterSnapDistance / this.editor.getZoomLevel()
    )) {
      nextLabelPosition = defaultLabelPosition;
    }
    this.didDrag = true;
    this.editor.updateShape({
      id: shape.id,
      type: shape.type,
      props: { labelPosition: nextLabelPosition }
    });
  }
  onPointerUp() {
    const shape = this.editor.getShape(this.shapeId);
    if (!shape)
      return;
    if (this.didDrag || !this.wasAlreadySelected) {
      this.complete();
    } else if (!this.editor.getIsReadonly()) {
      this.editor.setEditingShape(shape.id);
      this.editor.setCurrentTool("select.editing_shape");
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, {});
    } else {
      this.parent.transition("idle");
    }
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, {});
    } else {
      this.parent.transition("idle");
    }
  }
};
__publicField(PointingArrowLabel, "id", "pointing_arrow_label");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingCanvas.mjs
var PointingCanvas = class extends StateNode {
  onEnter(info) {
    const additiveSelectionKey = info.shiftKey || info.accelKey;
    if (!additiveSelectionKey) {
      if (this.editor.getSelectedShapeIds().length > 0) {
        this.editor.markHistoryStoppingPoint("selecting none");
        this.editor.selectNone();
      }
    }
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      this.parent.transition("brushing", info);
    }
  }
  onPointerUp(info) {
    selectOnCanvasPointerUp(this.editor, info);
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.parent.transition("idle");
  }
  complete() {
    this.parent.transition("idle");
  }
};
__publicField(PointingCanvas, "id", "pointing_canvas");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingHandle.mjs
var PointingHandle = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "didCtrlOnEnter", false);
    __publicField(this, "info", {});
  }
  onEnter(info) {
    this.info = info;
    this.didCtrlOnEnter = info.accelKey;
    const { shape } = info;
    if (this.editor.isShapeOfType(shape, "arrow")) {
      const initialBindings = getArrowBindings(this.editor, shape);
      const currentBinding = initialBindings[info.handle.id];
      const oppositeBinding = initialBindings[info.handle.id === "start" ? "end" : "start"];
      const arrowTransform = this.editor.getShapePageTransform(shape.id);
      if (currentBinding) {
        updateArrowTargetState({
          editor: this.editor,
          pointInPageSpace: arrowTransform.applyToPoint(info.handle),
          arrow: shape,
          isPrecise: currentBinding.props.isPrecise,
          isExact: info.altKey,
          currentBinding,
          oppositeBinding
        });
      }
    }
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onExit() {
    this.editor.setHintingShapes([]);
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerUp() {
    const { shape, handle } = this.info;
    if (this.editor.isShapeOfType(shape, "note")) {
      const { editor } = this;
      const nextNote = getNoteForAdjacentPosition(editor, shape, handle, false);
      if (nextNote) {
        startEditingShapeWithLabel(
          editor,
          nextNote,
          true
          /* selectAll */
        );
        return;
      }
    }
    this.parent.transition("idle", this.info);
  }
  onPointerMove(info) {
    const { editor } = this;
    if (editor.inputs.isDragging) {
      if (this.didCtrlOnEnter) {
        this.parent.transition("brushing", info);
      } else {
        this.startDraggingHandle();
      }
    }
  }
  onLongPress() {
    this.startDraggingHandle();
  }
  startDraggingHandle() {
    const { editor } = this;
    if (editor.getIsReadonly())
      return;
    const { shape, handle } = this.info;
    if (editor.isShapeOfType(shape, "note")) {
      const nextNote = getNoteForAdjacentPosition(editor, shape, handle, true);
      if (nextNote) {
        const centeredOnPointer = editor.getPointInParentSpace(nextNote, editor.inputs.originPagePoint).sub(Vec.Rot(NOTE_CENTER_OFFSET.clone().mul(shape.props.scale), nextNote.rotation));
        editor.updateShape({ ...nextNote, x: centeredOnPointer.x, y: centeredOnPointer.y });
        editor.setHoveredShape(nextNote.id).select(nextNote.id).setCurrentTool("select.translating", {
          ...this.info,
          target: "shape",
          shape: editor.getShape(nextNote),
          onInteractionEnd: "note",
          isCreating: true,
          onCreate: () => {
            startEditingShapeWithLabel(
              editor,
              nextNote,
              true
              /* selectAll */
            );
          }
        });
        return;
      }
    }
    this.parent.transition("dragging_handle", this.info);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(PointingHandle, "id", "pointing_handle");
function getNoteForAdjacentPosition(editor, shape, handle, forceNew) {
  const pageTransform = editor.getShapePageTransform(shape.id);
  const pagePoint = pageTransform.point();
  const pageRotation = pageTransform.rotation();
  const positions = getNoteAdjacentPositions(
    editor,
    pagePoint,
    pageRotation,
    shape.props.growY * shape.props.scale,
    0,
    shape.props.scale
  );
  const position = positions[handle.index];
  if (position) {
    return getNoteShapeForAdjacentPosition(editor, shape, position, pageRotation, forceNew);
  }
}

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingRotateHandle.mjs
var PointingRotateHandle = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  updateCursor() {
    this.editor.setCursor({
      type: CursorTypeMap[this.info.handle],
      rotation: this.editor.getSelectionRotation()
    });
  }
  onEnter(info) {
    this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    this.info = info;
    this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      this.startRotating();
    }
  }
  onLongPress() {
    this.startRotating();
  }
  startRotating() {
    if (this.editor.getIsReadonly())
      return;
    this.parent.transition("rotating", this.info);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, {});
    } else {
      this.parent.transition("idle");
    }
  }
  cancel() {
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, {});
    } else {
      this.parent.transition("idle");
    }
  }
};
__publicField(PointingRotateHandle, "id", "pointing_rotate_handle");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingSelection.mjs
var PointingSelection = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  onEnter(info) {
    this.info = info;
  }
  onPointerUp(info) {
    selectOnCanvasPointerUp(this.editor, info);
    this.parent.transition("idle", info);
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      this.startTranslating(info);
    }
  }
  onLongPress(info) {
    this.startTranslating(info);
  }
  startTranslating(info) {
    if (this.editor.getIsReadonly())
      return;
    this.parent.transition("translating", info);
  }
  onDoubleClick(info) {
    var _a5, _b;
    const hoveredShape = this.editor.getHoveredShape();
    const hitShape = hoveredShape && !this.editor.isShapeOfType(hoveredShape, "group") ? hoveredShape : this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
      hitInside: true,
      margin: 0,
      renderingOnly: true
    });
    if (hitShape) {
      this.parent.transition("idle");
      (_b = (_a5 = this.parent).onDoubleClick) == null ? void 0 : _b.call(_a5, {
        ...info,
        target: "shape",
        shape: this.editor.getShape(hitShape)
      });
      return;
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(PointingSelection, "id", "pointing_selection");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingShape.mjs
var PointingShape = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "hitShape", {});
    __publicField(this, "hitShapeForPointerUp", {});
    __publicField(this, "isDoubleClick", false);
    __publicField(this, "didCtrlOnEnter", false);
    __publicField(this, "didSelectOnEnter", false);
  }
  onEnter(info) {
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    const selectionBounds = this.editor.getSelectionRotatedPageBounds();
    const focusedGroupId = this.editor.getFocusedGroupId();
    const {
      inputs: { currentPagePoint }
    } = this.editor;
    const { shiftKey, altKey: altKey2, accelKey } = info;
    this.hitShape = info.shape;
    this.isDoubleClick = false;
    this.didCtrlOnEnter = accelKey;
    const outermostSelectingShape = this.editor.getOutermostSelectableShape(info.shape);
    const selectedAncestor = this.editor.findShapeAncestor(
      outermostSelectingShape,
      (parent) => selectedShapeIds.includes(parent.id)
    );
    if (this.didCtrlOnEnter || // If the shape has an onClick handler
    this.editor.getShapeUtil(info.shape).onClick || // ...or if the shape is the focused layer (e.g. group)
    outermostSelectingShape.id === focusedGroupId || // ...or if the shape is within the selection
    selectedShapeIds.includes(outermostSelectingShape.id) || // ...or if an ancestor of the shape is selected
    selectedAncestor || // ...or if the current point is NOT within the selection bounds
    selectedShapeIds.length > 1 && (selectionBounds == null ? void 0 : selectionBounds.containsPoint(currentPagePoint))) {
      this.didSelectOnEnter = false;
      this.hitShapeForPointerUp = outermostSelectingShape;
      return;
    }
    this.didSelectOnEnter = true;
    if (shiftKey && !altKey2) {
      this.editor.cancelDoubleClick();
      if (!selectedShapeIds.includes(outermostSelectingShape.id)) {
        this.editor.markHistoryStoppingPoint("shift selecting shape");
        this.editor.setSelectedShapes([...selectedShapeIds, outermostSelectingShape.id]);
      }
    } else {
      this.editor.markHistoryStoppingPoint("selecting shape");
      this.editor.setSelectedShapes([outermostSelectingShape.id]);
    }
  }
  onPointerUp(info) {
    var _a5;
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    const focusedGroupId = this.editor.getFocusedGroupId();
    const zoomLevel = this.editor.getZoomLevel();
    const {
      inputs: { currentPagePoint }
    } = this.editor;
    const additiveSelectionKey = info.shiftKey || info.accelKey;
    const hitShape = this.editor.getShapeAtPoint(currentPagePoint, {
      margin: this.editor.options.hitTestMargin / zoomLevel,
      hitInside: true,
      renderingOnly: true
    }) ?? this.hitShape;
    const selectingShape = hitShape ? this.editor.getOutermostSelectableShape(hitShape) : this.hitShapeForPointerUp;
    if (selectingShape) {
      const util = this.editor.getShapeUtil(selectingShape);
      if (util.onClick) {
        const change = (_a5 = util.onClick) == null ? void 0 : _a5.call(util, selectingShape);
        if (change) {
          this.editor.markHistoryStoppingPoint("shape on click");
          this.editor.updateShapes([change]);
          this.parent.transition("idle", info);
          return;
        }
      }
      if (selectingShape.id === focusedGroupId) {
        if (selectedShapeIds.length > 0) {
          this.editor.markHistoryStoppingPoint("clearing shape ids");
          this.editor.setSelectedShapes([]);
        } else {
          this.editor.popFocusedGroupId();
        }
        this.parent.transition("idle", info);
        return;
      }
    }
    if (!this.didSelectOnEnter) {
      const outermostSelectableShape = this.editor.getOutermostSelectableShape(
        hitShape,
        // if a group is selected, we want to stop before reaching that group
        // so we can drill down into the group
        (parent) => !selectedShapeIds.includes(parent.id)
      );
      if (selectedShapeIds.includes(outermostSelectableShape.id)) {
        if (additiveSelectionKey) {
          this.editor.markHistoryStoppingPoint("deselecting on pointer up");
          this.editor.deselect(selectingShape);
        } else {
          if (selectedShapeIds.includes(selectingShape.id)) {
            if (selectedShapeIds.length === 1) {
              const geometry = this.editor.getShapeUtil(selectingShape).getGeometry(selectingShape);
              const textLabels = getTextLabels(geometry);
              const textLabel = textLabels.length === 1 ? textLabels[0] : void 0;
              if (textLabel) {
                const pointInShapeSpace = this.editor.getPointInShapeSpace(
                  selectingShape,
                  currentPagePoint
                );
                if (textLabel.bounds.containsPoint(pointInShapeSpace, 0) && textLabel.hitTestPoint(pointInShapeSpace)) {
                  this.editor.run(() => {
                    this.editor.markHistoryStoppingPoint("editing on pointer up");
                    this.editor.select(selectingShape.id);
                    const util = this.editor.getShapeUtil(selectingShape);
                    if (this.editor.getIsReadonly()) {
                      if (!util.canEditInReadonly(selectingShape)) {
                        return;
                      }
                    }
                    this.editor.setEditingShape(selectingShape.id);
                    this.editor.setCurrentTool("select.editing_shape");
                    if (this.isDoubleClick) {
                      this.editor.emit("select-all-text", { shapeId: selectingShape.id });
                    } else {
                      this.editor.emit("place-caret", {
                        shapeId: selectingShape.id,
                        point: info.point
                      });
                    }
                  });
                  return;
                }
              }
            }
            this.editor.markHistoryStoppingPoint("selecting on pointer up");
            this.editor.select(selectingShape.id);
          } else {
            this.editor.markHistoryStoppingPoint("selecting on pointer up");
            this.editor.select(selectingShape);
          }
        }
      } else if (additiveSelectionKey) {
        const ancestors = this.editor.getShapeAncestors(outermostSelectableShape);
        this.editor.markHistoryStoppingPoint("shift deselecting on pointer up");
        this.editor.setSelectedShapes([
          ...this.editor.getSelectedShapeIds().filter((id) => !ancestors.find((a) => a.id === id)),
          outermostSelectableShape.id
        ]);
      } else {
        this.editor.markHistoryStoppingPoint("selecting on pointer up");
        this.editor.setSelectedShapes([outermostSelectableShape.id]);
      }
    }
    this.parent.transition("idle", info);
  }
  onDoubleClick() {
    this.isDoubleClick = true;
  }
  onPointerMove(info) {
    if (this.editor.inputs.isDragging) {
      if (this.didCtrlOnEnter) {
        this.parent.transition("brushing", info);
      } else {
        this.startTranslating(info);
      }
    }
  }
  onLongPress(info) {
    this.startTranslating(info);
  }
  startTranslating(info) {
    if (this.editor.getIsReadonly())
      return;
    this.editor.focus();
    this.parent.transition("translating", info);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(PointingShape, "id", "pointing_shape");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Resizing.mjs
var Resizing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "markId", "");
    // A switch to detect when the user is holding ctrl
    __publicField(this, "didHoldCommand", false);
    // we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,
    // so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas
    // so we allow passing a further offset into this state to negate such issues
    __publicField(this, "creationCursorOffset", { x: 0, y: 0 });
    __publicField(this, "snapshot", {});
  }
  onEnter(info) {
    const { isCreating = false, creatingMarkId, creationCursorOffset = { x: 0, y: 0 } } = info;
    this.info = info;
    this.didHoldCommand = false;
    this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    this.creationCursorOffset = creationCursorOffset;
    try {
      this.snapshot = this._createSnapshot();
    } catch (e) {
      console.error(e);
      this.cancel();
      return;
    }
    this.markId = "";
    if (isCreating) {
      if (creatingMarkId) {
        this.markId = creatingMarkId;
      } else {
        const markId = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        if (markId) {
          this.markId = markId;
        }
      }
    } else {
      this.markId = this.editor.markHistoryStoppingPoint("starting resizing");
    }
    if (isCreating) {
      this.editor.setCursor({ type: "cross", rotation: 0 });
    }
    this.handleResizeStart();
    this.updateShapes();
  }
  onTick({ elapsed }) {
    const { editor } = this;
    editor.edgeScrollManager.updateEdgeScrolling(elapsed);
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    this.updateShapes();
  }
  onKeyUp() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, {});
    } else {
      this.parent.transition("idle");
    }
  }
  complete() {
    var _a5, _b;
    kickoutOccludedShapes(this.editor, this.snapshot.selectedShapeIds);
    this.handleResizeEnd();
    if (this.info.isCreating && this.info.onCreate) {
      (_b = (_a5 = this.info).onCreate) == null ? void 0 : _b.call(_a5, this.editor.getOnlySelectedShape());
      return;
    }
    if (this.editor.getInstanceState().isToolLocked && this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, {});
      return;
    }
    this.parent.transition("idle");
  }
  handleResizeStart() {
    const { shapeSnapshots } = this.snapshot;
    const changes = [];
    shapeSnapshots.forEach(({ shape }) => {
      var _a5;
      const util = this.editor.getShapeUtil(shape);
      const change = (_a5 = util.onResizeStart) == null ? void 0 : _a5.call(util, shape);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  handleResizeEnd() {
    const { shapeSnapshots } = this.snapshot;
    const changes = [];
    shapeSnapshots.forEach(({ shape }) => {
      var _a5;
      const current = this.editor.getShape(shape.id);
      const util = this.editor.getShapeUtil(shape);
      const change = (_a5 = util.onResizeEnd) == null ? void 0 : _a5.call(util, shape, current);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  updateShapes() {
    const { altKey: altKey2, shiftKey } = this.editor.inputs;
    const {
      frames,
      shapeSnapshots,
      selectionBounds,
      cursorHandleOffset,
      selectedShapeIds,
      selectionRotation,
      canShapesDeform
    } = this.snapshot;
    let isAspectRatioLocked = shiftKey || !canShapesDeform;
    if (shapeSnapshots.size === 1) {
      const onlySnapshot = [...shapeSnapshots.values()][0];
      if (this.editor.isShapeOfType(onlySnapshot.shape, "text")) {
        isAspectRatioLocked = !(this.info.handle === "left" || this.info.handle === "right");
      }
    }
    const { ctrlKey } = this.editor.inputs;
    const currentPagePoint = this.editor.inputs.currentPagePoint.clone().sub(cursorHandleOffset).sub(this.creationCursorOffset);
    const originPagePoint = this.editor.inputs.originPagePoint.clone().sub(cursorHandleOffset);
    if (this.editor.getInstanceState().isGridMode && !ctrlKey) {
      const { gridSize } = this.editor.getDocumentSettings();
      currentPagePoint.snapToGrid(gridSize);
    }
    const dragHandle = this.info.handle;
    const scaleOriginHandle = rotateSelectionHandle2(dragHandle, Math.PI);
    this.editor.snaps.clearIndicators();
    const shouldSnap = this.editor.user.getIsSnapMode() ? !ctrlKey : ctrlKey;
    if (shouldSnap && selectionRotation % HALF_PI === 0) {
      const { nudge } = this.editor.snaps.shapeBounds.snapResizeShapes({
        dragDelta: Vec.Sub(currentPagePoint, originPagePoint),
        initialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,
        handle: rotateSelectionHandle2(dragHandle, selectionRotation),
        isAspectRatioLocked,
        isResizingFromCenter: altKey2
      });
      currentPagePoint.add(nudge);
    }
    const scaleOriginPage = Vec.RotWith(
      altKey2 ? selectionBounds.center : selectionBounds.getHandlePoint(scaleOriginHandle),
      selectionBounds.point,
      selectionRotation
    );
    const distanceFromScaleOriginNow = Vec.Sub(currentPagePoint, scaleOriginPage).rot(
      -selectionRotation
    );
    const distanceFromScaleOriginAtStart = Vec.Sub(originPagePoint, scaleOriginPage).rot(
      -selectionRotation
    );
    const scale = Vec.DivV(distanceFromScaleOriginNow, distanceFromScaleOriginAtStart);
    if (!Number.isFinite(scale.x))
      scale.x = 1;
    if (!Number.isFinite(scale.y))
      scale.y = 1;
    const isXLocked = dragHandle === "top" || dragHandle === "bottom";
    const isYLocked = dragHandle === "left" || dragHandle === "right";
    if (isAspectRatioLocked) {
      if (isYLocked) {
        scale.y = Math.abs(scale.x);
      } else if (isXLocked) {
        scale.x = Math.abs(scale.y);
      } else if (Math.abs(scale.x) > Math.abs(scale.y)) {
        scale.y = Math.abs(scale.x) * (scale.y < 0 ? -1 : 1);
      } else {
        scale.x = Math.abs(scale.y) * (scale.x < 0 ? -1 : 1);
      }
    } else {
      if (isXLocked) {
        scale.x = 1;
      }
      if (isYLocked) {
        scale.y = 1;
      }
    }
    if (!this.info.isCreating) {
      this.updateCursor({
        dragHandle,
        isFlippedX: scale.x < 0,
        isFlippedY: scale.y < 0,
        rotation: selectionRotation
      });
    }
    for (const id of shapeSnapshots.keys()) {
      const snapshot = shapeSnapshots.get(id);
      this.editor.resizeShape(id, scale, {
        initialShape: snapshot.shape,
        initialBounds: snapshot.bounds,
        initialPageTransform: snapshot.pageTransform,
        dragHandle,
        mode: selectedShapeIds.length === 1 && id === selectedShapeIds[0] ? "resize_bounds" : "scale_shape",
        scaleOrigin: scaleOriginPage,
        isAspectRatioLocked,
        scaleAxisRotation: selectionRotation,
        skipStartAndEndCallbacks: true
      });
    }
    if (this.editor.inputs.ctrlKey) {
      this.didHoldCommand = true;
      for (const { id, children } of frames) {
        if (!children.length)
          continue;
        const initial = shapeSnapshots.get(id).shape;
        const current = this.editor.getShape(id);
        if (!(initial && current))
          continue;
        const dx = current.x - initial.x;
        const dy = current.y - initial.y;
        const delta = new Vec(dx, dy).rot(-initial.rotation);
        if (delta.x !== 0 || delta.y !== 0) {
          for (const child of children) {
            this.editor.updateShape({
              id: child.id,
              type: child.type,
              x: child.x - delta.x,
              y: child.y - delta.y
            });
          }
        }
      }
    } else if (this.didHoldCommand) {
      this.didHoldCommand = false;
      for (const { children } of frames) {
        if (!children.length)
          continue;
        for (const child of children) {
          this.editor.updateShape({
            id: child.id,
            type: child.type,
            x: child.x,
            y: child.y
          });
        }
      }
    }
  }
  // ---
  updateCursor({
    dragHandle,
    isFlippedX,
    isFlippedY,
    rotation
  }) {
    const nextCursor = { ...this.editor.getInstanceState().cursor };
    switch (dragHandle) {
      case "top_left":
      case "bottom_right": {
        nextCursor.type = "nwse-resize";
        if (isFlippedX !== isFlippedY) {
          nextCursor.type = "nesw-resize";
        }
        break;
      }
      case "top_right":
      case "bottom_left": {
        nextCursor.type = "nesw-resize";
        if (isFlippedX !== isFlippedY) {
          nextCursor.type = "nwse-resize";
        }
        break;
      }
    }
    nextCursor.rotation = rotation;
    this.editor.setCursor(nextCursor);
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.editor.snaps.clearIndicators();
  }
  _createSnapshot() {
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    const selectionRotation = this.editor.getSelectionRotation();
    const {
      inputs: { originPagePoint }
    } = this.editor;
    const selectionBounds = this.editor.getSelectionRotatedPageBounds();
    if (!selectionBounds)
      throw Error("Resizing but nothing is selected");
    const dragHandlePoint = Vec.RotWith(
      selectionBounds.getHandlePoint(this.info.handle),
      selectionBounds.point,
      selectionRotation
    );
    const cursorHandleOffset = Vec.Sub(originPagePoint, dragHandlePoint);
    const shapeSnapshots = /* @__PURE__ */ new Map();
    const frames = [];
    selectedShapeIds.forEach((id) => {
      const shape = this.editor.getShape(id);
      if (shape) {
        if (shape.type === "frame") {
          frames.push({
            id,
            children: compact(
              this.editor.getSortedChildIdsForParent(shape).map((id2) => this.editor.getShape(id2))
            )
          });
        }
        shapeSnapshots.set(shape.id, this._createShapeSnapshot(shape));
        if (this.editor.isShapeOfType(shape, "frame") && selectedShapeIds.length === 1)
          return;
        this.editor.visitDescendants(shape.id, (descendantId) => {
          const descendent = this.editor.getShape(descendantId);
          if (descendent) {
            shapeSnapshots.set(descendent.id, this._createShapeSnapshot(descendent));
            if (this.editor.isShapeOfType(descendent, "frame")) {
              return false;
            }
          }
        });
      }
    });
    const canShapesDeform = ![...shapeSnapshots.values()].some(
      (shape) => !areAnglesCompatible(shape.pageRotation, selectionRotation) || shape.isAspectRatioLocked
    );
    return {
      shapeSnapshots,
      selectionBounds,
      cursorHandleOffset,
      selectionRotation,
      selectedShapeIds,
      canShapesDeform,
      initialSelectionPageBounds: this.editor.getSelectionPageBounds(),
      frames
    };
  }
  _createShapeSnapshot(shape) {
    const pageTransform = this.editor.getShapePageTransform(shape);
    const util = this.editor.getShapeUtil(shape);
    return {
      shape,
      bounds: this.editor.getShapeGeometry(shape).bounds,
      pageTransform,
      pageRotation: Mat.Decompose(pageTransform).rotation,
      isAspectRatioLocked: util.isAspectRatioLocked(shape)
    };
  }
};
__publicField(Resizing, "id", "resizing");
var ORDERED_SELECTION_HANDLES2 = [
  "top",
  "top_right",
  "right",
  "bottom_right",
  "bottom",
  "bottom_left",
  "left",
  "top_left"
];
function rotateSelectionHandle2(handle, rotation) {
  rotation = rotation % PI2;
  const numSteps = Math.round(rotation / (PI / 4));
  const currentIndex = ORDERED_SELECTION_HANDLES2.indexOf(handle);
  return ORDERED_SELECTION_HANDLES2[(currentIndex + numSteps) % ORDERED_SELECTION_HANDLES2.length];
}

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Rotating.mjs
var ONE_DEGREE = Math.PI / 180;
var Rotating = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "snapshot", {});
    __publicField(this, "info", {});
    __publicField(this, "markId", "");
  }
  onEnter(info) {
    this.info = info;
    this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    this.markId = this.editor.markHistoryStoppingPoint("rotate start");
    const snapshot = getRotationSnapshot({
      editor: this.editor,
      ids: this.editor.getSelectedShapeIds()
    });
    if (!snapshot)
      return this.parent.transition("idle", this.info);
    this.snapshot = snapshot;
    const newSelectionRotation = this._getRotationFromPointerPosition({
      snapToNearestDegree: false
    });
    applyRotationToSnapshotShapes({
      editor: this.editor,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: false }),
      snapshot: this.snapshot,
      stage: "start"
    });
    this.editor.setCursor({
      type: CursorTypeMap[this.info.handle],
      rotation: newSelectionRotation + this.snapshot.initialShapesRotation
    });
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.parent.setCurrentToolIdMask(void 0);
    this.snapshot = {};
  }
  onPointerMove() {
    this.update();
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  // ---
  update() {
    const newSelectionRotation = this._getRotationFromPointerPosition({
      snapToNearestDegree: false
    });
    applyRotationToSnapshotShapes({
      editor: this.editor,
      delta: newSelectionRotation,
      snapshot: this.snapshot,
      stage: "update"
    });
    this.editor.setCursor({
      type: CursorTypeMap[this.info.handle],
      rotation: newSelectionRotation + this.snapshot.initialShapesRotation
    });
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, this.info);
    } else {
      this.parent.transition("idle", this.info);
    }
  }
  complete() {
    applyRotationToSnapshotShapes({
      editor: this.editor,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: true }),
      snapshot: this.snapshot,
      stage: "end"
    });
    kickoutOccludedShapes(
      this.editor,
      this.snapshot.shapeSnapshots.map((s) => s.shape.id)
    );
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, this.info);
    } else {
      this.parent.transition("idle", this.info);
    }
  }
  _getRotationFromPointerPosition({ snapToNearestDegree }) {
    const {
      inputs: { shiftKey, currentPagePoint }
    } = this.editor;
    const { initialCursorAngle, initialShapesRotation, initialPageCenter } = this.snapshot;
    const preSnapRotationDelta = initialPageCenter.angle(currentPagePoint) - initialCursorAngle;
    let newSelectionRotation = initialShapesRotation + preSnapRotationDelta;
    if (shiftKey) {
      newSelectionRotation = snapAngle(newSelectionRotation, 24);
    } else if (snapToNearestDegree) {
      newSelectionRotation = Math.round(newSelectionRotation / ONE_DEGREE) * ONE_DEGREE;
      if (this.editor.getInstanceState().isCoarsePointer) {
        const snappedToRightAngle = snapAngle(newSelectionRotation, 4);
        const angleToRightAngle = shortAngleDist(newSelectionRotation, snappedToRightAngle);
        if (Math.abs(angleToRightAngle) < degreesToRadians(5)) {
          newSelectionRotation = snappedToRightAngle;
        }
      }
    }
    return newSelectionRotation - initialShapesRotation;
  }
};
__publicField(Rotating, "id", "rotating");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/ScribbleBrushing.mjs
var ScribbleBrushing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "hits", /* @__PURE__ */ new Set());
    __publicField(this, "size", 0);
    __publicField(this, "scribbleId", "id");
    __publicField(this, "initialSelectedShapeIds", /* @__PURE__ */ new Set());
    __publicField(this, "newlySelectedShapeIds", /* @__PURE__ */ new Set());
  }
  onEnter() {
    this.initialSelectedShapeIds = new Set(
      this.editor.inputs.shiftKey ? this.editor.getSelectedShapeIds() : []
    );
    this.newlySelectedShapeIds = /* @__PURE__ */ new Set();
    this.size = 0;
    this.hits.clear();
    const scribbleItem = this.editor.scribbles.addScribble({
      color: "selection-stroke",
      opacity: 0.32,
      size: 12
    });
    this.scribbleId = scribbleItem.id;
    this.updateScribbleSelection(true);
    this.editor.updateInstanceState({ brush: null });
  }
  onExit() {
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.updateScribbleSelection(true);
  }
  onPointerUp() {
    this.complete();
  }
  onKeyDown() {
    this.updateScribbleSelection(false);
  }
  onKeyUp() {
    if (!this.editor.inputs.altKey) {
      this.parent.transition("brushing");
    } else {
      this.updateScribbleSelection(false);
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  pushPointToScribble() {
    const { x, y } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, x, y);
  }
  updateScribbleSelection(addPoint) {
    const { editor } = this;
    const currentPageShapes = this.editor.getCurrentPageRenderingShapesSorted();
    const {
      inputs: { shiftKey, originPagePoint, previousPagePoint, currentPagePoint }
    } = this.editor;
    const { newlySelectedShapeIds, initialSelectedShapeIds } = this;
    if (addPoint) {
      this.pushPointToScribble();
    }
    const shapes = currentPageShapes;
    let shape, geometry, A, B;
    const minDist = 0;
    for (let i = 0, n = shapes.length; i < n; i++) {
      shape = shapes[i];
      if (editor.isShapeOfType(shape, "group") || newlySelectedShapeIds.has(shape.id) || editor.isShapeOrAncestorLocked(shape)) {
        continue;
      }
      geometry = editor.getShapeGeometry(shape);
      if (editor.isShapeOfType(shape, "frame") && geometry.bounds.containsPoint(editor.getPointInShapeSpace(shape, originPagePoint))) {
        continue;
      }
      const pageTransform = editor.getShapePageTransform(shape);
      if (!geometry || !pageTransform)
        continue;
      const pt = pageTransform.clone().invert();
      A = pt.applyToPoint(previousPagePoint);
      B = pt.applyToPoint(currentPagePoint);
      const { bounds } = geometry;
      if (bounds.minX - minDist > Math.max(A.x, B.x) || bounds.minY - minDist > Math.max(A.y, B.y) || bounds.maxX + minDist < Math.min(A.x, B.x) || bounds.maxY + minDist < Math.min(A.y, B.y)) {
        continue;
      }
      if (geometry.hitTestLineSegment(A, B, minDist)) {
        const outermostShape = this.editor.getOutermostSelectableShape(shape);
        const pageMask = this.editor.getShapeMask(outermostShape.id);
        if (pageMask) {
          const intersection = intersectLineSegmentPolygon(
            previousPagePoint,
            currentPagePoint,
            pageMask
          );
          if (intersection !== null) {
            const isInMask = pointInPolygon(currentPagePoint, pageMask);
            if (!isInMask)
              continue;
          }
        }
        newlySelectedShapeIds.add(outermostShape.id);
      }
    }
    const current = editor.getSelectedShapeIds();
    const next = new Set(
      shiftKey ? [...newlySelectedShapeIds, ...initialSelectedShapeIds] : [...newlySelectedShapeIds]
    );
    if (current.length !== next.size || current.some((id) => !next.has(id))) {
      this.editor.setSelectedShapes(Array.from(next));
    }
  }
  complete() {
    this.updateScribbleSelection(true);
    this.parent.transition("idle");
  }
  cancel() {
    this.editor.setSelectedShapes([...this.initialSelectedShapeIds]);
    this.parent.transition("idle");
  }
};
__publicField(ScribbleBrushing, "id", "scribble_brushing");

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/DragAndDropManager.mjs
var __create10 = Object.create;
var __defProp10 = Object.defineProperty;
var __getOwnPropDesc10 = Object.getOwnPropertyDescriptor;
var __knownSymbol10 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError10 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp10 = (obj, key, value) => key in obj ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name10 = (target, value) => __defProp10(target, "name", { value, configurable: true });
var __decoratorStart10 = (base2) => [, , , __create10((base2 == null ? void 0 : base2[__knownSymbol10("metadata")]) ?? null)];
var __decoratorStrings10 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn10 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError10("Function expected") : fn2;
var __decoratorContext10 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings10[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError10("Already initialized") : fns.push(__expectFn10(fn2 || null)) });
var __decoratorMetadata10 = (array2, target) => __defNormalProp10(target, __knownSymbol10("metadata"), array2[3]);
var __runInitializers10 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement10 = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings10[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc10(k < 4 ? target : { get [name]() {
    return __privateGet11(this, extra);
  }, set [name](x) {
    return __privateSet11(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name10(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name10(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext10(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn10(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet11 : __privateMethod10)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet11(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn10(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError10("Object expected");
    else
      __expectFn10(fn2 = it.get) && (desc.get = fn2), __expectFn10(fn2 = it.set) && (desc.set = fn2), __expectFn10(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata10(array2, target), desc && __defProp10(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField11 = (obj, key, value) => __defNormalProp10(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck10 = (obj, member, msg2) => member.has(obj) || __typeError10("Cannot " + msg2);
var __privateIn10 = (member, obj) => Object(obj) !== obj ? __typeError10('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet11 = (obj, member, getter) => (__accessCheck10(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet11 = (obj, member, value, setter) => (__accessCheck10(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod10 = (obj, member, method) => (__accessCheck10(obj, member, "access private method"), method);
var _dispose_dec2;
var _init10;
var INITIAL_POINTER_LAG_DURATION = 20;
var FAST_POINTER_LAG_DURATION = 100;
_dispose_dec2 = [bind];
var DragAndDropManager = class {
  constructor(editor) {
    this.editor = editor;
    __runInitializers10(_init10, 5, this);
    __publicField11(this, "prevDroppingShapeId", null);
    __publicField11(this, "droppingNodeTimer", null);
    __publicField11(this, "first", true);
    editor.disposables.add(this.dispose);
  }
  updateDroppingNode(movingShapes, cb) {
    var _a5;
    if (this.first) {
      this.editor.setHintingShapes(
        movingShapes.map((s) => this.editor.findShapeAncestor(s, (v) => v.type !== "group")).filter((s) => s)
      );
      this.prevDroppingShapeId = ((_a5 = this.editor.getDroppingOverShape(this.editor.inputs.originPagePoint, movingShapes)) == null ? void 0 : _a5.id) ?? null;
      this.first = false;
    }
    if (this.droppingNodeTimer === null) {
      this.setDragTimer(movingShapes, INITIAL_POINTER_LAG_DURATION, cb);
    } else if (this.editor.inputs.pointerVelocity.len() > 0.5) {
      clearTimeout(this.droppingNodeTimer);
      this.setDragTimer(movingShapes, FAST_POINTER_LAG_DURATION, cb);
    }
  }
  setDragTimer(movingShapes, duration, cb) {
    this.droppingNodeTimer = this.editor.timers.setTimeout(() => {
      this.editor.run(() => {
        this.handleDrag(this.editor.inputs.currentPagePoint, movingShapes, cb);
      });
      this.droppingNodeTimer = null;
    }, duration);
  }
  handleDrag(point, movingShapes, cb) {
    var _a5, _b, _c, _d, _e;
    movingShapes = compact(movingShapes.map((shape) => this.editor.getShape(shape.id)));
    const nextDroppingShapeId = ((_a5 = this.editor.getDroppingOverShape(point, movingShapes)) == null ? void 0 : _a5.id) ?? null;
    if (nextDroppingShapeId === this.prevDroppingShapeId) {
      this.hintParents(movingShapes);
      return;
    }
    const { prevDroppingShapeId } = this;
    const prevDroppingShape = prevDroppingShapeId && this.editor.getShape(prevDroppingShapeId);
    const nextDroppingShape = nextDroppingShapeId && this.editor.getShape(nextDroppingShapeId);
    if (prevDroppingShape) {
      (_c = (_b = this.editor.getShapeUtil(prevDroppingShape)).onDragShapesOut) == null ? void 0 : _c.call(_b, prevDroppingShape, movingShapes);
    }
    if (nextDroppingShape) {
      (_e = (_d = this.editor.getShapeUtil(nextDroppingShape)).onDragShapesOver) == null ? void 0 : _e.call(_d, nextDroppingShape, movingShapes);
    }
    this.hintParents(movingShapes);
    cb == null ? void 0 : cb();
    this.prevDroppingShapeId = nextDroppingShapeId;
  }
  hintParents(movingShapes) {
    const shapesGroupedByAncestor = /* @__PURE__ */ new Map();
    for (const shape of movingShapes) {
      const ancestor = this.editor.findShapeAncestor(shape, (v) => v.type !== "group");
      if (!ancestor)
        continue;
      if (!shapesGroupedByAncestor.has(ancestor.id)) {
        shapesGroupedByAncestor.set(ancestor.id, []);
      }
      shapesGroupedByAncestor.get(ancestor.id).push(shape.id);
    }
    const hintingShapes = [];
    for (const [ancestorId, shapeIds] of shapesGroupedByAncestor) {
      const ancestor = this.editor.getShape(ancestorId);
      if (!ancestor)
        continue;
      if (getOccludedChildren(this.editor, ancestor).length < shapeIds.length) {
        hintingShapes.push(ancestor.id);
      }
    }
    this.editor.setHintingShapes(hintingShapes);
  }
  dropShapes(shapes) {
    var _a5, _b;
    const { prevDroppingShapeId } = this;
    this.handleDrag(this.editor.inputs.currentPagePoint, shapes);
    if (prevDroppingShapeId) {
      const shape = this.editor.getShape(prevDroppingShapeId);
      if (!shape)
        return;
      (_b = (_a5 = this.editor.getShapeUtil(shape)).onDropShapesOver) == null ? void 0 : _b.call(_a5, shape, shapes);
    }
  }
  clear() {
    this.prevDroppingShapeId = null;
    if (this.droppingNodeTimer !== null) {
      clearTimeout(this.droppingNodeTimer);
    }
    this.droppingNodeTimer = null;
    this.editor.setHintingShapes([]);
    this.first = true;
  }
  dispose() {
    this.clear();
  }
};
_init10 = __decoratorStart10(null);
__decorateElement10(_init10, 1, "dispose", _dispose_dec2, DragAndDropManager);
__decoratorMetadata10(_init10, DragAndDropManager);

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Translating.mjs
var __create11 = Object.create;
var __defProp11 = Object.defineProperty;
var __getOwnPropDesc11 = Object.getOwnPropertyDescriptor;
var __knownSymbol11 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError11 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp11 = (obj, key, value) => key in obj ? __defProp11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name11 = (target, value) => __defProp11(target, "name", { value, configurable: true });
var __decoratorStart11 = (base2) => [, , , __create11((base2 == null ? void 0 : base2[__knownSymbol11("metadata")]) ?? null)];
var __decoratorStrings11 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn11 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError11("Function expected") : fn2;
var __decoratorContext11 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings11[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError11("Already initialized") : fns.push(__expectFn11(fn2 || null)) });
var __decoratorMetadata11 = (array2, target) => __defNormalProp11(target, __knownSymbol11("metadata"), array2[3]);
var __runInitializers11 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement11 = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings11[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc11(k < 4 ? target : { get [name]() {
    return __privateGet12(this, extra);
  }, set [name](x) {
    return __privateSet12(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name11(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name11(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext11(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn11(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet12 : __privateMethod11)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet12(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn11(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError11("Object expected");
    else
      __expectFn11(fn2 = it.get) && (desc.get = fn2), __expectFn11(fn2 = it.set) && (desc.set = fn2), __expectFn11(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata11(array2, target), desc && __defProp11(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField12 = (obj, key, value) => __defNormalProp11(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck11 = (obj, member, msg2) => member.has(obj) || __typeError11("Cannot " + msg2);
var __privateIn11 = (member, obj) => Object(obj) !== obj ? __typeError11('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet12 = (obj, member, getter) => (__accessCheck11(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet12 = (obj, member, value, setter) => (__accessCheck11(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod11 = (obj, member, method) => (__accessCheck11(obj, member, "access private method"), method);
var _updateParentTransforms_dec;
var _a4;
var _init11;
var Translating = class extends (_a4 = StateNode, _updateParentTransforms_dec = [bind], _a4) {
  constructor() {
    super(...arguments);
    __runInitializers11(_init11, 5, this);
    __publicField12(this, "info", {});
    __publicField12(this, "selectionSnapshot", {});
    __publicField12(this, "snapshot", {});
    __publicField12(this, "markId", "");
    __publicField12(this, "isCloning", false);
    __publicField12(this, "isCreating", false);
    __publicField12(this, "dragAndDropManager", new DragAndDropManager(this.editor));
  }
  onCreate(_shape) {
    return;
  }
  onEnter(info) {
    var _a5;
    const { isCreating = false, creatingMarkId, onCreate: onCreate2 = () => void 0 } = info;
    if (!((_a5 = this.editor.getSelectedShapeIds()) == null ? void 0 : _a5.length)) {
      this.parent.transition("idle");
      return;
    }
    this.info = info;
    this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    this.isCreating = isCreating;
    this.markId = "";
    if (isCreating) {
      if (creatingMarkId) {
        this.markId = creatingMarkId;
      } else {
        const markId = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        if (markId) {
          this.markId = markId;
        }
      }
    } else {
      this.markId = this.editor.markHistoryStoppingPoint("translating");
    }
    this.onCreate = onCreate2;
    this.isCloning = false;
    this.info = info;
    this.editor.setCursor({ type: "move", rotation: 0 });
    this.selectionSnapshot = getTranslatingSnapshot(this.editor);
    if (!this.isCreating) {
      if (this.editor.inputs.altKey) {
        this.startCloning();
        return;
      }
    }
    this.snapshot = this.selectionSnapshot;
    this.handleStart();
    this.updateShapes();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.selectionSnapshot = {};
    this.snapshot = {};
    this.editor.snaps.clearIndicators();
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.dragAndDropManager.clear();
  }
  onTick({ elapsed }) {
    const { editor } = this;
    this.dragAndDropManager.updateDroppingNode(
      this.snapshot.movingShapes,
      this.updateParentTransforms
    );
    editor.edgeScrollManager.updateEdgeScrolling(elapsed);
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    if (this.editor.inputs.altKey && !this.isCloning) {
      this.startCloning();
      return;
    }
    this.updateShapes();
  }
  onKeyUp() {
    if (!this.editor.inputs.altKey && this.isCloning) {
      this.stopCloning();
      return;
    }
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  startCloning() {
    if (this.isCreating)
      return;
    this.isCloning = true;
    this.reset();
    this.markId = this.editor.markHistoryStoppingPoint("translate cloning");
    this.editor.duplicateShapes(Array.from(this.editor.getSelectedShapeIds()));
    this.snapshot = getTranslatingSnapshot(this.editor);
    this.handleStart();
    this.updateShapes();
  }
  stopCloning() {
    this.isCloning = false;
    this.snapshot = this.selectionSnapshot;
    this.reset();
    this.markId = this.editor.markHistoryStoppingPoint("translate");
    this.updateShapes();
  }
  reset() {
    this.editor.bailToMark(this.markId);
  }
  complete() {
    var _a5;
    this.updateShapes();
    this.dragAndDropManager.dropShapes(this.snapshot.movingShapes);
    kickoutOccludedShapes(
      this.editor,
      this.snapshot.movingShapes.map((s) => s.id)
    );
    this.handleEnd();
    if (this.editor.getInstanceState().isToolLocked && this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd);
    } else {
      if (this.isCreating) {
        (_a5 = this.onCreate) == null ? void 0 : _a5.call(this, this.editor.getOnlySelectedShape());
      } else {
        this.parent.transition("idle");
      }
    }
  }
  cancel() {
    this.reset();
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd);
    } else {
      this.parent.transition("idle", this.info);
    }
  }
  handleStart() {
    const { movingShapes } = this.snapshot;
    const changes = [];
    movingShapes.forEach((shape) => {
      var _a5;
      const util = this.editor.getShapeUtil(shape);
      const change = (_a5 = util.onTranslateStart) == null ? void 0 : _a5.call(util, shape);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
    this.editor.setHoveredShape(null);
  }
  handleEnd() {
    const { movingShapes } = this.snapshot;
    if (this.isCloning && movingShapes.length > 0) {
      const currentAveragePagePoint = Vec.Average(
        movingShapes.map((s) => this.editor.getShapePageTransform(s.id).point())
      );
      const offset5 = Vec.Sub(currentAveragePagePoint, this.selectionSnapshot.averagePagePoint);
      if (!Vec.IsNaN(offset5)) {
        this.editor.updateInstanceState({
          duplicateProps: {
            shapeIds: movingShapes.map((s) => s.id),
            offset: { x: offset5.x, y: offset5.y }
          }
        });
      }
    }
    const changes = [];
    movingShapes.forEach((shape) => {
      var _a5;
      const current = this.editor.getShape(shape.id);
      const util = this.editor.getShapeUtil(shape);
      const change = (_a5 = util.onTranslateEnd) == null ? void 0 : _a5.call(util, shape, current);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  updateShapes() {
    const { snapshot } = this;
    this.dragAndDropManager.updateDroppingNode(snapshot.movingShapes, this.updateParentTransforms);
    moveShapesToPoint({
      editor: this.editor,
      snapshot
    });
    const { movingShapes } = snapshot;
    const changes = [];
    movingShapes.forEach((shape) => {
      var _a5;
      const current = this.editor.getShape(shape.id);
      const util = this.editor.getShapeUtil(shape);
      const change = (_a5 = util.onTranslate) == null ? void 0 : _a5.call(util, shape, current);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  updateParentTransforms() {
    const {
      editor,
      snapshot: { shapeSnapshots }
    } = this;
    const movingShapes = [];
    shapeSnapshots.forEach((shapeSnapshot) => {
      const shape = editor.getShape(shapeSnapshot.shape.id);
      if (!shape)
        return null;
      movingShapes.push(shape);
      const parentTransform = isPageId(shape.parentId) ? null : Mat.Inverse(editor.getShapePageTransform(shape.parentId));
      shapeSnapshot.parentTransform = parentTransform;
    });
  }
};
_init11 = __decoratorStart11(_a4);
__decorateElement11(_init11, 1, "updateParentTransforms", _updateParentTransforms_dec, Translating);
__decoratorMetadata11(_init11, Translating);
__publicField12(Translating, "id", "translating");
function getTranslatingSnapshot(editor) {
  var _a5;
  const movingShapes = [];
  const pagePoints = [];
  const selectedShapeIds = editor.getSelectedShapeIds();
  const shapeSnapshots = compact(
    selectedShapeIds.map((id) => {
      const shape = editor.getShape(id);
      if (!shape)
        return null;
      movingShapes.push(shape);
      const pageTransform = editor.getShapePageTransform(id);
      const pagePoint = pageTransform.point();
      const pageRotation = pageTransform.rotation();
      pagePoints.push(pagePoint);
      const parentTransform = PageRecordType.isId(shape.parentId) ? null : Mat.Inverse(editor.getShapePageTransform(shape.parentId));
      return {
        shape,
        pagePoint,
        pageRotation,
        parentTransform
      };
    })
  );
  const onlySelectedShape = editor.getOnlySelectedShape();
  let initialSnapPoints = [];
  if (onlySelectedShape) {
    initialSnapPoints = editor.snaps.shapeBounds.getSnapPoints(onlySelectedShape.id);
  } else {
    const selectionPageBounds = editor.getSelectionPageBounds();
    if (selectionPageBounds) {
      initialSnapPoints = selectionPageBounds.cornersAndCenter.map((p, i) => ({
        id: "selection:" + i,
        x: p.x,
        y: p.y
      }));
    }
  }
  let noteAdjacentPositions;
  let noteSnapshot;
  const { originPagePoint } = editor.inputs;
  const allHoveredNotes = shapeSnapshots.filter(
    (s) => editor.isShapeOfType(s.shape, "note") && editor.isPointInShape(s.shape, originPagePoint)
  );
  if (allHoveredNotes.length === 0) {
  } else if (allHoveredNotes.length === 1) {
    noteSnapshot = allHoveredNotes[0];
  } else {
    const allShapesSorted = editor.getCurrentPageShapesSorted();
    noteSnapshot = (_a5 = allHoveredNotes.map((s) => ({
      snapshot: s,
      index: allShapesSorted.findIndex((shape) => shape.id === s.shape.id)
    })).sort((a, b) => b.index - a.index)[0]) == null ? void 0 : _a5.snapshot;
  }
  if (noteSnapshot) {
    noteAdjacentPositions = getAvailableNoteAdjacentPositions(
      editor,
      noteSnapshot.pageRotation,
      noteSnapshot.shape.props.scale,
      noteSnapshot.shape.props.growY ?? 0
    );
  }
  return {
    averagePagePoint: Vec.Average(pagePoints),
    movingShapes,
    shapeSnapshots,
    initialPageBounds: editor.getSelectionPageBounds(),
    initialSnapPoints,
    noteAdjacentPositions,
    noteSnapshot
  };
}
function moveShapesToPoint({
  editor,
  snapshot
}) {
  const { inputs } = editor;
  const {
    noteSnapshot,
    noteAdjacentPositions,
    initialPageBounds,
    initialSnapPoints,
    shapeSnapshots,
    averagePagePoint
  } = snapshot;
  const isGridMode = editor.getInstanceState().isGridMode;
  const gridSize = editor.getDocumentSettings().gridSize;
  const delta = Vec.Sub(inputs.currentPagePoint, inputs.originPagePoint);
  const flatten = editor.inputs.shiftKey ? Math.abs(delta.x) < Math.abs(delta.y) ? "x" : "y" : null;
  if (flatten === "x") {
    delta.x = 0;
  } else if (flatten === "y") {
    delta.y = 0;
  }
  editor.snaps.clearIndicators();
  const isSnapping = editor.user.getIsSnapMode() ? !inputs.ctrlKey : inputs.ctrlKey;
  let snappedToPit = false;
  if (isSnapping && editor.inputs.pointerVelocity.len() < 0.5) {
    const { nudge } = editor.snaps.shapeBounds.snapTranslateShapes({
      dragDelta: delta,
      initialSelectionPageBounds: initialPageBounds,
      lockedAxis: flatten,
      initialSelectionSnapPoints: initialSnapPoints
    });
    delta.add(nudge);
  } else {
    if (noteSnapshot && noteAdjacentPositions) {
      const { scale } = noteSnapshot.shape.props;
      const pageCenter = noteSnapshot.pagePoint.clone().add(delta).add(NOTE_CENTER_OFFSET.clone().mul(scale).rot(noteSnapshot.pageRotation));
      let min4 = NOTE_ADJACENT_POSITION_SNAP_RADIUS / editor.getZoomLevel();
      let offset5 = new Vec(0, 0);
      for (const pit of noteAdjacentPositions) {
        const deltaToPit = Vec.Sub(pageCenter, pit);
        const dist = deltaToPit.len();
        if (dist < min4) {
          snappedToPit = true;
          min4 = dist;
          offset5 = deltaToPit;
        }
      }
      delta.sub(offset5);
    }
  }
  const averageSnappedPoint = Vec.Add(averagePagePoint, delta);
  const snapIndicators = editor.snaps.getIndicators();
  if (isGridMode && !inputs.ctrlKey && !snappedToPit && snapIndicators.length === 0) {
    averageSnappedPoint.snapToGrid(gridSize);
  }
  const averageSnap = Vec.Sub(averageSnappedPoint, averagePagePoint);
  editor.updateShapes(
    compact(
      shapeSnapshots.map(({ shape, pagePoint, parentTransform }) => {
        const newPagePoint = Vec.Add(pagePoint, averageSnap);
        const newLocalPoint = parentTransform ? Mat.applyToPoint(parentTransform, newPagePoint) : newPagePoint;
        return {
          id: shape.id,
          type: shape.type,
          x: newLocalPoint.x,
          y: newLocalPoint.y
        };
      })
    )
  );
}

// node_modules/tldraw/dist-esm/lib/tools/SelectTool/SelectTool.mjs
var SelectTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "reactor");
  }
  static children() {
    return [
      Crop,
      Cropping,
      Idle12,
      PointingCanvas,
      PointingShape,
      Translating,
      Brushing,
      ScribbleBrushing,
      PointingCropHandle,
      PointingSelection,
      PointingResizeHandle,
      EditingShape,
      Resizing,
      Rotating,
      PointingRotateHandle,
      PointingArrowLabel,
      PointingHandle,
      DraggingHandle
    ];
  }
  // We want to clean up the duplicate props when the selection changes
  cleanUpDuplicateProps() {
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    const instance = this.editor.getInstanceState();
    if (!instance.duplicateProps)
      return;
    const duplicatedShapes = new Set(instance.duplicateProps.shapeIds);
    if (selectedShapeIds.length === duplicatedShapes.size && selectedShapeIds.every((shapeId) => duplicatedShapes.has(shapeId))) {
      return;
    }
    this.editor.updateInstanceState({
      duplicateProps: null
    });
  }
  onEnter() {
    this.reactor = react("clean duplicate props", () => {
      try {
        this.cleanUpDuplicateProps();
      } catch (e) {
        if (typeof process !== "undefined" && false) {
        } else {
          console.error(e);
        }
      }
    });
  }
  onExit() {
    var _a5;
    (_a5 = this.reactor) == null ? void 0 : _a5.call(this);
    if (this.editor.getCurrentPageState().editingShapeId) {
      this.editor.setEditingShape(null);
    }
  }
};
__publicField(SelectTool, "id", "select");
__publicField(SelectTool, "initial", "idle");
__publicField(SelectTool, "isLockable", false);

// node_modules/tldraw/dist-esm/lib/tools/ZoomTool/childStates/Idle.mjs
var Idle13 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  onEnter(info) {
    this.info = info;
  }
  onPointerDown() {
    this.parent.transition("pointing", this.info);
  }
};
__publicField(Idle13, "id", "idle");

// node_modules/tldraw/dist-esm/lib/tools/ZoomTool/childStates/Pointing.mjs
var Pointing9 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  onEnter(info) {
    this.info = info;
  }
  onPointerUp() {
    this.complete();
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      this.parent.transition("zoom_brushing", this.info);
    }
  }
  onCancel() {
    this.cancel();
  }
  complete() {
    const { currentScreenPoint } = this.editor.inputs;
    if (this.editor.inputs.altKey) {
      this.editor.zoomOut(currentScreenPoint, { animation: { duration: 220 } });
    } else {
      this.editor.zoomIn(currentScreenPoint, { animation: { duration: 220 } });
    }
    this.parent.transition("idle", this.info);
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
};
__publicField(Pointing9, "id", "pointing");

// node_modules/tldraw/dist-esm/lib/tools/ZoomTool/childStates/ZoomBrushing.mjs
var ZoomBrushing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "zoomBrush", new Box());
  }
  onEnter(info) {
    this.info = info;
    this.update();
  }
  onExit() {
    this.editor.updateInstanceState({ zoomBrush: null });
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  update() {
    const {
      inputs: { originPagePoint, currentPagePoint }
    } = this.editor;
    this.zoomBrush.setTo(Box.FromPoints([originPagePoint, currentPagePoint]));
    this.editor.updateInstanceState({ zoomBrush: this.zoomBrush.toJson() });
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
  complete() {
    const { zoomBrush } = this;
    const threshold = 8 / this.editor.getZoomLevel();
    if (zoomBrush.width < threshold && zoomBrush.height < threshold) {
      const point = this.editor.inputs.currentScreenPoint;
      if (this.editor.inputs.altKey) {
        this.editor.zoomOut(point, { animation: { duration: 220 } });
      } else {
        this.editor.zoomIn(point, { animation: { duration: 220 } });
      }
    } else {
      const targetZoom = this.editor.inputs.altKey ? this.editor.getZoomLevel() / 2 : void 0;
      this.editor.zoomToBounds(zoomBrush, { targetZoom, animation: { duration: 220 } });
    }
    this.parent.transition("idle", this.info);
  }
};
__publicField(ZoomBrushing, "id", "zoom_brushing");

// node_modules/tldraw/dist-esm/lib/tools/ZoomTool/ZoomTool.mjs
var ZoomTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  static children() {
    return [Idle13, ZoomBrushing, Pointing9];
  }
  onEnter(info) {
    this.info = info;
    this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.updateInstanceState({ zoomBrush: null, cursor: { type: "default", rotation: 0 } });
    this.parent.setCurrentToolIdMask(void 0);
  }
  onKeyDown() {
    this.updateCursor();
  }
  onKeyUp(info) {
    this.updateCursor();
    if (info.code === "KeyZ") {
      this.complete();
    }
  }
  onInterrupt() {
    this.complete();
  }
  complete() {
    if (this.info.onInteractionEnd && this.info.onInteractionEnd !== "select") {
      this.editor.setCurrentTool(this.info.onInteractionEnd, this.info);
    } else {
      this.parent.transition("select");
    }
  }
  updateCursor() {
    if (this.editor.inputs.altKey) {
      this.editor.setCursor({ type: "zoom-out", rotation: 0 });
    } else {
      this.editor.setCursor({ type: "zoom-in", rotation: 0 });
    }
  }
};
__publicField(ZoomTool, "id", "zoom");
__publicField(ZoomTool, "initial", "idle");
__publicField(ZoomTool, "isLockable", false);

// node_modules/tldraw/dist-esm/lib/defaultTools.mjs
var defaultTools = [EraserTool, HandTool, LaserTool, ZoomTool, SelectTool];

// node_modules/tldraw/dist-esm/lib/ui/TldrawUi.mjs
var import_jsx_runtime210 = __toESM(require_jsx_runtime(), 1);
var import_classnames36 = __toESM(require_classnames(), 1);
var import_react140 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/FollowingIndicator.mjs
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
function FollowingIndicator() {
  const editor = useEditor();
  const followingUserId = useValue("follow", () => editor.getInstanceState().followingUserId, [
    editor
  ]);
  if (!followingUserId)
    return null;
  return (0, import_jsx_runtime150.jsx)(FollowingIndicatorInner, { userId: followingUserId });
}
function FollowingIndicatorInner({ userId }) {
  const presence = usePresence(userId);
  if (!presence)
    return null;
  return (0, import_jsx_runtime150.jsx)("div", { className: "tlui-following-indicator", style: { borderColor: presence.color } });
}

// node_modules/tldraw/dist-esm/lib/ui/context/TldrawUiContextProvider.mjs
var import_jsx_runtime209 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/utils/static-assets/assetUrls.mjs
var import_react103 = __toESM(require_react(), 1);
var defaultEditorAssetUrls = {
  fonts: {
    tldraw_mono: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-Medium.woff2`,
    tldraw_mono_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-MediumItalic.woff2`,
    tldraw_mono_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-Bold.woff2`,
    tldraw_mono_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-BoldItalic.woff2`,
    tldraw_serif: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-Medium.woff2`,
    tldraw_serif_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-MediumItalic.woff2`,
    tldraw_serif_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-Bold.woff2`,
    tldraw_serif_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-BoldItalic.woff2`,
    tldraw_sans: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-Medium.woff2`,
    tldraw_sans_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-MediumItalic.woff2`,
    tldraw_sans_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-Bold.woff2`,
    tldraw_sans_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-BoldItalic.woff2`,
    tldraw_draw: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Regular.woff2`,
    tldraw_draw_italic: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Regular_Italic.woff2`,
    tldraw_draw_bold: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Bold.woff2`,
    tldraw_draw_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Bold_Italic.woff2`
  }
};
function setDefaultEditorAssetUrls(assetUrls) {
  defaultEditorAssetUrls = assetUrls;
}
function useDefaultEditorAssetsWithOverrides(overrides) {
  return (0, import_react103.useMemo)(() => {
    if (!overrides)
      return defaultEditorAssetUrls;
    return {
      fonts: { ...defaultEditorAssetUrls.fonts, ...overrides == null ? void 0 : overrides.fonts }
    };
  }, [overrides]);
}

// node_modules/tldraw/dist-esm/lib/ui/icon-types.mjs
var iconTypes = [
  "align-bottom",
  "align-center-horizontal",
  "align-center-vertical",
  "align-left",
  "align-right",
  "align-top",
  "arrow-arc",
  "arrow-elbow",
  "arrow-left",
  "arrowhead-arrow",
  "arrowhead-bar",
  "arrowhead-diamond",
  "arrowhead-dot",
  "arrowhead-none",
  "arrowhead-square",
  "arrowhead-triangle-inverted",
  "arrowhead-triangle",
  "blob",
  "bold",
  "bookmark",
  "bring-forward",
  "bring-to-front",
  "broken",
  "bulletList",
  "check-circle",
  "check",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-ne",
  "chevrons-sw",
  "clipboard-copied",
  "clipboard-copy",
  "code",
  "color",
  "comment",
  "cross-2",
  "cross-circle",
  "dash-dashed",
  "dash-dotted",
  "dash-draw",
  "dash-solid",
  "disconnected",
  "discord",
  "distribute-horizontal",
  "distribute-vertical",
  "dot",
  "dots-horizontal",
  "dots-vertical",
  "drag-handle-dots",
  "duplicate",
  "edit",
  "external-link",
  "fill-fill",
  "fill-none",
  "fill-pattern",
  "fill-semi",
  "fill-solid",
  "follow",
  "following",
  "font-draw",
  "font-mono",
  "font-sans",
  "font-serif",
  "geo-arrow-down",
  "geo-arrow-left",
  "geo-arrow-right",
  "geo-arrow-up",
  "geo-check-box",
  "geo-cloud",
  "geo-diamond",
  "geo-ellipse",
  "geo-heart",
  "geo-hexagon",
  "geo-octagon",
  "geo-oval",
  "geo-pentagon",
  "geo-rectangle",
  "geo-rhombus-2",
  "geo-rhombus",
  "geo-star",
  "geo-trapezoid",
  "geo-triangle",
  "geo-x-box",
  "github",
  "group",
  "heading",
  "help-circle",
  "highlight",
  "horizontal-align-end",
  "horizontal-align-middle",
  "horizontal-align-start",
  "info-circle",
  "italic",
  "leading",
  "link",
  "list",
  "lock",
  "manual",
  "menu",
  "minus",
  "mixed",
  "pack",
  "plus",
  "question-mark-circle",
  "question-mark",
  "redo",
  "reset-zoom",
  "rotate-ccw",
  "rotate-cw",
  "send-backward",
  "send-to-back",
  "share-1",
  "size-extra-large",
  "size-large",
  "size-medium",
  "size-small",
  "spline-cubic",
  "spline-line",
  "stack-horizontal",
  "stack-vertical",
  "status-offline",
  "stretch-horizontal",
  "stretch-vertical",
  "strike",
  "text-align-center",
  "text-align-left",
  "text-align-right",
  "toggle-off",
  "toggle-on",
  "tool-arrow",
  "tool-eraser",
  "tool-frame",
  "tool-hand",
  "tool-highlight",
  "tool-laser",
  "tool-line",
  "tool-media",
  "tool-note",
  "tool-pencil",
  "tool-pointer",
  "tool-screenshot",
  "tool-text",
  "trash",
  "twitter",
  "underline",
  "undo",
  "ungroup",
  "unlock",
  "vertical-align-end",
  "vertical-align-middle",
  "vertical-align-start",
  "warning-triangle",
  "zoom-in",
  "zoom-out"
];

// node_modules/tldraw/dist-esm/lib/ui/assetUrls.mjs
var defaultUiAssetUrls = {
  ...defaultEditorAssetUrls,
  icons: Object.fromEntries(
    iconTypes.map((name) => [name, `${getDefaultCdnBaseUrl()}/icons/icon/0_merged.svg#${name}`])
  ),
  translations: Object.fromEntries(
    LANGUAGES.map((lang) => [
      lang.locale,
      `${getDefaultCdnBaseUrl()}/translations/${lang.locale}.json`
    ])
  ),
  embedIcons: Object.fromEntries(
    DEFAULT_EMBED_DEFINITIONS.map((def) => [
      def.type,
      `${getDefaultCdnBaseUrl()}/embed-icons/${def.type}.png`
    ])
  )
};
function setDefaultUiAssetUrls(urls) {
  defaultUiAssetUrls = urls;
}
function useDefaultUiAssetUrlsWithOverrides(overrides) {
  if (!overrides)
    return defaultUiAssetUrls;
  return {
    fonts: Object.assign({ ...defaultUiAssetUrls.fonts }, { ...overrides == null ? void 0 : overrides.fonts }),
    icons: Object.assign({ ...defaultUiAssetUrls.icons }, { ...overrides == null ? void 0 : overrides.icons }),
    embedIcons: Object.assign({ ...defaultUiAssetUrls.embedIcons }, { ...overrides == null ? void 0 : overrides.embedIcons }),
    translations: Object.assign(
      { ...defaultUiAssetUrls.translations },
      { ...overrides == null ? void 0 : overrides.translations }
    )
  };
}

// node_modules/tldraw/dist-esm/lib/ui/context/components.mjs
var import_jsx_runtime208 = __toESM(require_jsx_runtime(), 1);
var import_react138 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/ActionsMenu/DefaultActionsMenu.mjs
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var import_react105 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiPopover.mjs
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var import_react104 = __toESM(require_react(), 1);
function TldrawUiPopover({ id, children, onOpenChange, open }) {
  const [isOpen, handleOpenChange] = useMenuIsOpen(id, onOpenChange);
  return (0, import_jsx_runtime151.jsx)(dist_exports11.Root, { onOpenChange: handleOpenChange, open: open || isOpen, children: (0, import_jsx_runtime151.jsx)("div", { className: "tlui-popover", children }) });
}
function TldrawUiPopoverTrigger({ children }) {
  return (0, import_jsx_runtime151.jsx)(dist_exports11.Trigger, { asChild: true, dir: "ltr", children });
}
function TldrawUiPopoverContent({
  side,
  children,
  align = "center",
  sideOffset = 8,
  alignOffset = 0,
  disableEscapeKeyDown = false,
  autoFocusFirstButton = true
}) {
  const container = useContainer();
  const ref = import_react104.default.useRef(null);
  const handleOpenAutoFocus = import_react104.default.useCallback(() => {
    var _a5;
    if (!autoFocusFirstButton)
      return;
    const buttons = ((_a5 = ref.current) == null ? void 0 : _a5.querySelectorAll("button:not([disabled])")) ?? [];
    const visibleButtons = [...buttons].filter(
      (button) => button.offsetWidth || button.offsetHeight
    );
    const firstButton = visibleButtons[0];
    if (firstButton)
      firstButton.focus();
  }, [autoFocusFirstButton]);
  return (0, import_jsx_runtime151.jsx)(dist_exports11.Portal, { container, children: (0, import_jsx_runtime151.jsx)(
    dist_exports11.Content,
    {
      className: "tlui-popover__content",
      side,
      sideOffset,
      align,
      alignOffset,
      dir: "ltr",
      ref,
      onOpenAutoFocus: handleOpenAutoFocus,
      onEscapeKeyDown: (e) => disableEscapeKeyDown && e.preventDefault(),
      children
    }
  ) });
}

// node_modules/tldraw/dist-esm/lib/ui/components/ActionsMenu/DefaultActionsMenuContent.mjs
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/hooks/menu-hooks.mjs
function shapesWithUnboundArrows(editor) {
  const selectedShapeIds = editor.getSelectedShapeIds();
  const selectedShapes = selectedShapeIds.map((id) => {
    return editor.getShape(id);
  });
  return selectedShapes.filter((shape) => {
    if (!shape)
      return false;
    if (editor.isShapeOfType(shape, "arrow")) {
      const bindings = getArrowBindings(editor, shape);
      if (bindings.start || bindings.end)
        return false;
    }
    return true;
  });
}
var useThreeStackableItems = () => {
  const editor = useEditor();
  return useValue("threeStackableItems", () => shapesWithUnboundArrows(editor).length > 2, [editor]);
};
var useIsInSelectState = () => {
  const editor = useEditor();
  return useValue("isInSelectState", () => editor.isIn("select"), [editor]);
};
var useAllowGroup = () => {
  const editor = useEditor();
  return useValue(
    "allow group",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      if (selectedShapes.length < 2)
        return false;
      for (const shape of selectedShapes) {
        if (editor.isShapeOfType(shape, "arrow")) {
          const bindings = getArrowBindings(editor, shape);
          if (bindings.start) {
            if (!selectedShapes.some((s) => s.id === bindings.start.toId)) {
              return false;
            }
          }
          if (bindings.end) {
            if (!selectedShapes.some((s) => s.id === bindings.end.toId)) {
              return false;
            }
          }
        }
      }
      return true;
    },
    [editor]
  );
};
var useAllowUngroup = () => {
  const editor = useEditor();
  return useValue(
    "allowUngroup",
    () => editor.getSelectedShapeIds().some((id) => {
      var _a5;
      return ((_a5 = editor.getShape(id)) == null ? void 0 : _a5.type) === "group";
    }),
    [editor]
  );
};
var showMenuPaste = typeof window !== "undefined" && "navigator" in window && Boolean(navigator.clipboard) && Boolean(navigator.clipboard.read);
function useAnySelectedShapesCount(min4, max3) {
  const editor = useEditor();
  return useValue(
    "selectedShapes",
    () => {
      const len = editor.getSelectedShapes().length;
      if (min4 === void 0) {
        if (max3 === void 0) {
          return len;
        } else {
          return len <= max3;
        }
      } else {
        if (max3 === void 0) {
          return len >= min4;
        } else {
          return len >= min4 && len <= max3;
        }
      }
    },
    [editor, min4, max3]
  );
}
function useUnlockedSelectedShapesCount(min4, max3) {
  const editor = useEditor();
  return useValue(
    "selectedShapes",
    () => {
      const len = editor.getSelectedShapes().filter((s) => !editor.isShapeOrAncestorLocked(s)).length;
      if (min4 === void 0) {
        if (max3 === void 0) {
          return len;
        } else {
          return len <= max3;
        }
      } else {
        if (max3 === void 0) {
          return len >= min4;
        } else {
          return len >= min4 && len <= max3;
        }
      }
    },
    [editor]
  );
}
function useShowAutoSizeToggle() {
  const editor = useEditor();
  return useValue(
    "showAutoSizeToggle",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      return selectedShapes.length === 1 && editor.isShapeOfType(selectedShapes[0], "text") && selectedShapes[0].props.autoSize === false;
    },
    [editor]
  );
}
function useHasLinkShapeSelected() {
  const editor = useEditor();
  return useValue(
    "hasLinkShapeSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      return !!(onlySelectedShape && onlySelectedShape.type !== "embed" && "url" in onlySelectedShape.props && !onlySelectedShape.isLocked);
    },
    [editor]
  );
}
function useOnlyFlippableShape() {
  const editor = useEditor();
  return useValue(
    "onlyFlippableShape",
    () => {
      const shape = editor.getOnlySelectedShape();
      return shape && (editor.isShapeOfType(shape, "group") || editor.isShapeOfType(shape, "image") || editor.isShapeOfType(shape, "arrow") || editor.isShapeOfType(shape, "line") || editor.isShapeOfType(shape, "draw"));
    },
    [editor]
  );
}
function useCanRedo() {
  const editor = useEditor();
  return useValue("useCanRedo", () => editor.getCanRedo(), [editor]);
}
function useCanUndo() {
  const editor = useEditor();
  return useValue("useCanUndo", () => editor.getCanUndo(), [editor]);
}

// node_modules/tldraw/dist-esm/lib/ui/components/ActionsMenu/DefaultActionsMenuContent.mjs
function DefaultActionsMenuContent() {
  return (0, import_jsx_runtime152.jsxs)(import_jsx_runtime152.Fragment, { children: [
    (0, import_jsx_runtime152.jsx)(AlignMenuItems, {}),
    (0, import_jsx_runtime152.jsx)(DistributeMenuItems, {}),
    (0, import_jsx_runtime152.jsx)(StackMenuItems, {}),
    (0, import_jsx_runtime152.jsx)(ReorderMenuItems, {}),
    (0, import_jsx_runtime152.jsx)(ZoomOrRotateMenuItem, {}),
    (0, import_jsx_runtime152.jsx)(RotateCWMenuItem, {}),
    (0, import_jsx_runtime152.jsx)(EditLinkMenuItem, {}),
    (0, import_jsx_runtime152.jsx)(GroupOrUngroupMenuItem, {})
  ] });
}
function AlignMenuItems() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const isInSelectState = useIsInSelectState();
  const enabled = twoSelected && isInSelectState;
  return (0, import_jsx_runtime152.jsxs)(import_jsx_runtime152.Fragment, { children: [
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "align-left", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-horizontal", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "align-right", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "stretch-horizontal", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "align-top", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-vertical", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "align-bottom", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "stretch-vertical", disabled: !enabled })
  ] });
}
function DistributeMenuItems() {
  const threeSelected = useUnlockedSelectedShapesCount(3);
  const isInSelectState = useIsInSelectState();
  const enabled = threeSelected && isInSelectState;
  return (0, import_jsx_runtime152.jsxs)(import_jsx_runtime152.Fragment, { children: [
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "distribute-horizontal", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "distribute-vertical", disabled: !enabled })
  ] });
}
function StackMenuItems() {
  const threeStackableItems = useThreeStackableItems();
  const isInSelectState = useIsInSelectState();
  const enabled = threeStackableItems && isInSelectState;
  return (0, import_jsx_runtime152.jsxs)(import_jsx_runtime152.Fragment, { children: [
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "stack-horizontal", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "stack-vertical", disabled: !enabled })
  ] });
}
function ReorderMenuItems() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return (0, import_jsx_runtime152.jsxs)(import_jsx_runtime152.Fragment, { children: [
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "send-to-back", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "send-backward", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "bring-forward", disabled: !enabled }),
    (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "bring-to-front", disabled: !enabled })
  ] });
}
function ZoomOrRotateMenuItem() {
  const breakpoint = useBreakpoint();
  return breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM ? (0, import_jsx_runtime152.jsx)(ZoomTo100MenuItem, {}) : (0, import_jsx_runtime152.jsx)(RotateCCWMenuItem, {});
}
function ZoomTo100MenuItem() {
  const editor = useEditor();
  const isZoomedTo100 = useValue("zoom is 1", () => editor.getZoomLevel() === 1, [editor]);
  return (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-to-100", disabled: isZoomedTo100 });
}
function RotateCCWMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "rotate-ccw", disabled: !enabled });
}
function RotateCWMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "rotate-cw", disabled: !enabled });
}
function EditLinkMenuItem() {
  const showEditLink = useHasLinkShapeSelected();
  const isInSelectState = useIsInSelectState();
  const enabled = showEditLink && isInSelectState;
  return (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "edit-link", disabled: !enabled });
}
function GroupOrUngroupMenuItem() {
  const allowGroup = useAllowGroup();
  const allowUngroup = useAllowUngroup();
  return allowGroup ? (0, import_jsx_runtime152.jsx)(GroupMenuItem, {}) : allowUngroup ? (0, import_jsx_runtime152.jsx)(UngroupMenuItem, {}) : (0, import_jsx_runtime152.jsx)(GroupMenuItem, {});
}
function GroupMenuItem() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const isInSelectState = useIsInSelectState();
  const enabled = twoSelected && isInSelectState;
  return (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "group", disabled: !enabled });
}
function UngroupMenuItem() {
  return (0, import_jsx_runtime152.jsx)(TldrawUiMenuActionItem, { actionId: "ungroup" });
}

// node_modules/tldraw/dist-esm/lib/ui/components/ActionsMenu/DefaultActionsMenu.mjs
var DefaultActionsMenu = (0, import_react105.memo)(function DefaultActionsMenu2({
  children
}) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const ref = (0, import_react105.useRef)(null);
  usePassThroughWheelEvents(ref);
  const editor = useEditor();
  const isInAcceptableReadonlyState = useValue(
    "should display quick actions when in readonly",
    () => editor.isInAny("hand", "zoom"),
    [editor]
  );
  const content = children ?? (0, import_jsx_runtime153.jsx)(DefaultActionsMenuContent, {});
  if (isReadonlyMode && !isInAcceptableReadonlyState)
    return;
  return (0, import_jsx_runtime153.jsxs)(TldrawUiPopover, { id: "actions-menu", children: [
    (0, import_jsx_runtime153.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime153.jsx)(
      TldrawUiToolbarButton,
      {
        type: "icon",
        "data-testid": "actions-menu.button",
        title: msg2("actions-menu.title"),
        children: (0, import_jsx_runtime153.jsx)(TldrawUiButtonIcon, { icon: "dots-vertical", small: true })
      }
    ) }),
    (0, import_jsx_runtime153.jsx)(
      TldrawUiPopoverContent,
      {
        side: breakpoint >= PORTRAIT_BREAKPOINT.TABLET ? "bottom" : "top",
        sideOffset: 6,
        children: (0, import_jsx_runtime153.jsx)(
          TldrawUiToolbar,
          {
            ref,
            label: msg2("actions-menu.title"),
            className: "tlui-actions-menu tlui-buttons__grid",
            "data-testid": "actions-menu.content",
            children: (0, import_jsx_runtime153.jsx)(TldrawUiMenuContextProvider, { type: "icons", sourceId: "actions-menu", children: content })
          }
        )
      }
    )
  ] });
});

// node_modules/tldraw/dist-esm/lib/ui/components/ContextMenu/DefaultContextMenu.mjs
var import_jsx_runtime156 = __toESM(require_jsx_runtime(), 1);
var import_react106 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/ContextMenu/DefaultContextMenuContent.mjs
var import_jsx_runtime155 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/menu-items.mjs
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
function ToggleAutoSizeMenuItem() {
  const shouldDisplay = useShowAutoSizeToggle();
  if (!shouldDisplay)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-auto-size" });
}
function EditLinkMenuItem2() {
  const shouldDisplay = useHasLinkShapeSelected();
  if (!shouldDisplay)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "edit-link" });
}
function DuplicateMenuItem() {
  const shouldDisplay = useUnlockedSelectedShapesCount(1);
  if (!shouldDisplay)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "duplicate" });
}
function FlattenMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "should display flatten option",
    () => {
      const selectedShapeIds = editor.getSelectedShapeIds();
      if (selectedShapeIds.length === 0)
        return false;
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "image")) {
        return false;
      }
      return true;
    },
    [editor]
  );
  if (!shouldDisplay)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "flatten-to-image" });
}
function GroupMenuItem2() {
  const shouldDisplay = useAllowGroup();
  if (!shouldDisplay)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "group" });
}
function UngroupMenuItem2() {
  const shouldDisplay = useAllowUngroup();
  if (!shouldDisplay)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "ungroup" });
}
function RemoveFrameMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "allow unframe",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      if (selectedShapes.length === 0)
        return false;
      return selectedShapes.every((shape) => editor.isShapeOfType(shape, "frame"));
    },
    [editor]
  );
  if (!shouldDisplay)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "remove-frame" });
}
function FitFrameToContentMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "allow fit frame to content",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape)
        return false;
      return editor.isShapeOfType(onlySelectedShape, "frame") && editor.getSortedChildIdsForParent(onlySelectedShape).length > 0;
    },
    [editor]
  );
  if (!shouldDisplay)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "fit-frame-to-content" });
}
function ToggleLockMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue("selected shapes", () => editor.getSelectedShapes().length > 0, [
    editor
  ]);
  if (!shouldDisplay)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-lock" });
}
function ToggleTransparentBgMenuItem() {
  const editor = useEditor();
  const isTransparentBg = useValue(
    "isTransparentBg",
    () => !editor.getInstanceState().exportBackground,
    [editor]
  );
  return (0, import_jsx_runtime154.jsx)(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-transparent",
      checked: isTransparentBg,
      toggle: true
    }
  );
}
function UnlockAllMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue("any shapes", () => editor.getCurrentPageShapeIds().size > 0, [
    editor
  ]);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "unlock-all", disabled: !shouldDisplay });
}
function ZoomTo100MenuItem2() {
  const editor = useEditor();
  const isZoomedTo100 = useValue("zoomed to 100", () => editor.getZoomLevel() === 1, [editor]);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-to-100", noClose: true, disabled: isZoomedTo100 });
}
function ZoomToFitMenuItem() {
  const editor = useEditor();
  const hasShapes = useValue("has shapes", () => editor.getCurrentPageShapeIds().size > 0, [editor]);
  return (0, import_jsx_runtime154.jsx)(
    TldrawUiMenuActionItem,
    {
      actionId: "zoom-to-fit",
      disabled: !hasShapes,
      "data-testid": "minimap.zoom-menu.zoom-to-fit",
      noClose: true
    }
  );
}
function ZoomToSelectionMenuItem() {
  const editor = useEditor();
  const hasSelected = useValue("has shapes", () => editor.getSelectedShapeIds().length > 0, [
    editor
  ]);
  return (0, import_jsx_runtime154.jsx)(
    TldrawUiMenuActionItem,
    {
      actionId: "zoom-to-selection",
      disabled: !hasSelected,
      "data-testid": "minimap.zoom-menu.zoom-to-selection",
      noClose: true
    }
  );
}
function ClipboardMenuGroup() {
  return (0, import_jsx_runtime154.jsxs)(TldrawUiMenuGroup, { id: "clipboard", children: [
    (0, import_jsx_runtime154.jsx)(CutMenuItem, {}),
    (0, import_jsx_runtime154.jsx)(CopyMenuItem, {}),
    (0, import_jsx_runtime154.jsx)(PasteMenuItem, {}),
    (0, import_jsx_runtime154.jsx)(DuplicateMenuItem, {}),
    (0, import_jsx_runtime154.jsx)(DeleteMenuItem, {})
  ] });
}
function CopyAsMenuGroup() {
  var _a5;
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  return (0, import_jsx_runtime154.jsxs)(
    TldrawUiMenuSubmenu,
    {
      id: "copy-as",
      label: "context-menu.copy-as",
      size: "small",
      disabled: !atLeastOneShapeOnPage,
      children: [
        (0, import_jsx_runtime154.jsxs)(TldrawUiMenuGroup, { id: "copy-as-group", children: [
          (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "copy-as-svg" }),
          Boolean((_a5 = window.navigator.clipboard) == null ? void 0 : _a5.write) && (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "copy-as-png" })
        ] }),
        (0, import_jsx_runtime154.jsx)(TldrawUiMenuGroup, { id: "copy-as-bg", children: (0, import_jsx_runtime154.jsx)(ToggleTransparentBgMenuItem, {}) })
      ]
    }
  );
}
function CutMenuItem() {
  const shouldDisplay = useUnlockedSelectedShapesCount(1);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "cut", disabled: !shouldDisplay });
}
function CopyMenuItem() {
  const shouldDisplay = useAnySelectedShapesCount(1);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "copy", disabled: !shouldDisplay });
}
function PasteMenuItem() {
  const shouldDisplay = showMenuPaste;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "paste", disabled: !shouldDisplay });
}
function ConversionsMenuGroup() {
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  if (!atLeastOneShapeOnPage)
    return null;
  return (0, import_jsx_runtime154.jsxs)(TldrawUiMenuGroup, { id: "conversions", children: [
    (0, import_jsx_runtime154.jsx)(CopyAsMenuGroup, {}),
    (0, import_jsx_runtime154.jsxs)(TldrawUiMenuSubmenu, { id: "export-as", label: "context-menu.export-as", size: "small", children: [
      (0, import_jsx_runtime154.jsxs)(TldrawUiMenuGroup, { id: "export-as-group", children: [
        (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "export-as-svg" }),
        (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "export-as-png" })
      ] }),
      (0, import_jsx_runtime154.jsx)(TldrawUiMenuGroup, { id: "export-as-bg", children: (0, import_jsx_runtime154.jsx)(ToggleTransparentBgMenuItem, {}) })
    ] })
  ] });
}
function SelectAllMenuItem() {
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "select-all", disabled: !atLeastOneShapeOnPage });
}
function DeleteMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "delete", disabled: !oneSelected });
}
function EditMenuSubmenu() {
  const isReadonlyMode = useReadonly();
  if (!useAnySelectedShapesCount(1))
    return null;
  if (isReadonlyMode)
    return null;
  return (0, import_jsx_runtime154.jsxs)(TldrawUiMenuSubmenu, { id: "edit", label: "context-menu.edit", size: "small", children: [
    (0, import_jsx_runtime154.jsx)(GroupMenuItem2, {}),
    (0, import_jsx_runtime154.jsx)(UngroupMenuItem2, {}),
    (0, import_jsx_runtime154.jsx)(FlattenMenuItem, {}),
    (0, import_jsx_runtime154.jsx)(EditLinkMenuItem2, {}),
    (0, import_jsx_runtime154.jsx)(FitFrameToContentMenuItem, {}),
    (0, import_jsx_runtime154.jsx)(RemoveFrameMenuItem, {}),
    (0, import_jsx_runtime154.jsx)(ConvertToEmbedMenuItem, {}),
    (0, import_jsx_runtime154.jsx)(ConvertToBookmarkMenuItem, {}),
    (0, import_jsx_runtime154.jsx)(ToggleAutoSizeMenuItem, {}),
    (0, import_jsx_runtime154.jsx)(ToggleLockMenuItem, {})
  ] });
}
function ArrangeMenuSubmenu() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const onlyFlippableShapeSelected = useOnlyFlippableShape();
  const isReadonlyMode = useReadonly();
  if (isReadonlyMode)
    return null;
  if (!(twoSelected || onlyFlippableShapeSelected))
    return null;
  return (0, import_jsx_runtime154.jsxs)(TldrawUiMenuSubmenu, { id: "arrange", label: "context-menu.arrange", size: "small", children: [
    twoSelected && (0, import_jsx_runtime154.jsxs)(TldrawUiMenuGroup, { id: "align", children: [
      (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "align-left" }),
      (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-horizontal" }),
      (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "align-right" }),
      (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "align-top" }),
      (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-vertical" }),
      (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "align-bottom" })
    ] }),
    (0, import_jsx_runtime154.jsx)(DistributeMenuGroup, {}),
    twoSelected && (0, import_jsx_runtime154.jsxs)(TldrawUiMenuGroup, { id: "stretch", children: [
      (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "stretch-horizontal" }),
      (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "stretch-vertical" })
    ] }),
    (twoSelected || onlyFlippableShapeSelected) && (0, import_jsx_runtime154.jsxs)(TldrawUiMenuGroup, { id: "flip", children: [
      (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "flip-horizontal" }),
      (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "flip-vertical" })
    ] }),
    (0, import_jsx_runtime154.jsx)(OrderMenuGroup, {})
  ] });
}
function DistributeMenuGroup() {
  const threeSelected = useUnlockedSelectedShapesCount(3);
  if (!threeSelected)
    return null;
  return (0, import_jsx_runtime154.jsxs)(TldrawUiMenuGroup, { id: "distribute", children: [
    (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "distribute-horizontal" }),
    (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "distribute-vertical" })
  ] });
}
function OrderMenuGroup() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const threeStackableItems = useThreeStackableItems();
  if (!twoSelected)
    return null;
  return (0, import_jsx_runtime154.jsxs)(TldrawUiMenuGroup, { id: "order", children: [
    (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "pack" }),
    threeStackableItems && (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "stack-horizontal" }),
    threeStackableItems && (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "stack-vertical" })
  ] });
}
function ReorderMenuSubmenu() {
  const isReadonlyMode = useReadonly();
  const oneSelected = useUnlockedSelectedShapesCount(1);
  if (isReadonlyMode)
    return null;
  if (!oneSelected)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuSubmenu, { id: "reorder", label: "context-menu.reorder", size: "small", children: (0, import_jsx_runtime154.jsxs)(TldrawUiMenuGroup, { id: "reorder", children: [
    (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "bring-to-front" }),
    (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "bring-forward" }),
    (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "send-backward" }),
    (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "send-to-back" })
  ] }) });
}
function MoveToPageMenu() {
  const editor = useEditor();
  const pages = useValue("pages", () => editor.getPages(), [editor]);
  const currentPageId = useValue("current page id", () => editor.getCurrentPageId(), [editor]);
  const { addToast } = useToasts();
  const trackEvent = useUiEvents();
  const isReadonlyMode = useReadonly();
  const oneSelected = useUnlockedSelectedShapesCount(1);
  if (!oneSelected)
    return null;
  if (isReadonlyMode)
    return null;
  return (0, import_jsx_runtime154.jsxs)(TldrawUiMenuSubmenu, { id: "move-to-page", label: "context-menu.move-to-page", size: "small", children: [
    (0, import_jsx_runtime154.jsx)(TldrawUiMenuGroup, { id: "pages", children: pages.map((page) => (0, import_jsx_runtime154.jsx)(
      TldrawUiMenuItem,
      {
        id: page.id,
        disabled: currentPageId === page.id,
        label: page.name.length > 30 ? `${page.name.slice(0, 30)}…` : page.name,
        onSelect: () => {
          editor.markHistoryStoppingPoint("move_shapes_to_page");
          editor.moveShapesToPage(editor.getSelectedShapeIds(), page.id);
          const toPage = editor.getPage(page.id);
          if (toPage) {
            addToast({
              title: "Changed Page",
              description: `Moved to ${toPage.name}.`,
              actions: [
                {
                  label: "Go Back",
                  type: "primary",
                  onClick: () => {
                    editor.markHistoryStoppingPoint("change-page");
                    editor.setCurrentPage(currentPageId);
                  }
                }
              ]
            });
          }
          trackEvent("move-to-page", { source: "context-menu" });
        }
      },
      page.id
    )) }),
    (0, import_jsx_runtime154.jsx)(TldrawUiMenuGroup, { id: "new-page", children: (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "move-to-new-page" }) })
  ] });
}
function ConvertToBookmarkMenuItem() {
  const editor = useEditor();
  const oneEmbedSelected = useValue(
    "oneEmbedSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape)
        return false;
      return !!(editor.isShapeOfType(onlySelectedShape, "embed") && onlySelectedShape.props.url && !editor.isShapeOrAncestorLocked(onlySelectedShape));
    },
    [editor]
  );
  if (!oneEmbedSelected)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "convert-to-bookmark" });
}
function ConvertToEmbedMenuItem() {
  const editor = useEditor();
  const getEmbedDefinition = useGetEmbedDefinition();
  const oneEmbeddableBookmarkSelected = useValue(
    "oneEmbeddableBookmarkSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape)
        return false;
      return !!(editor.isShapeOfType(onlySelectedShape, "bookmark") && onlySelectedShape.props.url && getEmbedDefinition(onlySelectedShape.props.url) && !editor.isShapeOrAncestorLocked(onlySelectedShape));
    },
    [editor]
  );
  if (!oneEmbeddableBookmarkSelected)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "convert-to-embed" });
}
function ToggleSnapModeItem() {
  const editor = useEditor();
  const isSnapMode = useValue("isSnapMode", () => editor.user.getIsSnapMode(), [editor]);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-snap-mode", checked: isSnapMode });
}
function ToggleToolLockItem() {
  const editor = useEditor();
  const isToolLock = useValue("isToolLock", () => editor.getInstanceState().isToolLocked, [editor]);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-tool-lock", checked: isToolLock });
}
function ToggleGridItem() {
  const editor = useEditor();
  const isGridMode = useValue("isGridMode", () => editor.getInstanceState().isGridMode, [editor]);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-grid", checked: isGridMode });
}
function ToggleWrapModeItem() {
  const editor = useEditor();
  const isWrapMode = useValue("isWrapMode", () => editor.user.getIsWrapMode(), [editor]);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-wrap-mode", checked: isWrapMode });
}
function ToggleFocusModeItem() {
  const editor = useEditor();
  const isFocusMode = useValue("isFocusMode", () => editor.getInstanceState().isFocusMode, [editor]);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-focus-mode", checked: isFocusMode });
}
function ToggleEdgeScrollingItem() {
  const editor = useEditor();
  const edgeScrollSpeed = useValue("edgeScrollSpeed", () => editor.user.getEdgeScrollSpeed(), [
    editor
  ]);
  return (0, import_jsx_runtime154.jsx)(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-edge-scrolling",
      checked: edgeScrollSpeed === 1
    }
  );
}
function ToggleReduceMotionItem() {
  const editor = useEditor();
  const animationSpeed = useValue("animationSpeed", () => editor.user.getAnimationSpeed(), [editor]);
  return (0, import_jsx_runtime154.jsx)(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-reduce-motion",
      checked: animationSpeed === 0
    }
  );
}
function ToggleDebugModeItem() {
  const editor = useEditor();
  const isDebugMode = useValue("isDebugMode", () => editor.getInstanceState().isDebugMode, [editor]);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-debug-mode", checked: isDebugMode });
}
function ToggleDynamicSizeModeItem() {
  const editor = useEditor();
  const isDynamicResizeMode = useValue(
    "dynamic resize",
    () => editor.user.getIsDynamicResizeMode(),
    [editor]
  );
  return (0, import_jsx_runtime154.jsx)(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-dynamic-size-mode",
      checked: isDynamicResizeMode
    }
  );
}
function TogglePasteAtCursorItem() {
  const editor = useEditor();
  const pasteAtCursor = useValue("paste at cursor", () => editor.user.getIsPasteAtCursorMode(), [
    editor
  ]);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-paste-at-cursor", checked: pasteAtCursor });
}
function PrintItem() {
  const editor = useEditor();
  const emptyPage = useValue("emptyPage", () => editor.getCurrentPageShapeIds().size === 0, [
    editor
  ]);
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "print", disabled: emptyPage });
}
function CursorChatItem() {
  const editor = useEditor();
  const shouldShow = useValue(
    "show cursor chat",
    () => editor.getCurrentToolId() === "select" && !editor.getInstanceState().isCoarsePointer,
    [editor]
  );
  if (!shouldShow)
    return null;
  return (0, import_jsx_runtime154.jsx)(TldrawUiMenuActionItem, { actionId: "open-cursor-chat" });
}

// node_modules/tldraw/dist-esm/lib/ui/components/ContextMenu/DefaultContextMenuContent.mjs
function DefaultContextMenuContent() {
  const editor = useEditor();
  const showCollaborationUi = useShowCollaborationUi();
  const selectToolActive = useValue(
    "isSelectToolActive",
    () => editor.getCurrentToolId() === "select",
    [editor]
  );
  const isSinglePageMode = useValue("isSinglePageMode", () => editor.options.maxPages <= 1, [
    editor
  ]);
  if (!selectToolActive)
    return null;
  return (0, import_jsx_runtime155.jsxs)(import_jsx_runtime155.Fragment, { children: [
    showCollaborationUi && (0, import_jsx_runtime155.jsx)(CursorChatItem, {}),
    (0, import_jsx_runtime155.jsxs)(TldrawUiMenuGroup, { id: "modify", children: [
      (0, import_jsx_runtime155.jsx)(EditMenuSubmenu, {}),
      (0, import_jsx_runtime155.jsx)(ArrangeMenuSubmenu, {}),
      (0, import_jsx_runtime155.jsx)(ReorderMenuSubmenu, {}),
      !isSinglePageMode && (0, import_jsx_runtime155.jsx)(MoveToPageMenu, {})
    ] }),
    (0, import_jsx_runtime155.jsx)(ClipboardMenuGroup, {}),
    (0, import_jsx_runtime155.jsx)(ConversionsMenuGroup, {}),
    (0, import_jsx_runtime155.jsx)(TldrawUiMenuGroup, { id: "select-all", children: (0, import_jsx_runtime155.jsx)(SelectAllMenuItem, {}) })
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/ContextMenu/DefaultContextMenu.mjs
var DefaultContextMenu = (0, import_react106.memo)(function DefaultContextMenu2({
  children,
  disabled = false
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const { Canvas } = useEditorComponents();
  const cb = (0, import_react106.useCallback)(
    (isOpen2) => {
      if (!isOpen2) {
        const onlySelectedShape = editor.getOnlySelectedShape();
        if (onlySelectedShape && editor.isShapeOrAncestorLocked(onlySelectedShape)) {
          editor.setSelectedShapes([]);
        }
      } else {
        if (editor.getInstanceState().isCoarsePointer) {
          const selectedShapes = editor.getSelectedShapes();
          const {
            inputs: { currentPagePoint }
          } = editor;
          const shapesAtPoint = editor.getShapesAtPoint(currentPagePoint);
          if (
            // if there are no selected shapes
            !editor.getSelectedShapes().length || // OR if none of the shapes at the point include the selected shape
            !shapesAtPoint.some((s) => selectedShapes.includes(s))
          ) {
            const lockedShapes = shapesAtPoint.filter((s) => editor.isShapeOrAncestorLocked(s));
            if (lockedShapes.length) {
              editor.select(...lockedShapes.map((s) => s.id));
            }
          }
        }
      }
    },
    [editor]
  );
  const container = useContainer();
  const [isOpen, handleOpenChange] = useMenuIsOpen("context menu", cb);
  const content = children ?? (0, import_jsx_runtime156.jsx)(DefaultContextMenuContent, {});
  return (0, import_jsx_runtime156.jsxs)(dist_exports7.Root, { dir: "ltr", onOpenChange: handleOpenChange, modal: false, children: [
    (0, import_jsx_runtime156.jsx)(dist_exports7.Trigger, { onContextMenu: void 0, dir: "ltr", disabled, children: Canvas ? (0, import_jsx_runtime156.jsx)(Canvas, {}) : null }),
    isOpen && (0, import_jsx_runtime156.jsx)(dist_exports7.Portal, { container, children: (0, import_jsx_runtime156.jsx)(
      dist_exports7.Content,
      {
        className: "tlui-menu scrollable",
        "data-testid": "context-menu",
        "aria-label": msg2("context-menu.title"),
        alignOffset: -4,
        collisionPadding: 4,
        onContextMenu: preventDefault,
        children: (0, import_jsx_runtime156.jsx)(TldrawUiMenuContextProvider, { type: "context-menu", sourceId: "context-menu", children: content })
      }
    ) })
  ] });
});

// node_modules/tldraw/dist-esm/lib/ui/components/CursorChatBubble.mjs
var import_jsx_runtime157 = __toESM(require_jsx_runtime(), 1);
var import_react107 = __toESM(require_react(), 1);
var CHAT_MESSAGE_TIMEOUT_CLOSING = 2e3;
var CHAT_MESSAGE_TIMEOUT_CHATTING = 5e3;
var CursorChatBubble = track(function CursorChatBubble2() {
  const editor = useEditor();
  const { isChatting, chatMessage } = editor.getInstanceState();
  const rTimeout = (0, import_react107.useRef)(-1);
  const [value, setValue] = (0, import_react107.useState)("");
  (0, import_react107.useEffect)(() => {
    const closingUp = !isChatting && chatMessage;
    if (closingUp || isChatting) {
      const duration = isChatting ? CHAT_MESSAGE_TIMEOUT_CHATTING : CHAT_MESSAGE_TIMEOUT_CLOSING;
      rTimeout.current = editor.timers.setTimeout(() => {
        editor.updateInstanceState({ chatMessage: "", isChatting: false });
        setValue("");
        editor.focus();
      }, duration);
    }
    return () => {
      clearTimeout(rTimeout.current);
    };
  }, [editor, chatMessage, isChatting]);
  if (isChatting)
    return (0, import_jsx_runtime157.jsx)(CursorChatInput, { value, setValue, chatMessage });
  return chatMessage.trim() ? (0, import_jsx_runtime157.jsx)(NotEditingChatMessage, { chatMessage }) : null;
});
function usePositionBubble(ref) {
  const editor = useEditor();
  (0, import_react107.useLayoutEffect)(() => {
    var _a5;
    const elm = ref.current;
    if (!elm)
      return;
    const { x, y } = editor.inputs.currentScreenPoint;
    (_a5 = ref.current) == null ? void 0 : _a5.style.setProperty("transform", `translate(${x}px, ${y}px)`);
    function positionChatBubble(e) {
      var _a6;
      const { minX, minY } = editor.getViewportScreenBounds();
      (_a6 = ref.current) == null ? void 0 : _a6.style.setProperty(
        "transform",
        `translate(${e.clientX - minX}px, ${e.clientY - minY}px)`
      );
    }
    window.addEventListener("pointermove", positionChatBubble);
    return () => {
      window.removeEventListener("pointermove", positionChatBubble);
    };
  }, [ref, editor]);
}
var NotEditingChatMessage = ({ chatMessage }) => {
  const editor = useEditor();
  const ref = (0, import_react107.useRef)(null);
  usePositionBubble(ref);
  return (0, import_jsx_runtime157.jsx)(
    "div",
    {
      ref,
      className: "tl-cursor-chat tl-cursor-chat__bubble",
      style: { backgroundColor: editor.user.getColor() },
      children: chatMessage
    }
  );
};
var CursorChatInput = track(function CursorChatInput2({
  chatMessage,
  value,
  setValue
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const ref = (0, import_react107.useRef)(null);
  const placeholder = chatMessage || msg2("cursor-chat.type-to-chat");
  usePositionBubble(ref);
  (0, import_react107.useLayoutEffect)(() => {
    const elm = ref.current;
    if (!elm)
      return;
    const textMeasurement = editor.textMeasure.measureText(value || placeholder, {
      fontFamily: "var(--font-body)",
      fontSize: 12,
      fontWeight: "500",
      fontStyle: "normal",
      maxWidth: null,
      lineHeight: 1,
      padding: "6px"
    });
    elm.style.setProperty("width", textMeasurement.w + "px");
  }, [editor, value, placeholder]);
  (0, import_react107.useLayoutEffect)(() => {
    const raf = editor.timers.requestAnimationFrame(() => {
      var _a5;
      (_a5 = ref.current) == null ? void 0 : _a5.focus();
    });
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [editor]);
  const stopChatting = (0, import_react107.useCallback)(() => {
    editor.updateInstanceState({ isChatting: false });
    editor.focus();
  }, [editor]);
  const handleChange = (0, import_react107.useCallback)(
    (e) => {
      const { value: value2 } = e.target;
      setValue(value2.slice(0, 64));
      editor.updateInstanceState({ chatMessage: value2 });
    },
    [editor, setValue]
  );
  const handleKeyDown2 = (0, import_react107.useCallback)(
    (e) => {
      const elm = ref.current;
      if (!elm)
        return;
      const { value: currentValue } = elm;
      switch (e.key) {
        case "Enter": {
          preventDefault(e);
          e.stopPropagation();
          if (!currentValue) {
            stopChatting();
            return;
          }
          setValue("");
          break;
        }
        case "Escape": {
          preventDefault(e);
          e.stopPropagation();
          stopChatting();
          break;
        }
      }
    },
    [stopChatting, setValue]
  );
  const handlePaste = (0, import_react107.useCallback)((e) => {
    e.stopPropagation();
  }, []);
  return (0, import_jsx_runtime157.jsx)(
    "input",
    {
      ref,
      className: `tl-cursor-chat`,
      style: { backgroundColor: editor.user.getColor() },
      onBlur: stopChatting,
      onChange: handleChange,
      onKeyDown: handleKeyDown2,
      onPaste: handlePaste,
      value,
      placeholder,
      spellCheck: false
    }
  );
});

// node_modules/tldraw/dist-esm/lib/ui/components/DebugMenu/DefaultDebugMenu.mjs
var import_jsx_runtime160 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/DebugMenu/DefaultDebugMenuContent.mjs
var import_jsx_runtime159 = __toESM(require_jsx_runtime(), 1);
var import_react108 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/Button/TldrawUiButtonCheck.mjs
var import_jsx_runtime158 = __toESM(require_jsx_runtime(), 1);
function TldrawUiButtonCheck({ checked }) {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime158.jsx)(
    TldrawUiIcon,
    {
      label: msg2(checked ? "ui.checked" : "ui.unchecked"),
      icon: checked ? "check" : "none",
      className: "tlui-button__icon",
      small: true
    }
  );
}

// node_modules/tldraw/dist-esm/lib/ui/components/DebugMenu/DefaultDebugMenuContent.mjs
function DefaultDebugMenuContent() {
  const editor = useEditor();
  const { addToast } = useToasts();
  const { addDialog } = useDialogs();
  const [error, setError] = import_react108.default.useState(false);
  return (0, import_jsx_runtime159.jsxs)(import_jsx_runtime159.Fragment, { children: [
    (0, import_jsx_runtime159.jsxs)(TldrawUiMenuGroup, { id: "items", children: [
      (0, import_jsx_runtime159.jsx)(TldrawUiMenuItem, { id: "hard-reset", onSelect: hardResetEditor, label: "Hard reset" }),
      (0, import_jsx_runtime159.jsx)(
        TldrawUiMenuItem,
        {
          id: "add-toast",
          onSelect: () => {
            addToast({
              id: uniqueId(),
              title: "Something good happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "success"
            });
            addToast({
              id: uniqueId(),
              title: "Something happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "info",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            });
            addToast({
              id: uniqueId(),
              title: "Something maybe bad happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "warning",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            });
            addToast({
              id: uniqueId(),
              title: "Something bad happened",
              severity: "error",
              keepOpen: true
            });
          },
          label: untranslated("Show toast")
        }
      ),
      (0, import_jsx_runtime159.jsx)(
        TldrawUiMenuItem,
        {
          id: "show-dialog",
          label: "Show dialog",
          onSelect: () => {
            addDialog({
              component: ({ onClose }) => (0, import_jsx_runtime159.jsx)(
                ExampleDialog,
                {
                  displayDontShowAgain: true,
                  onCancel: () => onClose(),
                  onContinue: () => onClose()
                }
              ),
              onClose: () => {
              }
            });
          }
        }
      ),
      (0, import_jsx_runtime159.jsx)(
        TldrawUiMenuItem,
        {
          id: "create-shapes",
          label: "Create 100 shapes",
          onSelect: () => createNShapes(editor, 100)
        }
      ),
      (0, import_jsx_runtime159.jsx)(
        TldrawUiMenuItem,
        {
          id: "count-nodes",
          label: "Count shapes / nodes",
          onSelect: () => {
            var _a5;
            const selectedShapes = editor.getSelectedShapes();
            const shapes = selectedShapes.length === 0 ? editor.getRenderingShapes() : selectedShapes;
            window.alert(
              `Shapes ${shapes.length}, DOM nodes:${(_a5 = document.querySelector(".tl-shapes").querySelectorAll("*")) == null ? void 0 : _a5.length}`
            );
          }
        }
      ),
      (() => {
        if (error)
          throw Error("oh no!");
        return null;
      })(),
      (0, import_jsx_runtime159.jsx)(TldrawUiMenuItem, { id: "throw-error", onSelect: () => setError(true), label: "Throw error" })
    ] }),
    (0, import_jsx_runtime159.jsxs)(TldrawUiMenuGroup, { id: "flags", children: [
      (0, import_jsx_runtime159.jsx)(DebugFlags, {}),
      (0, import_jsx_runtime159.jsx)(FeatureFlags, {})
    ] })
  ] });
}
function DebugFlags() {
  const items = Object.values(debugFlags);
  if (!items.length)
    return null;
  return (0, import_jsx_runtime159.jsx)(TldrawUiMenuSubmenu, { id: "debug flags", label: "Debug Flags", children: (0, import_jsx_runtime159.jsx)(TldrawUiMenuGroup, { id: "debug flags", children: items.map((flag) => (0, import_jsx_runtime159.jsx)(DebugFlagToggle, { flag }, flag.name)) }) });
}
function FeatureFlags() {
  const items = Object.values(featureFlags);
  if (!items.length)
    return null;
  return (0, import_jsx_runtime159.jsx)(TldrawUiMenuSubmenu, { id: "feature flags", label: "Feature Flags", children: (0, import_jsx_runtime159.jsx)(TldrawUiMenuGroup, { id: "feature flags", children: items.map((flag) => (0, import_jsx_runtime159.jsx)(DebugFlagToggle, { flag }, flag.name)) }) });
}
function ExampleDialog({
  title = "title",
  body = "hello hello hello",
  cancel = "Cancel",
  confirm = "Continue",
  displayDontShowAgain = false,
  maxWidth = "350",
  onCancel,
  onContinue
}) {
  const [dontShowAgain, setDontShowAgain] = import_react108.default.useState(false);
  return (0, import_jsx_runtime159.jsxs)(import_jsx_runtime159.Fragment, { children: [
    (0, import_jsx_runtime159.jsxs)(TldrawUiDialogHeader, { children: [
      (0, import_jsx_runtime159.jsx)(TldrawUiDialogTitle, { children: title }),
      (0, import_jsx_runtime159.jsx)(TldrawUiDialogCloseButton, {})
    ] }),
    (0, import_jsx_runtime159.jsx)(TldrawUiDialogBody, { style: { maxWidth }, children: body }),
    (0, import_jsx_runtime159.jsxs)(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
      displayDontShowAgain && (0, import_jsx_runtime159.jsxs)(
        TldrawUiButton,
        {
          type: "normal",
          onClick: () => setDontShowAgain(!dontShowAgain),
          style: { marginRight: "auto" },
          children: [
            (0, import_jsx_runtime159.jsx)(TldrawUiButtonCheck, { checked: dontShowAgain }),
            (0, import_jsx_runtime159.jsx)(TldrawUiButtonLabel, { children: "Don’t show again" })
          ]
        }
      ),
      (0, import_jsx_runtime159.jsx)(TldrawUiButton, { type: "normal", onClick: onCancel, children: (0, import_jsx_runtime159.jsx)(TldrawUiButtonLabel, { children: cancel }) }),
      (0, import_jsx_runtime159.jsx)(TldrawUiButton, { type: "primary", onClick: async () => onContinue(), children: (0, import_jsx_runtime159.jsx)(TldrawUiButtonLabel, { children: confirm }) })
    ] })
  ] });
}
var DebugFlagToggle = track(function DebugFlagToggle2({
  flag,
  onChange
}) {
  const value = flag.get();
  return (0, import_jsx_runtime159.jsx)(
    TldrawUiMenuCheckboxItem,
    {
      id: flag.name,
      title: flag.name,
      label: flag.name.replace(/([a-z0-9])([A-Z])/g, (m) => `${m[0]} ${m[1].toLowerCase()}`).replace(/^[a-z]/, (m) => m.toUpperCase()),
      checked: value,
      onSelect: () => {
        flag.set(!value);
        onChange == null ? void 0 : onChange(!value);
      }
    }
  );
});
var t = 0;
function createNShapes(editor, n) {
  const gap = editor.options.adjacentShapeMargin;
  const shapesToCreate = Array(n);
  const cols = Math.floor(Math.sqrt(n));
  for (let i = 0; i < n; i++) {
    t++;
    shapesToCreate[i] = {
      id: createShapeId("box" + t),
      type: "geo",
      x: i % cols * (100 + gap),
      y: Math.floor(i / cols) * (100 + gap)
    };
  }
  editor.run(() => {
    editor.createShapes(shapesToCreate).setSelectedShapes(shapesToCreate.map((s) => s.id));
  });
}

// node_modules/tldraw/dist-esm/lib/ui/components/DebugMenu/DefaultDebugMenu.mjs
function DefaultDebugMenu({ children }) {
  const content = children ?? (0, import_jsx_runtime160.jsx)(DefaultDebugMenuContent, {});
  return (0, import_jsx_runtime160.jsxs)(TldrawUiDropdownMenuRoot, { id: "debug", children: [
    (0, import_jsx_runtime160.jsx)(TldrawUiDropdownMenuTrigger, { children: (0, import_jsx_runtime160.jsx)(TldrawUiButton, { type: "icon", title: "Debug menu", children: (0, import_jsx_runtime160.jsx)(TldrawUiButtonIcon, { icon: "dots-horizontal" }) }) }),
    (0, import_jsx_runtime160.jsx)(TldrawUiDropdownMenuContent, { side: "top", align: "end", alignOffset: 0, children: (0, import_jsx_runtime160.jsx)(TldrawUiMenuContextProvider, { type: "menu", sourceId: "debug-panel", children: content }) })
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/DefaultDebugPanel.mjs
var import_jsx_runtime161 = __toESM(require_jsx_runtime(), 1);
var import_react109 = __toESM(require_react(), 1);
var DefaultDebugPanel = (0, import_react109.memo)(function DefaultDebugPanel2() {
  const { DebugMenu } = useTldrawUiComponents();
  const ref = (0, import_react109.useRef)(null);
  usePassThroughWheelEvents(ref);
  return (0, import_jsx_runtime161.jsxs)("footer", { ref, className: "tlui-debug-panel", children: [
    (0, import_jsx_runtime161.jsx)(CurrentState, {}),
    (0, import_jsx_runtime161.jsx)(FPS, {}),
    DebugMenu && (0, import_jsx_runtime161.jsx)(DebugMenu, {})
  ] });
});
function useTick2(isEnabled = true) {
  const [_, setTick] = (0, import_react109.useState)(0);
  const editor = useEditor();
  (0, import_react109.useEffect)(() => {
    if (!isEnabled)
      return;
    const update = () => setTick((tick2) => tick2 + 1);
    editor.on("tick", update);
    return () => {
      editor.off("tick", update);
    };
  }, [editor, isEnabled]);
}
var CurrentState = track(function CurrentState2() {
  useTick2();
  const editor = useEditor();
  const path = editor.getPath();
  const hoverShape = editor.getHoveredShape();
  const selectedShape = editor.getOnlySelectedShape();
  const shape = path === "select.idle" || !path.includes("select.") ? hoverShape : selectedShape;
  const shapeInfo = shape && path.includes("select.") ? ` / ${shape.type || ""}${"geo" in shape.props ? " / " + shape.props.geo : ""} / [${Vec.ToInt(editor.getPointInShapeSpace(shape, editor.inputs.currentPagePoint))}]` : "";
  const ruler = path.startsWith("select.") && !path.includes(".idle") ? ` / [${Vec.ToInt(editor.inputs.originPagePoint)}] → [${Vec.ToInt(
    editor.inputs.currentPagePoint
  )}] = ${Vec.Dist(editor.inputs.originPagePoint, editor.inputs.currentPagePoint).toFixed(0)}` : "";
  return (0, import_jsx_runtime161.jsx)("div", { className: "tlui-debug-panel__current-state", children: `${path}${shapeInfo}${ruler}` });
});
function FPS() {
  const editor = useEditor();
  const showFps = useValue("show_fps", () => debugFlags.showFps.get(), [debugFlags]);
  const fpsRef = (0, import_react109.useRef)(null);
  (0, import_react109.useEffect)(() => {
    if (!showFps)
      return;
    const TICK_LENGTH = 250;
    let maxKnownFps = 0;
    let raf = -1;
    let start2 = performance.now();
    let currentTickLength = 0;
    let framesInCurrentTick = 0;
    let isSlow = false;
    function loop() {
      framesInCurrentTick++;
      currentTickLength = performance.now() - start2;
      if (currentTickLength > TICK_LENGTH) {
        const fps = Math.round(
          framesInCurrentTick * (TICK_LENGTH / currentTickLength) * (1e3 / TICK_LENGTH)
        );
        if (fps > maxKnownFps) {
          maxKnownFps = fps;
        }
        const slowFps = maxKnownFps * 0.75;
        if (fps < slowFps && !isSlow || fps >= slowFps && isSlow) {
          isSlow = !isSlow;
        }
        fpsRef.current.innerHTML = `FPS ${fps.toString()}`;
        fpsRef.current.className = `tlui-debug-panel__fps` + (isSlow ? ` tlui-debug-panel__fps__slow` : ``);
        currentTickLength -= TICK_LENGTH;
        framesInCurrentTick = 0;
        start2 = performance.now();
      }
      raf = editor.timers.requestAnimationFrame(loop);
    }
    loop();
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [showFps, editor]);
  if (!showFps)
    return null;
  return (0, import_jsx_runtime161.jsx)("div", { ref: fpsRef });
}

// node_modules/tldraw/dist-esm/lib/ui/components/DefaultMenuPanel.mjs
var import_jsx_runtime162 = __toESM(require_jsx_runtime(), 1);
var import_react110 = __toESM(require_react(), 1);
var DefaultMenuPanel = (0, import_react110.memo)(function MenuPanel() {
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const ref = (0, import_react110.useRef)(null);
  usePassThroughWheelEvents(ref);
  const { MainMenu, QuickActions, ActionsMenu, PageMenu } = useTldrawUiComponents();
  const editor = useEditor();
  const isSinglePageMode = useValue("isSinglePageMode", () => editor.options.maxPages <= 1, [
    editor
  ]);
  const showQuickActions = editor.options.actionShortcutsLocation === "menu" ? true : editor.options.actionShortcutsLocation === "toolbar" ? false : breakpoint >= PORTRAIT_BREAKPOINT.TABLET;
  if (!MainMenu && !PageMenu && !showQuickActions)
    return null;
  return (0, import_jsx_runtime162.jsx)("nav", { ref, className: "tlui-menu-zone", children: (0, import_jsx_runtime162.jsxs)("div", { className: "tlui-buttons__horizontal", children: [
    MainMenu && (0, import_jsx_runtime162.jsx)(MainMenu, {}),
    PageMenu && !isSinglePageMode && (0, import_jsx_runtime162.jsx)(PageMenu, {}),
    showQuickActions ? (0, import_jsx_runtime162.jsxs)(TldrawUiToolbar, { className: "tlui-buttons__horizontal", label: msg2("actions-menu.title"), children: [
      QuickActions && (0, import_jsx_runtime162.jsx)(QuickActions, {}),
      ActionsMenu && (0, import_jsx_runtime162.jsx)(ActionsMenu, {})
    ] }) : null
  ] }) });
});

// node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/DefaultHelperButtons.mjs
var import_jsx_runtime167 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/DefaultHelperButtonsContent.mjs
var import_jsx_runtime166 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/BackToContent.mjs
var import_jsx_runtime163 = __toESM(require_jsx_runtime(), 1);
var import_react111 = __toESM(require_react(), 1);
function BackToContent() {
  const editor = useEditor();
  const actions = useActions();
  const [showBackToContent, setShowBackToContent] = (0, import_react111.useState)(false);
  const rIsShowing = (0, import_react111.useRef)(false);
  useQuickReactor(
    "toggle showback to content",
    () => {
      const showBackToContentPrev = rIsShowing.current;
      const shapeIds = editor.getCurrentPageShapeIds();
      let showBackToContentNow = false;
      if (shapeIds.size) {
        showBackToContentNow = shapeIds.size === editor.getCulledShapes().size;
      }
      if (showBackToContentPrev !== showBackToContentNow) {
        setShowBackToContent(showBackToContentNow);
        rIsShowing.current = showBackToContentNow;
      }
    },
    [editor]
  );
  if (!showBackToContent)
    return null;
  return (0, import_jsx_runtime163.jsx)(
    TldrawUiMenuActionItem,
    {
      actionId: "back-to-content",
      onSelect: () => {
        actions["back-to-content"].onSelect("helper-buttons");
        setShowBackToContent(false);
      }
    }
  );
}

// node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/ExitPenMode.mjs
var import_jsx_runtime164 = __toESM(require_jsx_runtime(), 1);
function ExitPenMode() {
  const editor = useEditor();
  const isPenMode = useValue("is pen mode", () => editor.getInstanceState().isPenMode, [editor]);
  if (!isPenMode)
    return null;
  return (0, import_jsx_runtime164.jsx)(TldrawUiMenuActionItem, { actionId: "exit-pen-mode" });
}

// node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/StopFollowing.mjs
var import_jsx_runtime165 = __toESM(require_jsx_runtime(), 1);
function StopFollowing() {
  const editor = useEditor();
  const actions = useActions();
  const followingUser = useValue(
    "is following user",
    () => !!editor.getInstanceState().followingUserId,
    [editor]
  );
  if (!followingUser)
    return null;
  return (0, import_jsx_runtime165.jsx)(TldrawUiMenuItem, { ...actions["stop-following"] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/DefaultHelperButtonsContent.mjs
function DefaultHelperButtonsContent() {
  return (0, import_jsx_runtime166.jsxs)(import_jsx_runtime166.Fragment, { children: [
    (0, import_jsx_runtime166.jsx)(ExitPenMode, {}),
    (0, import_jsx_runtime166.jsx)(BackToContent, {}),
    (0, import_jsx_runtime166.jsx)(StopFollowing, {})
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/DefaultHelperButtons.mjs
function DefaultHelperButtons({ children }) {
  const content = children ?? (0, import_jsx_runtime167.jsx)(DefaultHelperButtonsContent, {});
  return (0, import_jsx_runtime167.jsx)("div", { className: "tlui-helper-buttons", children: (0, import_jsx_runtime167.jsx)(TldrawUiMenuContextProvider, { type: "helper-buttons", sourceId: "helper-buttons", children: content }) });
}

// node_modules/tldraw/dist-esm/lib/ui/components/KeyboardShortcutsDialog/DefaultKeyboardShortcutsDialog.mjs
var import_jsx_runtime169 = __toESM(require_jsx_runtime(), 1);
var import_classnames28 = __toESM(require_classnames(), 1);
var import_react112 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/KeyboardShortcutsDialog/DefaultKeyboardShortcutsDialogContent.mjs
var import_jsx_runtime168 = __toESM(require_jsx_runtime(), 1);
function DefaultKeyboardShortcutsDialogContent() {
  const showCollaborationUi = useShowCollaborationUi();
  return (0, import_jsx_runtime168.jsxs)(import_jsx_runtime168.Fragment, { children: [
    (0, import_jsx_runtime168.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.tools", id: "tools", children: [
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-tool-lock" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "insert-media" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "select" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "draw" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "eraser" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "hand" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "rectangle" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "ellipse" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "arrow" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "line" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "text" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "frame" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "note" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuToolItem, { toolId: "laser" }),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "pointer-down",
          label: "tool.pointer-down",
          kbd: ",",
          onSelect: () => {
          }
        }
      )
    ] }),
    (0, import_jsx_runtime168.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.preferences", id: "preferences", children: [
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-dark-mode" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-focus-mode" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-grid" })
    ] }),
    (0, import_jsx_runtime168.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.edit", id: "edit", children: [
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "undo" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "redo" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "cut" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "copy" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "paste" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "select-all" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "delete" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "duplicate" })
    ] }),
    (0, import_jsx_runtime168.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.view", id: "view", children: [
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-in" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-out" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-to-100" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-to-fit" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-to-selection" })
    ] }),
    (0, import_jsx_runtime168.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.transform", id: "transform", children: [
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "bring-to-front" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "bring-forward" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "send-backward" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "send-to-back" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "group" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "ungroup" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "flip-horizontal" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "flip-vertical" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "align-top" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-vertical" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "align-bottom" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "align-left" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-horizontal" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "align-right" })
    ] }),
    (0, import_jsx_runtime168.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.text-formatting", id: "text", children: [
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-bold",
          label: "tool.rich-text-bold",
          kbd: "cmd+b",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-italic",
          label: "tool.rich-text-italic",
          kbd: "cmd+i",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-code",
          label: "tool.rich-text-code",
          kbd: "cmd+e",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-highlight",
          label: "tool.rich-text-highlight",
          kbd: "cmd+shift+h",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-strikethrough",
          label: "tool.rich-text-strikethrough",
          kbd: "cmd+shift+s",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-link",
          label: "tool.rich-text-link",
          kbd: "cmd+shift+k",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-header",
          label: "tool.rich-text-header",
          kbd: "cmd+shift+[[1-6]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-orderedList",
          label: "tool.rich-text-orderedList",
          kbd: "cmd+shift+7",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-bulletedlist",
          label: "tool.rich-text-bulletList",
          kbd: "cmd+shift+8",
          onSelect: () => {
          }
        }
      )
    ] }),
    (0, import_jsx_runtime168.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.a11y", id: "a11y", children: [
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape",
          label: "a11y.select-shape",
          kbd: "[[Tab]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape-direction",
          label: "a11y.select-shape-direction",
          kbd: "cmd+↑→↓←",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape-container",
          label: "a11y.enter-leave-container",
          kbd: "cmd+shift+↑→",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-pan-camera",
          label: "a11y.pan-camera",
          kbd: "[[Space]]+↑→↓←",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "adjust-shape-styles",
          label: "a11y.adjust-shape-styles",
          kbd: "$+[[Enter]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-move-shape",
          label: "a11y.move-shape",
          kbd: "↑→↓←",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-move-shape-faster",
          label: "a11y.move-shape-faster",
          kbd: "shift+↑→↓←",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "enlarge-shapes" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "shrink-shapes" }),
      (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "a11y-repeat-shape-announce" })
    ] }),
    showCollaborationUi && (0, import_jsx_runtime168.jsx)(TldrawUiMenuGroup, { label: "shortcuts-dialog.collaboration", id: "collaboration", children: (0, import_jsx_runtime168.jsx)(TldrawUiMenuActionItem, { actionId: "open-cursor-chat" }) })
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/KeyboardShortcutsDialog/DefaultKeyboardShortcutsDialog.mjs
var DefaultKeyboardShortcutsDialog = (0, import_react112.memo)(function DefaultKeyboardShortcutsDialog2({
  children
}) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const content = children ?? (0, import_jsx_runtime169.jsx)(DefaultKeyboardShortcutsDialogContent, {});
  return (0, import_jsx_runtime169.jsxs)(import_jsx_runtime169.Fragment, { children: [
    (0, import_jsx_runtime169.jsxs)(TldrawUiDialogHeader, { className: "tlui-shortcuts-dialog__header", children: [
      (0, import_jsx_runtime169.jsx)(TldrawUiDialogTitle, { children: msg2("shortcuts-dialog.title") }),
      (0, import_jsx_runtime169.jsx)(TldrawUiDialogCloseButton, {})
    ] }),
    (0, import_jsx_runtime169.jsx)(
      TldrawUiDialogBody,
      {
        className: (0, import_classnames28.default)("tlui-shortcuts-dialog__body", {
          "tlui-shortcuts-dialog__body__mobile": breakpoint <= PORTRAIT_BREAKPOINT.MOBILE_XS,
          "tlui-shortcuts-dialog__body__tablet": breakpoint <= PORTRAIT_BREAKPOINT.TABLET
        }),
        children: (0, import_jsx_runtime169.jsx)(TldrawUiMenuContextProvider, { type: "keyboard-shortcuts", sourceId: "kbd", children: content })
      }
    ),
    (0, import_jsx_runtime169.jsx)("div", { className: "tlui-dialog__scrim" })
  ] });
});

// node_modules/tldraw/dist-esm/lib/ui/components/MainMenu/DefaultMainMenu.mjs
var import_jsx_runtime173 = __toESM(require_jsx_runtime(), 1);
var import_react114 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/MainMenu/DefaultMainMenuContent.mjs
var import_jsx_runtime172 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/HelpMenu/DefaultHelpMenuContent.mjs
var import_jsx_runtime171 = __toESM(require_jsx_runtime(), 1);
var import_react113 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/LanguageMenu.mjs
var import_jsx_runtime170 = __toESM(require_jsx_runtime(), 1);
function LanguageMenu() {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const currentLanguage = useValue("locale", () => editor == null ? void 0 : editor.user.getLocale(), [editor]);
  if (!editor)
    return null;
  return (0, import_jsx_runtime170.jsx)(TldrawUiMenuSubmenu, { id: "help menu language", label: "menu.language", children: (0, import_jsx_runtime170.jsx)(TldrawUiMenuGroup, { id: "languages", className: "tlui-language-menu", children: LANGUAGES.map(({ locale, label }) => (0, import_jsx_runtime170.jsx)(
    TldrawUiMenuCheckboxItem,
    {
      id: `language-${locale}`,
      title: locale,
      label,
      checked: locale === currentLanguage,
      readonlyOk: true,
      onSelect: () => {
        editor.user.updateUserPreferences({ locale });
        trackEvent("change-language", { source: "menu", locale });
      }
    },
    locale
  )) }) });
}

// node_modules/tldraw/dist-esm/lib/ui/components/HelpMenu/DefaultHelpMenuContent.mjs
function DefaultHelpMenuContent() {
  return (0, import_jsx_runtime171.jsxs)(import_jsx_runtime171.Fragment, { children: [
    (0, import_jsx_runtime171.jsx)(LanguageMenu, {}),
    (0, import_jsx_runtime171.jsx)(KeyboardShortcutsMenuItem, {})
  ] });
}
function KeyboardShortcutsMenuItem() {
  const { KeyboardShortcutsDialog } = useTldrawUiComponents();
  const { addDialog } = useDialogs();
  const handleSelect = (0, import_react113.useCallback)(() => {
    if (KeyboardShortcutsDialog)
      addDialog({ component: KeyboardShortcutsDialog });
  }, [addDialog, KeyboardShortcutsDialog]);
  if (!KeyboardShortcutsDialog)
    return null;
  return (0, import_jsx_runtime171.jsx)(
    TldrawUiMenuItem,
    {
      id: "keyboard-shortcuts-button",
      label: "help-menu.keyboard-shortcuts",
      readonlyOk: true,
      onSelect: handleSelect
    }
  );
}

// node_modules/tldraw/dist-esm/lib/ui/components/MainMenu/DefaultMainMenuContent.mjs
function DefaultMainMenuContent() {
  return (0, import_jsx_runtime172.jsxs)(import_jsx_runtime172.Fragment, { children: [
    (0, import_jsx_runtime172.jsxs)(TldrawUiMenuGroup, { id: "basic", children: [
      (0, import_jsx_runtime172.jsx)(EditSubmenu, {}),
      (0, import_jsx_runtime172.jsx)(ViewSubmenu, {}),
      (0, import_jsx_runtime172.jsx)(ExportFileContentSubMenu, {}),
      (0, import_jsx_runtime172.jsx)(ExtrasGroup, {})
    ] }),
    (0, import_jsx_runtime172.jsx)(PreferencesGroup, {})
  ] });
}
function ExportFileContentSubMenu() {
  return (0, import_jsx_runtime172.jsxs)(TldrawUiMenuSubmenu, { id: "export-all-as", label: "context-menu.export-all-as", size: "small", children: [
    (0, import_jsx_runtime172.jsxs)(TldrawUiMenuGroup, { id: "export-all-as-group", children: [
      (0, import_jsx_runtime172.jsx)(TldrawUiMenuActionItem, { actionId: "export-all-as-svg" }),
      (0, import_jsx_runtime172.jsx)(TldrawUiMenuActionItem, { actionId: "export-all-as-png" })
    ] }),
    (0, import_jsx_runtime172.jsx)(TldrawUiMenuGroup, { id: "export-all-as-bg", children: (0, import_jsx_runtime172.jsx)(ToggleTransparentBgMenuItem, {}) })
  ] });
}
function EditSubmenu() {
  return (0, import_jsx_runtime172.jsxs)(TldrawUiMenuSubmenu, { id: "edit", label: "menu.edit", children: [
    (0, import_jsx_runtime172.jsx)(UndoRedoGroup, {}),
    (0, import_jsx_runtime172.jsx)(ClipboardMenuGroup, {}),
    (0, import_jsx_runtime172.jsx)(ConversionsMenuGroup, {}),
    (0, import_jsx_runtime172.jsx)(MiscMenuGroup, {}),
    (0, import_jsx_runtime172.jsx)(LockGroup, {}),
    (0, import_jsx_runtime172.jsx)(TldrawUiMenuGroup, { id: "select-all", children: (0, import_jsx_runtime172.jsx)(SelectAllMenuItem, {}) })
  ] });
}
function MiscMenuGroup() {
  return (0, import_jsx_runtime172.jsxs)(TldrawUiMenuGroup, { id: "misc", children: [
    (0, import_jsx_runtime172.jsx)(GroupMenuItem2, {}),
    (0, import_jsx_runtime172.jsx)(UngroupMenuItem2, {}),
    (0, import_jsx_runtime172.jsx)(EditLinkMenuItem2, {}),
    (0, import_jsx_runtime172.jsx)(ToggleAutoSizeMenuItem, {}),
    (0, import_jsx_runtime172.jsx)(RemoveFrameMenuItem, {}),
    (0, import_jsx_runtime172.jsx)(FitFrameToContentMenuItem, {}),
    (0, import_jsx_runtime172.jsx)(ConvertToEmbedMenuItem, {}),
    (0, import_jsx_runtime172.jsx)(ConvertToBookmarkMenuItem, {}),
    (0, import_jsx_runtime172.jsx)(FlattenMenuItem, {})
  ] });
}
function LockGroup() {
  return (0, import_jsx_runtime172.jsxs)(TldrawUiMenuGroup, { id: "lock", children: [
    (0, import_jsx_runtime172.jsx)(ToggleLockMenuItem, {}),
    (0, import_jsx_runtime172.jsx)(UnlockAllMenuItem, {})
  ] });
}
function UndoRedoGroup() {
  const canUndo = useCanUndo();
  const canRedo = useCanRedo();
  return (0, import_jsx_runtime172.jsxs)(TldrawUiMenuGroup, { id: "undo-redo", children: [
    (0, import_jsx_runtime172.jsx)(TldrawUiMenuActionItem, { actionId: "undo", disabled: !canUndo }),
    (0, import_jsx_runtime172.jsx)(TldrawUiMenuActionItem, { actionId: "redo", disabled: !canRedo })
  ] });
}
function ViewSubmenu() {
  return (0, import_jsx_runtime172.jsx)(TldrawUiMenuSubmenu, { id: "view", label: "menu.view", children: (0, import_jsx_runtime172.jsxs)(TldrawUiMenuGroup, { id: "view-actions", children: [
    (0, import_jsx_runtime172.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-in" }),
    (0, import_jsx_runtime172.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-out" }),
    (0, import_jsx_runtime172.jsx)(ZoomTo100MenuItem2, {}),
    (0, import_jsx_runtime172.jsx)(ZoomToFitMenuItem, {}),
    (0, import_jsx_runtime172.jsx)(ZoomToSelectionMenuItem, {})
  ] }) });
}
function ExtrasGroup() {
  return (0, import_jsx_runtime172.jsxs)(import_jsx_runtime172.Fragment, { children: [
    (0, import_jsx_runtime172.jsx)(TldrawUiMenuActionItem, { actionId: "insert-embed" }),
    (0, import_jsx_runtime172.jsx)(TldrawUiMenuActionItem, { actionId: "insert-media" })
  ] });
}
function PreferencesGroup() {
  return (0, import_jsx_runtime172.jsxs)(TldrawUiMenuGroup, { id: "preferences", children: [
    (0, import_jsx_runtime172.jsxs)(TldrawUiMenuSubmenu, { id: "preferences", label: "menu.preferences", children: [
      (0, import_jsx_runtime172.jsxs)(TldrawUiMenuGroup, { id: "preferences-actions", children: [
        (0, import_jsx_runtime172.jsx)(ToggleSnapModeItem, {}),
        (0, import_jsx_runtime172.jsx)(ToggleToolLockItem, {}),
        (0, import_jsx_runtime172.jsx)(ToggleGridItem, {}),
        (0, import_jsx_runtime172.jsx)(ToggleWrapModeItem, {}),
        (0, import_jsx_runtime172.jsx)(ToggleFocusModeItem, {}),
        (0, import_jsx_runtime172.jsx)(ToggleEdgeScrollingItem, {}),
        (0, import_jsx_runtime172.jsx)(ToggleReduceMotionItem, {}),
        (0, import_jsx_runtime172.jsx)(ToggleDynamicSizeModeItem, {}),
        (0, import_jsx_runtime172.jsx)(TogglePasteAtCursorItem, {}),
        (0, import_jsx_runtime172.jsx)(ToggleDebugModeItem, {})
      ] }),
      (0, import_jsx_runtime172.jsx)(TldrawUiMenuGroup, { id: "color-scheme", children: (0, import_jsx_runtime172.jsx)(ColorSchemeMenu, {}) })
    ] }),
    (0, import_jsx_runtime172.jsx)(LanguageMenu, {}),
    (0, import_jsx_runtime172.jsx)(KeyboardShortcutsMenuItem, {})
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/MainMenu/DefaultMainMenu.mjs
var DefaultMainMenu = (0, import_react114.memo)(function DefaultMainMenu2({ children }) {
  const container = useContainer();
  const [isOpen, onOpenChange] = useMenuIsOpen("main menu");
  const msg2 = useTranslation();
  const content = children ?? (0, import_jsx_runtime173.jsx)(DefaultMainMenuContent, {});
  return (0, import_jsx_runtime173.jsxs)(dist_exports9.Root, { dir: "ltr", open: isOpen, onOpenChange, modal: false, children: [
    (0, import_jsx_runtime173.jsx)(dist_exports9.Trigger, { asChild: true, dir: "ltr", children: (0, import_jsx_runtime173.jsx)(TldrawUiButton, { type: "icon", "data-testid": "main-menu.button", title: msg2("menu.title"), children: (0, import_jsx_runtime173.jsx)(TldrawUiButtonIcon, { icon: "menu", small: true }) }) }),
    (0, import_jsx_runtime173.jsx)(dist_exports9.Portal, { container, children: (0, import_jsx_runtime173.jsx)(
      dist_exports9.Content,
      {
        className: "tlui-menu",
        side: "bottom",
        align: "start",
        collisionPadding: 4,
        alignOffset: 0,
        sideOffset: 6,
        children: (0, import_jsx_runtime173.jsx)(TldrawUiMenuContextProvider, { type: "menu", sourceId: "main-menu", children: content })
      }
    ) })
  ] });
});

// node_modules/tldraw/dist-esm/lib/ui/components/Minimap/DefaultMinimap.mjs
var import_jsx_runtime174 = __toESM(require_jsx_runtime(), 1);
var React97 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/Minimap/getRgba.mjs
var memo22 = {};
function getRgba(colorString) {
  if (memo22[colorString]) {
    return memo22[colorString];
  }
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  context.fillStyle = colorString;
  context.fillRect(0, 0, 1, 1);
  const [r, g, b, a] = context.getImageData(0, 0, 1, 1).data;
  const result = new Float32Array([r / 255, g / 255, b / 255, a / 255]);
  memo22[colorString] = result;
  return result;
}

// node_modules/tldraw/dist-esm/lib/ui/components/Minimap/minimap-webgl-shapes.mjs
var numArcSegmentsPerCorner = 10;
var roundedRectangleDataSize = (
  // num triangles in corners
  // num triangles in outer rects
  4 * 6 * numArcSegmentsPerCorner + // num triangles in center rect
  12 + 4 * 12
);
function pie(array2, {
  center,
  radius,
  numArcSegments = 20,
  startAngle = 0,
  endAngle = PI2,
  offset: offset5 = 0
}) {
  const angle = (endAngle - startAngle) / numArcSegments;
  let i = offset5;
  for (let a = startAngle; a < endAngle; a += angle) {
    array2[i++] = center.x;
    array2[i++] = center.y;
    array2[i++] = center.x + Math.cos(a) * radius;
    array2[i++] = center.y + Math.sin(a) * radius;
    array2[i++] = center.x + Math.cos(a + angle) * radius;
    array2[i++] = center.y + Math.sin(a + angle) * radius;
  }
  return array2;
}
function rectangle(array2, offset5, x, y, w, h) {
  array2[offset5++] = x;
  array2[offset5++] = y;
  array2[offset5++] = x;
  array2[offset5++] = y + h;
  array2[offset5++] = x + w;
  array2[offset5++] = y;
  array2[offset5++] = x + w;
  array2[offset5++] = y;
  array2[offset5++] = x;
  array2[offset5++] = y + h;
  array2[offset5++] = x + w;
  array2[offset5++] = y + h;
}
function roundedRectangle(data, box, radius) {
  const numArcSegments = numArcSegmentsPerCorner;
  radius = Math.min(radius, Math.min(box.w, box.h) / 2);
  const innerBox = Box.ExpandBy(box, -radius);
  if (innerBox.w <= 0 || innerBox.h <= 0) {
    pie(data, { center: box.center, radius, numArcSegments: numArcSegmentsPerCorner * 4 });
    return numArcSegmentsPerCorner * 4 * 6;
  }
  let offset5 = 0;
  rectangle(data, offset5, innerBox.minX, innerBox.minY, innerBox.w, innerBox.h);
  offset5 += 12;
  rectangle(data, offset5, innerBox.minX, box.minY, innerBox.w, radius);
  offset5 += 12;
  rectangle(data, offset5, innerBox.maxX, innerBox.minY, radius, innerBox.h);
  offset5 += 12;
  rectangle(data, offset5, innerBox.minX, innerBox.maxY, innerBox.w, radius);
  offset5 += 12;
  rectangle(data, offset5, box.minX, innerBox.minY, radius, innerBox.h);
  offset5 += 12;
  pie(data, {
    numArcSegments,
    offset: offset5,
    center: innerBox.point,
    radius,
    startAngle: PI,
    endAngle: PI * 1.5
  });
  offset5 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset5,
    center: Vec.Add(innerBox.point, new Vec(innerBox.w, 0)),
    radius,
    startAngle: PI * 1.5,
    endAngle: PI2
  });
  offset5 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset5,
    center: Vec.Add(innerBox.point, innerBox.size),
    radius,
    startAngle: 0,
    endAngle: HALF_PI
  });
  offset5 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset5,
    center: Vec.Add(innerBox.point, new Vec(0, innerBox.h)),
    radius,
    startAngle: HALF_PI,
    endAngle: PI
  });
  return roundedRectangleDataSize;
}

// node_modules/tldraw/dist-esm/lib/ui/components/Minimap/minimap-webgl-setup.mjs
function setupWebGl(canvas) {
  if (!canvas)
    throw new Error("Canvas element not found");
  const context = canvas.getContext("webgl2", {
    premultipliedAlpha: false
  });
  if (!context)
    throw new Error("Failed to get webgl2 context");
  const vertexShaderSourceCode = `#version 300 es
  precision mediump float;
  
  in vec2 shapeVertexPosition;

	uniform vec4 canvasPageBounds;

	// taken (with thanks) from
	// https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html
  void main() {
		// convert the position from pixels to 0.0 to 1.0
		vec2 zeroToOne = (shapeVertexPosition - canvasPageBounds.xy) / canvasPageBounds.zw;
	
		// convert from 0->1 to 0->2
		vec2 zeroToTwo = zeroToOne * 2.0;
	
		// convert from 0->2 to -1->+1 (clipspace)
		vec2 clipSpace = zeroToTwo - 1.0;
	
		gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
  }`;
  const vertexShader = context.createShader(context.VERTEX_SHADER);
  if (!vertexShader) {
    throw new Error("Failed to create vertex shader");
  }
  context.shaderSource(vertexShader, vertexShaderSourceCode);
  context.compileShader(vertexShader);
  if (!context.getShaderParameter(vertexShader, context.COMPILE_STATUS)) {
    throw new Error("Failed to compile vertex shader");
  }
  const fragmentShaderSourceCode = `#version 300 es
  precision mediump float;
  
	uniform vec4 fillColor;
  out vec4 outputColor;

  void main() {
	outputColor = fillColor;
  }`;
  const fragmentShader = context.createShader(context.FRAGMENT_SHADER);
  if (!fragmentShader) {
    throw new Error("Failed to create fragment shader");
  }
  context.shaderSource(fragmentShader, fragmentShaderSourceCode);
  context.compileShader(fragmentShader);
  if (!context.getShaderParameter(fragmentShader, context.COMPILE_STATUS)) {
    throw new Error("Failed to compile fragment shader");
  }
  const program = context.createProgram();
  if (!program) {
    throw new Error("Failed to create program");
  }
  context.attachShader(program, vertexShader);
  context.attachShader(program, fragmentShader);
  context.linkProgram(program);
  if (!context.getProgramParameter(program, context.LINK_STATUS)) {
    throw new Error("Failed to link program");
  }
  context.useProgram(program);
  const shapeVertexPositionAttributeLocation = context.getAttribLocation(
    program,
    "shapeVertexPosition"
  );
  if (shapeVertexPositionAttributeLocation < 0) {
    throw new Error("Failed to get shapeVertexPosition attribute location");
  }
  context.enableVertexAttribArray(shapeVertexPositionAttributeLocation);
  const canvasPageBoundsLocation = context.getUniformLocation(program, "canvasPageBounds");
  const fillColorLocation = context.getUniformLocation(program, "fillColor");
  const selectedShapesBuffer = context.createBuffer();
  if (!selectedShapesBuffer)
    throw new Error("Failed to create buffer");
  const unselectedShapesBuffer = context.createBuffer();
  if (!unselectedShapesBuffer)
    throw new Error("Failed to create buffer");
  return {
    context,
    selectedShapes: allocateBuffer(context, 1024),
    unselectedShapes: allocateBuffer(context, 4096),
    viewport: allocateBuffer(context, roundedRectangleDataSize),
    collaborators: allocateBuffer(context, 1024),
    prepareTriangles(stuff, len) {
      context.bindBuffer(context.ARRAY_BUFFER, stuff.buffer);
      context.bufferData(context.ARRAY_BUFFER, stuff.vertices, context.STATIC_DRAW, 0, len);
      context.enableVertexAttribArray(shapeVertexPositionAttributeLocation);
      context.vertexAttribPointer(
        shapeVertexPositionAttributeLocation,
        2,
        context.FLOAT,
        false,
        0,
        0
      );
    },
    drawTrianglesTransparently(len) {
      context.enable(context.BLEND);
      context.blendFunc(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA);
      context.drawArrays(context.TRIANGLES, 0, len / 2);
      context.disable(context.BLEND);
    },
    drawTriangles(len) {
      context.drawArrays(context.TRIANGLES, 0, len / 2);
    },
    setFillColor(color) {
      context.uniform4fv(fillColorLocation, color);
    },
    setCanvasPageBounds(bounds) {
      context.uniform4fv(canvasPageBoundsLocation, bounds);
    }
  };
}
function allocateBuffer(context, size4) {
  const buffer = context.createBuffer();
  if (!buffer)
    throw new Error("Failed to create buffer");
  return { buffer, vertices: new Float32Array(size4) };
}
function appendVertices(bufferStuff, offset5, data) {
  let len = bufferStuff.vertices.length;
  while (len < offset5 + data.length) {
    len *= 2;
  }
  if (len != bufferStuff.vertices.length) {
    const newVertices = new Float32Array(len);
    newVertices.set(bufferStuff.vertices);
    bufferStuff.vertices = newVertices;
  }
  bufferStuff.vertices.set(data, offset5);
}

// node_modules/tldraw/dist-esm/lib/ui/components/Minimap/MinimapManager.mjs
var __create12 = Object.create;
var __defProp12 = Object.defineProperty;
var __getOwnPropDesc12 = Object.getOwnPropertyDescriptor;
var __knownSymbol12 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError12 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp12 = (obj, key, value) => key in obj ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name12 = (target, value) => __defProp12(target, "name", { value, configurable: true });
var __decoratorStart12 = (base2) => [, , , __create12((base2 == null ? void 0 : base2[__knownSymbol12("metadata")]) ?? null)];
var __decoratorStrings12 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn12 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError12("Function expected") : fn2;
var __decoratorContext12 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings12[kind], name, metadata, addInitializer: (fn2) => done._ ? __typeError12("Already initialized") : fns.push(__expectFn12(fn2 || null)) });
var __decoratorMetadata12 = (array2, target) => __defNormalProp12(target, __knownSymbol12("metadata"), array2[3]);
var __runInitializers12 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n = fns && fns.length; i < n; i++)
    flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement12 = (array2, flags, name, decorators, target, extra) => {
  var fn2, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array2.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings12[k + 5];
  var initializers = k > 3 && (array2[j - 1] = []), extraInitializers = array2[j] || (array2[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc12(k < 4 ? target : { get [name]() {
    return __privateGet13(this, extra);
  }, set [name](x) {
    return __privateSet13(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name12(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name12(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext12(k, name, done = {}, array2[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn12(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p ? (x) => (k ^ 1 ? __privateGet13 : __privateMethod12)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p ? (x, y) => __privateSet13(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn12(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError12("Object expected");
    else
      __expectFn12(fn2 = it.get) && (desc.get = fn2), __expectFn12(fn2 = it.set) && (desc.set = fn2), __expectFn12(fn2 = it.init) && initializers.unshift(fn2);
  }
  return k || __decoratorMetadata12(array2, target), desc && __defProp12(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField13 = (obj, key, value) => __defNormalProp12(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck12 = (obj, member, msg2) => member.has(obj) || __typeError12("Cannot " + msg2);
var __privateIn12 = (member, obj) => Object(obj) !== obj ? __typeError12('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet13 = (obj, member, getter) => (__accessCheck12(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet13 = (obj, member, value, setter) => (__accessCheck12(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod12 = (obj, member, method) => (__accessCheck12(obj, member, "access private method"), method);
var _render_dec;
var _getCanvasPageBoundsArray_dec;
var _getZoom_dec;
var _getCanvasPageBounds_dec;
var _getCanvasClientPosition_dec;
var _getCanvasSize_dec;
var _getContentScreenBounds_dec;
var _getContentPageBounds_dec;
var _getDpr_dec;
var _close_dec;
var _init12;
_close_dec = [bind], _getDpr_dec = [computed], _getContentPageBounds_dec = [computed], _getContentScreenBounds_dec = [computed], _getCanvasSize_dec = [computed], _getCanvasClientPosition_dec = [computed], _getCanvasPageBounds_dec = [computed], _getZoom_dec = [computed], _getCanvasPageBoundsArray_dec = [computed], _render_dec = [bind];
var MinimapManager = class {
  constructor(editor, elem, container) {
    this.editor = editor;
    this.elem = elem;
    this.container = container;
    __runInitializers12(_init12, 5, this);
    __publicField13(this, "disposables", []);
    __publicField13(this, "gl");
    __publicField13(this, "shapeGeometryCache");
    __publicField13(this, "colors");
    __publicField13(this, "id", uniqueId());
    __publicField13(this, "canvasBoundingClientRect", atom("canvasBoundingClientRect", new Box()));
    __publicField13(this, "originPagePoint", new Vec());
    __publicField13(this, "originPageCenter", new Vec());
    __publicField13(this, "isInViewport", false);
    this.gl = setupWebGl(elem);
    this.shapeGeometryCache = editor.store.createComputedCache("webgl-geometry", (r) => {
      const bounds = editor.getShapeMaskedPageBounds(r.id);
      if (!bounds)
        return null;
      const arr = new Float32Array(12);
      rectangle(arr, 0, bounds.x, bounds.y, bounds.w, bounds.h);
      return arr;
    });
    this.colors = this._getColors();
    this.disposables.push(this._listenForCanvasResize(), react("minimap render", this.render));
  }
  close() {
    return this.disposables.forEach((d) => d());
  }
  _getColors() {
    const style2 = getComputedStyle(this.editor.getContainer());
    return {
      shapeFill: getRgba(style2.getPropertyValue("--color-text-3").trim()),
      selectFill: getRgba(style2.getPropertyValue("--color-selected").trim()),
      viewportFill: getRgba(style2.getPropertyValue("--color-muted-1").trim()),
      background: getRgba(style2.getPropertyValue("--color-low").trim())
    };
  }
  // this should be called after dark/light mode changes have propagated to the dom
  updateColors() {
    this.colors = this._getColors();
  }
  getDpr() {
    return this.editor.getInstanceState().devicePixelRatio;
  }
  getContentPageBounds() {
    const viewportPageBounds = this.editor.getViewportPageBounds();
    const commonShapeBounds = this.editor.getCurrentPageBounds();
    return commonShapeBounds ? Box.Expand(commonShapeBounds, viewportPageBounds) : viewportPageBounds;
  }
  getContentScreenBounds() {
    const contentPageBounds = this.getContentPageBounds();
    const topLeft = this.editor.pageToScreen(contentPageBounds.point);
    const bottomRight = this.editor.pageToScreen(
      new Vec(contentPageBounds.maxX, contentPageBounds.maxY)
    );
    return new Box(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
  }
  _getCanvasBoundingRect() {
    const { x, y, width, height } = this.elem.getBoundingClientRect();
    return new Box(x, y, width, height);
  }
  getCanvasScreenBounds() {
    return this.canvasBoundingClientRect.get();
  }
  _listenForCanvasResize() {
    const observer = new ResizeObserver(() => {
      const rect = this._getCanvasBoundingRect();
      this.canvasBoundingClientRect.set(rect);
    });
    observer.observe(this.elem);
    observer.observe(this.container);
    return () => observer.disconnect();
  }
  getCanvasSize() {
    const rect = this.canvasBoundingClientRect.get();
    const dpr = this.getDpr();
    return new Vec(rect.width * dpr, rect.height * dpr);
  }
  getCanvasClientPosition() {
    return this.canvasBoundingClientRect.get().point;
  }
  getCanvasPageBounds() {
    const canvasScreenBounds = this.getCanvasScreenBounds();
    const contentPageBounds = this.getContentPageBounds();
    const aspectRatio = canvasScreenBounds.width / canvasScreenBounds.height;
    let targetWidth = contentPageBounds.width;
    let targetHeight = targetWidth / aspectRatio;
    if (targetHeight < contentPageBounds.height) {
      targetHeight = contentPageBounds.height;
      targetWidth = targetHeight * aspectRatio;
    }
    const box = new Box(0, 0, targetWidth, targetHeight);
    box.center = contentPageBounds.center;
    return box;
  }
  getZoom() {
    return this.getCanvasPageBounds().width / this.getCanvasScreenBounds().width;
  }
  getCanvasPageBoundsArray() {
    const { x, y, w, h } = this.getCanvasPageBounds();
    return new Float32Array([x, y, w, h]);
  }
  getMinimapPagePoint(clientX, clientY) {
    const canvasPageBounds = this.getCanvasPageBounds();
    const canvasScreenBounds = this.getCanvasScreenBounds();
    let x = clientX - canvasScreenBounds.x;
    let y = clientY - canvasScreenBounds.y;
    x *= canvasPageBounds.width / canvasScreenBounds.width;
    y *= canvasPageBounds.height / canvasScreenBounds.height;
    x += canvasPageBounds.minX;
    y += canvasPageBounds.minY;
    return new Vec(x, y, 1);
  }
  minimapScreenPointToPagePoint(x, y, shiftKey = false, clampToBounds = false) {
    const { editor } = this;
    const vpPageBounds = editor.getViewportPageBounds();
    let { x: px, y: py } = this.getMinimapPagePoint(x, y);
    if (clampToBounds) {
      const shapesPageBounds = this.editor.getCurrentPageBounds() ?? new Box();
      const minX = shapesPageBounds.minX - vpPageBounds.width / 2;
      const maxX = shapesPageBounds.maxX + vpPageBounds.width / 2;
      const minY = shapesPageBounds.minY - vpPageBounds.height / 2;
      const maxY = shapesPageBounds.maxY + vpPageBounds.height / 2;
      const lx = Math.max(0, minX + vpPageBounds.width - px);
      const rx = Math.max(0, -(maxX - vpPageBounds.width - px));
      const ly = Math.max(0, minY + vpPageBounds.height - py);
      const ry = Math.max(0, -(maxY - vpPageBounds.height - py));
      px += (lx - rx) / 2;
      py += (ly - ry) / 2;
      px = clamp(px, minX, maxX);
      py = clamp(py, minY, maxY);
    }
    if (shiftKey) {
      const { originPagePoint } = this;
      const dx = Math.abs(px - originPagePoint.x);
      const dy = Math.abs(py - originPagePoint.y);
      if (dx > dy) {
        py = originPagePoint.y;
      } else {
        px = originPagePoint.x;
      }
    }
    return new Vec(px, py);
  }
  render() {
    const context = this.gl.context;
    const canvasSize = this.getCanvasSize();
    this.gl.setCanvasPageBounds(this.getCanvasPageBoundsArray());
    this.elem.width = canvasSize.x;
    this.elem.height = canvasSize.y;
    context.viewport(0, 0, canvasSize.x, canvasSize.y);
    context.clearColor(
      this.colors.background[0],
      this.colors.background[1],
      this.colors.background[2],
      1
    );
    context.clear(context.COLOR_BUFFER_BIT);
    const selectedShapes = new Set(this.editor.getSelectedShapeIds());
    const colors = this.colors;
    let selectedShapeOffset = 0;
    let unselectedShapeOffset = 0;
    const ids = this.editor.getCurrentPageShapeIdsSorted();
    for (let i = 0, len = ids.length; i < len; i++) {
      const shapeId = ids[i];
      const geometry = this.shapeGeometryCache.get(shapeId);
      if (!geometry)
        continue;
      const len2 = geometry.length;
      if (selectedShapes.has(shapeId)) {
        appendVertices(this.gl.selectedShapes, selectedShapeOffset, geometry);
        selectedShapeOffset += len2;
      } else {
        appendVertices(this.gl.unselectedShapes, unselectedShapeOffset, geometry);
        unselectedShapeOffset += len2;
      }
    }
    this.drawShapes(this.gl.unselectedShapes, unselectedShapeOffset, colors.shapeFill);
    this.drawShapes(this.gl.selectedShapes, selectedShapeOffset, colors.selectFill);
    this.drawViewport();
    this.drawCollaborators();
  }
  drawShapes(stuff, len, color) {
    this.gl.prepareTriangles(stuff, len);
    this.gl.setFillColor(color);
    this.gl.drawTriangles(len);
  }
  drawViewport() {
    const viewport2 = this.editor.getViewportPageBounds();
    const len = roundedRectangle(this.gl.viewport.vertices, viewport2, 4 * this.getZoom());
    this.gl.prepareTriangles(this.gl.viewport, len);
    this.gl.setFillColor(this.colors.viewportFill);
    this.gl.drawTrianglesTransparently(len);
    if (tlenv.isSafari) {
      this.gl.drawTrianglesTransparently(len);
      this.gl.drawTrianglesTransparently(len);
      this.gl.drawTrianglesTransparently(len);
    }
  }
  drawCollaborators() {
    const collaborators = this.editor.getCollaboratorsOnCurrentPage();
    if (!collaborators.length)
      return;
    const numSegmentsPerCircle = 20;
    const dataSizePerCircle = numSegmentsPerCircle * 6;
    const totalSize = dataSizePerCircle * collaborators.length;
    if (this.gl.collaborators.vertices.length < totalSize) {
      this.gl.collaborators.vertices = new Float32Array(totalSize);
    }
    const vertices = this.gl.collaborators.vertices;
    let offset5 = 0;
    const zoom = this.getZoom();
    for (const { cursor } of collaborators) {
      if (!cursor)
        continue;
      pie(vertices, {
        center: Vec.From(cursor),
        radius: 3 * zoom,
        offset: offset5,
        numArcSegments: numSegmentsPerCircle
      });
      offset5 += dataSizePerCircle;
    }
    this.gl.prepareTriangles(this.gl.collaborators, totalSize);
    offset5 = 0;
    for (const { color } of collaborators) {
      this.gl.setFillColor(getRgba(color));
      this.gl.context.drawArrays(this.gl.context.TRIANGLES, offset5 / 2, dataSizePerCircle / 2);
      offset5 += dataSizePerCircle;
    }
  }
};
_init12 = __decoratorStart12(null);
__decorateElement12(_init12, 1, "close", _close_dec, MinimapManager);
__decorateElement12(_init12, 1, "getDpr", _getDpr_dec, MinimapManager);
__decorateElement12(_init12, 1, "getContentPageBounds", _getContentPageBounds_dec, MinimapManager);
__decorateElement12(_init12, 1, "getContentScreenBounds", _getContentScreenBounds_dec, MinimapManager);
__decorateElement12(_init12, 1, "getCanvasSize", _getCanvasSize_dec, MinimapManager);
__decorateElement12(_init12, 1, "getCanvasClientPosition", _getCanvasClientPosition_dec, MinimapManager);
__decorateElement12(_init12, 1, "getCanvasPageBounds", _getCanvasPageBounds_dec, MinimapManager);
__decorateElement12(_init12, 1, "getZoom", _getZoom_dec, MinimapManager);
__decorateElement12(_init12, 1, "getCanvasPageBoundsArray", _getCanvasPageBoundsArray_dec, MinimapManager);
__decorateElement12(_init12, 1, "render", _render_dec, MinimapManager);
__decoratorMetadata12(_init12, MinimapManager);

// node_modules/tldraw/dist-esm/lib/ui/components/Minimap/DefaultMinimap.mjs
function DefaultMinimap() {
  const editor = useEditor();
  const container = useContainer();
  const msg2 = useTranslation();
  const rCanvas = React97.useRef(null);
  const rPointing = React97.useRef(false);
  const minimapRef = React97.useRef();
  React97.useEffect(() => {
    try {
      const minimap = new MinimapManager(editor, rCanvas.current, container);
      minimapRef.current = minimap;
      return minimapRef.current.close;
    } catch (e) {
      editor.annotateError(e, {
        origin: "minimap",
        willCrashApp: false
      });
      editor.timers.setTimeout(() => {
        throw e;
      });
    }
  }, [editor, container]);
  const onDoubleClick = React97.useCallback(
    (e) => {
      if (!editor.getCurrentPageShapeIds().size)
        return;
      if (!minimapRef.current)
        return;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        false
      );
      const clampedPoint = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        true
      );
      minimapRef.current.originPagePoint.setTo(clampedPoint);
      minimapRef.current.originPageCenter.setTo(editor.getViewportPageBounds().center);
      editor.centerOnPoint(point, { animation: { duration: editor.options.animationMediumMs } });
    },
    [editor]
  );
  const onPointerDown = React97.useCallback(
    (e) => {
      if (!minimapRef.current)
        return;
      const elm = e.currentTarget;
      setPointerCapture(elm, e);
      if (!editor.getCurrentPageShapeIds().size)
        return;
      rPointing.current = true;
      minimapRef.current.isInViewport = false;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        false
      );
      const _vpPageBounds = editor.getViewportPageBounds();
      const commonBounds = minimapRef.current.getContentPageBounds();
      const allowedBounds = new Box(
        commonBounds.x - _vpPageBounds.width / 2,
        commonBounds.y - _vpPageBounds.height / 2,
        commonBounds.width + _vpPageBounds.width,
        commonBounds.height + _vpPageBounds.height
      );
      if (allowedBounds.containsPoint(point) && !_vpPageBounds.containsPoint(point)) {
        minimapRef.current.isInViewport = _vpPageBounds.containsPoint(point);
        const delta = Vec.Sub(_vpPageBounds.center, _vpPageBounds.point);
        const pagePoint = Vec.Add(point, delta);
        minimapRef.current.originPagePoint.setTo(pagePoint);
        minimapRef.current.originPageCenter.setTo(point);
        editor.centerOnPoint(point, { animation: { duration: editor.options.animationMediumMs } });
      } else {
        const clampedPoint = minimapRef.current.minimapScreenPointToPagePoint(
          e.clientX,
          e.clientY,
          false,
          true
        );
        minimapRef.current.isInViewport = _vpPageBounds.containsPoint(clampedPoint);
        minimapRef.current.originPagePoint.setTo(clampedPoint);
        minimapRef.current.originPageCenter.setTo(_vpPageBounds.center);
      }
      function release(e2) {
        if (elm) {
          releasePointerCapture(elm, e2);
        }
        rPointing.current = false;
        document.body.removeEventListener("pointerup", release);
      }
      document.body.addEventListener("pointerup", release);
    },
    [editor]
  );
  const onPointerMove = React97.useCallback(
    (e) => {
      if (!minimapRef.current)
        return;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        e.shiftKey,
        true
      );
      if (rPointing.current) {
        if (minimapRef.current.isInViewport) {
          const delta = minimapRef.current.originPagePoint.clone().sub(minimapRef.current.originPageCenter);
          editor.centerOnPoint(Vec.Sub(point, delta));
          return;
        }
        editor.centerOnPoint(point);
      }
      const pagePoint = minimapRef.current.getMinimapPagePoint(e.clientX, e.clientY);
      const screenPoint = editor.pageToScreen(pagePoint);
      const info = {
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        ...getPointerInfo(e),
        point: screenPoint,
        isPen: editor.getInstanceState().isPenMode
      };
      editor.dispatch(info);
    },
    [editor]
  );
  const onWheel = React97.useCallback(
    (e) => {
      const offset5 = normalizeWheel(e);
      editor.dispatch({
        type: "wheel",
        name: "wheel",
        delta: offset5,
        point: new Vec(e.clientX, e.clientY),
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      });
    },
    [editor]
  );
  const isDarkMode = useIsDarkMode();
  React97.useEffect(() => {
    editor.timers.setTimeout(() => {
      var _a5, _b;
      (_a5 = minimapRef.current) == null ? void 0 : _a5.updateColors();
      (_b = minimapRef.current) == null ? void 0 : _b.render();
    });
  }, [isDarkMode, editor]);
  return (0, import_jsx_runtime174.jsx)("div", { className: "tlui-minimap", children: (0, import_jsx_runtime174.jsx)(
    "canvas",
    {
      role: "img",
      "aria-label": msg2("navigation-zone.minimap"),
      ref: rCanvas,
      className: "tlui-minimap__canvas",
      onDoubleClick,
      onPointerMove,
      onPointerDown,
      onWheelCapture: onWheel
    }
  ) });
}

// node_modules/tldraw/dist-esm/lib/ui/components/NavigationPanel/DefaultNavigationPanel.mjs
var import_jsx_runtime175 = __toESM(require_jsx_runtime(), 1);
var import_react116 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/hooks/useLocalStorageState.mjs
var import_react115 = __toESM(require_react(), 1);
function useLocalStorageState(key, defaultValue) {
  const [state, setState] = import_react115.default.useState(defaultValue);
  import_react115.default.useLayoutEffect(() => {
    const value = getFromLocalStorage(key);
    if (value) {
      try {
        setState(JSON.parse(value));
      } catch {
        console.error(`Could not restore value ${key} from local storage.`);
      }
    }
  }, [key]);
  const updateValue = import_react115.default.useCallback(
    (setter) => {
      setState((s) => {
        const value = typeof setter === "function" ? setter(s) : setter;
        setInLocalStorage(key, JSON.stringify(value));
        return value;
      });
    },
    [key]
  );
  return [state, updateValue];
}

// node_modules/tldraw/dist-esm/lib/ui/components/NavigationPanel/DefaultNavigationPanel.mjs
var DefaultNavigationPanel = (0, import_react116.memo)(function DefaultNavigationPanel2() {
  const actions = useActions();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const ref = (0, import_react116.useRef)(null);
  usePassThroughWheelEvents(ref);
  const [collapsed, setCollapsed] = useLocalStorageState("minimap", true);
  const toggleMinimap = (0, import_react116.useCallback)(() => {
    setCollapsed((s) => !s);
  }, [setCollapsed]);
  const { ZoomMenu, Minimap } = useTldrawUiComponents();
  if (breakpoint < PORTRAIT_BREAKPOINT.MOBILE) {
    return null;
  }
  return (0, import_jsx_runtime175.jsxs)("div", { ref, className: "tlui-navigation-panel", children: [
    (0, import_jsx_runtime175.jsx)(TldrawUiToolbar, { className: "tlui-buttons__horizontal", label: msg2("navigation-zone.title"), children: ZoomMenu && breakpoint < PORTRAIT_BREAKPOINT.TABLET ? (0, import_jsx_runtime175.jsx)(ZoomMenu, {}) : (0, import_jsx_runtime175.jsxs)(import_jsx_runtime175.Fragment, { children: [
      !collapsed && (0, import_jsx_runtime175.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.zoom-out",
          title: `${msg2(unwrapLabel(actions["zoom-out"].label))} ${kbdStr(actions["zoom-out"].kbd)}`,
          onClick: () => actions["zoom-out"].onSelect("navigation-zone"),
          children: (0, import_jsx_runtime175.jsx)(TldrawUiButtonIcon, { icon: "minus" })
        }
      ),
      ZoomMenu && (0, import_jsx_runtime175.jsx)(ZoomMenu, {}, "zoom-menu"),
      !collapsed && (0, import_jsx_runtime175.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.zoom-in",
          title: `${msg2(unwrapLabel(actions["zoom-in"].label))} ${kbdStr(actions["zoom-in"].kbd)}`,
          onClick: () => actions["zoom-in"].onSelect("navigation-zone"),
          children: (0, import_jsx_runtime175.jsx)(TldrawUiButtonIcon, { icon: "plus" })
        }
      ),
      Minimap && (0, import_jsx_runtime175.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.toggle-button",
          title: msg2("navigation-zone.toggle-minimap"),
          className: "tlui-navigation-panel__toggle",
          onClick: toggleMinimap,
          children: (0, import_jsx_runtime175.jsx)(TldrawUiButtonIcon, { icon: collapsed ? "chevrons-ne" : "chevrons-sw" })
        }
      )
    ] }) }),
    Minimap && breakpoint >= PORTRAIT_BREAKPOINT.TABLET && !collapsed && (0, import_jsx_runtime175.jsx)(Minimap, {})
  ] });
});

// node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/DefaultPageMenu.mjs
var import_jsx_runtime178 = __toESM(require_jsx_runtime(), 1);
var import_react119 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/PageItemInput.mjs
var import_jsx_runtime176 = __toESM(require_jsx_runtime(), 1);
var import_react117 = __toESM(require_react(), 1);
var PageItemInput = function PageItemInput2({
  name,
  id,
  isCurrentPage,
  onCancel,
  onComplete
}) {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const rInput = (0, import_react117.useRef)(null);
  const rMark = (0, import_react117.useRef)(null);
  const handleFocus = (0, import_react117.useCallback)(() => {
    rMark.current = editor.markHistoryStoppingPoint("rename page");
  }, [editor]);
  const handleChange = (0, import_react117.useCallback)(
    (value) => {
      editor.renamePage(id, value || "New Page");
      trackEvent("rename-page", { source: "page-menu" });
    },
    [editor, id, trackEvent]
  );
  const handleCancel = (0, import_react117.useCallback)(() => {
    if (rMark.current) {
      editor.bailToMark(rMark.current);
    }
    onCancel();
  }, [editor, onCancel]);
  return (0, import_jsx_runtime176.jsx)(
    TldrawUiInput,
    {
      className: "tlui-page-menu__item__input",
      ref: (el) => rInput.current = el,
      defaultValue: name,
      onValueChange: handleChange,
      onComplete,
      onCancel: handleCancel,
      onFocus: handleFocus,
      shouldManuallyMaintainScrollPositionWhenFocused: true,
      autoFocus: isCurrentPage,
      autoSelect: true
    }
  );
};

// node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/PageItemSubmenu.mjs
var import_jsx_runtime177 = __toESM(require_jsx_runtime(), 1);
var import_react118 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/edit-pages-shared.mjs
var onMovePage = (editor, id, from2, to, trackEvent) => {
  let index3;
  const pages = editor.getPages();
  const below = from2 > to ? pages[to - 1] : pages[to];
  const above = from2 > to ? pages[to] : pages[to + 1];
  if (below && !above) {
    index3 = getIndexAbove(below.index);
  } else if (!below && above) {
    index3 = getIndexBelow(pages[0].index);
  } else {
    index3 = getIndexBetween(below.index, above.index);
  }
  if (index3 !== pages[from2].index) {
    editor.markHistoryStoppingPoint("moving page");
    editor.updatePage({
      id,
      index: index3
    });
    trackEvent("move-page", { source: "page-menu" });
  }
};

// node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/PageItemSubmenu.mjs
var PageItemSubmenu = track(function PageItemSubmenu2({
  index: index3,
  listSize,
  item,
  onRename
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const pages = editor.getPages();
  const trackEvent = useUiEvents();
  const onDuplicate = (0, import_react118.useCallback)(() => {
    editor.markHistoryStoppingPoint("creating page");
    const newId = PageRecordType.createId();
    editor.duplicatePage(item.id, newId);
    trackEvent("duplicate-page", { source: "page-menu" });
  }, [editor, item, trackEvent]);
  const onMoveUp = (0, import_react118.useCallback)(() => {
    onMovePage(editor, item.id, index3, index3 - 1, trackEvent);
  }, [editor, item, index3, trackEvent]);
  const onMoveDown = (0, import_react118.useCallback)(() => {
    onMovePage(editor, item.id, index3, index3 + 1, trackEvent);
  }, [editor, item, index3, trackEvent]);
  const onDelete = (0, import_react118.useCallback)(() => {
    editor.markHistoryStoppingPoint("deleting page");
    editor.deletePage(item.id);
    trackEvent("delete-page", { source: "page-menu" });
  }, [editor, item, trackEvent]);
  return (0, import_jsx_runtime177.jsxs)(TldrawUiDropdownMenuRoot, { id: `page item submenu ${index3}`, children: [
    (0, import_jsx_runtime177.jsx)(TldrawUiDropdownMenuTrigger, { children: (0, import_jsx_runtime177.jsx)(TldrawUiButton, { type: "icon", title: msg2("page-menu.submenu.title"), children: (0, import_jsx_runtime177.jsx)(TldrawUiButtonIcon, { icon: "dots-vertical", small: true }) }) }),
    (0, import_jsx_runtime177.jsx)(TldrawUiDropdownMenuContent, { alignOffset: 0, side: "right", sideOffset: -4, children: (0, import_jsx_runtime177.jsxs)(TldrawUiMenuContextProvider, { type: "menu", sourceId: "page-menu", children: [
      (0, import_jsx_runtime177.jsxs)(TldrawUiMenuGroup, { id: "modify", children: [
        onRename && (0, import_jsx_runtime177.jsx)(TldrawUiMenuItem, { id: "rename", label: "page-menu.submenu.rename", onSelect: onRename }),
        (0, import_jsx_runtime177.jsx)(
          TldrawUiMenuItem,
          {
            id: "duplicate",
            label: "page-menu.submenu.duplicate-page",
            onSelect: onDuplicate,
            disabled: pages.length >= editor.options.maxPages
          }
        ),
        index3 > 0 && (0, import_jsx_runtime177.jsx)(
          TldrawUiMenuItem,
          {
            id: "move-up",
            onSelect: onMoveUp,
            label: "page-menu.submenu.move-up"
          }
        ),
        index3 < listSize - 1 && (0, import_jsx_runtime177.jsx)(
          TldrawUiMenuItem,
          {
            id: "move-down",
            label: "page-menu.submenu.move-down",
            onSelect: onMoveDown
          }
        )
      ] }),
      listSize > 1 && (0, import_jsx_runtime177.jsx)(TldrawUiMenuGroup, { id: "delete", children: (0, import_jsx_runtime177.jsx)(TldrawUiMenuItem, { id: "delete", onSelect: onDelete, label: "page-menu.submenu.delete" }) })
    ] }) })
  ] });
});

// node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/DefaultPageMenu.mjs
var DefaultPageMenu = (0, import_react119.memo)(function DefaultPageMenu2() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const handleOpenChange = (0, import_react119.useCallback)(() => setIsEditing(false), []);
  const [isOpen, onOpenChange] = useMenuIsOpen("page-menu", handleOpenChange);
  const ITEM_HEIGHT = 36;
  const rSortableContainer = (0, import_react119.useRef)(null);
  const pages = useValue("pages", () => editor.getPages(), [editor]);
  const currentPage = useValue("currentPage", () => editor.getCurrentPage(), [editor]);
  const currentPageId = useValue("currentPageId", () => editor.getCurrentPageId(), [editor]);
  const isReadonlyMode = useReadonly();
  const maxPageCountReached = useValue(
    "maxPageCountReached",
    () => editor.getPages().length >= editor.options.maxPages,
    [editor]
  );
  const isCoarsePointer = useValue(
    "isCoarsePointer",
    () => editor.getInstanceState().isCoarsePointer,
    [editor]
  );
  const [isEditing, setIsEditing] = (0, import_react119.useState)(false);
  const toggleEditing = (0, import_react119.useCallback)(() => {
    if (isReadonlyMode)
      return;
    setIsEditing((s) => !s);
  }, [isReadonlyMode]);
  const rMutables = (0, import_react119.useRef)({
    isPointing: false,
    status: "idle",
    pointing: null,
    startY: 0,
    startIndex: 0,
    dragIndex: 0
  });
  const [sortablePositionItems, setSortablePositionItems] = (0, import_react119.useState)(
    Object.fromEntries(
      pages.map((page, i) => [page.id, { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
    )
  );
  (0, import_react119.useLayoutEffect)(() => {
    setSortablePositionItems(
      Object.fromEntries(
        pages.map((page, i) => [page.id, { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
      )
    );
  }, [ITEM_HEIGHT, pages]);
  (0, import_react119.useEffect)(() => {
    if (!isOpen)
      return;
    editor.timers.requestAnimationFrame(() => {
      const elm = document.querySelector(
        `[data-testid="page-menu-item-${currentPageId}"]`
      );
      if (elm) {
        const container = rSortableContainer.current;
        if (!container)
          return;
        const elmTopPosition = elm.offsetTop;
        const containerScrollTopPosition = container.scrollTop;
        if (elmTopPosition < containerScrollTopPosition) {
          container.scrollTo({ top: elmTopPosition });
        }
        const elmBottomPosition = elmTopPosition + ITEM_HEIGHT;
        const containerScrollBottomPosition = container.scrollTop + container.offsetHeight;
        if (elmBottomPosition > containerScrollBottomPosition) {
          container.scrollTo({ top: elmBottomPosition - container.offsetHeight });
        }
      }
    });
  }, [ITEM_HEIGHT, currentPageId, isOpen, editor]);
  const handlePointerDown = (0, import_react119.useCallback)(
    (e) => {
      const { clientY, currentTarget } = e;
      const {
        dataset: { id, index: index3 }
      } = currentTarget;
      if (!id || !index3)
        return;
      const mut = rMutables.current;
      setPointerCapture(e.currentTarget, e);
      mut.status = "pointing";
      mut.pointing = { id, index: +index3 };
      const current = sortablePositionItems[id];
      const dragY = current.y;
      mut.startY = clientY;
      mut.startIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1));
    },
    [ITEM_HEIGHT, pages.length, sortablePositionItems]
  );
  const handlePointerMove = (0, import_react119.useCallback)(
    (e) => {
      const mut = rMutables.current;
      if (mut.status === "pointing") {
        const { clientY } = e;
        const offset5 = clientY - mut.startY;
        if (Math.abs(offset5) > 5) {
          mut.status = "dragging";
        }
      }
      if (mut.status === "dragging") {
        const { clientY } = e;
        const offsetY = clientY - mut.startY;
        const current = sortablePositionItems[mut.pointing.id];
        const { startIndex, pointing } = mut;
        const dragY = current.y + offsetY;
        const dragIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1));
        const next = { ...sortablePositionItems };
        next[pointing.id] = {
          y: current.y,
          offsetY,
          isSelected: true
        };
        if (dragIndex !== mut.dragIndex) {
          mut.dragIndex = dragIndex;
          for (let i = 0; i < pages.length; i++) {
            const item = pages[i];
            if (item.id === mut.pointing.id) {
              continue;
            }
            let { y } = next[item.id];
            if (dragIndex === startIndex) {
              y = i * ITEM_HEIGHT;
            } else if (dragIndex < startIndex) {
              if (dragIndex <= i && i < startIndex) {
                y = (i + 1) * ITEM_HEIGHT;
              } else {
                y = i * ITEM_HEIGHT;
              }
            } else if (dragIndex > startIndex) {
              if (dragIndex >= i && i > startIndex) {
                y = (i - 1) * ITEM_HEIGHT;
              } else {
                y = i * ITEM_HEIGHT;
              }
            }
            if (y !== next[item.id].y) {
              next[item.id] = { y, offsetY: 0, isSelected: true };
            }
          }
        }
        setSortablePositionItems(next);
      }
    },
    [ITEM_HEIGHT, pages, sortablePositionItems]
  );
  const handlePointerUp = (0, import_react119.useCallback)(
    (e) => {
      const mut = rMutables.current;
      if (mut.status === "dragging") {
        const { id, index: index3 } = mut.pointing;
        onMovePage(editor, id, index3, mut.dragIndex, trackEvent);
      }
      releasePointerCapture(e.currentTarget, e);
      mut.status = "idle";
    },
    [editor, trackEvent]
  );
  const handleKeyDown2 = (0, import_react119.useCallback)(
    (e) => {
      const mut = rMutables.current;
      if (e.key === "Escape") {
        if (mut.status === "dragging") {
          setSortablePositionItems(
            Object.fromEntries(
              pages.map((page, i) => [
                page.id,
                { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }
              ])
            )
          );
        }
        mut.status = "idle";
      }
    },
    [ITEM_HEIGHT, pages]
  );
  const handleCreatePageClick = (0, import_react119.useCallback)(() => {
    if (isReadonlyMode)
      return;
    editor.run(() => {
      editor.markHistoryStoppingPoint("creating page");
      const newPageId = PageRecordType.createId();
      editor.createPage({ name: msg2("page-menu.new-page-initial-name"), id: newPageId });
      editor.setCurrentPage(newPageId);
      setIsEditing(true);
    });
    trackEvent("new-page", { source: "page-menu" });
  }, [editor, msg2, isReadonlyMode, trackEvent]);
  const changePage = (0, import_react119.useCallback)(
    (id) => {
      editor.setCurrentPage(id);
      trackEvent("change-page", { source: "page-menu" });
    },
    [editor, trackEvent]
  );
  const renamePage = (0, import_react119.useCallback)(
    (id, name) => {
      editor.renamePage(id, name);
      trackEvent("rename-page", { source: "page-menu" });
    },
    [editor, trackEvent]
  );
  return (0, import_jsx_runtime178.jsxs)(TldrawUiPopover, { id: "pages", onOpenChange, open: isOpen, children: [
    (0, import_jsx_runtime178.jsx)(TldrawUiPopoverTrigger, { "data-testid": "main.page-menu", children: (0, import_jsx_runtime178.jsxs)(
      TldrawUiButton,
      {
        type: "menu",
        title: currentPage.name,
        "data-testid": "page-menu.button",
        className: "tlui-page-menu__trigger",
        children: [
          (0, import_jsx_runtime178.jsx)("div", { className: "tlui-page-menu__name", children: currentPage.name }),
          (0, import_jsx_runtime178.jsx)(TldrawUiButtonIcon, { icon: "chevron-down", small: true })
        ]
      }
    ) }),
    (0, import_jsx_runtime178.jsx)(
      TldrawUiPopoverContent,
      {
        side: "bottom",
        align: "start",
        sideOffset: 6,
        disableEscapeKeyDown: isEditing,
        children: (0, import_jsx_runtime178.jsxs)("div", { className: "tlui-page-menu__wrapper", children: [
          (0, import_jsx_runtime178.jsxs)("div", { className: "tlui-page-menu__header", children: [
            (0, import_jsx_runtime178.jsx)("div", { className: "tlui-page-menu__header__title", children: msg2("page-menu.title") }),
            !isReadonlyMode && (0, import_jsx_runtime178.jsxs)("div", { className: "tlui-buttons__horizontal", children: [
              (0, import_jsx_runtime178.jsx)(
                TldrawUiButton,
                {
                  type: "icon",
                  "data-testid": "page-menu.edit",
                  title: msg2(isEditing ? "page-menu.edit-done" : "page-menu.edit-start"),
                  onClick: toggleEditing,
                  children: (0, import_jsx_runtime178.jsx)(TldrawUiButtonIcon, { icon: isEditing ? "check" : "edit" })
                }
              ),
              (0, import_jsx_runtime178.jsx)(
                TldrawUiButton,
                {
                  type: "icon",
                  "data-testid": "page-menu.create",
                  title: msg2(
                    maxPageCountReached ? "page-menu.max-page-count-reached" : "page-menu.create-new-page"
                  ),
                  disabled: maxPageCountReached,
                  onClick: handleCreatePageClick,
                  children: (0, import_jsx_runtime178.jsx)(TldrawUiButtonIcon, { icon: "plus" })
                }
              )
            ] })
          ] }),
          (0, import_jsx_runtime178.jsx)(
            "div",
            {
              "data-testid": "page-menu.list",
              className: "tlui-page-menu__list tlui-menu__group",
              style: { height: ITEM_HEIGHT * pages.length + 4 },
              ref: rSortableContainer,
              children: pages.map((page, index3) => {
                const position = sortablePositionItems[page.id] ?? {
                  position: index3 * 40,
                  offsetY: 0
                };
                return isEditing ? (0, import_jsx_runtime178.jsxs)(
                  "div",
                  {
                    "data-testid": "page-menu.item",
                    className: "tlui-page_menu__item__sortable",
                    style: {
                      zIndex: page.id === currentPage.id ? 888 : index3,
                      transform: `translate(0px, ${position.y + position.offsetY}px)`
                    },
                    children: [
                      (0, import_jsx_runtime178.jsx)(
                        TldrawUiButton,
                        {
                          type: "icon",
                          tabIndex: -1,
                          className: "tlui-page_menu__item__sortable__handle",
                          onPointerDown: handlePointerDown,
                          onPointerUp: handlePointerUp,
                          onPointerMove: handlePointerMove,
                          onKeyDown: handleKeyDown2,
                          "data-id": page.id,
                          "data-index": index3,
                          children: (0, import_jsx_runtime178.jsx)(TldrawUiButtonIcon, { icon: "drag-handle-dots" })
                        }
                      ),
                      breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM && isCoarsePointer ? (
                        // sigh, this is a workaround for iOS Safari
                        // because the device and the radix popover seem
                        // to be fighting over scroll position. Nothing
                        // else seems to work!
                        (0, import_jsx_runtime178.jsxs)(TldrawUiButton, {
                          type: "normal",
                          className: "tlui-page-menu__item__button",
                          onClick: () => {
                            const name = window.prompt("Rename page", page.name);
                            if (name && name !== page.name) {
                              renamePage(page.id, name);
                            }
                          },
                          onDoubleClick: toggleEditing,
                          children: [
                            (0, import_jsx_runtime178.jsx)(TldrawUiButtonCheck, { checked: page.id === currentPage.id }),
                            (0, import_jsx_runtime178.jsx)(TldrawUiButtonLabel, { children: page.name })
                          ]
                        })
                      ) : (0, import_jsx_runtime178.jsx)(
                        "div",
                        {
                          className: "tlui-page_menu__item__sortable__title",
                          style: { height: ITEM_HEIGHT },
                          children: (0, import_jsx_runtime178.jsx)(
                            PageItemInput,
                            {
                              id: page.id,
                              name: page.name,
                              isCurrentPage: page.id === currentPage.id,
                              onComplete: () => {
                                setIsEditing(false);
                                editor.menus.clearOpenMenus();
                              },
                              onCancel: () => {
                                setIsEditing(false);
                                editor.menus.clearOpenMenus();
                              }
                            }
                          )
                        }
                      ),
                      !isReadonlyMode && (0, import_jsx_runtime178.jsx)("div", { className: "tlui-page_menu__item__submenu", "data-isediting": isEditing, children: (0, import_jsx_runtime178.jsx)(PageItemSubmenu, { index: index3, item: page, listSize: pages.length }) })
                    ]
                  },
                  page.id + "_editing"
                ) : (0, import_jsx_runtime178.jsxs)("div", { "data-testid": "page-menu.item", className: "tlui-page-menu__item", children: [
                  (0, import_jsx_runtime178.jsxs)(
                    TldrawUiButton,
                    {
                      type: "normal",
                      className: "tlui-page-menu__item__button",
                      onClick: () => changePage(page.id),
                      onDoubleClick: toggleEditing,
                      title: msg2("page-menu.go-to-page"),
                      children: [
                        (0, import_jsx_runtime178.jsx)(TldrawUiButtonCheck, { checked: page.id === currentPage.id }),
                        (0, import_jsx_runtime178.jsx)(TldrawUiButtonLabel, { children: page.name })
                      ]
                    }
                  ),
                  !isReadonlyMode && (0, import_jsx_runtime178.jsx)("div", { className: "tlui-page_menu__item__submenu", children: (0, import_jsx_runtime178.jsx)(
                    PageItemSubmenu,
                    {
                      index: index3,
                      item: page,
                      listSize: pages.length,
                      onRename: () => {
                        if (tlenv.isIos) {
                          const name = window.prompt("Rename page", page.name);
                          if (name && name !== page.name) {
                            renamePage(page.id, name);
                          }
                        } else {
                          setIsEditing(true);
                          if (currentPageId !== page.id) {
                            changePage(page.id);
                          }
                        }
                      }
                    }
                  ) })
                ] }, page.id);
              })
            }
          )
        ] })
      }
    )
  ] });
});

// node_modules/tldraw/dist-esm/lib/ui/components/QuickActions/DefaultQuickActions.mjs
var import_jsx_runtime180 = __toESM(require_jsx_runtime(), 1);
var import_react120 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/QuickActions/DefaultQuickActionsContent.mjs
var import_jsx_runtime179 = __toESM(require_jsx_runtime(), 1);
function DefaultQuickActionsContent() {
  const editor = useEditor();
  const isReadonlyMode = useReadonly();
  const isInAcceptableReadonlyState = useValue(
    "should display quick actions",
    () => editor.isInAny("select", "hand", "zoom"),
    [editor]
  );
  if (isReadonlyMode && !isInAcceptableReadonlyState)
    return;
  return (0, import_jsx_runtime179.jsxs)(import_jsx_runtime179.Fragment, { children: [
    (0, import_jsx_runtime179.jsx)(UndoRedoGroup2, {}),
    (0, import_jsx_runtime179.jsx)(DeleteDuplicateGroup, {})
  ] });
}
function DeleteDuplicateGroup() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const selectDependentActionsEnabled = oneSelected && isInSelectState;
  return (0, import_jsx_runtime179.jsxs)(import_jsx_runtime179.Fragment, { children: [
    (0, import_jsx_runtime179.jsx)(TldrawUiMenuActionItem, { actionId: "delete", disabled: !selectDependentActionsEnabled }),
    (0, import_jsx_runtime179.jsx)(TldrawUiMenuActionItem, { actionId: "duplicate", disabled: !selectDependentActionsEnabled })
  ] });
}
function UndoRedoGroup2() {
  const canUndo = useCanUndo();
  const canRedo = useCanRedo();
  return (0, import_jsx_runtime179.jsxs)(import_jsx_runtime179.Fragment, { children: [
    (0, import_jsx_runtime179.jsx)(TldrawUiMenuActionItem, { actionId: "undo", disabled: !canUndo }),
    (0, import_jsx_runtime179.jsx)(TldrawUiMenuActionItem, { actionId: "redo", disabled: !canRedo })
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/QuickActions/DefaultQuickActions.mjs
var DefaultQuickActions = (0, import_react120.memo)(function DefaultQuickActions2({
  children
}) {
  const content = children ?? (0, import_jsx_runtime180.jsx)(DefaultQuickActionsContent, {});
  return (0, import_jsx_runtime180.jsx)(TldrawUiMenuContextProvider, { type: "small-icons", sourceId: "quick-actions", children: content });
});

// node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/DefaultSharePanel.mjs
var import_jsx_runtime187 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/PeopleMenu.mjs
var import_jsx_runtime186 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/PeopleMenuAvatar.mjs
var import_jsx_runtime181 = __toESM(require_jsx_runtime(), 1);
function PeopleMenuAvatar({ userId }) {
  var _a5;
  const presence = usePresence(userId);
  if (!presence)
    return null;
  return (0, import_jsx_runtime181.jsx)(
    "div",
    {
      className: "tlui-people-menu__avatar",
      style: {
        backgroundColor: presence.color
      },
      children: ((_a5 = presence.userName) == null ? void 0 : _a5[0]) ?? ""
    },
    userId
  );
}

// node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/PeopleMenuItem.mjs
var import_jsx_runtime182 = __toESM(require_jsx_runtime(), 1);
var import_react121 = __toESM(require_react(), 1);
var PeopleMenuItem = track(function PeopleMenuItem2({ userId }) {
  var _a5;
  const editor = useEditor();
  const msg2 = useTranslation();
  const trackEvent = useUiEvents();
  const presence = usePresence(userId);
  const handleFollowClick = (0, import_react121.useCallback)(() => {
    if (editor.getInstanceState().followingUserId === userId) {
      editor.stopFollowingUser();
      trackEvent("stop-following", { source: "people-menu" });
    } else {
      editor.startFollowingUser(userId);
      trackEvent("start-following", { source: "people-menu" });
    }
  }, [editor, userId, trackEvent]);
  const theyAreFollowingYou = (presence == null ? void 0 : presence.followingUserId) === editor.user.getId();
  const youAreFollowingThem = editor.getInstanceState().followingUserId === userId;
  if (!presence)
    return null;
  return (0, import_jsx_runtime182.jsxs)(
    "div",
    {
      className: "tlui-people-menu__item tlui-buttons__horizontal",
      "data-follow": youAreFollowingThem || theyAreFollowingYou,
      children: [
        (0, import_jsx_runtime182.jsxs)(
          TldrawUiButton,
          {
            type: "menu",
            className: "tlui-people-menu__item__button",
            onClick: () => editor.zoomToUser(userId),
            onDoubleClick: handleFollowClick,
            children: [
              (0, import_jsx_runtime182.jsx)(TldrawUiIcon, { label: msg2("people-menu.avatar-color"), icon: "color", color: presence.color }),
              (0, import_jsx_runtime182.jsx)("div", { className: "tlui-people-menu__name", children: ((_a5 = presence.userName) == null ? void 0 : _a5.trim()) || msg2("people-menu.anonymous-user") })
            ]
          }
        ),
        (0, import_jsx_runtime182.jsx)(
          TldrawUiButton,
          {
            type: "icon",
            className: "tlui-people-menu__item__follow",
            title: theyAreFollowingYou ? msg2("people-menu.leading") : youAreFollowingThem ? msg2("people-menu.following") : msg2("people-menu.follow"),
            onClick: handleFollowClick,
            disabled: theyAreFollowingYou,
            children: (0, import_jsx_runtime182.jsx)(
              TldrawUiButtonIcon,
              {
                icon: theyAreFollowingYou ? "leading" : youAreFollowingThem ? "following" : "follow"
              }
            )
          }
        )
      ]
    }
  );
});

// node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/PeopleMenuMore.mjs
var import_jsx_runtime183 = __toESM(require_jsx_runtime(), 1);
function PeopleMenuMore({ count: count3 }) {
  return (0, import_jsx_runtime183.jsx)("div", { className: "tlui-people-menu__more", children: "+" + Math.abs(count3) });
}

// node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/UserPresenceEditor.mjs
var import_jsx_runtime185 = __toESM(require_jsx_runtime(), 1);
var import_react123 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/UserPresenceColorPicker.mjs
var import_jsx_runtime184 = __toESM(require_jsx_runtime(), 1);
var import_react122 = __toESM(require_react(), 1);
var UserPresenceColorPicker = track(function UserPresenceColorPicker2() {
  const editor = useEditor();
  const container = useContainer();
  const msg2 = useTranslation();
  const trackEvent = useUiEvents();
  const rPointing = (0, import_react122.useRef)(false);
  const [isOpen, setIsOpen] = (0, import_react122.useState)(false);
  const handleOpenChange = (0, import_react122.useCallback)((isOpen2) => {
    setIsOpen(isOpen2);
  }, []);
  const value = editor.user.getColor();
  const onValueChange = (0, import_react122.useCallback)(
    (item) => {
      editor.user.updateUserPreferences({ color: item });
      trackEvent("set-color", { source: "people-menu" });
    },
    [editor, trackEvent]
  );
  const {
    handleButtonClick,
    handleButtonPointerDown,
    handleButtonPointerEnter,
    handleButtonPointerUp
  } = import_react122.default.useMemo(() => {
    const handlePointerUp = () => {
      rPointing.current = false;
      window.removeEventListener("pointerup", handlePointerUp);
    };
    const handleButtonClick2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id)
        return;
      if (value === id)
        return;
      onValueChange(id);
    };
    const handleButtonPointerDown2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id)
        return;
      onValueChange(id);
      rPointing.current = true;
      window.addEventListener("pointerup", handlePointerUp);
    };
    const handleButtonPointerEnter2 = (e) => {
      if (!rPointing.current)
        return;
      const { id } = e.currentTarget.dataset;
      if (!id)
        return;
      onValueChange(id);
    };
    const handleButtonPointerUp2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id)
        return;
      onValueChange(id);
    };
    return {
      handleButtonClick: handleButtonClick2,
      handleButtonPointerDown: handleButtonPointerDown2,
      handleButtonPointerEnter: handleButtonPointerEnter2,
      handleButtonPointerUp: handleButtonPointerUp2
    };
  }, [value, onValueChange]);
  return (0, import_jsx_runtime184.jsxs)(dist_exports11.Root, { onOpenChange: handleOpenChange, open: isOpen, children: [
    (0, import_jsx_runtime184.jsx)(dist_exports11.Trigger, { dir: "ltr", asChild: true, children: (0, import_jsx_runtime184.jsx)(
      TldrawUiButton,
      {
        type: "icon",
        className: "tlui-people-menu__user__color",
        style: { color: editor.user.getColor() },
        title: msg2("people-menu.change-color"),
        children: (0, import_jsx_runtime184.jsx)(TldrawUiButtonIcon, { icon: "color" })
      }
    ) }),
    (0, import_jsx_runtime184.jsx)(dist_exports11.Portal, { container, children: (0, import_jsx_runtime184.jsx)(
      dist_exports11.Content,
      {
        dir: "ltr",
        className: "tlui-menu tlui-people-menu__user__color-picker",
        align: "start",
        side: "left",
        sideOffset: 8,
        children: (0, import_jsx_runtime184.jsx)("div", { className: "tlui-buttons__grid", children: USER_COLORS.map((item) => (0, import_jsx_runtime184.jsx)(
          TldrawUiButton,
          {
            type: "icon",
            "data-id": item,
            "data-testid": item,
            "aria-label": item,
            isActive: value === item,
            title: item,
            className: "tlui-button-grid__button",
            style: { color: item },
            onPointerEnter: handleButtonPointerEnter,
            onPointerDown: handleButtonPointerDown,
            onPointerUp: handleButtonPointerUp,
            onClick: handleButtonClick,
            children: (0, import_jsx_runtime184.jsx)(TldrawUiButtonIcon, { icon: "color" })
          },
          item
        )) })
      }
    ) })
  ] });
});

// node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/UserPresenceEditor.mjs
function UserPresenceEditor() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const userName = useValue("userName", () => editor.user.getName(), []);
  const msg2 = useTranslation();
  const rOriginalName = (0, import_react123.useRef)(userName);
  const rCurrentName = (0, import_react123.useRef)(userName);
  const [isEditingName, setIsEditingName] = (0, import_react123.useState)(false);
  const toggleEditingName = (0, import_react123.useCallback)(() => {
    setIsEditingName((s) => !s);
  }, []);
  const handleValueChange = (0, import_react123.useCallback)(
    (value) => {
      rCurrentName.current = value;
      editor.user.updateUserPreferences({ name: value });
    },
    [editor]
  );
  const handleBlur = (0, import_react123.useCallback)(() => {
    if (rOriginalName.current === rCurrentName.current)
      return;
    trackEvent("change-user-name", { source: "people-menu" });
    rOriginalName.current = rCurrentName.current;
  }, [trackEvent]);
  const handleCancel = (0, import_react123.useCallback)(() => {
    setIsEditingName(false);
    editor.user.updateUserPreferences({ name: rOriginalName.current });
    editor.menus.clearOpenMenus();
  }, [editor]);
  return (0, import_jsx_runtime185.jsxs)("div", { className: "tlui-people-menu__user", children: [
    (0, import_jsx_runtime185.jsx)(UserPresenceColorPicker, {}),
    isEditingName ? (0, import_jsx_runtime185.jsx)(
      TldrawUiInput,
      {
        className: "tlui-people-menu__user__input",
        defaultValue: userName,
        onValueChange: handleValueChange,
        onComplete: toggleEditingName,
        onCancel: handleCancel,
        onBlur: handleBlur,
        shouldManuallyMaintainScrollPositionWhenFocused: true,
        autoFocus: true,
        autoSelect: true
      }
    ) : (0, import_jsx_runtime185.jsxs)(import_jsx_runtime185.Fragment, { children: [
      (0, import_jsx_runtime185.jsx)(
        "div",
        {
          className: "tlui-people-menu__user__name",
          onDoubleClick: () => {
            if (!isEditingName)
              setIsEditingName(true);
          },
          children: userName || msg2("people-menu.anonymous-user")
        }
      ),
      !userName ? (0, import_jsx_runtime185.jsx)("div", { className: "tlui-people-menu__user__label", children: msg2("people-menu.user") }) : null
    ] }),
    (0, import_jsx_runtime185.jsx)(
      TldrawUiButton,
      {
        type: "icon",
        className: "tlui-people-menu__user__edit",
        "data-testid": "people-menu.change-name",
        title: msg2("people-menu.change-name"),
        onClick: toggleEditingName,
        children: (0, import_jsx_runtime185.jsx)(TldrawUiButtonIcon, { icon: isEditingName ? "check" : "edit" })
      }
    )
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/PeopleMenu.mjs
function PeopleMenu({ children }) {
  const msg2 = useTranslation();
  const container = useContainer();
  const editor = useEditor();
  const userIds = usePeerIds();
  const userColor = useValue("user", () => editor.user.getColor(), [editor]);
  const userName = useValue("user", () => editor.user.getName(), [editor]);
  const [isOpen, onOpenChange] = useMenuIsOpen("people menu");
  if (!userIds.length)
    return null;
  return (0, import_jsx_runtime186.jsxs)(dist_exports11.Root, { onOpenChange, open: isOpen, children: [
    (0, import_jsx_runtime186.jsx)(dist_exports11.Trigger, { dir: "ltr", asChild: true, children: (0, import_jsx_runtime186.jsxs)("button", { className: "tlui-people-menu__avatars-button", title: msg2("people-menu.title"), children: [
      userIds.length > 5 && (0, import_jsx_runtime186.jsx)(PeopleMenuMore, { count: userIds.length - 5 }),
      (0, import_jsx_runtime186.jsxs)("div", { className: "tlui-people-menu__avatars", children: [
        userIds.slice(-5).map((userId) => (0, import_jsx_runtime186.jsx)(PeopleMenuAvatar, { userId }, userId)),
        userIds.length > 0 && (0, import_jsx_runtime186.jsx)(
          "div",
          {
            className: "tlui-people-menu__avatar",
            style: {
              backgroundColor: userColor
            },
            children: (userName == null ? void 0 : userName[0]) ?? ""
          }
        )
      ] })
    ] }) }),
    (0, import_jsx_runtime186.jsx)(dist_exports11.Portal, { container, children: (0, import_jsx_runtime186.jsx)(
      dist_exports11.Content,
      {
        dir: "ltr",
        className: "tlui-menu",
        side: "bottom",
        sideOffset: 2,
        collisionPadding: 4,
        children: (0, import_jsx_runtime186.jsxs)("div", { className: "tlui-people-menu__wrapper", children: [
          (0, import_jsx_runtime186.jsx)("div", { className: "tlui-people-menu__section", children: (0, import_jsx_runtime186.jsx)(UserPresenceEditor, {}) }),
          userIds.length > 0 && (0, import_jsx_runtime186.jsx)("div", { className: "tlui-people-menu__section", children: userIds.map((userId) => {
            return (0, import_jsx_runtime186.jsx)(PeopleMenuItem, { userId }, userId + "_presence");
          }) }),
          children
        ] })
      }
    ) })
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/DefaultSharePanel.mjs
function DefaultSharePanel() {
  return (0, import_jsx_runtime187.jsx)("div", { className: "tlui-share-zone", draggable: false, children: (0, import_jsx_runtime187.jsx)(PeopleMenu, {}) });
}

// node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/DefaultStylePanel.mjs
var import_jsx_runtime193 = __toESM(require_jsx_runtime(), 1);
var import_classnames31 = __toESM(require_classnames(), 1);
var import_react127 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/hooks/useRelevantStyles.mjs
var selectToolStyles = Object.freeze([
  DefaultColorStyle,
  DefaultDashStyle,
  DefaultFillStyle,
  DefaultSizeStyle
]);
function useRelevantStyles(stylesToCheck = selectToolStyles) {
  const editor = useEditor();
  return useValue(
    "getRelevantStyles",
    () => {
      var _a5;
      const styles = new SharedStyleMap(editor.getSharedStyles());
      const isInShapeSpecificTool = !!((_a5 = editor.root.getCurrent()) == null ? void 0 : _a5.shapeType);
      const hasShapesSelected = editor.isIn("select") && editor.getSelectedShapeIds().length > 0;
      if (styles.size === 0 && editor.isIn("select") && editor.getSelectedShapeIds().length === 0) {
        for (const style2 of stylesToCheck) {
          styles.applyValue(style2, editor.getStyleForNextShape(style2));
        }
      }
      if (isInShapeSpecificTool || hasShapesSelected || styles.size > 0) {
        return styles;
      }
      return null;
    },
    [editor]
  );
}

// node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/DefaultStylePanelContent.mjs
var import_jsx_runtime192 = __toESM(require_jsx_runtime(), 1);
var import_react126 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/styles.mjs
var STYLES = {
  color: [
    { value: "black", icon: "color" },
    { value: "grey", icon: "color" },
    { value: "light-violet", icon: "color" },
    { value: "violet", icon: "color" },
    { value: "blue", icon: "color" },
    { value: "light-blue", icon: "color" },
    { value: "yellow", icon: "color" },
    { value: "orange", icon: "color" },
    { value: "green", icon: "color" },
    { value: "light-green", icon: "color" },
    { value: "light-red", icon: "color" },
    { value: "red", icon: "color" }
  ],
  fill: [
    { value: "none", icon: "fill-none" },
    { value: "semi", icon: "fill-semi" },
    { value: "solid", icon: "fill-solid" },
    { value: "pattern", icon: "fill-pattern" }
    // { value: 'fill', icon: 'fill-fill' },
  ],
  dash: [
    { value: "draw", icon: "dash-draw" },
    { value: "dashed", icon: "dash-dashed" },
    { value: "dotted", icon: "dash-dotted" },
    { value: "solid", icon: "dash-solid" }
  ],
  size: [
    { value: "s", icon: "size-small" },
    { value: "m", icon: "size-medium" },
    { value: "l", icon: "size-large" },
    { value: "xl", icon: "size-extra-large" }
  ],
  font: [
    { value: "draw", icon: "font-draw" },
    { value: "sans", icon: "font-sans" },
    { value: "serif", icon: "font-serif" },
    { value: "mono", icon: "font-mono" }
  ],
  textAlign: [
    { value: "start", icon: "text-align-left" },
    { value: "middle", icon: "text-align-center" },
    { value: "end", icon: "text-align-right" }
  ],
  horizontalAlign: [
    { value: "start", icon: "horizontal-align-start" },
    { value: "middle", icon: "horizontal-align-middle" },
    { value: "end", icon: "horizontal-align-end" }
  ],
  verticalAlign: [
    { value: "start", icon: "vertical-align-start" },
    { value: "middle", icon: "vertical-align-middle" },
    { value: "end", icon: "vertical-align-end" }
  ],
  geo: [
    { value: "rectangle", icon: "geo-rectangle" },
    { value: "ellipse", icon: "geo-ellipse" },
    { value: "triangle", icon: "geo-triangle" },
    { value: "diamond", icon: "geo-diamond" },
    { value: "star", icon: "geo-star" },
    { value: "pentagon", icon: "geo-pentagon" },
    { value: "hexagon", icon: "geo-hexagon" },
    { value: "octagon", icon: "geo-octagon" },
    { value: "rhombus", icon: "geo-rhombus" },
    { value: "rhombus-2", icon: "geo-rhombus-2" },
    { value: "oval", icon: "geo-oval" },
    { value: "trapezoid", icon: "geo-trapezoid" },
    { value: "arrow-left", icon: "geo-arrow-left" },
    { value: "arrow-up", icon: "geo-arrow-up" },
    { value: "arrow-down", icon: "geo-arrow-down" },
    { value: "arrow-right", icon: "geo-arrow-right" },
    { value: "cloud", icon: "geo-cloud" },
    { value: "x-box", icon: "geo-x-box" },
    { value: "check-box", icon: "geo-check-box" },
    { value: "heart", icon: "geo-heart" }
  ],
  arrowKind: [
    { value: "arc", icon: "arrow-arc" },
    { value: "elbow", icon: "arrow-elbow" }
  ],
  arrowheadStart: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  arrowheadEnd: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  spline: [
    { value: "line", icon: "spline-line" },
    { value: "cubic", icon: "spline-cubic" }
  ]
};

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiButtonPicker.mjs
var import_jsx_runtime188 = __toESM(require_jsx_runtime(), 1);
var import_classnames29 = __toESM(require_classnames(), 1);
var import_react124 = __toESM(require_react(), 1);
var TldrawUiButtonPicker = (0, import_react124.memo)(function TldrawUiButtonPicker2(props) {
  const {
    uiType,
    items,
    title,
    style: style2,
    value,
    // columns = clamp(items.length, 2, 4),
    onValueChange,
    onHistoryMark,
    theme
  } = props;
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const rPointing = (0, import_react124.useRef)(false);
  const rPointingOriginalActiveElement = (0, import_react124.useRef)(null);
  const {
    handleButtonClick,
    handleButtonPointerDown,
    handleButtonPointerEnter,
    handleButtonPointerUp
  } = (0, import_react124.useMemo)(() => {
    const handlePointerUp = () => {
      rPointing.current = false;
      window.removeEventListener("pointerup", handlePointerUp);
      const origActiveEl = rPointingOriginalActiveElement.current;
      if (origActiveEl && (["TEXTAREA", "INPUT"].includes(origActiveEl.nodeName) || origActiveEl.isContentEditable)) {
        origActiveEl.focus();
      } else if (breakpoint >= PORTRAIT_BREAKPOINT.TABLET_SM) {
        editor.getContainer().focus();
      }
      rPointingOriginalActiveElement.current = null;
    };
    const handleButtonClick2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (value.type === "shared" && value.value === id)
        return;
      onHistoryMark == null ? void 0 : onHistoryMark("point picker item");
      onValueChange(style2, id);
    };
    const handleButtonPointerDown2 = (e) => {
      const { id } = e.currentTarget.dataset;
      onHistoryMark == null ? void 0 : onHistoryMark("point picker item");
      onValueChange(style2, id);
      rPointing.current = true;
      rPointingOriginalActiveElement.current = document.activeElement;
      window.addEventListener("pointerup", handlePointerUp);
    };
    const handleButtonPointerEnter2 = (e) => {
      if (!rPointing.current)
        return;
      const { id } = e.currentTarget.dataset;
      onValueChange(style2, id);
    };
    const handleButtonPointerUp2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (value.type === "shared" && value.value === id)
        return;
      onValueChange(style2, id);
    };
    return {
      handleButtonClick: handleButtonClick2,
      handleButtonPointerDown: handleButtonPointerDown2,
      handleButtonPointerEnter: handleButtonPointerEnter2,
      handleButtonPointerUp: handleButtonPointerUp2
    };
  }, [editor, breakpoint, value, onHistoryMark, onValueChange, style2]);
  return (0, import_jsx_runtime188.jsx)(
    TldrawUiToolbarToggleGroup,
    {
      "data-testid": `style.${uiType}`,
      type: "single",
      className: (0, import_classnames29.default)("tlui-buttons__grid"),
      children: items.map((item) => {
        const label = title + " — " + msg2(`${uiType}-style.${item.value}`);
        return (0, import_jsx_runtime188.jsx)(
          TldrawUiToolbarToggleItem,
          {
            type: "icon",
            "data-id": item.value,
            "data-testid": `style.${uiType}.${item.value}`,
            "aria-label": label,
            value: item.value,
            "data-isactive": value.type === "shared" && value.value === item.value,
            title: label,
            className: (0, import_classnames29.default)("tlui-button-grid__button"),
            style: style2 === DefaultColorStyle ? { color: theme[item.value].solid } : void 0,
            onPointerEnter: handleButtonPointerEnter,
            onPointerDown: handleButtonPointerDown,
            onPointerUp: handleButtonPointerUp,
            onClick: handleButtonClick,
            children: (0, import_jsx_runtime188.jsx)(TldrawUiButtonIcon, { icon: item.icon })
          },
          item.value
        );
      })
    }
  );
});

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiSlider.mjs
var import_jsx_runtime189 = __toESM(require_jsx_runtime(), 1);
var import_react125 = __toESM(require_react(), 1);
var TldrawUiSlider = (0, import_react125.memo)(function Slider2({
  onHistoryMark,
  title,
  steps,
  value,
  label,
  onValueChange,
  ["data-testid"]: testId
}) {
  const msg2 = useTranslation();
  const [tabIndex, setTabIndex] = (0, import_react125.useState)(-1);
  (0, import_react125.useEffect)(() => {
    setTabIndex(0);
  }, []);
  const handleValueChange = (0, import_react125.useCallback)(
    (value2) => {
      onValueChange(value2[0]);
    },
    [onValueChange]
  );
  const handlePointerDown = (0, import_react125.useCallback)(() => {
    onHistoryMark("click slider");
  }, [onHistoryMark]);
  const handlePointerUp = (0, import_react125.useCallback)(() => {
    if (!value)
      return;
    onValueChange(value);
  }, [value, onValueChange]);
  const handleKeyEvent = (0, import_react125.useCallback)((event) => {
    if (event.key === "Tab") {
      event.stopPropagation();
    }
  }, []);
  return (0, import_jsx_runtime189.jsx)("div", { className: "tlui-slider__container", children: (0, import_jsx_runtime189.jsxs)(
    dist_exports12.Root,
    {
      "data-testid": testId,
      className: "tlui-slider",
      dir: "ltr",
      min: 0,
      max: steps,
      step: 1,
      value: value ? [value] : void 0,
      onPointerDown: handlePointerDown,
      onValueChange: handleValueChange,
      onPointerUp: handlePointerUp,
      onKeyDownCapture: handleKeyEvent,
      onKeyUpCapture: handleKeyEvent,
      title: title + " — " + msg2(label),
      children: [
        (0, import_jsx_runtime189.jsx)(dist_exports12.Track, { className: "tlui-slider__track", dir: "ltr", children: value !== null && (0, import_jsx_runtime189.jsx)(dist_exports12.Range, { className: "tlui-slider__range", dir: "ltr" }) }),
        value !== null && (0, import_jsx_runtime189.jsx)(
          dist_exports12.Thumb,
          {
            "aria-label": msg2("style-panel.opacity"),
            className: "tlui-slider__thumb",
            dir: "ltr",
            tabIndex
          }
        )
      ]
    }
  ) });
});

// node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/DoubleDropdownPicker.mjs
var import_jsx_runtime190 = __toESM(require_jsx_runtime(), 1);
var React100 = __toESM(require_react(), 1);
function DoubleDropdownPickerInner({
  label,
  uiTypeA,
  uiTypeB,
  labelA,
  labelB,
  itemsA,
  itemsB,
  styleA,
  styleB,
  valueA,
  valueB,
  onValueChange
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const [isOpenA, setIsOpenA] = React100.useState(false);
  const [isOpenB, setIsOpenB] = React100.useState(false);
  const iconA = React100.useMemo(
    () => {
      var _a5;
      return ((_a5 = itemsA.find((item) => valueA.type === "shared" && valueA.value === item.value)) == null ? void 0 : _a5.icon) ?? "mixed";
    },
    [itemsA, valueA]
  );
  const iconB = React100.useMemo(
    () => {
      var _a5;
      return ((_a5 = itemsB.find((item) => valueB.type === "shared" && valueB.value === item.value)) == null ? void 0 : _a5.icon) ?? "mixed";
    },
    [itemsB, valueB]
  );
  if (valueA === void 0 && valueB === void 0)
    return null;
  const idA = `style panel ${uiTypeA} A`;
  const idB = `style panel ${uiTypeB} B`;
  return (0, import_jsx_runtime190.jsxs)("div", { className: "tlui-style-panel__double-select-picker", children: [
    (0, import_jsx_runtime190.jsx)("div", { title: msg2(label), className: "tlui-style-panel__double-select-picker-label", children: msg2(label) }),
    (0, import_jsx_runtime190.jsxs)(TldrawUiToolbar, { label: msg2(label), className: "tlui-buttons__horizontal", children: [
      (0, import_jsx_runtime190.jsxs)(TldrawUiPopover, { id: idA, open: isOpenA, onOpenChange: setIsOpenA, children: [
        (0, import_jsx_runtime190.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime190.jsx)(
          TldrawUiToolbarButton,
          {
            type: "icon",
            "data-testid": `style.${uiTypeA}`,
            title: msg2(labelA) + " — " + (valueA === null || valueA.type === "mixed" ? msg2("style-panel.mixed") : msg2(`${uiTypeA}-style.${valueA.value}`)),
            children: (0, import_jsx_runtime190.jsx)(TldrawUiButtonIcon, { icon: iconA, small: true, invertIcon: true })
          }
        ) }),
        (0, import_jsx_runtime190.jsx)(TldrawUiPopoverContent, { side: "left", align: "center", sideOffset: 80, alignOffset: 0, children: (0, import_jsx_runtime190.jsx)(TldrawUiToolbar, { label: msg2(labelA), className: "tlui-buttons__grid", children: (0, import_jsx_runtime190.jsx)(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: itemsA.map((item) => {
          return (0, import_jsx_runtime190.jsx)(
            TldrawUiToolbarButton,
            {
              "data-testid": `style.${uiTypeA}.${item.value}`,
              type: "icon",
              onClick: () => {
                onValueChange(styleA, item.value);
                tlmenus.deleteOpenMenu(idA, editor.contextId);
                setIsOpenA(false);
              },
              title: `${msg2(labelA)} — ${msg2(`${uiTypeA}-style.${item.value}`)}`,
              children: (0, import_jsx_runtime190.jsx)(TldrawUiButtonIcon, { icon: item.icon, invertIcon: true })
            },
            item.value
          );
        }) }) }) })
      ] }),
      (0, import_jsx_runtime190.jsxs)(TldrawUiPopover, { id: idB, open: isOpenB, onOpenChange: setIsOpenB, children: [
        (0, import_jsx_runtime190.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime190.jsx)(
          TldrawUiToolbarButton,
          {
            type: "icon",
            "data-testid": `style.${uiTypeB}`,
            title: msg2(labelB) + " — " + (valueB === null || valueB.type === "mixed" ? msg2("style-panel.mixed") : msg2(`${uiTypeB}-style.${valueB.value}`)),
            children: (0, import_jsx_runtime190.jsx)(TldrawUiButtonIcon, { icon: iconB, small: true })
          }
        ) }),
        (0, import_jsx_runtime190.jsx)(TldrawUiPopoverContent, { side: "left", align: "center", sideOffset: 116, alignOffset: 0, children: (0, import_jsx_runtime190.jsx)(TldrawUiToolbar, { label: msg2(labelB), className: "tlui-buttons__grid", children: (0, import_jsx_runtime190.jsx)(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: itemsB.map((item) => {
          return (0, import_jsx_runtime190.jsx)(
            TldrawUiToolbarButton,
            {
              type: "icon",
              title: `${msg2(labelB)} — ${msg2(`${uiTypeB}-style.${item.value}`)}`,
              "data-testid": `style.${uiTypeB}.${item.value}`,
              onClick: () => {
                onValueChange(styleB, item.value);
                tlmenus.deleteOpenMenu(idB, editor.contextId);
                setIsOpenB(false);
              },
              children: (0, import_jsx_runtime190.jsx)(TldrawUiButtonIcon, { icon: item.icon })
            },
            item.value
          );
        }) }) }) })
      ] })
    ] })
  ] });
}
var DoubleDropdownPicker = React100.memo(
  DoubleDropdownPickerInner
);

// node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/DropdownPicker.mjs
var import_jsx_runtime191 = __toESM(require_jsx_runtime(), 1);
var import_classnames30 = __toESM(require_classnames(), 1);
var React101 = __toESM(require_react(), 1);
function DropdownPickerInner({
  id,
  label,
  uiType,
  stylePanelType,
  style: style2,
  items,
  type,
  value,
  onValueChange
}) {
  const msg2 = useTranslation();
  const editor = useEditor();
  const [isOpen, setIsOpen] = React101.useState(false);
  const icon = React101.useMemo(
    () => {
      var _a5;
      return (_a5 = items.find((item) => value.type === "shared" && item.value === value.value)) == null ? void 0 : _a5.icon;
    },
    [items, value]
  );
  const stylePanelName = msg2(`style-panel.${stylePanelType}`);
  const titleStr = value.type === "mixed" ? msg2("style-panel.mixed") : stylePanelName + " — " + msg2(`${uiType}-style.${value.value}`);
  const labelStr = label ? msg2(label) : "";
  const popoverId = `style panel ${id}`;
  return (0, import_jsx_runtime191.jsxs)(TldrawUiPopover, { id: popoverId, open: isOpen, onOpenChange: setIsOpen, children: [
    (0, import_jsx_runtime191.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime191.jsxs)(
      TldrawUiToolbarButton,
      {
        type,
        "data-testid": `style.${uiType}`,
        "data-direction": "left",
        title: titleStr,
        children: [
          labelStr && (0, import_jsx_runtime191.jsx)(TldrawUiButtonLabel, { children: labelStr }),
          (0, import_jsx_runtime191.jsx)(TldrawUiButtonIcon, { icon: icon ?? "mixed" })
        ]
      }
    ) }),
    (0, import_jsx_runtime191.jsx)(TldrawUiPopoverContent, { side: "left", align: "center", children: (0, import_jsx_runtime191.jsx)(
      TldrawUiToolbar,
      {
        label: labelStr,
        className: (0, import_classnames30.default)("tlui-buttons__grid", `tlui-buttons__${stylePanelType}`),
        children: (0, import_jsx_runtime191.jsx)(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: items.map((item) => {
          return (0, import_jsx_runtime191.jsx)(
            TldrawUiToolbarButton,
            {
              type: "icon",
              "data-testid": `style.${uiType}.${item.value}`,
              title: stylePanelName + " — " + msg2(`${uiType}-style.${item.value}`),
              isActive: icon === item.icon,
              onClick: () => {
                editor.markHistoryStoppingPoint("select style dropdown item");
                onValueChange(style2, item.value);
                tlmenus.deleteOpenMenu(popoverId, editor.contextId);
                setIsOpen(false);
              },
              children: (0, import_jsx_runtime191.jsx)(TldrawUiButtonIcon, { icon: item.icon })
            },
            item.value
          );
        }) })
      }
    ) })
  ] });
}
var DropdownPicker = React101.memo(DropdownPickerInner);

// node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/DefaultStylePanelContent.mjs
function DefaultStylePanelContent({ styles }) {
  const isDarkMode = useIsDarkMode();
  if (!styles)
    return null;
  const geo = styles.get(GeoShapeGeoStyle);
  const arrowheadEnd = styles.get(ArrowShapeArrowheadEndStyle);
  const arrowheadStart = styles.get(ArrowShapeArrowheadStartStyle);
  const arrowKind = styles.get(ArrowShapeKindStyle);
  const spline = styles.get(LineShapeSplineStyle);
  const font = styles.get(DefaultFontStyle);
  const hideGeo = geo === void 0;
  const hideArrowHeads = arrowheadEnd === void 0 && arrowheadStart === void 0;
  const hideSpline = spline === void 0;
  const hideArrowKind = arrowKind === void 0;
  const hideText = font === void 0;
  const theme = getDefaultColorTheme({ isDarkMode });
  return (0, import_jsx_runtime192.jsxs)(import_jsx_runtime192.Fragment, { children: [
    (0, import_jsx_runtime192.jsx)(CommonStylePickerSet, { theme, styles }),
    !hideText && (0, import_jsx_runtime192.jsx)(TextStylePickerSet, { theme, styles }),
    !(hideGeo && hideArrowHeads && hideSpline && hideArrowKind) && (0, import_jsx_runtime192.jsxs)("div", { className: "tlui-style-panel__section", children: [
      (0, import_jsx_runtime192.jsx)(GeoStylePickerSet, { styles }),
      (0, import_jsx_runtime192.jsx)(ArrowStylePickerSet, { styles }),
      (0, import_jsx_runtime192.jsx)(ArrowheadStylePickerSet, { styles }),
      (0, import_jsx_runtime192.jsx)(SplineStylePickerSet, { styles })
    ] })
  ] });
}
function useStyleChangeCallback() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  return import_react126.default.useMemo(
    () => function handleStyleChange(style2, value) {
      editor.run(() => {
        if (editor.isIn("select")) {
          editor.setStyleForSelectedShapes(style2, value);
        }
        editor.setStyleForNextShapes(style2, value);
        editor.updateInstanceState({ isChangingStyle: true });
      });
      trackEvent("set-style", { source: "style-panel", id: style2.id, value });
    },
    [editor, trackEvent]
  );
}
function CommonStylePickerSet({ styles, theme }) {
  const msg2 = useTranslation();
  const editor = useEditor();
  const onHistoryMark = (0, import_react126.useCallback)((id) => editor.markHistoryStoppingPoint(id), [editor]);
  const handleValueChange = useStyleChangeCallback();
  const color = styles.get(DefaultColorStyle);
  const fill = styles.get(DefaultFillStyle);
  const dash = styles.get(DefaultDashStyle);
  const size4 = styles.get(DefaultSizeStyle);
  const showPickers = fill !== void 0 || dash !== void 0 || size4 !== void 0;
  return (0, import_jsx_runtime192.jsxs)(import_jsx_runtime192.Fragment, { children: [
    (0, import_jsx_runtime192.jsxs)("div", { className: "tlui-style-panel__section__common", "data-testid": "style.panel", children: [
      color === void 0 ? null : (0, import_jsx_runtime192.jsx)(TldrawUiToolbar, { label: msg2("style-panel.color"), children: (0, import_jsx_runtime192.jsx)(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.color"),
          uiType: "color",
          style: DefaultColorStyle,
          items: STYLES.color,
          value: color,
          onValueChange: handleValueChange,
          theme,
          onHistoryMark
        }
      ) }),
      (0, import_jsx_runtime192.jsx)(OpacitySlider, {})
    ] }),
    showPickers && (0, import_jsx_runtime192.jsxs)("div", { className: "tlui-style-panel__section", children: [
      fill === void 0 ? null : (0, import_jsx_runtime192.jsx)(TldrawUiToolbar, { label: msg2("style-panel.fill"), children: (0, import_jsx_runtime192.jsx)(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.fill"),
          uiType: "fill",
          style: DefaultFillStyle,
          items: STYLES.fill,
          value: fill,
          onValueChange: handleValueChange,
          theme,
          onHistoryMark
        }
      ) }),
      dash === void 0 ? null : (0, import_jsx_runtime192.jsx)(TldrawUiToolbar, { label: msg2("style-panel.dash"), children: (0, import_jsx_runtime192.jsx)(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.dash"),
          uiType: "dash",
          style: DefaultDashStyle,
          items: STYLES.dash,
          value: dash,
          onValueChange: handleValueChange,
          theme,
          onHistoryMark
        }
      ) }),
      size4 === void 0 ? null : (0, import_jsx_runtime192.jsx)(TldrawUiToolbar, { label: msg2("style-panel.size"), children: (0, import_jsx_runtime192.jsx)(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.size"),
          uiType: "size",
          style: DefaultSizeStyle,
          items: STYLES.size,
          value: size4,
          onValueChange: (style2, value) => {
            handleValueChange(style2, value);
            const selectedShapeIds = editor.getSelectedShapeIds();
            if (selectedShapeIds.length > 0) {
              kickoutOccludedShapes(editor, selectedShapeIds);
            }
          },
          theme,
          onHistoryMark
        }
      ) })
    ] })
  ] });
}
function TextStylePickerSet({ theme, styles }) {
  const msg2 = useTranslation();
  const handleValueChange = useStyleChangeCallback();
  const editor = useEditor();
  const onHistoryMark = (0, import_react126.useCallback)((id) => editor.markHistoryStoppingPoint(id), [editor]);
  const font = styles.get(DefaultFontStyle);
  const textAlign = styles.get(DefaultTextAlignStyle);
  const labelAlign = styles.get(DefaultHorizontalAlignStyle);
  const verticalLabelAlign = styles.get(DefaultVerticalAlignStyle);
  if (font === void 0 && labelAlign === void 0) {
    return null;
  }
  return (0, import_jsx_runtime192.jsxs)("div", { className: "tlui-style-panel__section", children: [
    font === void 0 ? null : (0, import_jsx_runtime192.jsx)(TldrawUiToolbar, { label: msg2("style-panel.font"), children: (0, import_jsx_runtime192.jsx)(
      TldrawUiButtonPicker,
      {
        title: msg2("style-panel.font"),
        uiType: "font",
        style: DefaultFontStyle,
        items: STYLES.font,
        value: font,
        onValueChange: handleValueChange,
        theme,
        onHistoryMark
      }
    ) }),
    textAlign === void 0 ? null : (0, import_jsx_runtime192.jsxs)(TldrawUiToolbar, { label: msg2("style-panel.align"), className: "tlui-style-panel__row", children: [
      (0, import_jsx_runtime192.jsx)(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.align"),
          uiType: "align",
          style: DefaultTextAlignStyle,
          items: STYLES.textAlign,
          value: textAlign,
          onValueChange: handleValueChange,
          theme,
          onHistoryMark
        }
      ),
      (0, import_jsx_runtime192.jsx)("div", { className: "tlui-style-panel__row__extra-button", children: (0, import_jsx_runtime192.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          title: msg2("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: true,
          children: (0, import_jsx_runtime192.jsx)(TldrawUiButtonIcon, { icon: "vertical-align-middle" })
        }
      ) })
    ] }),
    labelAlign === void 0 ? null : (0, import_jsx_runtime192.jsxs)(TldrawUiToolbar, { label: msg2("style-panel.label-align"), className: "tlui-style-panel__row", children: [
      (0, import_jsx_runtime192.jsx)(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.label-align"),
          uiType: "align",
          style: DefaultHorizontalAlignStyle,
          items: STYLES.horizontalAlign,
          value: labelAlign,
          onValueChange: handleValueChange,
          theme,
          onHistoryMark
        }
      ),
      (0, import_jsx_runtime192.jsx)("div", { className: "tlui-style-panel__row__extra-button", children: verticalLabelAlign === void 0 ? (0, import_jsx_runtime192.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          title: msg2("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: true,
          children: (0, import_jsx_runtime192.jsx)(TldrawUiButtonIcon, { icon: "vertical-align-middle" })
        }
      ) : (0, import_jsx_runtime192.jsx)(
        DropdownPicker,
        {
          type: "icon",
          id: "geo-vertical-alignment",
          uiType: "verticalAlign",
          stylePanelType: "vertical-align",
          style: DefaultVerticalAlignStyle,
          items: STYLES.verticalAlign,
          value: verticalLabelAlign,
          onValueChange: handleValueChange
        }
      ) })
    ] })
  ] });
}
function GeoStylePickerSet({ styles }) {
  const msg2 = useTranslation();
  const handleValueChange = useStyleChangeCallback();
  const geo = styles.get(GeoShapeGeoStyle);
  if (geo === void 0) {
    return null;
  }
  return (0, import_jsx_runtime192.jsx)(TldrawUiToolbar, { label: msg2("style-panel.geo"), children: (0, import_jsx_runtime192.jsx)(
    DropdownPicker,
    {
      id: "geo",
      type: "menu",
      label: "style-panel.geo",
      uiType: "geo",
      stylePanelType: "geo",
      style: GeoShapeGeoStyle,
      items: STYLES.geo,
      value: geo,
      onValueChange: handleValueChange
    }
  ) });
}
function SplineStylePickerSet({ styles }) {
  const msg2 = useTranslation();
  const handleValueChange = useStyleChangeCallback();
  const spline = styles.get(LineShapeSplineStyle);
  if (spline === void 0) {
    return null;
  }
  return (0, import_jsx_runtime192.jsx)(TldrawUiToolbar, { label: msg2("style-panel.spline"), children: (0, import_jsx_runtime192.jsx)(
    DropdownPicker,
    {
      id: "spline",
      type: "menu",
      label: "style-panel.spline",
      uiType: "spline",
      stylePanelType: "spline",
      style: LineShapeSplineStyle,
      items: STYLES.spline,
      value: spline,
      onValueChange: handleValueChange
    }
  ) });
}
function ArrowStylePickerSet({ styles }) {
  const msg2 = useTranslation();
  const handleValueChange = useStyleChangeCallback();
  const arrowKind = styles.get(ArrowShapeKindStyle);
  if (arrowKind === void 0) {
    return null;
  }
  return (0, import_jsx_runtime192.jsx)(TldrawUiToolbar, { label: msg2("style-panel.arrow-kind"), children: (0, import_jsx_runtime192.jsx)(
    DropdownPicker,
    {
      id: "arrow-kind",
      type: "menu",
      label: "style-panel.arrow-kind",
      uiType: "arrow-kind",
      stylePanelType: "arrow-kind",
      style: ArrowShapeKindStyle,
      items: STYLES.arrowKind,
      value: arrowKind,
      onValueChange: handleValueChange
    }
  ) });
}
function ArrowheadStylePickerSet({ styles }) {
  const handleValueChange = useStyleChangeCallback();
  const arrowheadEnd = styles.get(ArrowShapeArrowheadEndStyle);
  const arrowheadStart = styles.get(ArrowShapeArrowheadStartStyle);
  if (!arrowheadEnd || !arrowheadStart) {
    return null;
  }
  return (0, import_jsx_runtime192.jsx)(
    DoubleDropdownPicker,
    {
      label: "style-panel.arrowheads",
      uiTypeA: "arrowheadStart",
      styleA: ArrowShapeArrowheadStartStyle,
      itemsA: STYLES.arrowheadStart,
      valueA: arrowheadStart,
      uiTypeB: "arrowheadEnd",
      styleB: ArrowShapeArrowheadEndStyle,
      itemsB: STYLES.arrowheadEnd,
      valueB: arrowheadEnd,
      onValueChange: handleValueChange,
      labelA: "style-panel.arrowhead-start",
      labelB: "style-panel.arrowhead-end"
    }
  );
}
var tldrawSupportedOpacities = [0.1, 0.25, 0.5, 0.75, 1];
function OpacitySlider() {
  const editor = useEditor();
  const onHistoryMark = (0, import_react126.useCallback)((id) => editor.markHistoryStoppingPoint(id), [editor]);
  const opacity = useValue("opacity", () => editor.getSharedOpacity(), [editor]);
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const handleOpacityValueChange = import_react126.default.useCallback(
    (value) => {
      const item = tldrawSupportedOpacities[value];
      editor.run(() => {
        if (editor.isIn("select")) {
          editor.setOpacityForSelectedShapes(item);
        }
        editor.setOpacityForNextShapes(item);
        editor.updateInstanceState({ isChangingStyle: true });
      });
      trackEvent("set-style", { source: "style-panel", id: "opacity", value });
    },
    [editor, trackEvent]
  );
  if (opacity === void 0)
    return null;
  const opacityIndex = opacity.type === "mixed" ? -1 : tldrawSupportedOpacities.indexOf(
    minBy(
      tldrawSupportedOpacities,
      (supportedOpacity) => Math.abs(supportedOpacity - opacity.value)
    )
  );
  return (0, import_jsx_runtime192.jsx)(
    TldrawUiSlider,
    {
      "data-testid": "style.opacity",
      value: opacityIndex >= 0 ? opacityIndex : tldrawSupportedOpacities.length - 1,
      label: opacity.type === "mixed" ? "style-panel.mixed" : `opacity-style.${opacity.value}`,
      onValueChange: handleOpacityValueChange,
      steps: tldrawSupportedOpacities.length - 1,
      title: msg2("style-panel.opacity"),
      onHistoryMark
    }
  );
}

// node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/DefaultStylePanel.mjs
var DefaultStylePanel = (0, import_react127.memo)(function DefaultStylePanel2({
  isMobile,
  children
}) {
  const editor = useEditor();
  const ref = (0, import_react127.useRef)(null);
  usePassThroughWheelEvents(ref);
  const styles = useRelevantStyles();
  const handlePointerOut = (0, import_react127.useCallback)(() => {
    if (!isMobile) {
      editor.updateInstanceState({ isChangingStyle: false });
    }
  }, [editor, isMobile]);
  const content = children ?? (0, import_jsx_runtime193.jsx)(DefaultStylePanelContent, { styles });
  return (0, import_jsx_runtime193.jsx)(
    "div",
    {
      ref,
      className: (0, import_classnames31.default)("tlui-style-panel", { "tlui-style-panel__wrapper": !isMobile }),
      "data-ismobile": isMobile,
      onPointerLeave: handlePointerOut,
      children: content
    }
  );
});

// node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultRichTextToolbar.mjs
var import_jsx_runtime197 = __toESM(require_jsx_runtime(), 1);
var import_react131 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiContextualToolbar.mjs
var import_jsx_runtime194 = __toESM(require_jsx_runtime(), 1);
var import_classnames32 = __toESM(require_classnames(), 1);
var import_react128 = __toESM(require_react(), 1);
var TldrawUiContextualToolbar = import_react128.default.forwardRef(function TldrawUiContextualToolbar2({ children, className, label }, toolbarRef) {
  usePassThroughWheelEvents(toolbarRef);
  usePassThroughMouseOverEvents(toolbarRef);
  return (0, import_jsx_runtime194.jsx)(
    "div",
    {
      ref: toolbarRef,
      "data-testid": "contextual-toolbar",
      className: (0, import_classnames32.default)("tlui-contextual-toolbar", className),
      onPointerDown: stopEventPropagation,
      children: (0, import_jsx_runtime194.jsx)(TldrawUiToolbar, { className: "tlui-menu tlui-buttons__horizontal", label, children })
    }
  );
});

// node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultRichTextToolbarContent.mjs
var import_jsx_runtime195 = __toESM(require_jsx_runtime(), 1);
var import_react129 = __toESM(require_react(), 1);
function DefaultRichTextToolbarContent({
  textEditor,
  onEditLinkStart
}) {
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const source = "rich-text-menu";
  const [_, set] = (0, import_react129.useState)(0);
  (0, import_react129.useEffect)(
    function forceUpdateWhenContentChanges() {
      function forceUpdate() {
        set((t2) => t2 + 1);
      }
      textEditor.on("update", forceUpdate);
      textEditor.on("selectionUpdate", forceUpdate);
    },
    [textEditor]
  );
  (0, import_react129.useEffect)(() => {
    function handleKeyDown2(event) {
      if (onEditLinkStart && isAccelKey(event) && event.shiftKey && event.key === "k") {
        event.preventDefault();
        onEditLinkStart();
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [onEditLinkStart]);
  const actions = (0, import_react129.useMemo)(() => {
    function handleOp(name, op) {
      trackEvent("rich-text", { operation: name, source });
      textEditor.chain().focus()[op]().run();
    }
    return [
      // { name: 'heading', attrs: { level: 3 }, onSelect() { textEditor.chain().focus().toggleHeading({ level: 3}).run() }},
      {
        name: "bold",
        onSelect() {
          handleOp("bold", "toggleBold");
        }
      },
      {
        name: "italic",
        onSelect() {
          handleOp("bold", "toggleItalic");
        }
      },
      // { name: 'underline', onSelect() { handleOp('underline', 'toggleUnderline') }},
      // { name: 'strike', onSelect() { handleOp('strike', 'toggleStrike')  }},
      {
        name: "code",
        onSelect() {
          handleOp("bold", "toggleCode");
        }
      },
      onEditLinkStart ? {
        name: "link",
        onSelect() {
          onEditLinkStart();
        }
      } : void 0,
      // ? is this really optional?
      {
        name: "bulletList",
        onSelect() {
          handleOp("bulletList", "toggleBulletList");
        }
      },
      {
        name: "highlight",
        onSelect() {
          handleOp("bulletList", "toggleHighlight");
        }
      }
    ].filter(Boolean);
  }, [textEditor, trackEvent, onEditLinkStart]);
  return actions.map(({ name, attrs, onSelect }) => {
    const isActive2 = textEditor.isActive(name, attrs);
    return (0, import_jsx_runtime195.jsx)(
      TldrawUiToolbarButton,
      {
        title: msg2(`tool.rich-text-${name}`),
        "data-testid": `rich-text.${name}`,
        type: "icon",
        isActive: isActive2,
        onPointerDown: preventDefault,
        onClick: onSelect,
        role: "option",
        "aria-pressed": isActive2,
        children: (0, import_jsx_runtime195.jsx)(TldrawUiButtonIcon, { small: true, icon: name })
      },
      name
    );
  });
}

// node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/LinkEditor.mjs
var import_jsx_runtime196 = __toESM(require_jsx_runtime(), 1);
var import_react130 = __toESM(require_react(), 1);
function LinkEditor({ textEditor, value: initialValue, onComplete }) {
  const editor = useEditor();
  const [value, setValue] = (0, import_react130.useState)(initialValue);
  const msg2 = useTranslation();
  const ref = (0, import_react130.useRef)(null);
  const trackEvent = useUiEvents();
  const source = "rich-text-menu";
  const linkifiedValue = value.startsWith("http") ? value : `https://${value}`;
  const handleValueChange = (value2) => setValue(value2);
  const handleLinkComplete = (link) => {
    trackEvent("rich-text", { operation: "link-edit", source });
    if (!link.startsWith("http://") && !link.startsWith("https://")) {
      link = `https://${link}`;
    }
    textEditor.commands.setLink({ href: link });
    if (editor.getInstanceState().isCoarsePointer) {
      textEditor.commands.blur();
    } else {
      textEditor.commands.focus();
    }
    onComplete();
  };
  const handleVisitLink = () => {
    trackEvent("rich-text", { operation: "link-visit", source });
    window.open(linkifiedValue, "_blank", "noopener, noreferrer");
    onComplete();
  };
  const handleRemoveLink = () => {
    trackEvent("rich-text", { operation: "link-remove", source });
    textEditor.chain().unsetLink().focus().run();
    onComplete();
  };
  const handleLinkCancel = () => onComplete();
  (0, import_react130.useEffect)(() => {
    var _a5;
    if (!value) {
      (_a5 = ref.current) == null ? void 0 : _a5.focus();
    }
  }, [value]);
  (0, import_react130.useEffect)(() => {
    setValue(initialValue);
  }, [initialValue]);
  return (0, import_jsx_runtime196.jsxs)(import_jsx_runtime196.Fragment, { children: [
    (0, import_jsx_runtime196.jsx)(
      TldrawUiInput,
      {
        ref,
        "data-testid": "rich-text.link-input",
        className: "tlui-rich-text__toolbar-link-input",
        value,
        onValueChange: handleValueChange,
        onComplete: handleLinkComplete,
        onCancel: handleLinkCancel,
        placeholder: "example.com"
      }
    ),
    (0, import_jsx_runtime196.jsx)(
      TldrawUiButton,
      {
        className: "tlui-rich-text__toolbar-link-visit",
        title: msg2("tool.rich-text-link-visit"),
        type: "icon",
        onPointerDown: preventDefault,
        onClick: handleVisitLink,
        disabled: !value,
        children: (0, import_jsx_runtime196.jsx)(TldrawUiButtonIcon, { small: true, icon: "external-link" })
      }
    ),
    (0, import_jsx_runtime196.jsx)(
      TldrawUiButton,
      {
        className: "tlui-rich-text__toolbar-link-remove",
        title: msg2("tool.rich-text-link-remove"),
        "data-testid": "rich-text.link-remove",
        type: "icon",
        onPointerDown: preventDefault,
        onClick: handleRemoveLink,
        children: (0, import_jsx_runtime196.jsx)(TldrawUiButtonIcon, { small: true, icon: "trash" })
      }
    )
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultRichTextToolbar.mjs
var MOVE_TIMEOUT = 150;
var HIDE_VISIBILITY_TIMEOUT = 16;
var SHOW_VISIBILITY_TIMEOUT = 16;
var TOOLBAR_GAP = 8;
var SCREEN_MARGIN = 16;
var MIN_DISTANCE_TO_REPOSITION_SQUARED = 16 ** 2;
var HIDE_TOOLBAR_WHEN_CAMERA_IS_MOVING = true;
var CHANGE_ONLY_WHEN_Y_CHANGES = true;
var LEFT_ALIGN_TOOLBAR = false;
var DefaultRichTextToolbar = track(function DefaultRichTextToolbar2({
  children
}) {
  const editor = useEditor();
  const textEditor = useValue("textEditor", () => editor.getRichTextEditor(), [editor]);
  if (editor.getInstanceState().isCoarsePointer || !textEditor)
    return null;
  return (0, import_jsx_runtime197.jsx)(ContextualToolbarInner, { textEditor, children });
});
function ContextualToolbarInner({
  textEditor,
  children
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const rToolbar = (0, import_react131.useRef)(null);
  const { isVisible, isInteractive, hide: hide5, show, position, move } = useToolbarVisibilityStateMachine();
  const { isEditingLink, onEditLinkStart, onEditLinkComplete } = useEditingLinkBehavior(textEditor);
  const forcePositionUpdateAtom = useAtom("force toolbar position update", 0);
  (0, import_react131.useEffect)(
    function forceUpdateWhenSelectionUpdates() {
      function handleSelectionUpdate() {
        forcePositionUpdateAtom.update((t2) => t2 + 1);
      }
      tltime.requestAnimationFrame("first forced update", handleSelectionUpdate);
      textEditor.on("selectionUpdate", handleSelectionUpdate);
      return () => {
        textEditor.off("selectionUpdate", handleSelectionUpdate);
      };
    },
    [textEditor, forcePositionUpdateAtom]
  );
  useReactor(
    "shape change",
    function forceUpdateOnNextFrameWhenShapeChanges() {
      editor.getEditingShape();
      forcePositionUpdateAtom.update((t2) => t2 + 1);
    },
    [editor]
  );
  const rCouldShowToolbar = (0, import_react131.useRef)(false);
  const [hasValidToolbarPosition, setHasValidToolbarPosition] = (0, import_react131.useState)(false);
  useQuickReactor(
    "toolbar position",
    function updateToolbarPositionAndDisplay() {
      const toolbarElm = rToolbar.current;
      if (!toolbarElm)
        return;
      editor.getCamera();
      forcePositionUpdateAtom.get();
      const position2 = getToolbarScreenPosition(editor, toolbarElm);
      if (!position2) {
        if (rCouldShowToolbar.current) {
          rCouldShowToolbar.current = false;
          setHasValidToolbarPosition(false);
        }
        return;
      }
      const cameraState2 = editor.getCameraState();
      if (cameraState2 === "moving") {
        const elm = rToolbar.current;
        elm.style.setProperty("transform", `translate(${position2.x}px, ${position2.y}px)`);
      } else {
        move(position2.x, position2.y);
      }
      if (!rCouldShowToolbar.current) {
        rCouldShowToolbar.current = true;
        setHasValidToolbarPosition(true);
      }
    },
    [editor, textEditor, forcePositionUpdateAtom]
  );
  const cameraState = useValue("camera state", () => editor.getCameraState(), [editor]);
  const isMousingDown = useIsMousingDownOnTextEditor(textEditor);
  (0, import_react131.useEffect)(() => {
    if (cameraState === "moving" && HIDE_TOOLBAR_WHEN_CAMERA_IS_MOVING) {
      hide5(true);
      return;
    }
    if (isMousingDown || !hasValidToolbarPosition) {
      hide5();
      return;
    }
    show();
  }, [hasValidToolbarPosition, cameraState, isMousingDown, show, hide5]);
  (0, import_react131.useLayoutEffect)(() => {
    const elm = rToolbar.current;
    if (!elm)
      return;
    elm.dataset.visible = `${isVisible}`;
  }, [isVisible, position]);
  (0, import_react131.useLayoutEffect)(() => {
    const elm = rToolbar.current;
    if (!elm)
      return;
    elm.style.setProperty("transform", `translate(${position.x}px, ${position.y}px)`);
  }, [position]);
  (0, import_react131.useLayoutEffect)(() => {
    const elm = rToolbar.current;
    if (!elm)
      return;
    elm.dataset.interactive = `${isInteractive}`;
  }, [isInteractive]);
  return (0, import_jsx_runtime197.jsx)(
    TldrawUiContextualToolbar,
    {
      ref: rToolbar,
      className: "tlui-rich-text__toolbar",
      "data-interactive": false,
      "data-visible": false,
      label: msg2("tool.rich-text-toolbar-title"),
      children: children ? children : isEditingLink ? (0, import_jsx_runtime197.jsx)(
        LinkEditor,
        {
          textEditor,
          value: textEditor.isActive("link") ? textEditor.getAttributes("link").href : "",
          onComplete: onEditLinkComplete
        }
      ) : (0, import_jsx_runtime197.jsx)(DefaultRichTextToolbarContent, { textEditor, onEditLinkStart })
    }
  );
}
function rectToBox(rect) {
  return new Box(rect.x, rect.y, rect.width, rect.height);
}
function getToolbarScreenPosition(editor, toolbarElm) {
  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0 || selection.isCollapsed)
    return;
  const rangeBoxes = [];
  for (let i = 0; i < selection.rangeCount; i++) {
    const range = selection.getRangeAt(i);
    rangeBoxes.push(rectToBox(range.getBoundingClientRect()));
  }
  const selectionBounds = Box.Common(rangeBoxes);
  const vsb = editor.getViewportScreenBounds();
  selectionBounds.x -= vsb.x;
  selectionBounds.y -= vsb.y;
  if (selectionBounds.midY < SCREEN_MARGIN || selectionBounds.midY > vsb.h - SCREEN_MARGIN || selectionBounds.midX < SCREEN_MARGIN || selectionBounds.midX > vsb.w - SCREEN_MARGIN) {
    return;
  }
  const toolbarBounds = rectToBox(toolbarElm.getBoundingClientRect());
  if (!toolbarBounds.width || !toolbarBounds.height)
    return;
  const { scrollLeft, scrollTop } = editor.getContainer();
  let x = LEFT_ALIGN_TOOLBAR ? selectionBounds.x : selectionBounds.midX - toolbarBounds.w / 2;
  let y = selectionBounds.y - toolbarBounds.h - TOOLBAR_GAP;
  x = clamp(x, SCREEN_MARGIN, vsb.w - toolbarBounds.w - SCREEN_MARGIN);
  y = clamp(y, SCREEN_MARGIN, vsb.h - toolbarBounds.h - SCREEN_MARGIN);
  x += scrollLeft;
  y += scrollTop;
  x = Math.round(x);
  y = Math.round(y);
  return { x, y };
}
function useEditingLinkBehavior(textEditor) {
  const [isEditingLink, setIsEditingLink] = (0, import_react131.useState)(false);
  (0, import_react131.useEffect)(() => {
    if (!textEditor) {
      setIsEditingLink(false);
      return;
    }
    const handleClick2 = () => {
      const isLinkActive = textEditor.isActive("link");
      setIsEditingLink(isLinkActive);
    };
    textEditor.view.dom.addEventListener("click", handleClick2);
    return () => {
      textEditor.view.dom.removeEventListener("click", handleClick2);
    };
  }, [textEditor, isEditingLink]);
  (0, import_react131.useEffect)(() => {
    if (!textEditor) {
      return;
    }
    if (textEditor.isActive("link")) {
      try {
        const { from: from2, to } = getMarkRange(
          textEditor.state.doc.resolve(textEditor.state.selection.from),
          textEditor.schema.marks.link
        );
        if (textEditor.state.selection.empty) {
          textEditor.commands.setTextSelection({ from: from2, to });
        }
      } catch {
      }
    }
  }, [textEditor, isEditingLink]);
  const onEditLinkStart = (0, import_react131.useCallback)(() => {
    setIsEditingLink(true);
  }, []);
  const onEditLinkCancel = (0, import_react131.useCallback)(() => {
    setIsEditingLink(false);
  }, []);
  const onEditLinkComplete = (0, import_react131.useCallback)(() => {
    setIsEditingLink(false);
    if (!textEditor)
      return;
    const from2 = textEditor.state.selection.from;
    textEditor.commands.setTextSelection({ from: from2, to: from2 });
  }, [textEditor]);
  return { isEditingLink, onEditLinkStart, onEditLinkComplete, onEditLinkCancel };
}
function sufficientlyDistant(curr, next) {
  if (CHANGE_ONLY_WHEN_Y_CHANGES) {
    return Vec.Sub(next, curr).y ** 2 >= MIN_DISTANCE_TO_REPOSITION_SQUARED;
  }
  return Vec.Len2(Vec.Sub(next, curr)) >= MIN_DISTANCE_TO_REPOSITION_SQUARED;
}
function useToolbarVisibilityStateMachine() {
  const editor = useEditor();
  const rState = (0, import_react131.useRef)({ name: "hidden" });
  const [isInteractive, setIsInteractive] = (0, import_react131.useState)(false);
  const [isVisible, setIsVisible] = (0, import_react131.useState)(false);
  const [position, setPosition] = (0, import_react131.useState)({ x: -1e3, y: -1e3 });
  const rCurrPosition = (0, import_react131.useRef)(new Vec(-1e3, -1e3));
  const rNextPosition = (0, import_react131.useRef)(new Vec(-1e3, -1e3));
  const rStableVisibilityTimeout = (0, import_react131.useRef)(-1);
  const rStablePositionTimeout = (0, import_react131.useRef)(-1);
  const move = (0, import_react131.useCallback)(
    (x, y) => {
      rNextPosition.current.x = x;
      rNextPosition.current.y = y;
      if (rState.current.name === "hidden" || rState.current.name === "showing")
        return;
      clearTimeout(rStablePositionTimeout.current);
      rStablePositionTimeout.current = editor.timers.setTimeout(() => {
        if (rState.current.name === "shown" && sufficientlyDistant(rNextPosition.current, rCurrPosition.current)) {
          const { x: x2, y: y2 } = rNextPosition.current;
          rCurrPosition.current = new Vec(x2, y2);
          setPosition({ x: x2, y: y2 });
        }
      }, MOVE_TIMEOUT);
    },
    [editor]
  );
  const hide5 = (0, import_react131.useCallback)(
    (immediate = false) => {
      switch (rState.current.name) {
        case "showing": {
          clearTimeout(rStableVisibilityTimeout.current);
          rState.current = { name: "hidden" };
          break;
        }
        case "shown": {
          rState.current = { name: "hiding" };
          setIsInteractive(false);
          if (immediate) {
            rState.current = { name: "hidden" };
            setIsVisible(false);
          } else {
            rStableVisibilityTimeout.current = editor.timers.setTimeout(() => {
              rState.current = { name: "hidden" };
              setIsVisible(false);
            }, HIDE_VISIBILITY_TIMEOUT);
          }
          break;
        }
        default: {
        }
      }
    },
    [editor]
  );
  const show = (0, import_react131.useCallback)(() => {
    switch (rState.current.name) {
      case "hidden": {
        rState.current = { name: "showing" };
        rStableVisibilityTimeout.current = editor.timers.setTimeout(() => {
          const { x, y } = rNextPosition.current;
          rCurrPosition.current = new Vec(x, y);
          setPosition({ x, y });
          rState.current = { name: "shown" };
          setIsVisible(true);
          setIsInteractive(true);
        }, SHOW_VISIBILITY_TIMEOUT);
        break;
      }
      case "hiding": {
        clearTimeout(rStableVisibilityTimeout.current);
        rState.current = { name: "shown" };
        setIsInteractive(true);
        move(rNextPosition.current.x, rNextPosition.current.y);
        break;
      }
      default: {
      }
    }
  }, [editor, move]);
  return { isVisible, isInteractive, show, hide: hide5, move, position };
}
function useIsMousingDownOnTextEditor(textEditor) {
  const [isMousingDown, setIsMousingDown] = (0, import_react131.useState)(false);
  (0, import_react131.useEffect)(() => {
    if (!textEditor)
      return;
    const handlePointingStateChange = debounce(({ isPointing }) => {
      setIsMousingDown(isPointing);
    }, 16);
    const handlePointingDown = () => handlePointingStateChange({ isPointing: true });
    const handlePointingUp = () => handlePointingStateChange({ isPointing: false });
    const touchDownEvents = ["touchstart", "pointerdown", "mousedown"];
    const touchUpEvents = ["touchend", "pointerup", "mouseup"];
    touchDownEvents.forEach((eventName) => {
      textEditor.view.dom.addEventListener(eventName, handlePointingDown);
    });
    touchUpEvents.forEach((eventName) => {
      document.body.addEventListener(eventName, handlePointingUp);
    });
    return () => {
      touchDownEvents.forEach((eventName) => {
        textEditor.view.dom.removeEventListener(eventName, handlePointingDown);
      });
      touchUpEvents.forEach((eventName) => {
        document.body.removeEventListener(eventName, handlePointingUp);
      });
    };
  }, [textEditor]);
  return isMousingDown;
}

// node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultToolbar.mjs
var import_jsx_runtime202 = __toESM(require_jsx_runtime(), 1);
var import_react135 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/MobileStylePanel.mjs
var import_jsx_runtime198 = __toESM(require_jsx_runtime(), 1);
var import_react132 = __toESM(require_react(), 1);
function MobileStylePanel() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const relevantStyles = useRelevantStyles();
  const color = relevantStyles == null ? void 0 : relevantStyles.get(DefaultColorStyle);
  const theme = getDefaultColorTheme({ isDarkMode: editor.user.getIsDarkMode() });
  const currentColor = ((color == null ? void 0 : color.type) === "shared" ? theme[color.value] : theme.black).solid;
  const disableStylePanel = useValue(
    "disable style panel",
    () => editor.isInAny("hand", "zoom", "eraser", "laser"),
    [editor]
  );
  const handleStylesOpenChange = (0, import_react132.useCallback)(
    (isOpen) => {
      if (!isOpen) {
        editor.updateInstanceState({ isChangingStyle: false });
      }
    },
    [editor]
  );
  const { StylePanel } = useTldrawUiComponents();
  if (!StylePanel)
    return null;
  return (0, import_jsx_runtime198.jsxs)(TldrawUiPopover, { id: "mobile style menu", onOpenChange: handleStylesOpenChange, children: [
    (0, import_jsx_runtime198.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime198.jsx)(
      TldrawUiButton,
      {
        type: "tool",
        "data-testid": "mobile-styles.button",
        style: {
          color: disableStylePanel ? "var(--color-muted-1)" : currentColor
        },
        title: msg2("style-panel.title"),
        disabled: disableStylePanel,
        children: (0, import_jsx_runtime198.jsx)(
          TldrawUiButtonIcon,
          {
            icon: disableStylePanel ? "blob" : (color == null ? void 0 : color.type) === "mixed" ? "mixed" : "blob"
          }
        )
      }
    ) }),
    (0, import_jsx_runtime198.jsx)(TldrawUiPopoverContent, { side: "top", align: "end", children: StylePanel && (0, import_jsx_runtime198.jsx)(StylePanel, { isMobile: true }) })
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultToolbarContent.mjs
var import_jsx_runtime199 = __toESM(require_jsx_runtime(), 1);
function DefaultToolbarContent() {
  return (0, import_jsx_runtime199.jsxs)(import_jsx_runtime199.Fragment, { children: [
    (0, import_jsx_runtime199.jsx)(SelectToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(HandToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(DrawToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(EraserToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(ArrowToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(TextToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(NoteToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(AssetToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(RectangleToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(EllipseToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(TriangleToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(DiamondToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(HexagonToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(OvalToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(RhombusToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(StarToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(CloudToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(HeartToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(XBoxToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(CheckBoxToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(ArrowLeftToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(ArrowUpToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(ArrowDownToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(ArrowRightToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(LineToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(HighlightToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(LaserToolbarItem, {}),
    (0, import_jsx_runtime199.jsx)(FrameToolbarItem, {})
  ] });
}
function useIsToolSelected(tool) {
  var _a5;
  const editor = useEditor();
  const geo = (_a5 = tool == null ? void 0 : tool.meta) == null ? void 0 : _a5.geo;
  return useValue(
    "is tool selected",
    () => {
      if (!tool)
        return false;
      const activeToolId = editor.getCurrentToolId();
      if (activeToolId === "geo") {
        return geo === editor.getSharedStyles().getAsKnownValue(GeoShapeGeoStyle);
      } else {
        return activeToolId === tool.id;
      }
    },
    [editor, tool == null ? void 0 : tool.id, geo]
  );
}
function ToolbarItem({ tool }) {
  const tools = useTools();
  const isSelected = useIsToolSelected(tools[tool]);
  return (0, import_jsx_runtime199.jsx)(TldrawUiMenuToolItem, { toolId: tool, isSelected });
}
function SelectToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "select" });
}
function HandToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "hand" });
}
function DrawToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "draw" });
}
function EraserToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "eraser" });
}
function ArrowToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "arrow" });
}
function TextToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "text" });
}
function NoteToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "note" });
}
function AssetToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(TldrawUiMenuToolItem, { toolId: "asset" });
}
function RectangleToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "rectangle" });
}
function EllipseToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "ellipse" });
}
function DiamondToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "diamond" });
}
function TriangleToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "triangle" });
}
function TrapezoidToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "trapezoid" });
}
function RhombusToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "rhombus" });
}
function HeartToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "heart" });
}
function HexagonToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "hexagon" });
}
function CloudToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "cloud" });
}
function StarToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "star" });
}
function OvalToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "oval" });
}
function XBoxToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "x-box" });
}
function CheckBoxToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "check-box" });
}
function ArrowLeftToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "arrow-left" });
}
function ArrowUpToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "arrow-up" });
}
function ArrowDownToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "arrow-down" });
}
function ArrowRightToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "arrow-right" });
}
function LineToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "line" });
}
function HighlightToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "highlight" });
}
function FrameToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "frame" });
}
function LaserToolbarItem() {
  return (0, import_jsx_runtime199.jsx)(ToolbarItem, { tool: "laser" });
}

// node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs
var import_jsx_runtime200 = __toESM(require_jsx_runtime(), 1);
var import_classnames33 = __toESM(require_classnames(), 1);
var import_react134 = __toESM(require_react(), 1);

// node_modules/hotkeys-js/dist/hotkeys.esm.js
var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object2, event, method, useCapture) {
  if (object2.addEventListener) {
    object2.addEventListener(event, method, useCapture);
  } else if (object2.attachEvent) {
    object2.attachEvent("on".concat(event), method);
  }
}
function removeEvent(object2, event, method, useCapture) {
  if (object2.removeEventListener) {
    object2.removeEventListener(event, method, useCapture);
  } else if (object2.detachEvent) {
    object2.detachEvent("on".concat(event), method);
  }
}
function getMods2(modifier, key) {
  const mods = key.slice(0, key.length - 1);
  for (let i = 0; i < mods.length; i++)
    mods[i] = modifier[mods[i].toLowerCase()];
  return mods;
}
function getKeys(key) {
  if (typeof key !== "string")
    key = "";
  key = key.replace(/\s/g, "");
  const keys2 = key.split(",");
  let index3 = keys2.lastIndexOf("");
  for (; index3 >= 0; ) {
    keys2[index3 - 1] += ",";
    keys2.splice(index3, 1);
    index3 = keys2.lastIndexOf("");
  }
  return keys2;
}
function compareArray(a1, a2) {
  const arr1 = a1.length >= a2.length ? a1 : a2;
  const arr2 = a1.length >= a2.length ? a2 : a1;
  let isIndex = true;
  for (let i = 0; i < arr1.length; i++) {
    if (arr2.indexOf(arr1[i]) === -1)
      isIndex = false;
  }
  return isIndex;
}
var _keyMap = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
};
var _modifier = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
};
var modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {};
for (let k = 1; k < 20; k++) {
  _keyMap["f".concat(k)] = 111 + k;
}
var _downKeys = [];
var winListendFocus = null;
var _scope = "all";
var elementEventMap = /* @__PURE__ */ new Map();
var code = (x) => _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
var getKey = (x) => Object.keys(_keyMap).find((k) => _keyMap[k] === x);
var getModifier = (x) => Object.keys(_modifier).find((k) => _modifier[k] === x);
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function getPressedKeyString() {
  return _downKeys.map((c) => getKey(c) || getModifier(c) || String.fromCharCode(c));
}
function getAllKeyCodes() {
  const result = [];
  Object.keys(_handlers).forEach((k) => {
    _handlers[k].forEach((_ref) => {
      let {
        key,
        scope,
        mods,
        shortcut
      } = _ref;
      result.push({
        scope,
        shortcut,
        mods,
        keys: key.split("+").map((v) => code(v))
      });
    });
  });
  return result;
}
function filter(event) {
  const target = event.target || event.srcElement;
  const {
    tagName
  } = target;
  let flag = true;
  const isInput = tagName === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(target.type);
  if (target.isContentEditable || (isInput || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  let handlers2;
  let i;
  if (!scope)
    scope = getScope();
  for (const key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers2 = _handlers[key];
      for (i = 0; i < handlers2.length; ) {
        if (handlers2[i].scope === scope) {
          const deleteItems = handlers2.splice(i, 1);
          deleteItems.forEach((_ref2) => {
            let {
              element
            } = _ref2;
            return removeKeyEvent(element);
          });
        } else {
          i++;
        }
      }
    }
  }
  if (getScope() === scope)
    setScope(newScope || "all");
}
function clearModifier(event) {
  let key = event.keyCode || event.which || event.charCode;
  const i = _downKeys.indexOf(key);
  if (i >= 0) {
    _downKeys.splice(i, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224)
    key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (const k in _modifier)
      if (_modifier[k] === key)
        hotkeys[k] = false;
  }
}
function unbind(keysInfo) {
  if (typeof keysInfo === "undefined") {
    Object.keys(_handlers).forEach((key) => {
      Array.isArray(_handlers[key]) && _handlers[key].forEach((info) => eachUnbind(info));
      delete _handlers[key];
    });
    removeKeyEvent(null);
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach((info) => {
      if (info.key)
        eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key)
      eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    let [scope, method] = args;
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
var eachUnbind = (_ref3) => {
  let {
    key,
    scope,
    method,
    splitKey = "+"
  } = _ref3;
  const multipleKeys = getKeys(key);
  multipleKeys.forEach((originKey) => {
    const unbindKeys = originKey.split(splitKey);
    const len = unbindKeys.length;
    const lastKey = unbindKeys[len - 1];
    const keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode])
      return;
    if (!scope)
      scope = getScope();
    const mods = len > 1 ? getMods2(_modifier, unbindKeys) : [];
    const unbindElements = [];
    _handlers[keyCode] = _handlers[keyCode].filter((record) => {
      const isMatchingMethod = method ? record.method === method : true;
      const isUnbind = isMatchingMethod && record.scope === scope && compareArray(record.mods, mods);
      if (isUnbind)
        unbindElements.push(record.element);
      return !isUnbind;
    });
    unbindElements.forEach((element) => removeKeyEvent(element));
  });
};
function eventHandler(event, handler, scope, element) {
  if (handler.element !== element) {
    return;
  }
  let modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (const y in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y)) {
        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      handler.keys = [];
      handler.keys = handler.keys.concat(_downKeys);
      if (handler.method(event, handler) === false) {
        if (event.preventDefault)
          event.preventDefault();
        else
          event.returnValue = false;
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.cancelBubble)
          event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event, element) {
  const asterisk = _handlers["*"];
  let key = event.keyCode || event.which || event.charCode;
  if (!hotkeys.filter.call(this, event))
    return;
  if (key === 93 || key === 224)
    key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229)
    _downKeys.push(key);
  ["metaKey", "ctrlKey", "altKey", "shiftKey"].forEach((keyName2) => {
    const keyNum = modifierMap[keyName2];
    if (event[keyName2] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName2] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName2 === "metaKey" && event[keyName2]) {
      _downKeys = _downKeys.filter((k) => k in modifierMap || k === key);
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (const k in _modifier) {
      if (_modifier[k] === key)
        hotkeys[k] = true;
    }
    if (!asterisk)
      return;
  }
  for (const e in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
      _mods[e] = event[modifierMap[e]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  const scope = getScope();
  if (asterisk) {
    for (let i = 0; i < asterisk.length; i++) {
      if (asterisk[i].scope === scope && (event.type === "keydown" && asterisk[i].keydown || event.type === "keyup" && asterisk[i].keyup)) {
        eventHandler(event, asterisk[i], scope, element);
      }
    }
  }
  if (!(key in _handlers))
    return;
  const handlerKey = _handlers[key];
  const keyLen = handlerKey.length;
  for (let i = 0; i < keyLen; i++) {
    if (event.type === "keydown" && handlerKey[i].keydown || event.type === "keyup" && handlerKey[i].keyup) {
      if (handlerKey[i].key) {
        const record = handlerKey[i];
        const {
          splitKey
        } = record;
        const keyShortcut = record.key.split(splitKey);
        const _downKeysCurrent = [];
        for (let a = 0; a < keyShortcut.length; a++) {
          _downKeysCurrent.push(code(keyShortcut[a]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope, element);
        }
      }
    }
  }
}
function hotkeys(key, option, method) {
  _downKeys = [];
  const keys2 = getKeys(key);
  let mods = [];
  let scope = "all";
  let element = document;
  let i = 0;
  let keyup = false;
  let keydown = true;
  let splitKey = "+";
  let capture = false;
  let single = false;
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope)
      scope = option.scope;
    if (option.element)
      element = option.element;
    if (option.keyup)
      keyup = option.keyup;
    if (option.keydown !== void 0)
      keydown = option.keydown;
    if (option.capture !== void 0)
      capture = option.capture;
    if (typeof option.splitKey === "string")
      splitKey = option.splitKey;
    if (option.single === true)
      single = true;
  }
  if (typeof option === "string")
    scope = option;
  if (single)
    unbind(key, scope);
  for (; i < keys2.length; i++) {
    key = keys2[i].split(splitKey);
    mods = [];
    if (key.length > 1)
      mods = getMods2(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers))
      _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys2[i],
      method,
      key: keys2[i],
      splitKey,
      element
    });
  }
  if (typeof element !== "undefined" && window) {
    if (!elementEventMap.has(element)) {
      const keydownListener = function() {
        let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return dispatch(event, element);
      };
      const keyupListenr = function() {
        let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        dispatch(event, element);
        clearModifier(event);
      };
      elementEventMap.set(element, {
        keydownListener,
        keyupListenr,
        capture
      });
      addEvent(element, "keydown", keydownListener, capture);
      addEvent(element, "keyup", keyupListenr, capture);
    }
    if (!winListendFocus) {
      const listener = () => {
        _downKeys = [];
      };
      winListendFocus = {
        listener,
        capture
      };
      addEvent(window, "focus", listener, capture);
    }
  }
}
function trigger(shortcut) {
  let scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(_handlers).forEach((key) => {
    const dataList = _handlers[key].filter((item) => item.scope === scope && item.shortcut === shortcut);
    dataList.forEach((data) => {
      if (data && data.method) {
        data.method();
      }
    });
  });
}
function removeKeyEvent(element) {
  const values = Object.values(_handlers).flat();
  const findindex = values.findIndex((_ref4) => {
    let {
      element: el
    } = _ref4;
    return el === element;
  });
  if (findindex < 0) {
    const {
      keydownListener,
      keyupListenr,
      capture
    } = elementEventMap.get(element) || {};
    if (keydownListener && keyupListenr) {
      removeEvent(element, "keyup", keyupListenr, capture);
      removeEvent(element, "keydown", keydownListener, capture);
      elementEventMap.delete(element);
    }
  }
  if (values.length <= 0 || elementEventMap.size <= 0) {
    const eventKeys = Object.keys(elementEventMap);
    eventKeys.forEach((el) => {
      const {
        keydownListener,
        keyupListenr,
        capture
      } = elementEventMap.get(el) || {};
      if (keydownListener && keyupListenr) {
        removeEvent(el, "keyup", keyupListenr, capture);
        removeEvent(el, "keydown", keydownListener, capture);
        elementEventMap.delete(el);
      }
    });
    elementEventMap.clear();
    Object.keys(_handlers).forEach((key) => delete _handlers[key]);
    if (winListendFocus) {
      const {
        listener,
        capture
      } = winListendFocus;
      removeEvent(window, "focus", listener, capture);
      winListendFocus = null;
    }
  }
}
var _api = {
  getPressedKeyString,
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  getAllKeyCodes,
  isPressed,
  filter,
  trigger,
  unbind,
  keyMap: _keyMap,
  modifier: _modifier,
  modifierMap
};
for (const a in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a)) {
    hotkeys[a] = _api[a];
  }
}
if (typeof window !== "undefined") {
  const _hotkeys = window.hotkeys;
  hotkeys.noConflict = (deep) => {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useKeyboardShortcuts.mjs
var import_react133 = __toESM(require_react(), 1);
var SKIP_KBDS = [
  // we set these in useNativeClipboardEvents instead
  "copy",
  "cut",
  "paste",
  // There's also an upload asset action, so we don't want to set the kbd twice
  "asset"
];
function useKeyboardShortcuts() {
  const editor = useEditor();
  const isReadonlyMode = useReadonly();
  const actions = useActions();
  const tools = useTools();
  const isFocused = useValue("is focused", () => editor.getInstanceState().isFocused, [editor]);
  (0, import_react133.useEffect)(() => {
    if (!isFocused)
      return;
    const disposables = new Array();
    const hot = (keys2, callback) => {
      hotkeys(keys2, { element: document.body }, callback);
      disposables.push(() => {
        hotkeys.unbind(keys2, callback);
      });
    };
    const hotUp = (keys2, callback) => {
      hotkeys(keys2, { element: document.body, keyup: true, keydown: false }, callback);
      disposables.push(() => {
        hotkeys.unbind(keys2, callback);
      });
    };
    for (const action of Object.values(actions)) {
      if (!action.kbd)
        continue;
      if (isReadonlyMode && !action.readonlyOk)
        continue;
      if (SKIP_KBDS.includes(action.id))
        continue;
      hot(getHotkeysStringFromKbd(action.kbd), (event) => {
        if (areShortcutsDisabled3(editor))
          return;
        preventDefault(event);
        action.onSelect("kbd");
      });
    }
    for (const tool of Object.values(tools)) {
      if (!tool.kbd || !tool.readonlyOk && editor.getIsReadonly()) {
        continue;
      }
      if (SKIP_KBDS.includes(tool.id))
        continue;
      hot(getHotkeysStringFromKbd(tool.kbd), (event) => {
        if (areShortcutsDisabled3(editor))
          return;
        preventDefault(event);
        tool.onSelect("kbd");
      });
    }
    hot(",", (e) => {
      if (areShortcutsDisabled3(editor))
        return;
      if (editor.inputs.keys.has("Comma"))
        return;
      preventDefault(e);
      editor.focus();
      editor.inputs.keys.add("Comma");
      const { x, y, z } = editor.inputs.currentPagePoint;
      const screenpoints = editor.pageToScreen({ x, y });
      const info = {
        type: "pointer",
        name: "pointer_down",
        point: { x: screenpoints.x, y: screenpoints.y, z },
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e),
        pointerId: 0,
        button: 0,
        isPen: editor.getInstanceState().isPenMode,
        target: "canvas"
      };
      editor.dispatch(info);
    });
    hotUp(",", (e) => {
      if (areShortcutsDisabled3(editor))
        return;
      if (!editor.inputs.keys.has("Comma"))
        return;
      editor.inputs.keys.delete("Comma");
      const { x, y, z } = editor.inputs.currentScreenPoint;
      const info = {
        type: "pointer",
        name: "pointer_up",
        point: { x, y, z },
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e),
        pointerId: 0,
        button: 0,
        isPen: editor.getInstanceState().isPenMode,
        target: "canvas"
      };
      editor.dispatch(info);
    });
    return () => {
      disposables.forEach((d) => d());
    };
  }, [actions, tools, isReadonlyMode, editor, isFocused]);
}
function areShortcutsDisabled3(editor) {
  return editor.menus.hasAnyOpenMenus() || editor.getEditingShapeId() !== null || editor.getCrashingError();
}
function getHotkeysStringFromKbd(kbd2) {
  return getKeys2(kbd2).map((kbd22) => {
    let str = "";
    const shift5 = kbd22.includes("!");
    const alt = kbd22.includes("?");
    const cmd = kbd22.includes("$");
    const k = kbd22.replace(/[!?$]/g, "");
    if (shift5 && alt && cmd) {
      str = `cmd+shift+alt+${k},ctrl+shift+alt+${k}`;
    } else if (shift5 && cmd) {
      str = `cmd+shift+${k},ctrl+shift+${k}`;
    } else if (alt && cmd) {
      str = `cmd+alt+${k},ctrl+alt+${k}`;
    } else if (alt && shift5) {
      str = `shift+alt+${k}`;
    } else if (shift5) {
      str = `shift+${k}`;
    } else if (alt) {
      str = `alt+${k}`;
    } else if (cmd) {
      str = `cmd+${k},ctrl+${k}`;
    } else {
      str = k;
    }
    return str;
  }).join(",");
}
function getKeys2(key) {
  if (typeof key !== "string")
    key = "";
  key = key.replace(/\s/g, "");
  const keys2 = key.split(",");
  let index3 = keys2.lastIndexOf("");
  for (; index3 >= 0; ) {
    keys2[index3 - 1] += ",";
    keys2.splice(index3, 1);
    index3 = keys2.lastIndexOf("");
  }
  return keys2;
}

// node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs
var IsInOverflowContext = (0, import_react134.createContext)(false);
var NUMBERED_SHORTCUT_KEYS = {
  "1": 0,
  "2": 1,
  "3": 2,
  "4": 3,
  "5": 4,
  "6": 5,
  "7": 6,
  "8": 7,
  "9": 8,
  "0": 9
};
function OverflowingToolbar({ children }) {
  const editor = useEditor();
  const id = useUniqueSafeId();
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const rButtons = (0, import_react134.useRef)([]);
  const [isOpen, setIsOpen] = (0, import_react134.useState)(false);
  const overflowIndex = Math.min(8, 5 + breakpoint);
  const [totalItems, setTotalItems] = (0, import_react134.useState)(0);
  const mainToolsRef = (0, import_react134.useRef)(null);
  const [lastActiveOverflowItem, setLastActiveOverflowItem] = (0, import_react134.useState)(null);
  const css = (0, import_react134.useMemo)(() => {
    const activeCss = lastActiveOverflowItem ? `:not([data-value="${lastActiveOverflowItem}"])` : "";
    return `
			#${id}_main > *:nth-child(n + ${overflowIndex + (lastActiveOverflowItem ? 1 : 2)})${activeCss} {
				display: none;
			}
			#${id}_more > *:nth-child(-n + ${overflowIndex}) {
				display: none;
			}
			#${id}_more > *:nth-child(-n + ${overflowIndex + 4}) {
				margin-top: 0;
			}
        `;
  }, [lastActiveOverflowItem, id, overflowIndex]);
  const onDomUpdate = useEvent(() => {
    var _a5;
    if (!mainToolsRef.current)
      return;
    const children2 = Array.from(mainToolsRef.current.children);
    setTotalItems(children2.length);
    const lastActiveElementIdx = children2.findIndex(
      (el) => el.getAttribute("data-value") === lastActiveOverflowItem
    );
    if (lastActiveElementIdx <= overflowIndex) {
      setLastActiveOverflowItem(null);
    }
    const activeElementIdx = Array.from(mainToolsRef.current.children).findIndex(
      (el) => el.getAttribute("aria-pressed") === "true"
    );
    if (activeElementIdx === -1)
      return;
    if (activeElementIdx >= overflowIndex) {
      setLastActiveOverflowItem(children2[activeElementIdx].getAttribute("data-value"));
    }
    rButtons.current = Array.from(((_a5 = mainToolsRef.current) == null ? void 0 : _a5.children) ?? []).filter(
      (el) => {
        if (!(el instanceof HTMLElement))
          return false;
        if (el.tagName.toLowerCase() !== "button")
          return false;
        return !!(el.offsetWidth || el.offsetHeight);
      }
    );
  });
  (0, import_react134.useLayoutEffect)(() => {
    onDomUpdate();
  });
  (0, import_react134.useLayoutEffect)(() => {
    if (!mainToolsRef.current)
      return;
    const mutationObserver = new MutationObserver(onDomUpdate);
    mutationObserver.observe(mainToolsRef.current, {
      childList: true,
      subtree: true,
      attributeFilter: ["data-value", "aria-pressed"]
    });
    return () => {
      mutationObserver.disconnect();
    };
  }, [onDomUpdate]);
  (0, import_react134.useEffect)(() => {
    if (!editor.options.enableToolbarKeyboardShortcuts)
      return;
    function handleKeyDown2(event) {
      var _a5;
      if (areShortcutsDisabled3(editor) || activeElementShouldCaptureKeys(
        true
        /* allow buttons */
      ))
        return;
      if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey)
        return;
      const index3 = NUMBERED_SHORTCUT_KEYS[event.key];
      if (typeof index3 === "number") {
        preventDefault(event);
        (_a5 = rButtons.current[index3]) == null ? void 0 : _a5.click();
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [editor]);
  const popoverId = "toolbar overflow";
  return (0, import_jsx_runtime200.jsxs)(import_jsx_runtime200.Fragment, { children: [
    (0, import_jsx_runtime200.jsx)("style", { nonce: editor.options.nonce, children: css }),
    (0, import_jsx_runtime200.jsxs)(
      TldrawUiToolbar,
      {
        className: (0, import_classnames33.default)("tlui-toolbar__tools", {
          "tlui-toolbar__tools__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
        }),
        label: msg2("tool-panel.title"),
        children: [
          (0, import_jsx_runtime200.jsx)("div", { id: `${id}_main`, ref: mainToolsRef, className: "tlui-toolbar__tools__list", children: (0, import_jsx_runtime200.jsx)(TldrawUiMenuContextProvider, { type: "toolbar", sourceId: "toolbar", children }) }),
          totalItems > overflowIndex + 1 && (0, import_jsx_runtime200.jsx)(IsInOverflowContext.Provider, { value: true, children: (0, import_jsx_runtime200.jsxs)(TldrawUiPopover, { id: popoverId, open: isOpen, onOpenChange: setIsOpen, children: [
            (0, import_jsx_runtime200.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime200.jsx)(
              TldrawUiToolbarButton,
              {
                title: msg2("tool-panel.more"),
                type: "tool",
                className: "tlui-toolbar__overflow",
                "data-testid": "tools.more-button",
                children: (0, import_jsx_runtime200.jsx)(TldrawUiButtonIcon, { icon: "chevron-up" })
              }
            ) }),
            (0, import_jsx_runtime200.jsx)(TldrawUiPopoverContent, { side: "top", align: "center", children: (0, import_jsx_runtime200.jsx)(
              TldrawUiToolbar,
              {
                className: "tlui-buttons__grid",
                "data-testid": "tools.more-content",
                label: msg2("tool-panel.more"),
                id: `${id}_more`,
                onClick: () => {
                  tlmenus.deleteOpenMenu(popoverId, editor.contextId);
                  setIsOpen(false);
                },
                children: (0, import_jsx_runtime200.jsx)(TldrawUiMenuContextProvider, { type: "toolbar-overflow", sourceId: "toolbar", children })
              }
            ) })
          ] }) })
        ]
      }
    )
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/ToggleToolLockedButton.mjs
var import_jsx_runtime201 = __toESM(require_jsx_runtime(), 1);
var import_classnames34 = __toESM(require_classnames(), 1);
function ToggleToolLockedButton({ activeToolId }) {
  const editor = useEditor();
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const isToolLocked = useValue("is tool locked", () => editor.getInstanceState().isToolLocked, [
    editor
  ]);
  const tool = useValue("current tool", () => editor.getCurrentTool(), [editor]);
  if (!activeToolId || !tool.isLockable)
    return null;
  return (0, import_jsx_runtime201.jsx)(
    TldrawUiButton,
    {
      type: "normal",
      title: msg2("action.toggle-tool-lock"),
      "data-testid": "tool-lock",
      className: (0, import_classnames34.default)("tlui-toolbar__lock-button", {
        "tlui-toolbar__lock-button__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
      }),
      onClick: () => editor.updateInstanceState({ isToolLocked: !isToolLocked }),
      children: (0, import_jsx_runtime201.jsx)(TldrawUiButtonIcon, { icon: isToolLocked ? "lock" : "unlock", small: true })
    }
  );
}

// node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultToolbar.mjs
var DefaultToolbar = (0, import_react135.memo)(function DefaultToolbar2({ children }) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const activeToolId = useValue("current tool id", () => editor.getCurrentToolId(), [editor]);
  const ref = (0, import_react135.useRef)(null);
  usePassThroughWheelEvents(ref);
  const { ActionsMenu, QuickActions } = useTldrawUiComponents();
  const showQuickActions = editor.options.actionShortcutsLocation === "menu" ? false : editor.options.actionShortcutsLocation === "toolbar" ? true : breakpoint < PORTRAIT_BREAKPOINT.TABLET;
  return (0, import_jsx_runtime202.jsx)("div", { ref, className: "tlui-toolbar", children: (0, import_jsx_runtime202.jsxs)("div", { className: "tlui-toolbar__inner", children: [
    (0, import_jsx_runtime202.jsxs)("div", { className: "tlui-toolbar__left", children: [
      !isReadonlyMode && (0, import_jsx_runtime202.jsxs)("div", { className: "tlui-toolbar__extras", children: [
        showQuickActions && (0, import_jsx_runtime202.jsxs)(
          TldrawUiToolbar,
          {
            className: "tlui-toolbar__extras__controls tlui-buttons__horizontal",
            label: msg2("actions-menu.title"),
            children: [
              QuickActions && (0, import_jsx_runtime202.jsx)(QuickActions, {}),
              ActionsMenu && (0, import_jsx_runtime202.jsx)(ActionsMenu, {})
            ]
          }
        ),
        (0, import_jsx_runtime202.jsx)(ToggleToolLockedButton, { activeToolId })
      ] }),
      (0, import_jsx_runtime202.jsx)(OverflowingToolbar, { children: children ?? (0, import_jsx_runtime202.jsx)(DefaultToolbarContent, {}) })
    ] }),
    breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM && !isReadonlyMode && (0, import_jsx_runtime202.jsx)("div", { className: "tlui-toolbar__tools", children: (0, import_jsx_runtime202.jsx)(MobileStylePanel, {}) })
  ] }) });
});

// node_modules/tldraw/dist-esm/lib/ui/components/TopPanel/DefaultTopPanel.mjs
var import_jsx_runtime205 = __toESM(require_jsx_runtime(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/OfflineIndicator/OfflineIndicator.mjs
var import_jsx_runtime203 = __toESM(require_jsx_runtime(), 1);
var import_classnames35 = __toESM(require_classnames(), 1);
function OfflineIndicator() {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime203.jsxs)("div", { className: (0, import_classnames35.default)("tlui-offline-indicator"), children: [
    msg2("status.offline"),
    (0, import_jsx_runtime203.jsx)(TldrawUiIcon, { label: msg2("status.offline"), icon: "status-offline", small: true })
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/TopPanel/CenteredTopPanelContainer.mjs
var import_jsx_runtime204 = __toESM(require_jsx_runtime(), 1);
var import_react136 = __toESM(require_react(), 1);
function CenteredTopPanelContainer({
  maxWidth = 420,
  ignoreRightWidth = 0,
  stylePanelWidth = 148,
  marginBetweenZones = 12,
  squeezeAmount = 52,
  children
}) {
  const ref = (0, import_react136.useRef)(null);
  const breakpoint = useBreakpoint();
  const updateLayout = (0, import_react136.useCallback)(() => {
    const element = ref.current;
    if (!element)
      return;
    const layoutTop = element.parentElement.parentElement;
    const leftPanel = layoutTop.querySelector(".tlui-layout__top__left");
    const rightPanel = layoutTop.querySelector(".tlui-layout__top__right");
    const totalWidth = layoutTop.offsetWidth;
    const leftWidth = leftPanel.offsetWidth;
    const rightWidth = rightPanel.offsetWidth;
    const selfWidth = element.offsetWidth - ignoreRightWidth;
    let xCoordIfCentered = (totalWidth - selfWidth) / 2;
    if (totalWidth % 2 !== 0) {
      xCoordIfCentered -= 0.5;
    }
    const xCoordIfLeftAligned = leftWidth + marginBetweenZones;
    const left2 = element.offsetLeft;
    const maxWidthProperty = Math.min(
      totalWidth - rightWidth - leftWidth - 2 * marginBetweenZones,
      maxWidth
    );
    const xCoord = Math.max(xCoordIfCentered, xCoordIfLeftAligned) - left2;
    if (rightPanel.offsetWidth > stylePanelWidth && breakpoint <= 6) {
      element.style.setProperty("max-width", maxWidthProperty - squeezeAmount + "px");
    } else {
      element.style.setProperty("max-width", maxWidthProperty + "px");
    }
    element.style.setProperty("transform", `translate(${xCoord}px, 0px)`);
  }, [breakpoint, ignoreRightWidth, marginBetweenZones, maxWidth, squeezeAmount, stylePanelWidth]);
  (0, import_react136.useLayoutEffect)(() => {
    const element = ref.current;
    if (!element)
      return;
    const layoutTop = element.parentElement.parentElement;
    const leftPanel = layoutTop.querySelector(".tlui-layout__top__left");
    const rightPanel = layoutTop.querySelector(".tlui-layout__top__right");
    const observer = new ResizeObserver(updateLayout);
    observer.observe(leftPanel);
    observer.observe(rightPanel);
    observer.observe(layoutTop);
    observer.observe(element);
    updateLayout();
    return () => {
      observer.disconnect();
    };
  }, [updateLayout]);
  (0, import_react136.useLayoutEffect)(() => {
    updateLayout();
  });
  return (0, import_jsx_runtime204.jsx)("div", { ref, className: "tlui-top-panel__container", children });
}

// node_modules/tldraw/dist-esm/lib/ui/components/TopPanel/DefaultTopPanel.mjs
function DefaultTopPanel() {
  const isOffline = useCollaborationStatus() === "offline";
  return (0, import_jsx_runtime205.jsx)(CenteredTopPanelContainer, { children: isOffline && (0, import_jsx_runtime205.jsx)(OfflineIndicator, {}) });
}

// node_modules/tldraw/dist-esm/lib/ui/components/ZoomMenu/DefaultZoomMenu.mjs
var import_jsx_runtime207 = __toESM(require_jsx_runtime(), 1);
var import_react137 = __toESM(require_react(), 1);

// node_modules/tldraw/dist-esm/lib/ui/components/ZoomMenu/DefaultZoomMenuContent.mjs
var import_jsx_runtime206 = __toESM(require_jsx_runtime(), 1);
function DefaultZoomMenuContent() {
  return (0, import_jsx_runtime206.jsxs)(import_jsx_runtime206.Fragment, { children: [
    (0, import_jsx_runtime206.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-in", noClose: true }),
    (0, import_jsx_runtime206.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-out", noClose: true }),
    (0, import_jsx_runtime206.jsx)(ZoomTo100MenuItem2, {}),
    (0, import_jsx_runtime206.jsx)(ZoomToFitMenuItem, {}),
    (0, import_jsx_runtime206.jsx)(ZoomToSelectionMenuItem, {})
  ] });
}

// node_modules/tldraw/dist-esm/lib/ui/components/ZoomMenu/DefaultZoomMenu.mjs
var DefaultZoomMenu = (0, import_react137.memo)(function DefaultZoomMenu2({ children }) {
  const container = useContainer();
  const [isOpen, onOpenChange] = useMenuIsOpen("zoom menu");
  const content = children ?? (0, import_jsx_runtime207.jsx)(DefaultZoomMenuContent, {});
  return (0, import_jsx_runtime207.jsxs)(dist_exports9.Root, { dir: "ltr", open: isOpen, onOpenChange, modal: false, children: [
    (0, import_jsx_runtime207.jsx)(ZoomTriggerButton, {}),
    (0, import_jsx_runtime207.jsx)(dist_exports9.Portal, { container, children: (0, import_jsx_runtime207.jsx)(
      dist_exports9.Content,
      {
        className: "tlui-menu",
        side: "top",
        align: "start",
        alignOffset: 0,
        sideOffset: 8,
        collisionPadding: 4,
        children: (0, import_jsx_runtime207.jsx)(TldrawUiMenuContextProvider, { type: "menu", sourceId: "zoom-menu", children: content })
      }
    ) })
  ] });
});
var ZoomTriggerButton = () => {
  const editor = useEditor();
  const breakpoint = useBreakpoint();
  const zoom = useValue("zoom", () => editor.getZoomLevel(), [editor]);
  const msg2 = useTranslation();
  const handleDoubleClick2 = (0, import_react137.useCallback)(() => {
    editor.resetZoom(editor.getViewportScreenCenter(), {
      animation: { duration: editor.options.animationMediumMs }
    });
  }, [editor]);
  const value = `${Math.floor(zoom * 100)}%`;
  return (0, import_jsx_runtime207.jsx)(
    TldrawUiToolbarButton,
    {
      asChild: true,
      type: "icon",
      "aria-label": `${msg2("navigation-zone.zoom")} — ${value}`,
      title: `${msg2("navigation-zone.zoom")} — ${value}`,
      "data-testid": "minimap.zoom-menu-button",
      className: "tlui-zoom-menu__button",
      onDoubleClick: handleDoubleClick2,
      children: (0, import_jsx_runtime207.jsx)(dist_exports9.Trigger, { dir: "ltr", children: breakpoint < PORTRAIT_BREAKPOINT.MOBILE ? null : (0, import_jsx_runtime207.jsx)("span", { style: { flexGrow: 0, textAlign: "center" }, children: value }) })
    }
  );
};

// node_modules/tldraw/dist-esm/lib/ui/context/components.mjs
var TldrawUiComponentsContext = (0, import_react138.createContext)(null);
function TldrawUiComponentsProvider({
  overrides = {},
  children
}) {
  const _overrides = useShallowObjectIdentity(overrides);
  const showCollaborationUi = useShowCollaborationUi();
  return (0, import_jsx_runtime208.jsx)(
    TldrawUiComponentsContext.Provider,
    {
      value: (0, import_react138.useMemo)(
        () => ({
          ContextMenu: DefaultContextMenu,
          ActionsMenu: DefaultActionsMenu,
          HelpMenu: null,
          ZoomMenu: DefaultZoomMenu,
          MainMenu: DefaultMainMenu,
          Minimap: DefaultMinimap,
          StylePanel: DefaultStylePanel,
          PageMenu: DefaultPageMenu,
          NavigationPanel: DefaultNavigationPanel,
          Toolbar: DefaultToolbar,
          RichTextToolbar: DefaultRichTextToolbar,
          KeyboardShortcutsDialog: DefaultKeyboardShortcutsDialog,
          QuickActions: DefaultQuickActions,
          HelperButtons: DefaultHelperButtons,
          DebugPanel: DefaultDebugPanel,
          DebugMenu: DefaultDebugMenu,
          MenuPanel: DefaultMenuPanel,
          SharePanel: showCollaborationUi ? DefaultSharePanel : null,
          CursorChatBubble: showCollaborationUi ? CursorChatBubble : null,
          TopPanel: showCollaborationUi ? DefaultTopPanel : null,
          Dialogs: DefaultDialogs,
          Toasts: DefaultToasts,
          A11y: DefaultA11yAnnouncer,
          ..._overrides
        }),
        [_overrides, showCollaborationUi]
      ),
      children
    }
  );
}
function useTldrawUiComponents() {
  const components = (0, import_react138.useContext)(TldrawUiComponentsContext);
  if (!components) {
    throw new Error("useTldrawUiComponents must be used within a TldrawUiComponentsProvider");
  }
  return components;
}

// node_modules/tldraw/dist-esm/lib/ui/context/TldrawUiContextProvider.mjs
var TldrawUiContextProvider = track(function TldrawUiContextProvider2({
  overrides,
  components,
  assetUrls,
  onUiEvent,
  forceMobile,
  mediaMimeTypes,
  children
}) {
  const editor = useMaybeEditor();
  return (0, import_jsx_runtime209.jsx)(MimeTypeContext.Provider, { value: mediaMimeTypes, children: (0, import_jsx_runtime209.jsx)(AssetUrlsProvider, { assetUrls: useDefaultUiAssetUrlsWithOverrides(assetUrls), children: (0, import_jsx_runtime209.jsx)(
    TldrawUiTranslationProvider,
    {
      overrides: useMergedTranslationOverrides(overrides),
      locale: (editor == null ? void 0 : editor.user.getLocale()) ?? defaultUserPreferences.locale,
      children: (0, import_jsx_runtime209.jsx)(TldrawUiEventsProvider, { onEvent: onUiEvent, children: (0, import_jsx_runtime209.jsx)(TldrawUiToastsProvider, { children: (0, import_jsx_runtime209.jsx)(TldrawUiDialogsProvider, { context: "tla", children: (0, import_jsx_runtime209.jsx)(TldrawUiA11yProvider, { children: (0, import_jsx_runtime209.jsx)(BreakPointProvider, { forceMobile, children: (0, import_jsx_runtime209.jsx)(TldrawUiComponentsProvider, { overrides: components, children: (0, import_jsx_runtime209.jsx)(InternalProviders, { overrides, children }) }) }) }) }) }) })
    }
  ) }) });
});
function InternalProviders({
  overrides,
  children
}) {
  const mergedOverrides = useMergedOverrides(overrides);
  return (0, import_jsx_runtime209.jsx)(ActionsProvider, { overrides: mergedOverrides.actions, children: (0, import_jsx_runtime209.jsx)(ToolsProvider, { overrides: mergedOverrides.tools, children }) });
}

// node_modules/tldraw/dist-esm/lib/ui/hooks/useEditorEvents.mjs
var import_react139 = __toESM(require_react(), 1);
function useEditorEvents() {
  const editor = useEditor();
  const { addToast } = useToasts();
  (0, import_react139.useEffect)(() => {
    function handleMaxShapes({ name, count: count3 }) {
      addToast({
        title: "Maximum Shapes Reached",
        description: `You've reached the maximum number of shapes allowed on ${name} (${count3}). Please delete some shapes or move to a different page to continue.`,
        severity: "warning"
      });
    }
    editor.addListener("max-shapes", handleMaxShapes);
    return () => {
      editor.removeListener("max-shapes", handleMaxShapes);
    };
  }, [editor, addToast]);
}

// node_modules/tldraw/dist-esm/lib/ui/TldrawUi.mjs
var TldrawUi = import_react140.default.memo(function TldrawUi2({
  renderDebugMenuItems,
  children,
  hideUi,
  components,
  ...rest
}) {
  return (0, import_jsx_runtime210.jsx)(TldrawUiContextProvider, { ...rest, components, children: (0, import_jsx_runtime210.jsx)(TldrawUiInner, { hideUi, renderDebugMenuItems, children }) });
});
var TldrawUiInner = import_react140.default.memo(function TldrawUiInner2({
  children,
  hideUi,
  ...rest
}) {
  return (0, import_jsx_runtime210.jsxs)(import_jsx_runtime210.Fragment, { children: [
    children,
    hideUi ? null : (0, import_jsx_runtime210.jsx)(TldrawUiContent, { ...rest })
  ] });
});
var TldrawUiContent = import_react140.default.memo(function TldrawUI() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const isFocusMode = useValue("focus", () => editor.getInstanceState().isFocusMode, [editor]);
  const isDebugMode = useValue("debug", () => editor.getInstanceState().isDebugMode, [editor]);
  const {
    SharePanel,
    TopPanel,
    MenuPanel: MenuPanel2,
    StylePanel,
    Toolbar: Toolbar2,
    HelpMenu,
    NavigationPanel,
    HelperButtons,
    DebugPanel,
    CursorChatBubble: CursorChatBubble3,
    RichTextToolbar,
    Toasts,
    Dialogs,
    A11y
  } = useTldrawUiComponents();
  useKeyboardShortcuts();
  useNativeClipboardEvents();
  useEditorEvents();
  const rIsEditingAnything = (0, import_react140.useRef)(false);
  const rHidingTimeout = (0, import_react140.useRef)(-1);
  const [hideToolbarWhileEditing, setHideToolbarWhileEditing] = (0, import_react140.useState)(false);
  useReactor(
    "update hide toolbar while delayed",
    () => {
      const isMobileEnvironment = tlenv.isIos || tlenv.isAndroid;
      if (!isMobileEnvironment)
        return;
      const editingShape = editor.getEditingShapeId();
      if (editingShape === null) {
        if (rIsEditingAnything.current) {
          rIsEditingAnything.current = false;
          clearTimeout(rHidingTimeout.current);
          if (tlenv.isAndroid) {
            rHidingTimeout.current = editor.timers.setTimeout(() => {
              setHideToolbarWhileEditing(false);
            }, 150);
          } else {
            setHideToolbarWhileEditing(false);
          }
        }
        return;
      }
      if (!rIsEditingAnything.current) {
        rIsEditingAnything.current = true;
        clearTimeout(rHidingTimeout.current);
        setHideToolbarWhileEditing(true);
      }
    },
    []
  );
  const { "toggle-focus-mode": toggleFocus } = useActions();
  return (0, import_jsx_runtime210.jsxs)(
    "div",
    {
      className: (0, import_classnames36.default)("tlui-layout", {
        "tlui-layout__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
      }),
      "data-iseditinganything": hideToolbarWhileEditing,
      "data-breakpoint": breakpoint,
      children: [
        (0, import_jsx_runtime210.jsx)(SkipToMainContent, {}),
        isFocusMode ? (0, import_jsx_runtime210.jsx)("div", { className: "tlui-layout__top", children: (0, import_jsx_runtime210.jsx)(
          TldrawUiButton,
          {
            type: "icon",
            className: "tlui-focus-button",
            title: msg2("focus-mode.toggle-focus-mode"),
            onClick: () => toggleFocus.onSelect("menu"),
            children: (0, import_jsx_runtime210.jsx)(TldrawUiButtonIcon, { icon: "dot" })
          }
        ) }) : (0, import_jsx_runtime210.jsxs)(import_jsx_runtime210.Fragment, { children: [
          (0, import_jsx_runtime210.jsxs)("div", { className: "tlui-layout__top", children: [
            (0, import_jsx_runtime210.jsxs)("div", { className: "tlui-layout__top__left", children: [
              MenuPanel2 && (0, import_jsx_runtime210.jsx)(MenuPanel2, {}),
              HelperButtons && (0, import_jsx_runtime210.jsx)(HelperButtons, {})
            ] }),
            (0, import_jsx_runtime210.jsx)("div", { className: "tlui-layout__top__center", children: TopPanel && (0, import_jsx_runtime210.jsx)(TopPanel, {}) }),
            (0, import_jsx_runtime210.jsxs)("div", { className: "tlui-layout__top__right", children: [
              SharePanel && (0, import_jsx_runtime210.jsx)(SharePanel, {}),
              StylePanel && breakpoint >= PORTRAIT_BREAKPOINT.TABLET_SM && !isReadonlyMode && (0, import_jsx_runtime210.jsx)(StylePanel, {})
            ] })
          ] }),
          (0, import_jsx_runtime210.jsxs)("div", { className: "tlui-layout__bottom", children: [
            (0, import_jsx_runtime210.jsxs)("div", { className: "tlui-layout__bottom__main", children: [
              NavigationPanel && (0, import_jsx_runtime210.jsx)(NavigationPanel, {}),
              Toolbar2 && (0, import_jsx_runtime210.jsx)(Toolbar2, {}),
              HelpMenu && (0, import_jsx_runtime210.jsx)(HelpMenu, {})
            ] }),
            isDebugMode && DebugPanel && (0, import_jsx_runtime210.jsx)(DebugPanel, {}),
            A11y && (0, import_jsx_runtime210.jsx)(A11y, {})
          ] })
        ] }),
        RichTextToolbar && (0, import_jsx_runtime210.jsx)(RichTextToolbar, {}),
        Toasts && (0, import_jsx_runtime210.jsx)(Toasts, {}),
        Dialogs && (0, import_jsx_runtime210.jsx)(Dialogs, {}),
        (0, import_jsx_runtime210.jsx)(FollowingIndicator, {}),
        CursorChatBubble3 && (0, import_jsx_runtime210.jsx)(CursorChatBubble3, {})
      ]
    }
  );
});

// node_modules/tldraw/dist-esm/lib/ui/components/LoadingScreen.mjs
var import_jsx_runtime211 = __toESM(require_jsx_runtime(), 1);
var LoadingScreen2 = () => {
  const { Spinner: Spinner2 } = useEditorComponents();
  return (0, import_jsx_runtime211.jsx)(TldrawUiContextProvider, { children: (0, import_jsx_runtime211.jsx)(LoadingScreen, { children: Spinner2 ? (0, import_jsx_runtime211.jsx)(Spinner2, {}) : null }) });
};

// node_modules/tldraw/dist-esm/lib/Tldraw.mjs
var allDefaultTools = [...defaultTools, ...defaultShapeTools];
function Tldraw(props) {
  const {
    children,
    maxImageDimension,
    maxAssetSize,
    acceptedImageMimeTypes,
    acceptedVideoMimeTypes,
    onMount: onMount2,
    components = {},
    shapeUtils = [],
    bindingUtils = [],
    tools = [],
    embeds,
    textOptions,
    ...rest
  } = props;
  const _components = useShallowObjectIdentity(components);
  const componentsWithDefault = (0, import_react141.useMemo)(
    () => ({
      Scribble: TldrawScribble,
      ShapeIndicators: TldrawShapeIndicators,
      CollaboratorScribble: TldrawScribble,
      SelectionForeground: TldrawSelectionForeground,
      Handles: TldrawHandles,
      Overlays: TldrawOverlays,
      Spinner,
      LoadingScreen: LoadingScreen2,
      ..._components
    }),
    [_components]
  );
  const _shapeUtils = useShallowArrayIdentity(shapeUtils);
  const shapeUtilsWithDefaults = (0, import_react141.useMemo)(
    () => mergeArraysAndReplaceDefaults("type", _shapeUtils, defaultShapeUtils),
    [_shapeUtils]
  );
  const _bindingUtils = useShallowArrayIdentity(bindingUtils);
  const bindingUtilsWithDefaults = (0, import_react141.useMemo)(
    () => mergeArraysAndReplaceDefaults("type", _bindingUtils, defaultBindingUtils),
    [_bindingUtils]
  );
  const _tools = useShallowArrayIdentity(tools);
  const toolsWithDefaults = (0, import_react141.useMemo)(
    () => mergeArraysAndReplaceDefaults("id", allDefaultTools, _tools),
    [_tools]
  );
  const _imageMimeTypes = useShallowArrayIdentity(
    acceptedImageMimeTypes ?? DEFAULT_SUPPORTED_IMAGE_TYPES
  );
  const _videoMimeTypes = useShallowArrayIdentity(
    acceptedVideoMimeTypes ?? DEFAULT_SUPPORT_VIDEO_TYPES
  );
  const textOptionsWithDefaults = (0, import_react141.useMemo)(() => {
    return {
      addFontsFromNode: defaultAddFontsFromNode,
      ...textOptions,
      tipTapConfig: {
        extensions: tipTapDefaultExtensions,
        ...textOptions == null ? void 0 : textOptions.tipTapConfig
      }
    };
  }, [textOptions]);
  const mediaMimeTypes = (0, import_react141.useMemo)(
    () => [..._imageMimeTypes, ..._videoMimeTypes],
    [_imageMimeTypes, _videoMimeTypes]
  );
  const assets = useDefaultEditorAssetsWithOverrides(rest.assetUrls);
  const embedShapeUtil = shapeUtilsWithDefaults.find((util) => util.type === "embed");
  if (embedShapeUtil && embeds) {
    EmbedShapeUtil.setEmbedDefinitions(embeds);
  }
  return (0, import_jsx_runtime212.jsx)(
    TldrawEditor,
    {
      initialState: "select",
      ...rest,
      components: componentsWithDefault,
      shapeUtils: shapeUtilsWithDefaults,
      bindingUtils: bindingUtilsWithDefaults,
      tools: toolsWithDefaults,
      textOptions: textOptionsWithDefaults,
      assetUrls: assets,
      children: (0, import_jsx_runtime212.jsxs)(TldrawUi, { ...rest, components: componentsWithDefault, mediaMimeTypes, children: [
        (0, import_jsx_runtime212.jsx)(
          InsideOfEditorAndUiContext,
          {
            maxImageDimension,
            maxAssetSize,
            acceptedImageMimeTypes: _imageMimeTypes,
            acceptedVideoMimeTypes: _videoMimeTypes,
            onMount: onMount2
          }
        ),
        children
      ] })
    }
  );
}
function InsideOfEditorAndUiContext({
  maxImageDimension,
  maxAssetSize,
  acceptedImageMimeTypes,
  acceptedVideoMimeTypes,
  onMount: onMount2
}) {
  const editor = useEditor();
  const toasts = useToasts();
  const msg2 = useTranslation();
  useOnMount(() => {
    const unsubs = [];
    unsubs.push(registerDefaultSideEffects(editor));
    editor.fonts.requestFonts(allDefaultFontFaces);
    registerDefaultExternalContentHandlers(editor, {
      maxImageDimension,
      maxAssetSize,
      acceptedImageMimeTypes,
      acceptedVideoMimeTypes,
      toasts,
      msg: msg2
    });
    unsubs.push(editor.store.props.onMount(editor));
    unsubs.push(onMount2 == null ? void 0 : onMount2(editor));
    return () => {
      unsubs.forEach((fn2) => fn2 == null ? void 0 : fn2());
    };
  });
  const { Canvas } = useEditorComponents();
  const { ContextMenu: ContextMenu2 } = useTldrawUiComponents();
  if (ContextMenu2) {
    return (0, import_jsx_runtime212.jsx)(ContextMenu2, {});
  }
  if (Canvas) {
    return (0, import_jsx_runtime212.jsx)(Canvas, {});
  }
  return null;
}

// node_modules/tldraw/dist-esm/lib/TldrawImage.mjs
var import_jsx_runtime213 = __toESM(require_jsx_runtime(), 1);
var import_react142 = __toESM(require_react(), 1);
var defaultTextOptions = {
  tipTapConfig: {
    extensions: tipTapDefaultExtensions
  },
  addFontsFromNode: defaultAddFontsFromNode
};
var TldrawImage = (0, import_react142.memo)(function TldrawImage2(props) {
  const [url, setUrl] = (0, import_react142.useState)(null);
  const [container, setContainer] = (0, import_react142.useState)(null);
  const _shapeUtils = useShallowArrayIdentity(props.shapeUtils ?? []);
  const shapeUtilsWithDefaults = (0, import_react142.useMemo)(
    () => mergeArraysAndReplaceDefaults("type", _shapeUtils, defaultShapeUtils),
    [_shapeUtils]
  );
  const _bindingUtils = useShallowArrayIdentity(props.bindingUtils ?? []);
  const bindingUtilsWithDefaults = (0, import_react142.useMemo)(
    () => mergeArraysAndReplaceDefaults("type", _bindingUtils, defaultBindingUtils),
    [_bindingUtils]
  );
  const store = useTLStore({ snapshot: props.snapshot, shapeUtils: shapeUtilsWithDefaults });
  const {
    pageId,
    bounds,
    scale,
    pixelRatio,
    background,
    padding,
    darkMode,
    preserveAspectRatio,
    format: format2 = "svg",
    licenseKey,
    assetUrls,
    textOptions = defaultTextOptions
  } = props;
  (0, import_react142.useLayoutEffect)(() => {
    if (!container)
      return;
    if (!store)
      return;
    let isCancelled = false;
    const tempElm = document.createElement("div");
    container.appendChild(tempElm);
    container.classList.add("tl-container", "tl-theme__light");
    const editor = new Editor({
      store,
      shapeUtils: shapeUtilsWithDefaults,
      bindingUtils: bindingUtilsWithDefaults,
      tools: [],
      getContainer: () => tempElm,
      licenseKey,
      fontAssetUrls: assetUrls == null ? void 0 : assetUrls.fonts,
      textOptions
    });
    if (pageId)
      editor.setCurrentPage(pageId);
    const shapeIds = editor.getCurrentPageShapeIds();
    async function setSvg() {
      const imageResult = await editor.toImage([...shapeIds], {
        bounds,
        scale,
        background,
        padding,
        darkMode,
        preserveAspectRatio,
        format: format2
      });
      if (!imageResult || isCancelled)
        return;
      const url2 = URL.createObjectURL(imageResult.blob);
      setUrl(url2);
      editor.dispose();
    }
    setSvg();
    return () => {
      isCancelled = true;
    };
  }, [
    format2,
    container,
    store,
    shapeUtilsWithDefaults,
    bindingUtilsWithDefaults,
    pageId,
    bounds,
    scale,
    background,
    padding,
    darkMode,
    preserveAspectRatio,
    licenseKey,
    pixelRatio,
    assetUrls,
    textOptions
  ]);
  (0, import_react142.useEffect)(() => {
    return () => {
      if (url)
        URL.revokeObjectURL(url);
    };
  }, [url]);
  return (0, import_jsx_runtime213.jsx)("div", { ref: setContainer, style: { position: "relative", width: "100%", height: "100%" }, children: url && (0, import_jsx_runtime213.jsx)(
    "img",
    {
      src: url,
      referrerPolicy: "strict-origin-when-cross-origin",
      style: { width: "100%", height: "100%" }
    }
  ) });
});

// node_modules/tldraw/dist-esm/lib/ui/components/HelpMenu/DefaultHelpMenu.mjs
var import_jsx_runtime214 = __toESM(require_jsx_runtime(), 1);
var import_react143 = __toESM(require_react(), 1);
var DefaultHelpMenu = (0, import_react143.memo)(function DefaultHelpMenu2({ children }) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const ref = (0, import_react143.useRef)(null);
  usePassThroughWheelEvents(ref);
  const content = children ?? (0, import_jsx_runtime214.jsx)(DefaultHelpMenuContent, {});
  if (breakpoint < PORTRAIT_BREAKPOINT.MOBILE)
    return null;
  return (0, import_jsx_runtime214.jsx)("div", { ref, className: "tlui-help-menu", children: (0, import_jsx_runtime214.jsxs)(TldrawUiDropdownMenuRoot, { id: "help menu", children: [
    (0, import_jsx_runtime214.jsx)(TldrawUiDropdownMenuTrigger, { children: (0, import_jsx_runtime214.jsx)(TldrawUiButton, { type: "help", title: msg2("help-menu.title"), "data-testid": "help-menu.button", children: (0, import_jsx_runtime214.jsx)(TldrawUiButtonIcon, { icon: "question-mark", small: true }) }) }),
    (0, import_jsx_runtime214.jsx)(TldrawUiDropdownMenuContent, { side: "top", align: "end", alignOffset: 0, sideOffset: 8, children: (0, import_jsx_runtime214.jsx)(TldrawUiMenuContextProvider, { type: "menu", sourceId: "help-menu", children: content }) })
  ] }) });
});

// node_modules/tldraw/dist-esm/lib/utils/assets/preload-font.mjs
async function preloadFont(id, font) {
  const {
    url,
    style: style2 = "normal",
    weight = "500",
    display,
    featureSettings,
    stretch,
    unicodeRange,
    variant,
    format: format2
  } = font;
  const descriptors = {
    style: style2,
    weight,
    display,
    featureSettings,
    stretch,
    unicodeRange,
    // @ts-expect-error why is this here
    variant
  };
  const fontInstance = new FontFace(id, `url(${url})`, descriptors);
  await fontInstance.load();
  document.fonts.add(fontInstance);
  fontInstance.$$_url = url;
  fontInstance.$$_fontface = `
@font-face {
	font-family: ${fontInstance.family};
	font-stretch: ${fontInstance.stretch};
	font-weight: ${fontInstance.weight};
	font-style: ${fontInstance.style};
	src: url("${url}") format("${format2}")
}`;
  return fontInstance;
}

// node_modules/tldraw/dist-esm/lib/utils/tldr/buildFromV1Document.mjs
var TLDRAW_V1_VERSION = 15.5;
function buildFromV1Document(editor, _document) {
  let document2 = _document;
  editor.run(() => {
    document2 = migrate2(document2, TLDRAW_V1_VERSION);
    editor.cancel().cancel().cancel().cancel();
    const firstPageId = editor.getPages()[0].id;
    editor.setCurrentPage(firstPageId);
    for (const page of editor.getPages().slice(1)) {
      editor.deletePage(page.id);
    }
    editor.selectAll();
    editor.deleteShapes(editor.getSelectedShapeIds());
    const v1AssetIdsToV2AssetIds = /* @__PURE__ */ new Map();
    Object.values(document2.assets ?? {}).forEach((v1Asset) => {
      switch (v1Asset.type) {
        case "image": {
          const assetId = AssetRecordType.createId();
          v1AssetIdsToV2AssetIds.set(v1Asset.id, assetId);
          const placeholderAsset = {
            id: assetId,
            typeName: "asset",
            type: "image",
            props: {
              w: coerceDimension(v1Asset.size[0]),
              h: coerceDimension(v1Asset.size[1]),
              name: v1Asset.fileName ?? "Untitled",
              isAnimated: false,
              mimeType: null,
              src: v1Asset.src
            },
            meta: {}
          };
          editor.createAssets([placeholderAsset]);
          tryMigrateAsset(editor, placeholderAsset);
          break;
        }
        case "video":
          {
            const assetId = AssetRecordType.createId();
            v1AssetIdsToV2AssetIds.set(v1Asset.id, assetId);
            editor.createAssets([
              {
                id: assetId,
                typeName: "asset",
                type: "video",
                props: {
                  w: coerceDimension(v1Asset.size[0]),
                  h: coerceDimension(v1Asset.size[1]),
                  name: v1Asset.fileName ?? "Untitled",
                  isAnimated: true,
                  mimeType: null,
                  src: v1Asset.src
                },
                meta: {}
              }
            ]);
          }
          break;
      }
    });
    const v1PageIdsToV2PageIds = /* @__PURE__ */ new Map();
    Object.values(document2.pages ?? {}).sort((a, b) => (a.childIndex ?? 1) < (b.childIndex ?? 1) ? -1 : 1).forEach((v1Page, i) => {
      if (i === 0) {
        v1PageIdsToV2PageIds.set(v1Page.id, editor.getCurrentPageId());
      } else {
        const pageId = PageRecordType.createId();
        v1PageIdsToV2PageIds.set(v1Page.id, pageId);
        editor.createPage({ name: v1Page.name ?? "Page", id: pageId });
      }
    });
    Object.values(document2.pages ?? {}).sort((a, b) => (a.childIndex ?? 1) < (b.childIndex ?? 1) ? -1 : 1).forEach((v1Page) => {
      editor.setCurrentPage(v1PageIdsToV2PageIds.get(v1Page.id));
      const v1ShapeIdsToV2ShapeIds = /* @__PURE__ */ new Map();
      const v1GroupShapeIdsToV1ChildIds = /* @__PURE__ */ new Map();
      const v1Shapes = Object.values(v1Page.shapes ?? {}).sort((a, b) => a.childIndex < b.childIndex ? -1 : 1).slice(0, editor.options.maxShapesPerPage);
      v1Shapes.forEach((v1Shape) => {
        if (v1Shape.type !== "group")
          return;
        const shapeId = createShapeId();
        v1ShapeIdsToV2ShapeIds.set(v1Shape.id, shapeId);
        v1GroupShapeIdsToV1ChildIds.set(v1Shape.id, []);
      });
      function decideNotToCreateShape(v1Shape) {
        v1ShapeIdsToV2ShapeIds.delete(v1Shape.id);
        const v1GroupParent = v1GroupShapeIdsToV1ChildIds.has(v1Shape.parentId);
        if (v1GroupParent) {
          const ids = v1GroupShapeIdsToV1ChildIds.get(v1Shape.parentId).filter((id) => id !== v1Shape.id);
          v1GroupShapeIdsToV1ChildIds.set(v1Shape.parentId, ids);
        }
      }
      v1Shapes.forEach((v1Shape) => {
        var _a5, _b;
        if (v1Shape.type === "group") {
          return;
        }
        const shapeId = createShapeId();
        v1ShapeIdsToV2ShapeIds.set(v1Shape.id, shapeId);
        if (v1Shape.parentId !== v1Page.id) {
          if (v1GroupShapeIdsToV1ChildIds.has(v1Shape.parentId)) {
            v1GroupShapeIdsToV1ChildIds.get(v1Shape.parentId).push(v1Shape.id);
          } else {
            console.warn("parent does not exist", v1Shape);
          }
        }
        const parentId = v1PageIdsToV2PageIds.get(v1Page.id);
        const inCommon = {
          id: shapeId,
          parentId,
          x: coerceNumber(v1Shape.point[0]),
          y: coerceNumber(v1Shape.point[1]),
          rotation: 0,
          isLocked: !!v1Shape.isLocked
        };
        switch (v1Shape.type) {
          case "sticky": {
            editor.createShapes([
              {
                ...inCommon,
                type: "note",
                props: {
                  richText: toRichText(v1Shape.text ?? ""),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  align: getV2Align(v1Shape.style.textAlign)
                }
              }
            ]);
            break;
          }
          case "rectangle": {
            editor.createShapes([
              {
                ...inCommon,
                type: "geo",
                props: {
                  geo: "rectangle",
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  richText: toRichText(v1Shape.label ?? ""),
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  align: "middle"
                }
              }
            ]);
            const pageBoundsBeforeLabel = editor.getShapePageBounds(inCommon.id);
            editor.updateShapes([
              {
                id: inCommon.id,
                type: "geo",
                props: {
                  richText: toRichText(v1Shape.label ?? "")
                }
              }
            ]);
            if (pageBoundsBeforeLabel.width === pageBoundsBeforeLabel.height) {
              const shape = editor.getShape(inCommon.id);
              const { growY } = shape.props;
              const w = coerceDimension(shape.props.w);
              const h = coerceDimension(shape.props.h);
              const newW = w + growY / 2;
              const newH = h + growY / 2;
              editor.updateShapes([
                {
                  id: inCommon.id,
                  type: "geo",
                  x: coerceNumber(shape.x) - (newW - w) / 2,
                  y: coerceNumber(shape.y) - (newH - h) / 2,
                  props: {
                    w: newW,
                    h: newH
                  }
                }
              ]);
            }
            break;
          }
          case "triangle": {
            editor.createShapes([
              {
                ...inCommon,
                type: "geo",
                props: {
                  geo: "triangle",
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  align: "middle"
                }
              }
            ]);
            const pageBoundsBeforeLabel = editor.getShapePageBounds(inCommon.id);
            editor.updateShapes([
              {
                id: inCommon.id,
                type: "geo",
                props: {
                  richText: toRichText(v1Shape.label ?? "")
                }
              }
            ]);
            if (pageBoundsBeforeLabel.width === pageBoundsBeforeLabel.height) {
              const shape = editor.getShape(inCommon.id);
              const { growY } = shape.props;
              const w = coerceDimension(shape.props.w);
              const h = coerceDimension(shape.props.h);
              const newW = w + growY / 2;
              const newH = h + growY / 2;
              editor.updateShapes([
                {
                  id: inCommon.id,
                  type: "geo",
                  x: coerceNumber(shape.x) - (newW - w) / 2,
                  y: coerceNumber(shape.y) - (newH - h) / 2,
                  props: {
                    w: newW,
                    h: newH
                  }
                }
              ]);
            }
            break;
          }
          case "ellipse": {
            editor.createShapes([
              {
                ...inCommon,
                type: "geo",
                props: {
                  geo: "ellipse",
                  w: coerceDimension(v1Shape.radius[0]) * 2,
                  h: coerceDimension(v1Shape.radius[1]) * 2,
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  align: "middle"
                }
              }
            ]);
            const pageBoundsBeforeLabel = editor.getShapePageBounds(inCommon.id);
            editor.updateShapes([
              {
                id: inCommon.id,
                type: "geo",
                props: {
                  richText: toRichText(v1Shape.label ?? "")
                }
              }
            ]);
            if (pageBoundsBeforeLabel.width === pageBoundsBeforeLabel.height) {
              const shape = editor.getShape(inCommon.id);
              const { growY } = shape.props;
              const w = coerceDimension(shape.props.w);
              const h = coerceDimension(shape.props.h);
              const newW = w + growY / 2;
              const newH = h + growY / 2;
              editor.updateShapes([
                {
                  id: inCommon.id,
                  type: "geo",
                  x: coerceNumber(shape.x) - (newW - w) / 2,
                  y: coerceNumber(shape.y) - (newH - h) / 2,
                  props: {
                    w: newW,
                    h: newH
                  }
                }
              ]);
            }
            break;
          }
          case "draw": {
            if (v1Shape.points.length === 0) {
              decideNotToCreateShape(v1Shape);
              break;
            }
            editor.createShapes([
              {
                ...inCommon,
                type: "draw",
                props: {
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  dash: getV2Dash(v1Shape.style.dash),
                  isPen: false,
                  isComplete: v1Shape.isComplete,
                  segments: [{ type: "free", points: v1Shape.points.map(getV2Point) }]
                }
              }
            ]);
            break;
          }
          case "arrow": {
            const v1Bend = coerceNumber(v1Shape.bend);
            const v1Start = getV2Point(v1Shape.handles.start.point);
            const v1End = getV2Point(v1Shape.handles.end.point);
            const dist = Vec.Dist(v1Start, v1End);
            const v2Bend = dist * -v1Bend / 2;
            editor.createShapes([
              {
                ...inCommon,
                type: "arrow",
                props: {
                  text: v1Shape.label ?? "",
                  color: getV2Color(v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  arrowheadStart: getV2Arrowhead((_a5 = v1Shape.decorations) == null ? void 0 : _a5.start),
                  arrowheadEnd: getV2Arrowhead((_b = v1Shape.decorations) == null ? void 0 : _b.end),
                  start: {
                    x: coerceNumber(v1Shape.handles.start.point[0]),
                    y: coerceNumber(v1Shape.handles.start.point[1])
                  },
                  end: {
                    x: coerceNumber(v1Shape.handles.end.point[0]),
                    y: coerceNumber(v1Shape.handles.end.point[1])
                  },
                  bend: v2Bend
                }
              }
            ]);
            break;
          }
          case "text": {
            editor.createShapes([
              {
                ...inCommon,
                type: "text",
                props: {
                  richText: toRichText(v1Shape.text ?? " "),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2TextSize(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  textAlign: getV2TextAlign(v1Shape.style.textAlign),
                  scale: v1Shape.style.scale ?? 1
                }
              }
            ]);
            break;
          }
          case "image": {
            const assetId = v1AssetIdsToV2AssetIds.get(v1Shape.assetId);
            if (!assetId) {
              console.warn("Could not find asset id", v1Shape.assetId);
              return;
            }
            editor.createShapes([
              {
                ...inCommon,
                type: "image",
                props: {
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  assetId
                }
              }
            ]);
            break;
          }
          case "video": {
            const assetId = v1AssetIdsToV2AssetIds.get(v1Shape.assetId);
            if (!assetId) {
              console.warn("Could not find asset id", v1Shape.assetId);
              return;
            }
            editor.createShapes([
              {
                ...inCommon,
                type: "video",
                props: {
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  assetId
                }
              }
            ]);
            break;
          }
        }
        const rotation = coerceNumber(v1Shape.rotation);
        if (rotation !== 0) {
          editor.select(shapeId);
          editor.rotateShapesBy([shapeId], rotation);
        }
      });
      v1GroupShapeIdsToV1ChildIds.forEach((v1ChildIds, v1GroupId) => {
        const v2ChildShapeIds = v1ChildIds.map((id) => v1ShapeIdsToV2ShapeIds.get(id));
        const v2GroupId = v1ShapeIdsToV2ShapeIds.get(v1GroupId);
        editor.groupShapes(v2ChildShapeIds, { groupId: v2GroupId });
        const v1Group = v1Page.shapes[v1GroupId];
        const rotation = coerceNumber(v1Group.rotation);
        if (rotation !== 0) {
          editor.select(v2GroupId);
          editor.rotateShapesBy([v2GroupId], rotation);
        }
      });
      v1Shapes.forEach((v1Shape) => {
        if (v1Shape.type !== "arrow") {
          return;
        }
        const v2ShapeId = v1ShapeIdsToV2ShapeIds.get(v1Shape.id);
        const util = editor.getShapeUtil("arrow");
        editor.inputs.ctrlKey = false;
        for (const handleId of ["start", "end"]) {
          const bindingId = v1Shape.handles[handleId].bindingId;
          if (bindingId) {
            const binding = v1Page.bindings[bindingId];
            if (!binding) {
              continue;
            }
            const targetId = v1ShapeIdsToV2ShapeIds.get(binding.toId);
            const targetShape = editor.getShape(targetId);
            if (!targetShape)
              continue;
            if (targetId) {
              const bounds2 = editor.getShapePageBounds(targetId);
              const v2ShapeFresh = editor.getShape(v2ShapeId);
              const nx = clamp((coerceNumber(binding.point[0]) + 0.5) / 2, 0.2, 0.8);
              const ny = clamp((coerceNumber(binding.point[1]) + 0.5) / 2, 0.2, 0.8);
              const point = editor.getPointInShapeSpace(v2ShapeFresh, {
                x: bounds2.minX + bounds2.width * nx,
                y: bounds2.minY + bounds2.height * ny
              });
              const handles = editor.getShapeHandles(v2ShapeFresh);
              const change = util.onHandleDrag(v2ShapeFresh, {
                handle: {
                  ...handles.find((h) => h.id === handleId),
                  x: point.x,
                  y: point.y
                },
                isPrecise: point.x !== 0.5 || point.y !== 0.5
              });
              if (change) {
                editor.updateShape(change);
              }
              const freshBinding = getArrowBindings(
                editor,
                editor.getShape(v2ShapeId)
              )[handleId];
              if (freshBinding) {
                const updatedFreshBinding = structuredClone(freshBinding);
                if (binding.distance === 0) {
                  updatedFreshBinding.props.isExact = true;
                }
                if (updatedFreshBinding.toId !== targetId) {
                  updatedFreshBinding.toId = targetId;
                  updatedFreshBinding.props.normalizedAnchor = { x: nx, y: ny };
                }
                editor.updateBinding(updatedFreshBinding);
              }
            }
          }
        }
      });
    });
    editor.setCurrentPage(firstPageId);
    editor.clearHistory();
    editor.selectNone();
    const bounds = editor.getCurrentPageBounds();
    if (bounds) {
      editor.zoomToBounds(bounds, { targetZoom: 1 });
    }
  });
}
function coerceNumber(n) {
  if (typeof n !== "number")
    return 0;
  if (Number.isNaN(n))
    return 0;
  if (!Number.isFinite(n))
    return 0;
  return n;
}
function coerceDimension(d) {
  const n = coerceNumber(d);
  if (n <= 0)
    return 1;
  return n;
}
async function tryMigrateAsset(editor, placeholderAsset) {
  try {
    if (placeholderAsset.type === "bookmark" || !placeholderAsset.props.src)
      return;
    const response = await fetch(placeholderAsset.props.src);
    if (!response.ok)
      return;
    const file = new File([await response.blob()], placeholderAsset.props.name, {
      type: response.headers.get("content-type") ?? placeholderAsset.props.mimeType ?? void 0
    });
    const newAsset = await editor.getAssetForExternalContent({ type: "file", file });
    if (!newAsset)
      throw new Error("Could not get asset for external content");
    if (newAsset.type === "bookmark")
      return;
    editor.updateAssets([
      {
        id: placeholderAsset.id,
        type: placeholderAsset.type,
        props: {
          ...newAsset.props,
          name: placeholderAsset.props.name
        }
      }
    ]);
  } catch {
  }
}
function migrate2(document2, newVersion) {
  const { version: version2 = 0 } = document2;
  if (!document2.assets) {
    document2.assets = {};
  }
  const assetIdsInUse = /* @__PURE__ */ new Set();
  Object.values(document2.pages).forEach(
    (page) => Object.values(page.shapes).forEach((shape) => {
      const { parentId, children, assetId } = shape;
      if (assetId) {
        assetIdsInUse.add(assetId);
      }
      if (parentId !== page.id && !page.shapes[parentId]) {
        console.warn("Encountered a shape with a missing parent!");
        shape.parentId = page.id;
      }
      if (shape.type === "group" && children) {
        children.forEach((childId) => {
          if (!page.shapes[childId]) {
            console.warn("Encountered a parent with a missing child!", shape.id, childId);
            children == null ? void 0 : children.splice(children.indexOf(childId), 1);
          }
        });
      }
    })
  );
  Object.keys(document2.assets).forEach((assetId) => {
    if (!assetIdsInUse.has(assetId)) {
      delete document2.assets[assetId];
    }
  });
  if (version2 !== newVersion) {
    if (version2 < 14) {
      Object.values(document2.pages).forEach((page) => {
        Object.values(page.shapes).filter(
          (shape) => shape.type === "text"
          /* Text */
        ).forEach((shape) => {
          if (shape.style.font === void 0) {
            ;
            shape.style.font = "script";
          }
        });
      });
    }
    if (version2 <= 13) {
      Object.values(document2.pages).forEach((page) => {
        Object.values(page.bindings).forEach((binding) => {
          Object.assign(binding, binding.meta);
        });
        Object.values(page.shapes).forEach((shape) => {
          Object.entries(shape.style).forEach(([id, style2]) => {
            if (typeof style2 === "string") {
              shape.style[id] = style2.toLowerCase();
            }
          });
          if (shape.type === "arrow") {
            if (shape.decorations) {
              Object.entries(shape.decorations).forEach(([id, decoration]) => {
                if (decoration === "Arrow") {
                  shape.decorations = {
                    ...shape.decorations,
                    [id]: "arrow"
                    /* Arrow */
                  };
                }
              });
            }
          }
        });
      });
    }
    if (version2 <= 13.1 && document2.name == null) {
      document2.name = "New Document";
    }
    if (version2 < 15 && document2.assets == null) {
      document2.assets = {};
    }
    Object.values(document2.pages).forEach((page) => {
      Object.values(page.shapes).forEach((shape) => {
        if (version2 < 15.2) {
          if ((shape.type === "image" || shape.type === "video") && shape.style.isFilled == null) {
            shape.style.isFilled = true;
          }
        }
        if (version2 < 15.3) {
          if (shape.type === "rectangle" || shape.type === "triangle" || shape.type === "ellipse" || shape.type === "arrow") {
            if ("text" in shape && typeof shape.text === "string") {
              shape.label = shape.text;
            }
            if (!shape.label) {
              shape.label = "";
            }
            if (!shape.labelPoint) {
              shape.labelPoint = [0.5, 0.5];
            }
          }
        }
      });
    });
  }
  Object.values(document2.pageStates).forEach((pageState) => {
    pageState.selectedIds = pageState.selectedIds.filter((id) => {
      return document2.pages[pageState.id].shapes[id] !== void 0;
    });
    pageState.bindingId = void 0;
    pageState.editingId = void 0;
    pageState.hoveredId = void 0;
    pageState.pointedId = void 0;
  });
  document2.version = newVersion;
  return document2;
}
var TLV1ShapeType = ((TLV1ShapeType2) => {
  TLV1ShapeType2["Sticky"] = "sticky";
  TLV1ShapeType2["Ellipse"] = "ellipse";
  TLV1ShapeType2["Rectangle"] = "rectangle";
  TLV1ShapeType2["Triangle"] = "triangle";
  TLV1ShapeType2["Draw"] = "draw";
  TLV1ShapeType2["Arrow"] = "arrow";
  TLV1ShapeType2["Text"] = "text";
  TLV1ShapeType2["Group"] = "group";
  TLV1ShapeType2["Image"] = "image";
  TLV1ShapeType2["Video"] = "video";
  return TLV1ShapeType2;
})(TLV1ShapeType || {});
var TLV1ColorStyle = ((TLV1ColorStyle2) => {
  TLV1ColorStyle2["White"] = "white";
  TLV1ColorStyle2["LightGray"] = "lightGray";
  TLV1ColorStyle2["Gray"] = "gray";
  TLV1ColorStyle2["Black"] = "black";
  TLV1ColorStyle2["Green"] = "green";
  TLV1ColorStyle2["Cyan"] = "cyan";
  TLV1ColorStyle2["Blue"] = "blue";
  TLV1ColorStyle2["Indigo"] = "indigo";
  TLV1ColorStyle2["Violet"] = "violet";
  TLV1ColorStyle2["Red"] = "red";
  TLV1ColorStyle2["Orange"] = "orange";
  TLV1ColorStyle2["Yellow"] = "yellow";
  return TLV1ColorStyle2;
})(TLV1ColorStyle || {});
var TLV1SizeStyle = ((TLV1SizeStyle2) => {
  TLV1SizeStyle2["Small"] = "small";
  TLV1SizeStyle2["Medium"] = "medium";
  TLV1SizeStyle2["Large"] = "large";
  return TLV1SizeStyle2;
})(TLV1SizeStyle || {});
var TLV1DashStyle = ((TLV1DashStyle2) => {
  TLV1DashStyle2["Draw"] = "draw";
  TLV1DashStyle2["Solid"] = "solid";
  TLV1DashStyle2["Dashed"] = "dashed";
  TLV1DashStyle2["Dotted"] = "dotted";
  return TLV1DashStyle2;
})(TLV1DashStyle || {});
var TLV1AlignStyle = ((TLV1AlignStyle2) => {
  TLV1AlignStyle2["Start"] = "start";
  TLV1AlignStyle2["Middle"] = "middle";
  TLV1AlignStyle2["End"] = "end";
  TLV1AlignStyle2["Justify"] = "justify";
  return TLV1AlignStyle2;
})(TLV1AlignStyle || {});
var TLV1FontStyle = ((TLV1FontStyle2) => {
  TLV1FontStyle2["Script"] = "script";
  TLV1FontStyle2["Sans"] = "sans";
  TLV1FontStyle2["Serif"] = "serif";
  TLV1FontStyle2["Mono"] = "mono";
  return TLV1FontStyle2;
})(TLV1FontStyle || {});
var TLV1Decoration = ((TLV1Decoration2) => {
  TLV1Decoration2["Arrow"] = "arrow";
  return TLV1Decoration2;
})(TLV1Decoration || {});
var TLV1AssetType = ((TLV1AssetType2) => {
  TLV1AssetType2["Image"] = "image";
  TLV1AssetType2["Video"] = "video";
  return TLV1AssetType2;
})(TLV1AssetType || {});
var v1ColorsToV2Colors = {
  [
    "white"
    /* White */
  ]: "black",
  [
    "black"
    /* Black */
  ]: "black",
  [
    "lightGray"
    /* LightGray */
  ]: "grey",
  [
    "gray"
    /* Gray */
  ]: "grey",
  [
    "green"
    /* Green */
  ]: "light-green",
  [
    "cyan"
    /* Cyan */
  ]: "green",
  [
    "blue"
    /* Blue */
  ]: "light-blue",
  [
    "indigo"
    /* Indigo */
  ]: "blue",
  [
    "orange"
    /* Orange */
  ]: "orange",
  [
    "yellow"
    /* Yellow */
  ]: "yellow",
  [
    "red"
    /* Red */
  ]: "red",
  [
    "violet"
    /* Violet */
  ]: "light-violet"
};
var v1FontsToV2Fonts = {
  [
    "mono"
    /* Mono */
  ]: "mono",
  [
    "sans"
    /* Sans */
  ]: "sans",
  [
    "script"
    /* Script */
  ]: "draw",
  [
    "serif"
    /* Serif */
  ]: "serif"
};
var v1AlignsToV2Aligns = {
  [
    "start"
    /* Start */
  ]: "start",
  [
    "middle"
    /* Middle */
  ]: "middle",
  [
    "end"
    /* End */
  ]: "end",
  [
    "justify"
    /* Justify */
  ]: "start"
};
var v1TextAlignsToV2TextAligns = {
  [
    "start"
    /* Start */
  ]: "start",
  [
    "middle"
    /* Middle */
  ]: "middle",
  [
    "end"
    /* End */
  ]: "end",
  [
    "justify"
    /* Justify */
  ]: "start"
};
var v1TextSizesToV2TextSizes = {
  [
    "small"
    /* Small */
  ]: "s",
  [
    "medium"
    /* Medium */
  ]: "l",
  [
    "large"
    /* Large */
  ]: "xl"
};
var v1SizesToV2Sizes = {
  [
    "small"
    /* Small */
  ]: "m",
  [
    "medium"
    /* Medium */
  ]: "l",
  [
    "large"
    /* Large */
  ]: "xl"
};
var v1DashesToV2Dashes = {
  [
    "solid"
    /* Solid */
  ]: "solid",
  [
    "dashed"
    /* Dashed */
  ]: "dashed",
  [
    "dotted"
    /* Dotted */
  ]: "dotted",
  [
    "draw"
    /* Draw */
  ]: "draw"
};
function getV2Color(color) {
  return color ? v1ColorsToV2Colors[color] ?? "black" : "black";
}
function getV2Font(font) {
  return font ? v1FontsToV2Fonts[font] ?? "draw" : "draw";
}
function getV2Align(align) {
  return align ? v1AlignsToV2Aligns[align] ?? "middle" : "middle";
}
function getV2TextAlign(align) {
  return align ? v1TextAlignsToV2TextAligns[align] ?? "middle" : "middle";
}
function getV2TextSize(size4) {
  return size4 ? v1TextSizesToV2TextSizes[size4] ?? "m" : "m";
}
function getV2Size(size4) {
  return size4 ? v1SizesToV2Sizes[size4] ?? "l" : "l";
}
function getV2Dash(dash) {
  return dash ? v1DashesToV2Dashes[dash] ?? "draw" : "draw";
}
function getV2Point(point) {
  return {
    x: coerceNumber(point[0]),
    y: coerceNumber(point[1]),
    z: point[2] == null ? 0.5 : coerceNumber(point[2])
  };
}
function getV2Arrowhead(decoration) {
  return decoration === "arrow" ? "arrow" : "none";
}
function getV2Fill(isFilled, color) {
  return isFilled ? color === "black" || color === "white" ? "semi" : "solid" : "none";
}

// node_modules/tldraw/dist-esm/lib/utils/tldr/file.mjs
var TLDRAW_FILE_MIMETYPE = "application/vnd.tldraw+json";
var TLDRAW_FILE_EXTENSION = ".tldr";
var LATEST_TLDRAW_FILE_FORMAT_VERSION = 1;
var schemaV1 = validation_exports.object({
  schemaVersion: validation_exports.literal(1),
  storeVersion: validation_exports.positiveInteger,
  recordVersions: validation_exports.dict(
    validation_exports.string,
    validation_exports.object({
      version: validation_exports.positiveInteger,
      subTypeVersions: validation_exports.dict(validation_exports.string, validation_exports.positiveInteger).optional(),
      subTypeKey: validation_exports.string.optional()
    })
  )
});
var schemaV2 = validation_exports.object({
  schemaVersion: validation_exports.literal(2),
  sequences: validation_exports.dict(validation_exports.string, validation_exports.positiveInteger)
});
var tldrawFileValidator = validation_exports.object({
  tldrawFileFormatVersion: validation_exports.nonZeroInteger,
  schema: validation_exports.numberUnion("schemaVersion", {
    1: schemaV1,
    2: schemaV2
  }),
  records: validation_exports.arrayOf(
    validation_exports.object({
      id: validation_exports.string,
      typeName: validation_exports.string
    }).allowUnknownProperties()
  )
});
function isV1File(data) {
  var _a5;
  try {
    if ((_a5 = data.document) == null ? void 0 : _a5.version) {
      return true;
    }
    return false;
  } catch {
    return false;
  }
}
function parseTldrawJsonFile({
  json,
  schema
}) {
  let data;
  try {
    data = tldrawFileValidator.validate(JSON.parse(json));
  } catch (e) {
    try {
      data = JSON.parse(json);
      if (isV1File(data)) {
        return Result.err({ type: "v1File", data });
      }
    } catch {
    }
    return Result.err({ type: "notATldrawFile", cause: e });
  }
  if (data.tldrawFileFormatVersion > LATEST_TLDRAW_FILE_FORMAT_VERSION) {
    return Result.err({
      type: "fileFormatVersionTooNew",
      version: data.tldrawFileFormatVersion
    });
  }
  let migrationResult;
  let storeSnapshot;
  try {
    const records = pruneUnusedAssets(data.records);
    storeSnapshot = Object.fromEntries(records.map((r) => [r.id, r]));
    migrationResult = schema.migrateStoreSnapshot({ store: storeSnapshot, schema: data.schema });
  } catch (e) {
    return Result.err({ type: "invalidRecords", cause: e });
  }
  if (migrationResult.type === "error") {
    return Result.err({ type: "migrationFailed", reason: migrationResult.reason });
  }
  try {
    return Result.ok(
      createTLStore({
        snapshot: { store: storeSnapshot, schema: data.schema },
        schema
      })
    );
  } catch (e) {
    return Result.err({ type: "invalidRecords", cause: e });
  }
}
function pruneUnusedAssets(records) {
  const usedAssets = /* @__PURE__ */ new Set();
  for (const record of records) {
    if (record.typeName === "shape" && "assetId" in record.props && record.props.assetId) {
      usedAssets.add(record.props.assetId);
    }
  }
  return records.filter((r) => r.typeName !== "asset" || usedAssets.has(r.id));
}
async function serializeTldrawJson(editor) {
  const records = [];
  for (const record of editor.store.allRecords()) {
    switch (record.typeName) {
      case "asset":
        if (record.type !== "bookmark" && record.props.src && !record.props.src.startsWith("data:")) {
          let assetSrcToSave;
          try {
            let src = record.props.src;
            if (!src.startsWith("http")) {
              src = await editor.resolveAssetUrl(record.id, { shouldResolveToOriginal: true }) || "";
            }
            assetSrcToSave = await FileHelpers.blobToDataUrl(await (await fetch(src)).blob());
          } catch {
            assetSrcToSave = record.props.src;
          }
          records.push({
            ...record,
            props: {
              ...record.props,
              src: assetSrcToSave
            }
          });
        } else {
          records.push(record);
        }
        break;
      default:
        records.push(record);
        break;
    }
  }
  return JSON.stringify({
    tldrawFileFormatVersion: LATEST_TLDRAW_FILE_FORMAT_VERSION,
    schema: editor.store.schema.serialize(),
    records: pruneUnusedAssets(records)
  });
}
async function serializeTldrawJsonBlob(editor) {
  return new Blob([await serializeTldrawJson(editor)], { type: TLDRAW_FILE_MIMETYPE });
}
async function parseAndLoadDocument(editor, document2, msg2, addToast, onV1FileLoad, forceDarkMode) {
  const parseFileResult = parseTldrawJsonFile({
    schema: editor.store.schema,
    json: document2
  });
  if (!parseFileResult.ok) {
    let description;
    switch (parseFileResult.error.type) {
      case "notATldrawFile":
        editor.annotateError(parseFileResult.error.cause, {
          origin: "file-system.open.parse",
          willCrashApp: false,
          tags: { parseErrorType: parseFileResult.error.type }
        });
        reportError(parseFileResult.error.cause);
        description = msg2("file-system.file-open-error.not-a-tldraw-file");
        break;
      case "fileFormatVersionTooNew":
        description = msg2("file-system.file-open-error.file-format-version-too-new");
        break;
      case "migrationFailed":
        if (parseFileResult.error.reason === MigrationFailureReason.TargetVersionTooNew) {
          description = msg2("file-system.file-open-error.file-format-version-too-new");
        } else {
          description = msg2("file-system.file-open-error.generic-corrupted-file");
        }
        break;
      case "invalidRecords":
        editor.annotateError(parseFileResult.error.cause, {
          origin: "file-system.open.parse",
          willCrashApp: false,
          tags: { parseErrorType: parseFileResult.error.type }
        });
        reportError(parseFileResult.error.cause);
        description = msg2("file-system.file-open-error.generic-corrupted-file");
        break;
      case "v1File": {
        buildFromV1Document(editor, parseFileResult.error.data.document);
        onV1FileLoad == null ? void 0 : onV1FileLoad();
        return;
      }
      default:
        exhaustiveSwitchError(parseFileResult.error, "type");
    }
    addToast({
      title: msg2("file-system.file-open-error.title"),
      description,
      severity: "error"
    });
    return;
  }
  transact(() => {
    const snapshot = parseFileResult.value.getStoreSnapshot();
    editor.loadSnapshot(snapshot);
    editor.clearHistory();
    extractAssets(editor, snapshot, msg2, addToast);
    const bounds = editor.getCurrentPageBounds();
    if (bounds) {
      editor.zoomToBounds(bounds, { targetZoom: 1, immediate: true });
    }
  });
  if (forceDarkMode)
    editor.user.updateUserPreferences({ colorScheme: "dark" });
}
async function extractAssets(editor, snapshot, msg2, addToast) {
  const mediaAssets = /* @__PURE__ */ new Map();
  for (const record of Object.values(snapshot.store)) {
    if (record.typeName === "asset" && record.props.src && record.props.src.startsWith("data:") && (record.type === "image" || record.type === "video")) {
      mediaAssets.set(record.id, record);
    }
  }
  Promise.allSettled(
    [...mediaAssets].map(async ([id, asset]) => {
      try {
        const blob = await fetch(asset.props.src).then((r) => r.blob());
        const file = new File([blob], asset.props.name, {
          type: asset.props.mimeType
        });
        const newAsset = await editor.getAssetForExternalContent({
          type: "file",
          file
        });
        if (!newAsset) {
          throw Error("Could not create an asset");
        }
        editor.updateAssets([{ ...newAsset, id }]);
      } catch (error) {
        addToast({
          title: msg2("assets.files.upload-failed"),
          severity: "error"
        });
        console.error(error);
        return;
      }
    })
  );
}

// node_modules/tldraw/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "tldraw",
  "3.13.1",
  "esm"
);

export {
  registerTldrawLibraryVersion,
  omitFromStackTrace,
  noop,
  Result,
  exhaustiveSwitchError,
  assert,
  assertExists,
  promiseWithResolve,
  sleep,
  ExecutionQueue,
  measureCbDuration,
  measureDuration,
  measureAverageDuration,
  PerformanceTracker,
  rotateArray,
  dedupe,
  compact,
  last,
  minBy,
  maxBy,
  partition,
  areArraysShallowEqual,
  mergeArraysAndReplaceDefaults,
  bind,
  WeakCache,
  debounce,
  annotateError,
  getErrorAnnotations,
  fetch,
  Image,
  FileHelpers,
  getHashForString,
  getHashForObject,
  getHashForBuffer,
  lns,
  mockUniqueId,
  restoreUniqueId,
  uniqueId,
  getFirstFromIterable,
  PngHelpers,
  DEFAULT_SUPPORTED_IMAGE_TYPES,
  DEFAULT_SUPPORT_VIDEO_TYPES,
  DEFAULT_SUPPORTED_MEDIA_TYPES,
  DEFAULT_SUPPORTED_MEDIA_TYPE_LIST,
  MediaHelpers,
  lerp,
  invLerp,
  rng,
  modulate,
  hasOwnProperty,
  getOwnProperty,
  objectMapKeys,
  objectMapValues,
  objectMapEntries,
  objectMapFromEntries,
  filterEntries,
  mapObjectMapValues,
  areObjectsShallowEqual,
  groupBy,
  omit,
  ZERO_INDEX_KEY,
  validateIndexKey,
  getIndicesBetween,
  getIndicesAbove,
  getIndicesBelow,
  getIndexBetween,
  getIndexAbove,
  getIndexBelow,
  getIndices,
  sortByIndex,
  retry,
  sortById,
  getFromLocalStorage,
  setInLocalStorage,
  deleteFromLocalStorage,
  clearLocalStorage,
  getFromSessionStorage,
  setInSessionStorage,
  deleteFromSessionStorage,
  clearSessionStorage,
  stringEnum,
  fpsThrottle,
  throttleToNextFrame,
  Timers,
  safeParseUrl,
  isDefined,
  isNonNull,
  isNonNullish,
  structuredClone,
  isNativeStructuredClone,
  STRUCTURED_CLONE_OBJECT_PROTOTYPE,
  warnDeprecatedGetter,
  warnOnce,
  import_lodash,
  EMPTY_ARRAY,
  ArraySet,
  RESET_VALUE,
  EffectScheduler,
  react,
  reactor,
  transaction,
  transact,
  UNINITIALIZED,
  isUninitialized,
  withDiff,
  getComputedInstance,
  computed,
  unsafe__withoutCapture,
  whyAmIRunning,
  atom,
  isAtom,
  isSignal,
  useStateTracking,
  track,
  useAtom,
  useComputed,
  useQuickReactor,
  useReactor,
  useValue,
  AtomMap,
  IncrementalSetConstructor,
  RecordType,
  createRecordType,
  assertIdType,
  createEmptyRecordsDiff,
  reverseRecordsDiff,
  isRecordsDiffEmpty,
  squashRecordDiffs,
  squashRecordDiffsMutable,
  require_lodash3 as require_lodash,
  StoreQueries,
  StoreSideEffects,
  devFreeze,
  Store,
  createComputedCache,
  defineMigrations,
  createMigrationSequence,
  createMigrationIds,
  createRecordMigrationSequence,
  parseMigrationId,
  MigrationFailureReason,
  StoreSchema,
  Validator,
  ArrayOfValidator,
  ObjectValidator,
  UnionValidator,
  DictValidator,
  validation_exports,
  idValidator,
  assetIdValidator,
  createAssetValidator,
  vecModelValidator,
  boxModelValidator,
  opacityValidator,
  parentIdValidator,
  shapeIdValidator,
  createShapeValidator,
  bindingIdValidator,
  createBindingValidator,
  rootBindingMigrations,
  isBinding,
  isBindingId,
  createBindingId,
  createBindingPropsMigrationSequence,
  createBindingPropsMigrationIds,
  StyleProp,
  EnumStyleProp,
  rootShapeMigrations,
  isShape,
  isShapeId,
  createShapeId,
  getShapePropKeysByStyle,
  createShapePropsMigrationSequence,
  createShapePropsMigrationIds,
  defaultColorNames,
  DefaultColorThemePalette,
  getDefaultColorTheme,
  DefaultColorStyle,
  DefaultDashStyle,
  DefaultFillStyle,
  DefaultFontStyle,
  DefaultFontFamilies,
  DefaultSizeStyle,
  ArrowShapeKindStyle,
  ArrowShapeArrowheadStartStyle,
  ArrowShapeArrowheadEndStyle,
  arrowShapeProps,
  arrowShapeVersions,
  arrowShapeMigrations,
  ElbowArrowSnap,
  arrowBindingProps,
  arrowBindingVersions,
  arrowBindingMigrations,
  CameraRecordType,
  TL_CURSOR_TYPES,
  TL_CANVAS_UI_COLOR_TYPES,
  canvasUiColorTypeValidator,
  TL_SCRIBBLE_STATES,
  scribbleValidator,
  pageIdValidator,
  PageRecordType,
  isPageId,
  pluckPreservingValues,
  TLINSTANCE_ID,
  InstancePageStateRecordType,
  PointerRecordType,
  TLPOINTER_ID,
  InstancePresenceRecordType,
  createPresenceStateDerivation,
  getDefaultUserPresence,
  isDocument,
  DocumentRecordType,
  TLDOCUMENT_ID,
  assetValidator,
  assetMigrations,
  AssetRecordType,
  bookmarkShapeProps,
  bookmarkShapeMigrations,
  drawShapeProps,
  drawShapeMigrations,
  embedShapeProps,
  embedShapeMigrations,
  frameShapeProps,
  frameShapeMigrations,
  richTextValidator,
  toRichText,
  DefaultHorizontalAlignStyle,
  DefaultVerticalAlignStyle,
  GeoShapeGeoStyle,
  geoShapeProps,
  geoShapeMigrations,
  groupShapeProps,
  groupShapeMigrations,
  highlightShapeProps,
  highlightShapeMigrations,
  ImageShapeCrop,
  imageShapeProps,
  imageShapeMigrations,
  LineShapeSplineStyle,
  lineShapeProps,
  lineShapeMigrations,
  noteShapeProps,
  noteShapeMigrations,
  DefaultTextAlignStyle,
  textShapeProps,
  textShapeMigrations,
  videoShapeProps,
  videoShapeMigrations,
  defaultShapeSchemas,
  defaultBindingSchemas,
  createTLSchema,
  TL_HANDLE_TYPES,
  LANGUAGES,
  getDefaultTranslationLocale,
  ErrorBoundary,
  OptionalErrorBoundary,
  suffixSafeId,
  useUniqueSafeId,
  useSharedSafeId,
  sanitizeId,
  EditorContext,
  useEditor,
  useMaybeEditor,
  DefaultBackground,
  useTransform,
  EASINGS,
  Vec,
  precise,
  average,
  PI,
  HALF_PI,
  PI2,
  SIN,
  clamp,
  toPrecision,
  approximately,
  perimeterOfEllipse,
  canonicalizeRotation,
  clockwiseAngleDist,
  counterClockwiseAngleDist,
  shortAngleDist,
  clampRadians,
  snapAngle,
  areAnglesCompatible,
  degreesToRadians,
  radiansToDegrees,
  getPointOnCircle,
  getPolygonVertices,
  rangeIntersection,
  pointInPolygon,
  toDomPrecision,
  toFixed,
  isSafeFloat,
  angleDistance,
  getPointInArcT,
  getArcMeasure,
  centerOfCircleFromThreePoints,
  getPointsOnArc,
  DefaultBrush,
  tlenv,
  DEFAULT_CAMERA_OPTIONS,
  DEFAULT_ANIMATION_OPTIONS,
  SIDES,
  featureFlags,
  debugFlags,
  loopToHtmlElement,
  preventDefault,
  setPointerCapture,
  releasePointerCapture,
  stopEventPropagation,
  activeElementShouldCaptureKeys,
  isAccelKey,
  getPointerInfo,
  ContainerProvider,
  useContainer,
  useContainerIfExists,
  normalizeWheel,
  Box,
  rotateSelectionHandle,
  ROTATE_CORNER_TO_SELECTION_CORNER,
  Mat,
  intersectLineSegmentLineSegment,
  intersectLineSegmentCircle,
  intersectLineSegmentPolyline,
  intersectLineSegmentPolygon,
  intersectCircleCircle,
  intersectCirclePolygon,
  intersectCirclePolyline,
  intersectPolygonBounds,
  linesIntersect,
  intersectPolygonPolygon,
  polygonsIntersect,
  polygonIntersectsPolyline,
  Geometry2dFilters,
  Geometry2d,
  TransformedGeometry2d,
  Group2d,
  uniq,
  usePeerIds,
  usePresence,
  MenuClickCapture,
  DefaultCanvas,
  DefaultCollaboratorHint,
  DefaultCursor,
  DefaultGrid,
  DefaultHandle,
  DefaultHandles,
  getSvgPathFromPoints,
  DefaultScribble,
  DefaultSelectionForeground,
  DefaultShapeIndicator,
  DefaultShapeIndicators,
  DefaultSnapIndicator,
  DefaultSpinner,
  DefaultSvgDefs,
  useShallowArrayIdentity,
  useShallowObjectIdentity,
  useEditorComponents,
  runtime,
  setRuntimeOverrides,
  hardResetEditor,
  refreshPage,
  DefaultErrorFallback,
  userTypeValidator,
  USER_COLORS,
  defaultUserPreferences,
  getFreshUserPreferences,
  setUserPreferences,
  getUserPreferences,
  createTLUser,
  useTldrawUser,
  TAB_ID,
  createSessionStateSnapshotSignal,
  loadSessionStateSnapshotIntoStore,
  extractSessionStateFromLegacySnapshot,
  loadSnapshot,
  getSnapshot,
  SVGContainer,
  Edge2d,
  Polyline2d,
  Polygon2d,
  Rectangle2d,
  ShapeUtil,
  getPerfectDashProps,
  GroupShapeUtil,
  coreShapes,
  useEvent,
  useReactiveEvent,
  useSvgExportContext,
  useDelaySvgExport,
  clampToBrowserMaxCanvasSize,
  getSvgAsImage,
  tlmenus,
  tltime,
  defaultTldrawOptions,
  ReadonlySharedStyleMap,
  SharedStyleMap,
  dataUrlToFile,
  getDefaultCdnBaseUrl,
  createDeepLinkString,
  parseDeepLinkString,
  getIncrementedName,
  getRotationSnapshot,
  applyRotationToSnapshotShapes,
  ClickManager,
  EdgeScrollManager,
  FontManager,
  HistoryManager,
  ScribbleManager,
  BoundsSnaps,
  HandleSnaps,
  SnapManager,
  TextManager,
  UserPreferencesManager,
  EVENT_NAME_MAP,
  StateNode,
  Editor,
  useIsDarkMode,
  getCursor,
  inlineBase64AssetStore,
  createTLSchemaFromUtils,
  createTLStore,
  Table,
  LocalIndexedDb,
  useRefState,
  useLocalStore,
  LicenseManager,
  usePassThroughWheelEvents,
  TldrawEditor,
  LoadingScreen,
  ErrorScreen,
  useOnMount,
  HTMLContainer,
  DefaultSelectionBackground,
  BindingUtil,
  resizeBox,
  BaseBoxShapeUtil,
  resizeScaled,
  maybeSnapToGrid,
  BaseBoxShapeTool,
  useGlobalMenuIsOpen,
  useIsCropping,
  useIsEditing,
  usePassThroughMouseOverEvents,
  useSelectionEvents,
  useTLStore,
  useTLSchemaFromUtils,
  useViewportHeight,
  Arc2d,
  Circle2d,
  CubicBezier2d,
  CubicSpline2d,
  Ellipse2d,
  Point2d,
  Stadium2d,
  getFontsFromRichText,
  hardReset,
  openWindow,
  debugEnableLicensing,
  usePrefersReducedMotion,
  TldrawUiA11yProvider,
  useA11y,
  AssetUrlsProvider,
  useAssetUrls,
  useCurrentTranslation,
  TldrawUiTranslationProvider,
  useTranslation,
  TldrawUiButton,
  DefaultA11yAnnouncer,
  useSelectedShapesAnnouncer,
  TldrawUiEventsProvider,
  useUiEvents,
  kickoutOccludedShapes,
  getOccludedChildren,
  removeFrame,
  fitFrameToContent,
  TldrawUiButtonLabel,
  TldrawUiIcon,
  TldrawUiButtonIcon,
  TldrawUiDialogHeader,
  TldrawUiDialogTitle,
  TldrawUiDialogCloseButton,
  TldrawUiDialogBody,
  TldrawUiDialogFooter,
  TldrawUiInput,
  DEFAULT_EMBED_DEFINITIONS,
  embedShapePermissionDefaults,
  useShowCollaborationUi,
  useCollaborationStatus,
  PORTRAIT_BREAKPOINT,
  BreakPointProvider,
  useBreakpoint,
  TldrawUiDialogsProvider,
  useDialogs,
  TldrawUiToastsProvider,
  useToasts,
  useMenuClipboardEvents,
  useNativeClipboardEvents,
  exportToBlob,
  copyAs,
  useCopyAs,
  exportAs,
  downloadFile,
  useExportAs,
  useDefaultHelpers,
  useActions,
  unwrapLabel,
  useReadonly,
  TldrawUiKbd,
  TldrawUiMenuContextProvider,
  TldrawUiMenuCheckboxItem,
  useMenuIsOpen,
  TldrawUiDropdownMenuRoot,
  TldrawUiDropdownMenuTrigger,
  TldrawUiDropdownMenuContent,
  TldrawUiDropdownMenuSub,
  TldrawUiDropdownMenuSubTrigger,
  TldrawUiDropdownMenuGroup,
  TldrawUiDropdownMenuIndicator,
  TldrawUiDropdownMenuItem,
  TldrawUiDropdownMenuCheckboxItem,
  TldrawUiMenuGroup,
  TldrawUiMenuSubmenu,
  ColorSchemeMenu,
  DefaultDialogs,
  DefaultToasts,
  TldrawUiMenuActionCheckboxItem,
  Spinner,
  TldrawUiToolbar,
  TldrawUiToolbarButton,
  TldrawUiToolbarToggleGroup,
  TldrawUiToolbarToggleItem,
  TldrawUiMenuItem,
  TldrawUiMenuActionItem,
  useTools,
  TldrawUiMenuToolItem,
  TldrawHandles,
  TldrawOverlays,
  TldrawArrowHints,
  TldrawScribble,
  TldrawSelectionForeground,
  TldrawShapeIndicators,
  getArrowBindings,
  getArrowInfo,
  getArrowTerminalsInArrowSpace,
  ArrowBindingUtil,
  defaultBindingUtils,
  TEXT_PROPS,
  STROKE_SIZES2 as STROKE_SIZES,
  FONT_SIZES,
  LABEL_FONT_SIZES,
  ARROW_LABEL_FONT_SIZES,
  FONT_FAMILIES,
  containBoxSize,
  downsizeImage,
  putExcalidrawContent,
  DefaultFontFaces,
  allDefaultFontFaces,
  TextDirection,
  KeyboardShiftEnterTweakExtension,
  tipTapDefaultExtensions,
  renderHtmlFromRichText,
  renderHtmlFromRichTextForMeasurement,
  renderPlaintextFromRichText,
  renderRichTextFromHTML,
  defaultAddFontsFromNode,
  truncateStringWithEllipsis,
  DEFAULT_MAX_IMAGE_DIMENSION,
  DEFAULT_MAX_ASSET_SIZE,
  registerDefaultExternalContentHandlers,
  defaultHandleExternalFileAsset,
  defaultHandleExternalUrlAsset,
  defaultHandleExternalSvgTextContent,
  defaultHandleExternalEmbedContent,
  defaultHandleExternalFileContent,
  defaultHandleExternalTextContent,
  defaultHandleExternalUrlContent,
  defaultHandleExternalTldrawContent,
  defaultHandleExternalExcalidrawContent,
  getMediaAssetInfoPartial,
  createShapesForAssets,
  centerSelectionAroundPoint,
  createEmptyBookmarkShape,
  ArrowShapeTool,
  DrawShapeTool,
  FrameShapeTool,
  GeoShapeTool,
  HighlightShapeTool,
  LineShapeTool,
  NoteShapeTool,
  TextShapeTool,
  defaultShapeTools,
  PlainTextArea,
  useEditablePlainText,
  useEditableText,
  PlainTextLabel,
  TextLabel,
  useDefaultColorTheme,
  ArrowShapeUtil,
  BookmarkShapeUtil,
  DrawShapeUtil,
  getEmbedInfo,
  EmbedShapeUtil,
  FrameShapeUtil,
  RichTextArea,
  useEditableRichText,
  RichTextLabel,
  RichTextSVG,
  GeoShapeUtil,
  HighlightShapeUtil,
  getDefaultCrop,
  getUncroppedSize,
  getCropBox,
  useImageOrVideoAsset,
  useAsset,
  ImageShapeUtil,
  LineShapeUtil,
  NoteShapeUtil,
  TextShapeUtil,
  VideoShapeUtil,
  defaultShapeUtils,
  registerDefaultSideEffects,
  EraserTool,
  HandTool,
  LaserTool,
  SelectTool,
  ZoomTool,
  defaultTools,
  defaultEditorAssetUrls,
  setDefaultEditorAssetUrls,
  setDefaultUiAssetUrls,
  TldrawUiPopover,
  TldrawUiPopoverTrigger,
  TldrawUiPopoverContent,
  useCanRedo,
  useCanUndo,
  DefaultActionsMenuContent,
  AlignMenuItems,
  DistributeMenuItems,
  StackMenuItems,
  ReorderMenuItems,
  ZoomOrRotateMenuItem,
  RotateCWMenuItem,
  GroupOrUngroupMenuItem,
  DefaultActionsMenu,
  ToggleAutoSizeMenuItem,
  EditLinkMenuItem2 as EditLinkMenuItem,
  DuplicateMenuItem,
  GroupMenuItem2 as GroupMenuItem,
  UngroupMenuItem2 as UngroupMenuItem,
  RemoveFrameMenuItem,
  FitFrameToContentMenuItem,
  ToggleLockMenuItem,
  ToggleTransparentBgMenuItem,
  UnlockAllMenuItem,
  ZoomTo100MenuItem2 as ZoomTo100MenuItem,
  ZoomToFitMenuItem,
  ZoomToSelectionMenuItem,
  ClipboardMenuGroup,
  CopyAsMenuGroup,
  CutMenuItem,
  CopyMenuItem,
  PasteMenuItem,
  ConversionsMenuGroup,
  SelectAllMenuItem,
  DeleteMenuItem,
  EditMenuSubmenu,
  ArrangeMenuSubmenu,
  ReorderMenuSubmenu,
  MoveToPageMenu,
  ConvertToBookmarkMenuItem,
  ConvertToEmbedMenuItem,
  ToggleSnapModeItem,
  ToggleToolLockItem,
  ToggleGridItem,
  ToggleWrapModeItem,
  ToggleFocusModeItem,
  ToggleEdgeScrollingItem,
  ToggleReduceMotionItem,
  ToggleDebugModeItem,
  ToggleDynamicSizeModeItem,
  TogglePasteAtCursorItem,
  PrintItem,
  CursorChatItem,
  DefaultContextMenuContent,
  DefaultContextMenu,
  TldrawUiButtonCheck,
  DefaultDebugMenuContent,
  DebugFlags,
  FeatureFlags,
  ExampleDialog,
  DefaultDebugMenu,
  DefaultMenuPanel,
  DefaultHelperButtonsContent,
  DefaultHelperButtons,
  DefaultKeyboardShortcutsDialogContent,
  DefaultKeyboardShortcutsDialog,
  LanguageMenu,
  DefaultHelpMenuContent,
  KeyboardShortcutsMenuItem,
  DefaultMainMenuContent,
  ExportFileContentSubMenu,
  EditSubmenu,
  MiscMenuGroup,
  UndoRedoGroup,
  ViewSubmenu,
  ExtrasGroup,
  PreferencesGroup,
  DefaultMainMenu,
  DefaultMinimap,
  useLocalStorageState,
  DefaultNavigationPanel,
  PageItemInput,
  PageItemSubmenu,
  DefaultPageMenu,
  DefaultQuickActionsContent,
  DefaultQuickActions,
  PeopleMenu,
  DefaultSharePanel,
  useRelevantStyles,
  TldrawUiButtonPicker,
  TldrawUiSlider,
  DefaultStylePanelContent,
  CommonStylePickerSet,
  TextStylePickerSet,
  GeoStylePickerSet,
  SplineStylePickerSet,
  ArrowheadStylePickerSet,
  OpacitySlider,
  DefaultStylePanel,
  TldrawUiContextualToolbar,
  DefaultRichTextToolbarContent,
  DefaultRichTextToolbar,
  MobileStylePanel,
  DefaultToolbarContent,
  useIsToolSelected,
  ToolbarItem,
  SelectToolbarItem,
  HandToolbarItem,
  DrawToolbarItem,
  EraserToolbarItem,
  ArrowToolbarItem,
  TextToolbarItem,
  NoteToolbarItem,
  AssetToolbarItem,
  RectangleToolbarItem,
  EllipseToolbarItem,
  DiamondToolbarItem,
  TriangleToolbarItem,
  TrapezoidToolbarItem,
  RhombusToolbarItem,
  HexagonToolbarItem,
  CloudToolbarItem,
  StarToolbarItem,
  OvalToolbarItem,
  XBoxToolbarItem,
  CheckBoxToolbarItem,
  ArrowLeftToolbarItem,
  ArrowUpToolbarItem,
  ArrowDownToolbarItem,
  ArrowRightToolbarItem,
  LineToolbarItem,
  HighlightToolbarItem,
  FrameToolbarItem,
  LaserToolbarItem,
  useKeyboardShortcuts,
  OverflowingToolbar,
  DefaultToolbar,
  OfflineIndicator,
  CenteredTopPanelContainer,
  DefaultTopPanel,
  DefaultZoomMenuContent,
  DefaultZoomMenu,
  TldrawUiComponentsProvider,
  useTldrawUiComponents,
  TldrawUiContextProvider,
  TldrawUi,
  Tldraw,
  TldrawImage,
  DefaultHelpMenu,
  preloadFont,
  buildFromV1Document,
  TLV1ShapeType,
  TLV1ColorStyle,
  TLV1SizeStyle,
  TLV1DashStyle,
  TLV1AlignStyle,
  TLV1FontStyle,
  TLV1Decoration,
  TLV1AssetType,
  TLDRAW_FILE_EXTENSION,
  parseTldrawJsonFile,
  serializeTldrawJson,
  serializeTldrawJsonBlob,
  parseAndLoadDocument
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tldraw/utils/dist-esm/lib/bind.mjs:
  (*!
   * MIT License: https://github.com/NoHomey/bind-decorator/blob/master/License
   * Copyright (c) 2016 Ivo Stratev
   *)

@tldraw/utils/dist-esm/lib/id.mjs:
  (*!
   * MIT License: https://github.com/ai/nanoid/blob/main/LICENSE
   * Modified code originally from <https://github.com/ai/nanoid>
   * Copyright 2017 Andrey Sitnik <andrey@sitnik.ru>
   *
   * `nanoid` is currently only distributed as an ES module. Some tools (jest, playwright) don't
   * properly support ESM-only code yet, and tldraw itself is distributed as both an ES module and a
   * CommonJS module. By including nanoid here, we can make sure it works well in every environment
   * where tldraw is used. We can also remove some unused features like custom alphabets.
   *)

@tldraw/utils/dist-esm/lib/media/apng.mjs:
  (*!
   * MIT License: https://github.com/vHeemstra/is-apng/blob/main/license
   * Copyright (c) Philip van Heemstra
   *)

@tldraw/utils/dist-esm/lib/media/gif.mjs:
  (*!
   * MIT License
   * Modified code originally from <https://github.com/qzb/is-animated>
   * Copyright (c) 2016 Józef Sokołowski <j.k.sokolowski@gmail.com>
   *)

@tldraw/utils/dist-esm/lib/media/png.mjs:
  (*!
   * MIT License: https://github.com/alexgorbatchev/crc/blob/master/LICENSE
   * Copyright: 2014 Alex Gorbatchev
   * Code: crc32, https://github.com/alexgorbatchev/crc/blob/master/src/calculators/crc32.ts
   *)

@tldraw/utils/dist-esm/lib/media/webp.mjs:
  (*!
   * MIT License: https://github.com/sindresorhus/is-webp/blob/main/license
   * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
   *)

@tldraw/store/dist-esm/lib/ImmutableMap.mjs:
  (*!
   * This file was lovingly and delicately extracted from Immutable.js
   * MIT License: https://github.com/immutable-js/immutable-js/blob/main/LICENSE
   * Copyright (c) 2014-present, Lee Byron and other contributors.
   *)

@tldraw/editor/dist-esm/lib/hooks/useScreenBounds.mjs:
  (*!
   * Author: excalidraw
   * MIT License: https://github.com/excalidraw/excalidraw/blob/master/LICENSE
   * https://github.com/excalidraw/excalidraw/blob/48c3465b19f10ec755b3eb84e21a01a468e96e43/packages/excalidraw/utils.ts#L600
   *)

@tldraw/editor/dist-esm/lib/utils/browserCanvasMaxSize.mjs:
  (*!
   * Extracted from https://github.com/jhildenbiddle/canvas-size
   * MIT License: https://github.com/jhildenbiddle/canvas-size/blob/master/LICENSE
   * Copyright (c) John Hildenbiddle
   *)

@tldraw/editor/dist-esm/lib/hooks/useViewportHeight.mjs:
  (*!
   * BSD License: https://github.com/outline/rich-markdown-editor/blob/main/LICENSE
   * Copyright (c) 2020 General Outline, Inc (https://www.getoutline.com/) and individual contributors.
   *
   * Returns the height of the viewport.
   * This is mainly to account for virtual keyboards on mobile devices.
   *
   * N.B. On iOS, you have to take into account the offsetTop as well so that you get an accurate position
   * while using the virtual keyboard.
   *)

tldraw/dist-esm/lib/shapes/shared/PathBuilder.mjs:
  (*!
   * Adapted from https://github.com/rveciana/svg-path-properties
   * MIT License: https://github.com/rveciana/svg-path-properties/blob/master/LICENSE
   * https://github.com/rveciana/svg-path-properties/blob/74d850d14998274f6eae279424bdc2194f156490/src/arc.ts#L121
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-BBAGFWLJ.js.map
