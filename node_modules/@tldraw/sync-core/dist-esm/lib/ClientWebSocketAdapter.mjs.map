{
  "version": 3,
  "sources": ["../../src/lib/ClientWebSocketAdapter.ts"],
  "sourcesContent": ["import { atom, Atom } from '@tldraw/state'\nimport { TLRecord } from '@tldraw/tlschema'\nimport { assert, warnOnce } from '@tldraw/utils'\nimport { chunk } from './chunk'\nimport { TLSocketClientSentEvent, TLSocketServerSentEvent } from './protocol'\nimport {\n\tTLPersistentClientSocket,\n\tTLPersistentClientSocketStatus,\n\tTLSocketStatusListener,\n\tTLSyncErrorCloseEventCode,\n\tTLSyncErrorCloseEventReason,\n} from './TLSyncClient'\n\nfunction listenTo<T extends EventTarget>(target: T, event: string, handler: () => void) {\n\ttarget.addEventListener(event, handler)\n\treturn () => {\n\t\ttarget.removeEventListener(event, handler)\n\t}\n}\n\nfunction debug(...args: any[]) {\n\t// @ts-ignore\n\tif (typeof window !== 'undefined' && window.__tldraw_socket_debug) {\n\t\tconst now = new Date()\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log(\n\t\t\t`${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}.${now.getMilliseconds()}`,\n\t\t\t...args\n\t\t\t//, new Error().stack\n\t\t)\n\t}\n}\n\n// NOTE: ClientWebSocketAdapter requires its users to implement their own connection loss\n//       detection, for example by regularly pinging the server and .restart()ing\n//       the connection when a number of pings goes unanswered. Without this mechanism,\n//       we might not be able to detect the websocket connection going down in a timely manner\n//       (it will probably time out on outgoing data packets at some point).\n//\n//       This is by design. While the Websocket protocol specifies protocol-level pings,\n//       they don't seem to be surfaced in browser APIs and can't be relied on. Therefore,\n//       pings need to be implemented one level up, on the application API side, which for our\n//       codebase means whatever code that uses ClientWebSocketAdapter.\n/** @internal */\nexport class ClientWebSocketAdapter implements TLPersistentClientSocket<TLRecord> {\n\t_ws: WebSocket | null = null\n\n\tisDisposed = false\n\n\t/** @internal */\n\treadonly _reconnectManager: ReconnectManager\n\n\t// TODO: .close should be a project-wide interface with a common contract (.close()d thing\n\t//       can only be garbage collected, and can't be used anymore)\n\tclose() {\n\t\tthis.isDisposed = true\n\t\tthis._reconnectManager.close()\n\t\t//  WebSocket.close() is idempotent\n\t\tthis._ws?.close()\n\t}\n\n\tconstructor(getUri: () => Promise<string> | string) {\n\t\tthis._reconnectManager = new ReconnectManager(this, getUri)\n\t}\n\n\tprivate _handleConnect() {\n\t\tdebug('handleConnect')\n\n\t\tthis._connectionStatus.set('online')\n\t\tthis.statusListeners.forEach((cb) => cb({ status: 'online' }))\n\n\t\tthis._reconnectManager.connected()\n\t}\n\n\tprivate _handleDisconnect(\n\t\treason: 'closed' | 'manual',\n\t\tcloseCode?: number,\n\t\tdidOpen?: boolean,\n\t\tcloseReason?: string\n\t) {\n\t\tcloseReason = closeReason || TLSyncErrorCloseEventReason.UNKNOWN_ERROR\n\n\t\tdebug('handleDisconnect', {\n\t\t\tcurrentStatus: this.connectionStatus,\n\t\t\tcloseCode,\n\t\t\treason,\n\t\t})\n\n\t\tlet newStatus: 'offline' | 'error'\n\t\tswitch (reason) {\n\t\t\tcase 'closed':\n\t\t\t\tif (closeCode === TLSyncErrorCloseEventCode) {\n\t\t\t\t\tnewStatus = 'error'\n\t\t\t\t} else {\n\t\t\t\t\tnewStatus = 'offline'\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase 'manual':\n\t\t\t\tnewStatus = 'offline'\n\t\t\t\tbreak\n\t\t}\n\n\t\tif (closeCode === 1006 && !didOpen) {\n\t\t\twarnOnce(\n\t\t\t\t\"Could not open WebSocket connection. This might be because you're trying to load a URL that doesn't support websockets. Check the URL you're trying to connect to.\"\n\t\t\t)\n\t\t}\n\n\t\tif (\n\t\t\t// it the status changed\n\t\t\tthis.connectionStatus !== newStatus &&\n\t\t\t// ignore errors if we're already in the offline state\n\t\t\t!(newStatus === 'error' && this.connectionStatus === 'offline')\n\t\t) {\n\t\t\tthis._connectionStatus.set(newStatus)\n\t\t\tthis.statusListeners.forEach((cb) =>\n\t\t\t\tcb(newStatus === 'error' ? { status: 'error', reason: closeReason } : { status: newStatus })\n\t\t\t)\n\t\t}\n\n\t\tthis._reconnectManager.disconnected()\n\t}\n\n\t_setNewSocket(ws: WebSocket) {\n\t\tassert(!this.isDisposed, 'Tried to set a new websocket on a disposed socket')\n\t\tassert(\n\t\t\tthis._ws === null ||\n\t\t\t\tthis._ws.readyState === WebSocket.CLOSED ||\n\t\t\t\tthis._ws.readyState === WebSocket.CLOSING,\n\t\t\t`Tried to set a new websocket in when the existing one was ${this._ws?.readyState}`\n\t\t)\n\n\t\tlet didOpen = false\n\n\t\t// NOTE: Sockets can stay for quite a while in the CLOSING state. This is because the transition\n\t\t//       between CLOSING and CLOSED happens either after the closing handshake, or after a\n\t\t//       timeout, but in either case those sockets don't need any special handling, the browser\n\t\t//       will close them eventually. We just \"orphan\" such sockets and ignore their onclose/onerror.\n\t\tws.onopen = () => {\n\t\t\tdebug('ws.onopen')\n\t\t\tassert(\n\t\t\t\tthis._ws === ws,\n\t\t\t\t\"sockets must only be orphaned when they are CLOSING or CLOSED, so they can't open\"\n\t\t\t)\n\t\t\tdidOpen = true\n\t\t\tthis._handleConnect()\n\t\t}\n\t\tws.onclose = (event: CloseEvent) => {\n\t\t\tdebug('ws.onclose', event)\n\t\t\tif (this._ws === ws) {\n\t\t\t\tthis._handleDisconnect('closed', event.code, didOpen, event.reason)\n\t\t\t} else {\n\t\t\t\tdebug('ignoring onclose for an orphaned socket')\n\t\t\t}\n\t\t}\n\t\tws.onerror = (event) => {\n\t\t\tdebug('ws.onerror', event)\n\t\t\tif (this._ws === ws) {\n\t\t\t\tthis._handleDisconnect('closed')\n\t\t\t} else {\n\t\t\t\tdebug('ignoring onerror for an orphaned socket')\n\t\t\t}\n\t\t}\n\t\tws.onmessage = (ev) => {\n\t\t\tassert(\n\t\t\t\tthis._ws === ws,\n\t\t\t\t\"sockets must only be orphaned when they are CLOSING or CLOSED, so they can't receive messages\"\n\t\t\t)\n\t\t\tconst parsed = JSON.parse(ev.data.toString())\n\t\t\tthis.messageListeners.forEach((cb) => cb(parsed))\n\t\t}\n\n\t\tthis._ws = ws\n\t}\n\n\t_closeSocket() {\n\t\tif (this._ws === null) return\n\n\t\tthis._ws.close()\n\t\t// explicitly orphan the socket to ignore its onclose/onerror, because onclose can be delayed\n\t\tthis._ws = null\n\t\tthis._handleDisconnect('manual')\n\t}\n\n\t// TLPersistentClientSocket stuff\n\n\t_connectionStatus: Atom<TLPersistentClientSocketStatus | 'initial'> = atom(\n\t\t'websocket connection status',\n\t\t'initial'\n\t)\n\n\t// eslint-disable-next-line no-restricted-syntax\n\tget connectionStatus(): TLPersistentClientSocketStatus {\n\t\tconst status = this._connectionStatus.get()\n\t\treturn status === 'initial' ? 'offline' : status\n\t}\n\n\tsendMessage(msg: TLSocketClientSentEvent<TLRecord>) {\n\t\tassert(!this.isDisposed, 'Tried to send message on a disposed socket')\n\n\t\tif (!this._ws) return\n\t\tif (this.connectionStatus === 'online') {\n\t\t\tconst chunks = chunk(JSON.stringify(msg))\n\t\t\tfor (const part of chunks) {\n\t\t\t\tthis._ws.send(part)\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn('Tried to send message while ' + this.connectionStatus)\n\t\t}\n\t}\n\n\tprivate messageListeners = new Set<(msg: TLSocketServerSentEvent<TLRecord>) => void>()\n\tonReceiveMessage(cb: (val: TLSocketServerSentEvent<TLRecord>) => void) {\n\t\tassert(!this.isDisposed, 'Tried to add message listener on a disposed socket')\n\n\t\tthis.messageListeners.add(cb)\n\t\treturn () => {\n\t\t\tthis.messageListeners.delete(cb)\n\t\t}\n\t}\n\n\tprivate statusListeners = new Set<TLSocketStatusListener>()\n\tonStatusChange(cb: TLSocketStatusListener) {\n\t\tassert(!this.isDisposed, 'Tried to add status listener on a disposed socket')\n\n\t\tthis.statusListeners.add(cb)\n\t\treturn () => {\n\t\t\tthis.statusListeners.delete(cb)\n\t\t}\n\t}\n\n\trestart() {\n\t\tassert(!this.isDisposed, 'Tried to restart a disposed socket')\n\t\tdebug('restarting')\n\n\t\tthis._closeSocket()\n\t\tthis._reconnectManager.maybeReconnected()\n\t}\n}\n\n// Those constants are exported primarily for tests\n// ACTIVE_ means the tab is active, document.hidden is false\nexport const ACTIVE_MIN_DELAY = 500\nexport const ACTIVE_MAX_DELAY = 2000\n// Correspondingly, here document.hidden is true. It's intended to reduce the load and battery drain\n// on client devices somewhat when they aren't looking at the tab. We don't disconnect completely\n// to minimise issues with reconnection/sync when the tab becomes visible again\nexport const INACTIVE_MIN_DELAY = 1000\nexport const INACTIVE_MAX_DELAY = 1000 * 60 * 5\nexport const DELAY_EXPONENT = 1.5\n// this is a tradeoff between quickly detecting connections stuck in the CONNECTING state and\n// not needlessly reconnecting if the connection is just slow to establish\nexport const ATTEMPT_TIMEOUT = 1000\n\n/** @internal */\nexport class ReconnectManager {\n\tprivate isDisposed = false\n\tprivate disposables: (() => void)[] = [\n\t\t() => {\n\t\t\tif (this.reconnectTimeout) clearTimeout(this.reconnectTimeout)\n\t\t\tif (this.recheckConnectingTimeout) clearTimeout(this.recheckConnectingTimeout)\n\t\t},\n\t]\n\tprivate reconnectTimeout: ReturnType<typeof setTimeout> | null = null\n\tprivate recheckConnectingTimeout: ReturnType<typeof setTimeout> | null = null\n\n\tprivate lastAttemptStart: number | null = null\n\tintendedDelay: number = ACTIVE_MIN_DELAY\n\tprivate state: 'pendingAttempt' | 'pendingAttemptResult' | 'delay' | 'connected'\n\n\tconstructor(\n\t\tprivate socketAdapter: ClientWebSocketAdapter,\n\t\tprivate getUri: () => Promise<string> | string\n\t) {\n\t\tthis.subscribeToReconnectHints()\n\n\t\tthis.disposables.push(\n\t\t\tlistenTo(window, 'offline', () => {\n\t\t\t\tdebug('window went offline')\n\t\t\t\t// On the one hand, 'offline' event is not really reliable; on the other, the only\n\t\t\t\t// alternative is to wait for pings not being delivered, which takes more than 20 seconds,\n\t\t\t\t// which means we won't see the ClientWebSocketAdapter status change for more than\n\t\t\t\t// 20 seconds after the tab goes offline. Our application layer must be resistent to\n\t\t\t\t// connection restart anyway, so we can just try to reconnect and see if\n\t\t\t\t// we're truly offline.\n\t\t\t\tthis.socketAdapter._closeSocket()\n\t\t\t})\n\t\t)\n\n\t\tthis.state = 'pendingAttempt'\n\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\tthis.scheduleAttempt()\n\t}\n\n\tprivate subscribeToReconnectHints() {\n\t\tthis.disposables.push(\n\t\t\tlistenTo(window, 'online', () => {\n\t\t\t\tdebug('window went online')\n\t\t\t\tthis.maybeReconnected()\n\t\t\t}),\n\t\t\tlistenTo(document, 'visibilitychange', () => {\n\t\t\t\tif (!document.hidden) {\n\t\t\t\t\tdebug('document became visible')\n\t\t\t\t\tthis.maybeReconnected()\n\t\t\t\t}\n\t\t\t})\n\t\t)\n\n\t\tif (Object.prototype.hasOwnProperty.call(navigator, 'connection')) {\n\t\t\tconst connection = (navigator as any)['connection'] as EventTarget\n\t\t\tthis.disposables.push(\n\t\t\t\tlistenTo(connection, 'change', () => {\n\t\t\t\t\tdebug('navigator.connection change')\n\t\t\t\t\tthis.maybeReconnected()\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\t}\n\n\tprivate scheduleAttempt() {\n\t\tassert(this.state === 'pendingAttempt')\n\t\tdebug('scheduling a connection attempt')\n\t\tPromise.resolve(this.getUri()).then((uri) => {\n\t\t\t// this can happen if the promise gets resolved too late\n\t\t\tif (this.state !== 'pendingAttempt' || this.isDisposed) return\n\t\t\tassert(\n\t\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.OPEN,\n\t\t\t\t'There should be no connection attempts while already connected'\n\t\t\t)\n\n\t\t\tthis.lastAttemptStart = Date.now()\n\t\t\tthis.socketAdapter._setNewSocket(new WebSocket(httpToWs(uri)))\n\t\t\tthis.state = 'pendingAttemptResult'\n\t\t})\n\t}\n\n\tprivate getMaxDelay() {\n\t\treturn document.hidden ? INACTIVE_MAX_DELAY : ACTIVE_MAX_DELAY\n\t}\n\n\tprivate getMinDelay() {\n\t\treturn document.hidden ? INACTIVE_MIN_DELAY : ACTIVE_MIN_DELAY\n\t}\n\n\tprivate clearReconnectTimeout() {\n\t\tif (this.reconnectTimeout) {\n\t\t\tclearTimeout(this.reconnectTimeout)\n\t\t\tthis.reconnectTimeout = null\n\t\t}\n\t}\n\n\tprivate clearRecheckConnectingTimeout() {\n\t\tif (this.recheckConnectingTimeout) {\n\t\t\tclearTimeout(this.recheckConnectingTimeout)\n\t\t\tthis.recheckConnectingTimeout = null\n\t\t}\n\t}\n\n\tmaybeReconnected() {\n\t\tdebug('ReconnectManager.maybeReconnected')\n\t\t// It doesn't make sense to have another check scheduled if we're already checking it now.\n\t\t// If we have a CONNECTING check scheduled and relevant, it'll be recreated below anyway\n\t\tthis.clearRecheckConnectingTimeout()\n\n\t\t// readyState can be CONNECTING, OPEN, CLOSING, CLOSED, or null (if getUri() is still pending)\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.OPEN) {\n\t\t\tdebug('ReconnectManager.maybeReconnected: already connected')\n\t\t\t// nothing to do, we're already OK\n\t\t\treturn\n\t\t}\n\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.CONNECTING) {\n\t\t\tdebug('ReconnectManager.maybeReconnected: connecting')\n\t\t\t// We might be waiting for a TCP connection that sent SYN out and will never get it back,\n\t\t\t// while a new connection appeared. On the other hand, we might have just started connecting\n\t\t\t// and will succeed in a bit. Thus, we're checking how old the attempt is and retry anew\n\t\t\t// if it's old enough. This by itself can delay the connection a bit, but shouldn't prevent\n\t\t\t// new connections as long as `maybeReconnected` is not looped itself\n\t\t\tassert(\n\t\t\t\tthis.lastAttemptStart,\n\t\t\t\t'ReadyState=CONNECTING without lastAttemptStart should be impossible'\n\t\t\t)\n\t\t\tconst sinceLastStart = Date.now() - this.lastAttemptStart\n\t\t\tif (sinceLastStart < ATTEMPT_TIMEOUT) {\n\t\t\t\tdebug('ReconnectManager.maybeReconnected: connecting, rechecking later')\n\t\t\t\tthis.recheckConnectingTimeout = setTimeout(\n\t\t\t\t\t() => this.maybeReconnected(),\n\t\t\t\t\tATTEMPT_TIMEOUT - sinceLastStart\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tdebug('ReconnectManager.maybeReconnected: connecting, but for too long, retry now')\n\t\t\t\t// Last connection attempt was started a while ago, it's possible that network conditions\n\t\t\t\t// changed, and it's worth retrying to connect. `disconnected` will handle reconnection\n\t\t\t\t//\n\t\t\t\t// NOTE: The danger here is looping in connection attemps if connections are slow.\n\t\t\t\t//       Make sure that `maybeReconnected` is not called in the `disconnected` codepath!\n\t\t\t\tthis.clearRecheckConnectingTimeout()\n\t\t\t\tthis.socketAdapter._closeSocket()\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tdebug('ReconnectManager.maybeReconnected: closing/closed/null, retry now')\n\t\t// readyState is CLOSING or CLOSED, or the websocket is null\n\t\t// Restart the backoff and retry ASAP (honouring the min delay)\n\t\t// this.state doesn't really matter, because disconnected() will handle any state correctly\n\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\tthis.disconnected()\n\t}\n\n\tdisconnected() {\n\t\tdebug('ReconnectManager.disconnected')\n\t\t// This either means we're freshly disconnected, or the last connection attempt failed;\n\t\t// either way, time to try again.\n\n\t\t// Guard against delayed notifications and recheck synchronously\n\t\tif (\n\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.OPEN &&\n\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.CONNECTING\n\t\t) {\n\t\t\tdebug('ReconnectManager.disconnected: websocket is not OPEN or CONNECTING')\n\t\t\tthis.clearReconnectTimeout()\n\n\t\t\tlet delayLeft\n\t\t\tif (this.state === 'connected') {\n\t\t\t\t// it's the first sign that we got disconnected; the state will be updated below,\n\t\t\t\t// just set the appropriate delay for now\n\t\t\t\tthis.intendedDelay = this.getMinDelay()\n\t\t\t\tdelayLeft = this.intendedDelay\n\t\t\t} else {\n\t\t\t\tdelayLeft =\n\t\t\t\t\tthis.lastAttemptStart !== null\n\t\t\t\t\t\t? this.lastAttemptStart + this.intendedDelay - Date.now()\n\t\t\t\t\t\t: 0\n\t\t\t}\n\n\t\t\tif (delayLeft > 0) {\n\t\t\t\tdebug('ReconnectManager.disconnected: delaying, delayLeft', delayLeft)\n\t\t\t\t// try again later\n\t\t\t\tthis.state = 'delay'\n\n\t\t\t\tthis.reconnectTimeout = setTimeout(() => this.disconnected(), delayLeft)\n\t\t\t} else {\n\t\t\t\t// not connected and not delayed, time to retry\n\t\t\t\tthis.state = 'pendingAttempt'\n\n\t\t\t\tthis.intendedDelay = Math.min(\n\t\t\t\t\tthis.getMaxDelay(),\n\t\t\t\t\tMath.max(this.getMinDelay(), this.intendedDelay) * DELAY_EXPONENT\n\t\t\t\t)\n\t\t\t\tdebug(\n\t\t\t\t\t'ReconnectManager.disconnected: attempting a connection, next delay',\n\t\t\t\t\tthis.intendedDelay\n\t\t\t\t)\n\t\t\t\tthis.scheduleAttempt()\n\t\t\t}\n\t\t}\n\t}\n\n\tconnected() {\n\t\tdebug('ReconnectManager.connected')\n\t\t// this notification could've been delayed, recheck synchronously\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.OPEN) {\n\t\t\tdebug('ReconnectManager.connected: websocket is OPEN')\n\t\t\tthis.state = 'connected'\n\t\t\tthis.clearReconnectTimeout()\n\t\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\t}\n\t}\n\n\tclose() {\n\t\tthis.disposables.forEach((d) => d())\n\t\tthis.isDisposed = true\n\t}\n}\n\nfunction httpToWs(url: string) {\n\treturn url.replace(/^http(s)?:/, 'ws$1:')\n}\n"],
  "mappings": "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",
  "names": []
}
