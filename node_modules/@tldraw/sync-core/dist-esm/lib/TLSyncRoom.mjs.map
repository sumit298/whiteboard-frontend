{
  "version": 3,
  "sources": ["../../src/lib/TLSyncRoom.ts"],
  "sourcesContent": ["import { Atom, atom, transaction } from '@tldraw/state'\nimport {\n\tIdOf,\n\tMigrationFailureReason,\n\tRecordType,\n\tSerializedSchema,\n\tStoreSchema,\n\tUnknownRecord,\n} from '@tldraw/store'\nimport { DocumentRecordType, PageRecordType, TLDOCUMENT_ID } from '@tldraw/tlschema'\nimport {\n\tIndexKey,\n\tResult,\n\tassert,\n\tassertExists,\n\texhaustiveSwitchError,\n\tgetOwnProperty,\n\thasOwnProperty,\n\tisNativeStructuredClone,\n\tobjectMapEntries,\n\tobjectMapKeys,\n\tstructuredClone,\n} from '@tldraw/utils'\nimport isEqual from 'lodash.isequal'\nimport { createNanoEvents } from 'nanoevents'\nimport {\n\tRoomSession,\n\tRoomSessionState,\n\tSESSION_IDLE_TIMEOUT,\n\tSESSION_REMOVAL_WAIT_TIME,\n\tSESSION_START_WAIT_TIME,\n} from './RoomSession'\nimport { TLSyncLog } from './TLSocketRoom'\nimport { TLSyncErrorCloseEventCode, TLSyncErrorCloseEventReason } from './TLSyncClient'\nimport {\n\tNetworkDiff,\n\tObjectDiff,\n\tRecordOp,\n\tRecordOpType,\n\tValueOpType,\n\tapplyObjectDiff,\n\tdiffRecord,\n} from './diff'\nimport { interval } from './interval'\nimport {\n\tTLIncompatibilityReason,\n\tTLSocketClientSentEvent,\n\tTLSocketServerSentDataEvent,\n\tTLSocketServerSentEvent,\n\tgetTlsyncProtocolVersion,\n} from './protocol'\n\n/** @internal */\nexport interface TLRoomSocket<R extends UnknownRecord> {\n\tisOpen: boolean\n\tsendMessage(msg: TLSocketServerSentEvent<R>): void\n\tclose(code?: number, reason?: string): void\n}\n\n// the max number of tombstones to keep in the store\nexport const MAX_TOMBSTONES = 3000\n// the number of tombstones to delete when the max is reached\nexport const TOMBSTONE_PRUNE_BUFFER_SIZE = 300\n// the minimum time between data-related messages to the clients\nexport const DATA_MESSAGE_DEBOUNCE_INTERVAL = 1000 / 60\n\nconst timeSince = (time: number) => Date.now() - time\n\n/** @internal */\nexport class DocumentState<R extends UnknownRecord> {\n\t_atom: Atom<{ state: R; lastChangedClock: number }>\n\n\tstatic createWithoutValidating<R extends UnknownRecord>(\n\t\tstate: R,\n\t\tlastChangedClock: number,\n\t\trecordType: RecordType<R, any>\n\t): DocumentState<R> {\n\t\treturn new DocumentState(state, lastChangedClock, recordType)\n\t}\n\n\tstatic createAndValidate<R extends UnknownRecord>(\n\t\tstate: R,\n\t\tlastChangedClock: number,\n\t\trecordType: RecordType<R, any>\n\t): Result<DocumentState<R>, Error> {\n\t\ttry {\n\t\t\trecordType.validate(state)\n\t\t} catch (error: any) {\n\t\t\treturn Result.err(error)\n\t\t}\n\t\treturn Result.ok(new DocumentState(state, lastChangedClock, recordType))\n\t}\n\n\tprivate constructor(\n\t\tstate: R,\n\t\tlastChangedClock: number,\n\t\tprivate readonly recordType: RecordType<R, any>\n\t) {\n\t\tthis._atom = atom('document:' + state.id, { state, lastChangedClock })\n\t}\n\t// eslint-disable-next-line no-restricted-syntax\n\tget state() {\n\t\treturn this._atom.get().state\n\t}\n\t// eslint-disable-next-line no-restricted-syntax\n\tget lastChangedClock() {\n\t\treturn this._atom.get().lastChangedClock\n\t}\n\treplaceState(state: R, clock: number): Result<ObjectDiff | null, Error> {\n\t\tconst diff = diffRecord(this.state, state)\n\t\tif (!diff) return Result.ok(null)\n\t\ttry {\n\t\t\tthis.recordType.validate(state)\n\t\t} catch (error: any) {\n\t\t\treturn Result.err(error)\n\t\t}\n\t\tthis._atom.set({ state, lastChangedClock: clock })\n\t\treturn Result.ok(diff)\n\t}\n\tmergeDiff(diff: ObjectDiff, clock: number): Result<ObjectDiff | null, Error> {\n\t\tconst newState = applyObjectDiff(this.state, diff)\n\t\treturn this.replaceState(newState, clock)\n\t}\n}\n\n/** @public */\nexport interface RoomSnapshot {\n\tclock: number\n\tdocuments: Array<{ state: UnknownRecord; lastChangedClock: number }>\n\ttombstones?: Record<string, number>\n\tschema?: SerializedSchema\n}\n\n/**\n * A room is a workspace for a group of clients. It allows clients to collaborate on documents\n * within that workspace.\n *\n * @internal\n */\nexport class TLSyncRoom<R extends UnknownRecord, SessionMeta> {\n\t// A table of connected clients\n\treadonly sessions = new Map<string, RoomSession<R, SessionMeta>>()\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\tpruneSessions = () => {\n\t\tfor (const client of this.sessions.values()) {\n\t\t\tswitch (client.state) {\n\t\t\t\tcase RoomSessionState.Connected: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.lastInteractionTime) > SESSION_IDLE_TIMEOUT\n\t\t\t\t\tif (hasTimedOut || !client.socket.isOpen) {\n\t\t\t\t\t\tthis.cancelSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase RoomSessionState.AwaitingConnectMessage: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.sessionStartTime) > SESSION_START_WAIT_TIME\n\t\t\t\t\tif (hasTimedOut || !client.socket.isOpen) {\n\t\t\t\t\t\t// remove immediately\n\t\t\t\t\t\tthis.removeSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase RoomSessionState.AwaitingRemoval: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.cancellationTime) > SESSION_REMOVAL_WAIT_TIME\n\t\t\t\t\tif (hasTimedOut) {\n\t\t\t\t\t\tthis.removeSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\texhaustiveSwitchError(client)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate disposables: Array<() => void> = [interval(this.pruneSessions, 2000)]\n\n\tprivate _isClosed = false\n\n\tclose() {\n\t\tthis.disposables.forEach((d) => d())\n\t\tthis.sessions.forEach((session) => {\n\t\t\tsession.socket.close()\n\t\t})\n\t\tthis._isClosed = true\n\t}\n\n\tisClosed() {\n\t\treturn this._isClosed\n\t}\n\n\treadonly events = createNanoEvents<{\n\t\troom_became_empty(): void\n\t\tsession_removed(args: { sessionId: string; meta: SessionMeta }): void\n\t}>()\n\n\t// Values associated with each uid (must be serializable).\n\t/** @internal */\n\tstate = atom<{\n\t\tdocuments: Record<string, DocumentState<R>>\n\t\ttombstones: Record<string, number>\n\t}>('room state', {\n\t\tdocuments: {},\n\t\ttombstones: {},\n\t})\n\n\t// this clock should start higher than the client, to make sure that clients who sync with their\n\t// initial lastServerClock value get the full state\n\t// in this case clients will start with 0, and the server will start with 1\n\tclock = 1\n\tdocumentClock = 1\n\ttombstoneHistoryStartsAtClock = this.clock\n\t// map from record id to clock upon deletion\n\n\treadonly serializedSchema: SerializedSchema\n\n\treadonly documentTypes: Set<string>\n\treadonly presenceType: RecordType<R, any> | null\n\tprivate log?: TLSyncLog\n\tpublic readonly schema: StoreSchema<R, any>\n\tprivate onDataChange?(): void\n\tprivate onPresenceChange?(): void\n\n\tconstructor(opts: {\n\t\tlog?: TLSyncLog\n\t\tschema: StoreSchema<R, any>\n\t\tsnapshot?: RoomSnapshot\n\t\tonDataChange?(): void\n\t\tonPresenceChange?(): void\n\t}) {\n\t\tthis.schema = opts.schema\n\t\tlet snapshot = opts.snapshot\n\t\tthis.log = opts.log\n\t\tthis.onDataChange = opts.onDataChange\n\t\tthis.onPresenceChange = opts.onPresenceChange\n\n\t\tassert(\n\t\t\tisNativeStructuredClone,\n\t\t\t'TLSyncRoom is supposed to run either on Cloudflare Workers' +\n\t\t\t\t'or on a 18+ version of Node.js, which both support the native structuredClone API'\n\t\t)\n\n\t\t// do a json serialization cycle to make sure the schema has no 'undefined' values\n\t\tthis.serializedSchema = JSON.parse(JSON.stringify(this.schema.serialize()))\n\n\t\tthis.documentTypes = new Set(\n\t\t\tObject.values<RecordType<R, any>>(this.schema.types)\n\t\t\t\t.filter((t) => t.scope === 'document')\n\t\t\t\t.map((t) => t.typeName)\n\t\t)\n\n\t\tconst presenceTypes = new Set(\n\t\t\tObject.values<RecordType<R, any>>(this.schema.types).filter((t) => t.scope === 'presence')\n\t\t)\n\n\t\tif (presenceTypes.size > 1) {\n\t\t\tthrow new Error(\n\t\t\t\t`TLSyncRoom: exactly zero or one presence type is expected, but found ${presenceTypes.size}`\n\t\t\t)\n\t\t}\n\n\t\tthis.presenceType = presenceTypes.values().next()?.value ?? null\n\n\t\tif (!snapshot) {\n\t\t\tsnapshot = {\n\t\t\t\tclock: 0,\n\t\t\t\tdocuments: [\n\t\t\t\t\t{\n\t\t\t\t\t\tstate: DocumentRecordType.create({ id: TLDOCUMENT_ID }),\n\t\t\t\t\t\tlastChangedClock: 0,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tstate: PageRecordType.create({ name: 'Page 1', index: 'a1' as IndexKey }),\n\t\t\t\t\t\tlastChangedClock: 0,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t}\n\t\t}\n\n\t\tthis.clock = snapshot.clock\n\t\tlet didIncrementClock = false\n\t\tconst ensureClockDidIncrement = (_reason: string) => {\n\t\t\tif (!didIncrementClock) {\n\t\t\t\tdidIncrementClock = true\n\t\t\t\tthis.clock++\n\t\t\t}\n\t\t}\n\n\t\tconst tombstones = { ...snapshot.tombstones }\n\t\tconst filteredDocuments = []\n\t\tfor (const doc of snapshot.documents) {\n\t\t\tif (this.documentTypes.has(doc.state.typeName)) {\n\t\t\t\tfilteredDocuments.push(doc)\n\t\t\t} else {\n\t\t\t\tensureClockDidIncrement('doc type was not doc type')\n\t\t\t\ttombstones[doc.state.id] = this.clock\n\t\t\t}\n\t\t}\n\n\t\tconst documents: Record<string, DocumentState<R>> = Object.fromEntries(\n\t\t\tfilteredDocuments.map((r) => [\n\t\t\t\tr.state.id,\n\t\t\t\tDocumentState.createWithoutValidating<R>(\n\t\t\t\t\tr.state as R,\n\t\t\t\t\tr.lastChangedClock,\n\t\t\t\t\tassertExists(getOwnProperty(this.schema.types, r.state.typeName))\n\t\t\t\t),\n\t\t\t])\n\t\t)\n\n\t\tconst migrationResult = this.schema.migrateStoreSnapshot({\n\t\t\tstore: Object.fromEntries(\n\t\t\t\tobjectMapEntries(documents).map(([id, { state }]) => [id, state as R])\n\t\t\t) as Record<IdOf<R>, R>,\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\tschema: snapshot.schema ?? this.schema.serializeEarliestVersion(),\n\t\t})\n\n\t\tif (migrationResult.type === 'error') {\n\t\t\t// TODO: Fault tolerance\n\t\t\tthrow new Error('Failed to migrate: ' + migrationResult.reason)\n\t\t}\n\n\t\tfor (const [id, r] of objectMapEntries(migrationResult.value)) {\n\t\t\tconst existing = documents[id]\n\t\t\tif (!existing) {\n\t\t\t\t// record was added during migration\n\t\t\t\tensureClockDidIncrement('record was added during migration')\n\t\t\t\tdocuments[id] = DocumentState.createWithoutValidating(\n\t\t\t\t\tr,\n\t\t\t\t\tthis.clock,\n\t\t\t\t\tassertExists(getOwnProperty(this.schema.types, r.typeName)) as any\n\t\t\t\t)\n\t\t\t} else if (!isEqual(existing.state, r)) {\n\t\t\t\t// record was maybe updated during migration\n\t\t\t\tensureClockDidIncrement('record was maybe updated during migration')\n\t\t\t\texisting.replaceState(r, this.clock)\n\t\t\t}\n\t\t}\n\n\t\tfor (const id of objectMapKeys(documents)) {\n\t\t\tif (!migrationResult.value[id as keyof typeof migrationResult.value]) {\n\t\t\t\t// record was removed during migration\n\t\t\t\tensureClockDidIncrement('record was removed during migration')\n\t\t\t\ttombstones[id] = this.clock\n\t\t\t\tdelete documents[id]\n\t\t\t}\n\t\t}\n\n\t\tthis.state.set({ documents, tombstones })\n\n\t\tthis.pruneTombstones()\n\t\tthis.documentClock = this.clock\n\t\tif (didIncrementClock) {\n\t\t\topts.onDataChange?.()\n\t\t}\n\t}\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\tprivate pruneTombstones = () => {\n\t\t// avoid blocking any pending responses\n\t\tthis.state.update(({ tombstones, documents }) => {\n\t\t\tconst entries = Object.entries(this.state.get().tombstones)\n\t\t\tif (entries.length > MAX_TOMBSTONES) {\n\t\t\t\t// sort entries in ascending order by clock\n\t\t\t\tentries.sort((a, b) => a[1] - b[1])\n\t\t\t\t// trim off the first bunch\n\t\t\t\tconst excessQuantity = entries.length - MAX_TOMBSTONES\n\t\t\t\ttombstones = Object.fromEntries(entries.slice(excessQuantity + TOMBSTONE_PRUNE_BUFFER_SIZE))\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tdocuments,\n\t\t\t\ttombstones,\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate getDocument(id: string) {\n\t\treturn this.state.get().documents[id]\n\t}\n\n\tprivate addDocument(id: string, state: R, clock: number): Result<void, Error> {\n\t\tlet { documents, tombstones } = this.state.get()\n\t\tif (hasOwnProperty(tombstones, id)) {\n\t\t\ttombstones = { ...tombstones }\n\t\t\tdelete tombstones[id]\n\t\t}\n\t\tconst createResult = DocumentState.createAndValidate(\n\t\t\tstate,\n\t\t\tclock,\n\t\t\tassertExists(getOwnProperty(this.schema.types, state.typeName))\n\t\t)\n\t\tif (!createResult.ok) return createResult\n\t\tdocuments = { ...documents, [id]: createResult.value }\n\t\tthis.state.set({ documents, tombstones })\n\t\treturn Result.ok(undefined)\n\t}\n\n\tprivate removeDocument(id: string, clock: number) {\n\t\tthis.state.update(({ documents, tombstones }) => {\n\t\t\tdocuments = { ...documents }\n\t\t\tdelete documents[id]\n\t\t\ttombstones = { ...tombstones, [id]: clock }\n\t\t\treturn { documents, tombstones }\n\t\t})\n\t}\n\n\tgetSnapshot(): RoomSnapshot {\n\t\tconst { documents, tombstones } = this.state.get()\n\t\treturn {\n\t\t\tclock: this.clock,\n\t\t\ttombstones,\n\t\t\tschema: this.serializedSchema,\n\t\t\tdocuments: Object.values(documents)\n\t\t\t\t.filter((d) => this.documentTypes.has(d.state.typeName))\n\t\t\t\t.map((doc) => ({\n\t\t\t\t\tstate: doc.state,\n\t\t\t\t\tlastChangedClock: doc.lastChangedClock,\n\t\t\t\t})),\n\t\t}\n\t}\n\n\t/**\n\t * Send a message to a particular client. Debounces data events\n\t *\n\t * @param sessionId - The id of the session to send the message to.\n\t * @param message - The message to send.\n\t */\n\tprivate sendMessage(\n\t\tsessionId: string,\n\t\tmessage: TLSocketServerSentEvent<R> | TLSocketServerSentDataEvent<R>\n\t) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Tried to send message to unknown session', message.type)\n\t\t\treturn\n\t\t}\n\t\tif (session.state !== RoomSessionState.Connected) {\n\t\t\tthis.log?.warn?.('Tried to send message to disconnected client', message.type)\n\t\t\treturn\n\t\t}\n\t\tif (session.socket.isOpen) {\n\t\t\tif (message.type !== 'patch' && message.type !== 'push_result') {\n\t\t\t\t// this is not a data message\n\t\t\t\tif (message.type !== 'pong') {\n\t\t\t\t\t// non-data messages like \"connect\" might still need to be ordered correctly with\n\t\t\t\t\t// respect to data messages, so it's better to flush just in case\n\t\t\t\t\tthis._flushDataMessages(sessionId)\n\t\t\t\t}\n\t\t\t\tsession.socket.sendMessage(message)\n\t\t\t} else {\n\t\t\t\tif (session.debounceTimer === null) {\n\t\t\t\t\t// this is the first message since the last flush, don't delay it\n\t\t\t\t\tsession.socket.sendMessage({ type: 'data', data: [message] })\n\n\t\t\t\t\tsession.debounceTimer = setTimeout(\n\t\t\t\t\t\t() => this._flushDataMessages(sessionId),\n\t\t\t\t\t\tDATA_MESSAGE_DEBOUNCE_INTERVAL\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tsession.outstandingDataMessages.push(message)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.cancelSession(session.sessionId)\n\t\t}\n\t}\n\n\t// needs to accept sessionId and not a session because the session might be dead by the time\n\t// the timer fires\n\t_flushDataMessages(sessionId: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\n\t\tif (!session || session.state !== RoomSessionState.Connected) {\n\t\t\treturn\n\t\t}\n\n\t\tsession.debounceTimer = null\n\n\t\tif (session.outstandingDataMessages.length > 0) {\n\t\t\tsession.socket.sendMessage({ type: 'data', data: session.outstandingDataMessages })\n\t\t\tsession.outstandingDataMessages.length = 0\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate removeSession(sessionId: string, fatalReason?: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Tried to remove unknown session')\n\t\t\treturn\n\t\t}\n\n\t\tthis.sessions.delete(sessionId)\n\n\t\tconst presence = this.getDocument(session.presenceId ?? '')\n\n\t\ttry {\n\t\t\tif (fatalReason) {\n\t\t\t\tsession.socket.close(TLSyncErrorCloseEventCode, fatalReason)\n\t\t\t} else {\n\t\t\t\tsession.socket.close()\n\t\t\t}\n\t\t} catch {\n\t\t\t// noop, calling .close() multiple times is fine\n\t\t}\n\n\t\tif (presence) {\n\t\t\tthis.state.update(({ tombstones, documents }) => {\n\t\t\t\tdocuments = { ...documents }\n\t\t\t\tdelete documents[session.presenceId!]\n\t\t\t\treturn { documents, tombstones }\n\t\t\t})\n\n\t\t\tthis.broadcastPatch({\n\t\t\t\tdiff: { [session.presenceId!]: [RecordOpType.Remove] },\n\t\t\t\tsourceSessionId: sessionId,\n\t\t\t})\n\t\t}\n\n\t\tthis.events.emit('session_removed', { sessionId, meta: session.meta })\n\t\tif (this.sessions.size === 0) {\n\t\t\tthis.events.emit('room_became_empty')\n\t\t}\n\t}\n\n\tprivate cancelSession(sessionId: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\treturn\n\t\t}\n\n\t\tif (session.state === RoomSessionState.AwaitingRemoval) {\n\t\t\tthis.log?.warn?.('Tried to cancel session that is already awaiting removal')\n\t\t\treturn\n\t\t}\n\n\t\tthis.sessions.set(sessionId, {\n\t\t\tstate: RoomSessionState.AwaitingRemoval,\n\t\t\tsessionId,\n\t\t\tpresenceId: session.presenceId,\n\t\t\tsocket: session.socket,\n\t\t\tcancellationTime: Date.now(),\n\t\t\tmeta: session.meta,\n\t\t\tisReadonly: session.isReadonly,\n\t\t\trequiresLegacyRejection: session.requiresLegacyRejection,\n\t\t})\n\n\t\ttry {\n\t\t\tsession.socket.close()\n\t\t} catch {\n\t\t\t// noop, calling .close() multiple times is fine\n\t\t}\n\t}\n\n\t/**\n\t * Broadcast a message to all connected clients except the one with the sessionId provided.\n\t *\n\t * @param message - The message to broadcast.\n\t */\n\tbroadcastPatch(message: { diff: NetworkDiff<R>; sourceSessionId?: string }) {\n\t\tconst { diff, sourceSessionId } = message\n\t\tthis.sessions.forEach((session) => {\n\t\t\tif (session.state !== RoomSessionState.Connected) return\n\t\t\tif (sourceSessionId === session.sessionId) return\n\t\t\tif (!session.socket.isOpen) {\n\t\t\t\tthis.cancelSession(session.sessionId)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst res = this.migrateDiffForSession(session.serializedSchema, diff)\n\n\t\t\tif (!res.ok) {\n\t\t\t\t// disconnect client and send incompatibility error\n\t\t\t\tthis.rejectSession(\n\t\t\t\t\tsession.sessionId,\n\t\t\t\t\tres.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\ttype: 'patch',\n\t\t\t\tdiff: res.value,\n\t\t\t\tserverClock: this.clock,\n\t\t\t})\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * When a client connects to the room, add them to the list of clients and then merge the history\n\t * down into the snapshots.\n\t *\n\t * @internal\n\t */\n\thandleNewSession(opts: {\n\t\tsessionId: string\n\t\tsocket: TLRoomSocket<R>\n\t\tmeta: SessionMeta\n\t\tisReadonly: boolean\n\t}) {\n\t\tconst { sessionId, socket, meta, isReadonly } = opts\n\t\tconst existing = this.sessions.get(sessionId)\n\t\tthis.sessions.set(sessionId, {\n\t\t\tstate: RoomSessionState.AwaitingConnectMessage,\n\t\t\tsessionId,\n\t\t\tsocket,\n\t\t\tpresenceId: existing?.presenceId ?? this.presenceType?.createId() ?? null,\n\t\t\tsessionStartTime: Date.now(),\n\t\t\tmeta,\n\t\t\tisReadonly: isReadonly ?? false,\n\t\t\t// this gets set later during handleConnectMessage\n\t\t\trequiresLegacyRejection: false,\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * When we send a diff to a client, if that client is on a lower version than us, we need to make\n\t * the diff compatible with their version. At the moment this means migrating each affected record\n\t * to the client's version and sending the whole record again. We can optimize this later by\n\t * keeping the previous versions of records around long enough to recalculate these diffs for\n\t * older client versions.\n\t */\n\tprivate migrateDiffForSession(\n\t\tserializedSchema: SerializedSchema,\n\t\tdiff: NetworkDiff<R>\n\t): Result<NetworkDiff<R>, MigrationFailureReason> {\n\t\t// TODO: optimize this by recalculating patches using the previous versions of records\n\n\t\t// when the client connects we check whether the schema is identical and make sure\n\t\t// to use the same object reference so that === works on this line\n\t\tif (serializedSchema === this.serializedSchema) {\n\t\t\treturn Result.ok(diff)\n\t\t}\n\n\t\tconst result: NetworkDiff<R> = {}\n\t\tfor (const [id, op] of Object.entries(diff)) {\n\t\t\tif (op[0] === RecordOpType.Remove) {\n\t\t\t\tresult[id] = op\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst migrationResult = this.schema.migratePersistedRecord(\n\t\t\t\tthis.getDocument(id).state,\n\t\t\t\tserializedSchema,\n\t\t\t\t'down'\n\t\t\t)\n\n\t\t\tif (migrationResult.type === 'error') {\n\t\t\t\treturn Result.err(migrationResult.reason)\n\t\t\t}\n\n\t\t\tresult[id] = [RecordOpType.Put, migrationResult.value]\n\t\t}\n\n\t\treturn Result.ok(result)\n\t}\n\n\t/**\n\t * When the server receives a message from the clients Currently, supports connect and patches.\n\t * Invalid messages types throws an error. Currently, doesn't validate data.\n\t *\n\t * @param sessionId - The session that sent the message\n\t * @param message - The message that was sent\n\t */\n\tasync handleMessage(sessionId: string, message: TLSocketClientSentEvent<R>) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Received message from unknown session')\n\t\t\treturn\n\t\t}\n\t\tswitch (message.type) {\n\t\t\tcase 'connect': {\n\t\t\t\treturn this.handleConnectRequest(session, message)\n\t\t\t}\n\t\t\tcase 'push': {\n\t\t\t\treturn this.handlePushRequest(session, message)\n\t\t\t}\n\t\t\tcase 'ping': {\n\t\t\t\tif (session.state === RoomSessionState.Connected) {\n\t\t\t\t\tsession.lastInteractionTime = Date.now()\n\t\t\t\t}\n\t\t\t\treturn this.sendMessage(session.sessionId, { type: 'pong' })\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\texhaustiveSwitchError(message)\n\t\t\t}\n\t\t}\n\t}\n\n\t/** If the client is out of date, or we are out of date, we need to let them know */\n\trejectSession(sessionId: string, fatalReason?: TLSyncErrorCloseEventReason | string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) return\n\t\tif (!fatalReason) {\n\t\t\tthis.removeSession(sessionId)\n\t\t\treturn\n\t\t}\n\t\tif (session.requiresLegacyRejection) {\n\t\t\ttry {\n\t\t\t\tif (session.socket.isOpen) {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\tlet legacyReason: TLIncompatibilityReason\n\t\t\t\t\tswitch (fatalReason) {\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.CLIENT_TOO_OLD:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.ClientTooOld\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.SERVER_TOO_OLD:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.ServerTooOld\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.INVALID_RECORD:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.InvalidRecord\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.InvalidOperation\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tsession.socket.sendMessage({\n\t\t\t\t\t\ttype: 'incompatibility_error',\n\t\t\t\t\t\treason: legacyReason,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// noop\n\t\t\t} finally {\n\t\t\t\tthis.removeSession(sessionId)\n\t\t\t}\n\t\t} else {\n\t\t\tthis.removeSession(sessionId, fatalReason)\n\t\t}\n\t}\n\n\tprivate handleConnectRequest(\n\t\tsession: RoomSession<R, SessionMeta>,\n\t\tmessage: Extract<TLSocketClientSentEvent<R>, { type: 'connect' }>\n\t) {\n\t\t// if the protocol versions don't match, disconnect the client\n\t\t// we will eventually want to try to make our protocol backwards compatible to some degree\n\t\t// and have a MIN_PROTOCOL_VERSION constant that the TLSyncRoom implements support for\n\t\tlet theirProtocolVersion = message.protocolVersion\n\t\t// 5 is the same as 6\n\t\tif (theirProtocolVersion === 5) {\n\t\t\ttheirProtocolVersion = 6\n\t\t}\n\t\t// 6 is almost the same as 7\n\t\tsession.requiresLegacyRejection = theirProtocolVersion === 6\n\t\tif (theirProtocolVersion === 6) {\n\t\t\ttheirProtocolVersion++\n\t\t}\n\t\tif (theirProtocolVersion == null || theirProtocolVersion < getTlsyncProtocolVersion()) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t} else if (theirProtocolVersion > getTlsyncProtocolVersion()) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.SERVER_TOO_OLD)\n\t\t\treturn\n\t\t}\n\t\t// If the client's store is at a different version to ours, it could cause corruption.\n\t\t// We should disconnect the client and ask them to refresh.\n\t\tif (message.schema == null) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t}\n\t\tconst migrations = this.schema.getMigrationsSince(message.schema)\n\t\t// if the client's store is at a different version to ours, we can't support them\n\t\tif (!migrations.ok || migrations.value.some((m) => m.scope === 'store' || !m.down)) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t}\n\n\t\tconst sessionSchema = isEqual(message.schema, this.serializedSchema)\n\t\t\t? this.serializedSchema\n\t\t\t: message.schema\n\n\t\tconst connect = (msg: TLSocketServerSentEvent<R>) => {\n\t\t\tthis.sessions.set(session.sessionId, {\n\t\t\t\tstate: RoomSessionState.Connected,\n\t\t\t\tsessionId: session.sessionId,\n\t\t\t\tpresenceId: session.presenceId,\n\t\t\t\tsocket: session.socket,\n\t\t\t\tserializedSchema: sessionSchema,\n\t\t\t\tlastInteractionTime: Date.now(),\n\t\t\t\tdebounceTimer: null,\n\t\t\t\toutstandingDataMessages: [],\n\t\t\t\tmeta: session.meta,\n\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\trequiresLegacyRejection: session.requiresLegacyRejection,\n\t\t\t})\n\t\t\tthis.sendMessage(session.sessionId, msg)\n\t\t}\n\n\t\ttransaction((rollback) => {\n\t\t\tif (\n\t\t\t\t// if the client requests changes since a time before we have tombstone history, send them the full state\n\t\t\t\tmessage.lastServerClock < this.tombstoneHistoryStartsAtClock ||\n\t\t\t\t// similarly, if they ask for a time we haven't reached yet, send them the full state\n\t\t\t\t// this will only happen if the DB is reset (or there is no db) and the server restarts\n\t\t\t\t// or if the server exits/crashes with unpersisted changes\n\t\t\t\tmessage.lastServerClock > this.clock\n\t\t\t) {\n\t\t\t\tconst diff: NetworkDiff<R> = {}\n\t\t\t\tfor (const [id, doc] of Object.entries(this.state.get().documents)) {\n\t\t\t\t\tif (id !== session.presenceId) {\n\t\t\t\t\t\tdiff[id] = [RecordOpType.Put, doc.state]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst migrated = this.migrateDiffForSession(sessionSchema, diff)\n\t\t\t\tif (!migrated.ok) {\n\t\t\t\t\trollback()\n\t\t\t\t\tthis.rejectSession(\n\t\t\t\t\t\tsession.sessionId,\n\t\t\t\t\t\tmigrated.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconnect({\n\t\t\t\t\ttype: 'connect',\n\t\t\t\t\tconnectRequestId: message.connectRequestId,\n\t\t\t\t\thydrationType: 'wipe_all',\n\t\t\t\t\tprotocolVersion: getTlsyncProtocolVersion(),\n\t\t\t\t\tschema: this.schema.serialize(),\n\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\tdiff: migrated.value,\n\t\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// calculate the changes since the time the client last saw\n\t\t\t\tconst diff: NetworkDiff<R> = {}\n\t\t\t\tconst updatedDocs = Object.values(this.state.get().documents).filter(\n\t\t\t\t\t(doc) => doc.lastChangedClock > message.lastServerClock\n\t\t\t\t)\n\t\t\t\tconst presenceDocs = this.presenceType\n\t\t\t\t\t? Object.values(this.state.get().documents).filter(\n\t\t\t\t\t\t\t(doc) =>\n\t\t\t\t\t\t\t\tthis.presenceType!.typeName === doc.state.typeName &&\n\t\t\t\t\t\t\t\tdoc.state.id !== session.presenceId\n\t\t\t\t\t\t)\n\t\t\t\t\t: []\n\t\t\t\tconst deletedDocsIds = Object.entries(this.state.get().tombstones)\n\t\t\t\t\t.filter(([_id, deletedAtClock]) => deletedAtClock > message.lastServerClock)\n\t\t\t\t\t.map(([id]) => id)\n\n\t\t\t\tfor (const doc of updatedDocs) {\n\t\t\t\t\tdiff[doc.state.id] = [RecordOpType.Put, doc.state]\n\t\t\t\t}\n\t\t\t\tfor (const doc of presenceDocs) {\n\t\t\t\t\tdiff[doc.state.id] = [RecordOpType.Put, doc.state]\n\t\t\t\t}\n\n\t\t\t\tfor (const docId of deletedDocsIds) {\n\t\t\t\t\tdiff[docId] = [RecordOpType.Remove]\n\t\t\t\t}\n\t\t\t\tconst migrated = this.migrateDiffForSession(sessionSchema, diff)\n\t\t\t\tif (!migrated.ok) {\n\t\t\t\t\trollback()\n\t\t\t\t\tthis.rejectSession(\n\t\t\t\t\t\tsession.sessionId,\n\t\t\t\t\t\tmigrated.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconnect({\n\t\t\t\t\ttype: 'connect',\n\t\t\t\t\tconnectRequestId: message.connectRequestId,\n\t\t\t\t\thydrationType: 'wipe_presence',\n\t\t\t\t\tschema: this.schema.serialize(),\n\t\t\t\t\tprotocolVersion: getTlsyncProtocolVersion(),\n\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\tdiff: migrated.value,\n\t\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate handlePushRequest(\n\t\tsession: RoomSession<R, SessionMeta> | null,\n\t\tmessage: Extract<TLSocketClientSentEvent<R>, { type: 'push' }>\n\t) {\n\t\t// We must be connected to handle push requests\n\t\tif (session && session.state !== RoomSessionState.Connected) {\n\t\t\treturn\n\t\t}\n\n\t\t// update the last interaction time\n\t\tif (session) {\n\t\t\tsession.lastInteractionTime = Date.now()\n\t\t}\n\n\t\t// increment the clock for this push\n\t\tthis.clock++\n\n\t\tconst initialDocumentClock = this.documentClock\n\t\tlet didPresenceChange = false\n\t\ttransaction((rollback) => {\n\t\t\t// collect actual ops that resulted from the push\n\t\t\t// these will be broadcast to other users\n\t\t\tinterface ActualChanges {\n\t\t\t\tdiff: NetworkDiff<R> | null\n\t\t\t}\n\t\t\tconst docChanges: ActualChanges = { diff: null }\n\t\t\tconst presenceChanges: ActualChanges = { diff: null }\n\n\t\t\tconst propagateOp = (changes: ActualChanges, id: string, op: RecordOp<R>) => {\n\t\t\t\tif (!changes.diff) changes.diff = {}\n\t\t\t\tchanges.diff[id] = op\n\t\t\t}\n\n\t\t\tconst fail = (\n\t\t\t\treason: TLSyncErrorCloseEventReason,\n\t\t\t\tunderlyingError?: Error\n\t\t\t): Result<void, void> => {\n\t\t\t\trollback()\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.rejectSession(session.sessionId, reason)\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('failed to apply changes: ' + reason, underlyingError)\n\t\t\t\t}\n\t\t\t\tif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n\t\t\t\t\tthis.log?.error?.('failed to apply push', reason, message, underlyingError)\n\t\t\t\t}\n\t\t\t\treturn Result.err(undefined)\n\t\t\t}\n\n\t\t\tconst addDocument = (changes: ActualChanges, id: string, _state: R): Result<void, void> => {\n\t\t\t\tconst res = session\n\t\t\t\t\t? this.schema.migratePersistedRecord(_state, session.serializedSchema, 'up')\n\t\t\t\t\t: { type: 'success' as const, value: _state }\n\t\t\t\tif (res.type === 'error') {\n\t\t\t\t\treturn fail(\n\t\t\t\t\t\tres.reason === MigrationFailureReason.TargetVersionTooOld // target version is our version\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tconst { value: state } = res\n\n\t\t\t\t// Get the existing document, if any\n\t\t\t\tconst doc = this.getDocument(id)\n\n\t\t\t\tif (doc) {\n\t\t\t\t\t// If there's an existing document, replace it with the new state\n\t\t\t\t\t// but propagate a diff rather than the entire value\n\t\t\t\t\tconst diff = doc.replaceState(state, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, if we don't already have a document with this id\n\t\t\t\t\t// create the document and propagate the put op\n\t\t\t\t\tconst result = this.addDocument(id, state, this.clock)\n\t\t\t\t\tif (!result.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Put, state])\n\t\t\t\t}\n\n\t\t\t\treturn Result.ok(undefined)\n\t\t\t}\n\n\t\t\tconst patchDocument = (\n\t\t\t\tchanges: ActualChanges,\n\t\t\t\tid: string,\n\t\t\t\tpatch: ObjectDiff\n\t\t\t): Result<void, void> => {\n\t\t\t\t// if it was already deleted, there's no need to apply the patch\n\t\t\t\tconst doc = this.getDocument(id)\n\t\t\t\tif (!doc) return Result.ok(undefined)\n\t\t\t\t// If the client's version of the record is older than ours,\n\t\t\t\t// we apply the patch to the downgraded version of the record\n\t\t\t\tconst downgraded = session\n\t\t\t\t\t? this.schema.migratePersistedRecord(doc.state, session.serializedSchema, 'down')\n\t\t\t\t\t: { type: 'success' as const, value: doc.state }\n\t\t\t\tif (downgraded.type === 'error') {\n\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\t\t}\n\n\t\t\t\tif (downgraded.value === doc.state) {\n\t\t\t\t\t// If the versions are compatible, apply the patch and propagate the patch op\n\t\t\t\t\tconst diff = doc.mergeDiff(patch, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// need to apply the patch to the downgraded version and then upgrade it\n\n\t\t\t\t\t// apply the patch to the downgraded version\n\t\t\t\t\tconst patched = applyObjectDiff(downgraded.value, patch)\n\t\t\t\t\t// then upgrade the patched version and use that as the new state\n\t\t\t\t\tconst upgraded = session\n\t\t\t\t\t\t? this.schema.migratePersistedRecord(patched, session.serializedSchema, 'up')\n\t\t\t\t\t\t: { type: 'success' as const, value: patched }\n\t\t\t\t\t// If the client's version is too old, we'll hit an error\n\t\t\t\t\tif (upgraded.type === 'error') {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\t\t\t}\n\t\t\t\t\t// replace the state with the upgraded version and propagate the patch op\n\t\t\t\t\tconst diff = doc.replaceState(upgraded.value, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value])\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Result.ok(undefined)\n\t\t\t}\n\n\t\t\tconst { clientClock } = message\n\n\t\t\tif (this.presenceType && session?.presenceId && 'presence' in message && message.presence) {\n\t\t\t\tif (!session) throw new Error('session is required for presence pushes')\n\t\t\t\t// The push request was for the presence scope.\n\t\t\t\tconst id = session.presenceId\n\t\t\t\tconst [type, val] = message.presence\n\t\t\t\tconst { typeName } = this.presenceType\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase RecordOpType.Put: {\n\t\t\t\t\t\t// Try to put the document. If it fails, stop here.\n\t\t\t\t\t\tconst res = addDocument(presenceChanges, id, { ...val, id, typeName })\n\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase RecordOpType.Patch: {\n\t\t\t\t\t\t// Try to patch the document. If it fails, stop here.\n\t\t\t\t\t\tconst res = patchDocument(presenceChanges, id, {\n\t\t\t\t\t\t\t...val,\n\t\t\t\t\t\t\tid: [ValueOpType.Put, id],\n\t\t\t\t\t\t\ttypeName: [ValueOpType.Put, typeName],\n\t\t\t\t\t\t})\n\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (message.diff && !session?.isReadonly) {\n\t\t\t\t// The push request was for the document scope.\n\t\t\t\tfor (const [id, op] of Object.entries(message.diff!)) {\n\t\t\t\t\tswitch (op[0]) {\n\t\t\t\t\t\tcase RecordOpType.Put: {\n\t\t\t\t\t\t\t// Try to add the document.\n\t\t\t\t\t\t\t// If we're putting a record with a type that we don't recognize, fail\n\t\t\t\t\t\t\tif (!this.documentTypes.has(op[1].typeName)) {\n\t\t\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst res = addDocument(docChanges, id, op[1])\n\t\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RecordOpType.Patch: {\n\t\t\t\t\t\t\t// Try to patch the document. If it fails, stop here.\n\t\t\t\t\t\t\tconst res = patchDocument(docChanges, id, op[1])\n\t\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RecordOpType.Remove: {\n\t\t\t\t\t\t\tconst doc = this.getDocument(id)\n\t\t\t\t\t\t\tif (!doc) {\n\t\t\t\t\t\t\t\t// If the doc was already deleted, don't do anything, no need to propagate a delete op\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Delete the document and propagate the delete op\n\t\t\t\t\t\t\tthis.removeDocument(id, this.clock)\n\t\t\t\t\t\t\t// Schedule a pruneTombstones call to happen on the next call stack\n\t\t\t\t\t\t\tsetTimeout(this.pruneTombstones, 0)\n\t\t\t\t\t\t\tpropagateOp(docChanges, id, op)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Let the client know what action to take based on the results of the push\n\t\t\tif (\n\t\t\t\t// if there was only a presence push, the client doesn't need to do anything aside from\n\t\t\t\t// shift the push request.\n\t\t\t\t!message.diff ||\n\t\t\t\tisEqual(docChanges.diff, message.diff)\n\t\t\t) {\n\t\t\t\t// COMMIT\n\t\t\t\t// Applying the client's changes had the exact same effect on the server as\n\t\t\t\t// they had on the client, so the client should keep the diff\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: 'commit',\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else if (!docChanges.diff) {\n\t\t\t\t// DISCARD\n\t\t\t\t// Applying the client's changes had no effect, so the client should drop the diff\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: 'discard',\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// REBASE\n\t\t\t\t// Applying the client's changes had a different non-empty effect on the server,\n\t\t\t\t// so the client should rebase with our gold-standard / authoritative diff.\n\t\t\t\t// First we need to migrate the diff to the client's version\n\t\t\t\tif (session) {\n\t\t\t\t\tconst migrateResult = this.migrateDiffForSession(\n\t\t\t\t\t\tsession.serializedSchema,\n\t\t\t\t\t\tdocChanges.diff\n\t\t\t\t\t)\n\t\t\t\t\tif (!migrateResult.ok) {\n\t\t\t\t\t\treturn fail(\n\t\t\t\t\t\t\tmigrateResult.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\t// If the migration worked, send the rebased diff to the client\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: { rebaseWithDiff: migrateResult.value },\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there are merged changes, broadcast them to all other clients\n\t\t\tif (docChanges.diff || presenceChanges.diff) {\n\t\t\t\tthis.broadcastPatch({\n\t\t\t\t\tsourceSessionId: session?.sessionId,\n\t\t\t\t\tdiff: {\n\t\t\t\t\t\t...docChanges.diff,\n\t\t\t\t\t\t...presenceChanges.diff,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (docChanges.diff) {\n\t\t\t\tthis.documentClock = this.clock\n\t\t\t}\n\t\t\tif (presenceChanges.diff) {\n\t\t\t\tdidPresenceChange = true\n\t\t\t}\n\n\t\t\treturn\n\t\t})\n\n\t\t// if it threw the changes will have been rolled back and the document clock will not have been incremented\n\t\tif (this.documentClock !== initialDocumentClock) {\n\t\t\tthis.onDataChange?.()\n\t\t}\n\n\t\tif (didPresenceChange) {\n\t\t\tthis.onPresenceChange?.()\n\t\t}\n\t}\n\n\t/**\n\t * Handle the event when a client disconnects.\n\t *\n\t * @param sessionId - The session that disconnected.\n\t */\n\thandleClose(sessionId: string) {\n\t\tthis.cancelSession(sessionId)\n\t}\n\n\t/**\n\t * Allow applying changes to the store in a transactional way.\n\t * @param updater - A function that will be called with a store object that can be used to make changes.\n\t * @returns A promise that resolves when the transaction is complete.\n\t */\n\tasync updateStore(updater: (store: RoomStoreMethods<R>) => void | Promise<void>) {\n\t\tif (this._isClosed) {\n\t\t\tthrow new Error('Cannot update store on a closed room')\n\t\t}\n\t\tconst context = new StoreUpdateContext<R>(\n\t\t\tObject.fromEntries(this.getSnapshot().documents.map((d) => [d.state.id, d.state]))\n\t\t)\n\t\ttry {\n\t\t\tawait updater(context)\n\t\t} finally {\n\t\t\tcontext.close()\n\t\t}\n\n\t\tconst diff = context.toDiff()\n\t\tif (Object.keys(diff).length === 0) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.handlePushRequest(null, { type: 'push', diff, clientClock: 0 })\n\t}\n}\n\n/**\n * @public\n */\nexport interface RoomStoreMethods<R extends UnknownRecord = UnknownRecord> {\n\tput(record: R): void\n\tdelete(recordOrId: R | string): void\n\tget(id: string): R | null\n\tgetAll(): R[]\n}\n\nclass StoreUpdateContext<R extends UnknownRecord> implements RoomStoreMethods<R> {\n\tconstructor(private readonly snapshot: Record<string, UnknownRecord>) {}\n\tprivate readonly updates = {\n\t\tputs: {} as Record<string, UnknownRecord>,\n\t\tdeletes: new Set<string>(),\n\t}\n\tput(record: R): void {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tif (record.id in this.snapshot && isEqual(this.snapshot[record.id], record)) {\n\t\t\tdelete this.updates.puts[record.id]\n\t\t} else {\n\t\t\tthis.updates.puts[record.id] = structuredClone(record)\n\t\t}\n\t\tthis.updates.deletes.delete(record.id)\n\t}\n\tdelete(recordOrId: R | string): void {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tconst id = typeof recordOrId === 'string' ? recordOrId : recordOrId.id\n\t\tdelete this.updates.puts[id]\n\t\tif (this.snapshot[id]) {\n\t\t\tthis.updates.deletes.add(id)\n\t\t}\n\t}\n\tget(id: string): R | null {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tif (hasOwnProperty(this.updates.puts, id)) {\n\t\t\treturn structuredClone(this.updates.puts[id]) as R\n\t\t}\n\t\tif (this.updates.deletes.has(id)) {\n\t\t\treturn null\n\t\t}\n\t\treturn structuredClone(this.snapshot[id] ?? null) as R\n\t}\n\n\tgetAll(): R[] {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tconst result = Object.values(this.updates.puts)\n\t\tfor (const [id, record] of Object.entries(this.snapshot)) {\n\t\t\tif (!this.updates.deletes.has(id) && !hasOwnProperty(this.updates.puts, id)) {\n\t\t\t\tresult.push(record)\n\t\t\t}\n\t\t}\n\t\treturn structuredClone(result) as R[]\n\t}\n\n\ttoDiff(): NetworkDiff<any> {\n\t\tconst diff: NetworkDiff<R> = {}\n\t\tfor (const [id, record] of Object.entries(this.updates.puts)) {\n\t\t\tdiff[id] = [RecordOpType.Put, record as R]\n\t\t}\n\t\tfor (const id of this.updates.deletes) {\n\t\t\tdiff[id] = [RecordOpType.Remove]\n\t\t}\n\t\treturn diff\n\t}\n\n\tprivate _isClosed = false\n\tclose() {\n\t\tthis._isClosed = true\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
