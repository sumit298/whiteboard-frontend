"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var TLSyncRoom_exports = {};
__export(TLSyncRoom_exports, {
  DATA_MESSAGE_DEBOUNCE_INTERVAL: () => DATA_MESSAGE_DEBOUNCE_INTERVAL,
  DocumentState: () => DocumentState,
  MAX_TOMBSTONES: () => MAX_TOMBSTONES,
  TLSyncRoom: () => TLSyncRoom,
  TOMBSTONE_PRUNE_BUFFER_SIZE: () => TOMBSTONE_PRUNE_BUFFER_SIZE
});
module.exports = __toCommonJS(TLSyncRoom_exports);
var import_state = require("@tldraw/state");
var import_store = require("@tldraw/store");
var import_tlschema = require("@tldraw/tlschema");
var import_utils = require("@tldraw/utils");
var import_lodash = __toESM(require("lodash.isequal"));
var import_nanoevents = require("nanoevents");
var import_RoomSession = require("./RoomSession");
var import_TLSyncClient = require("./TLSyncClient");
var import_diff = require("./diff");
var import_interval = require("./interval");
var import_protocol = require("./protocol");
const MAX_TOMBSTONES = 3e3;
const TOMBSTONE_PRUNE_BUFFER_SIZE = 300;
const DATA_MESSAGE_DEBOUNCE_INTERVAL = 1e3 / 60;
const timeSince = (time) => Date.now() - time;
class DocumentState {
  constructor(state, lastChangedClock, recordType) {
    this.recordType = recordType;
    this._atom = (0, import_state.atom)("document:" + state.id, { state, lastChangedClock });
  }
  _atom;
  static createWithoutValidating(state, lastChangedClock, recordType) {
    return new DocumentState(state, lastChangedClock, recordType);
  }
  static createAndValidate(state, lastChangedClock, recordType) {
    try {
      recordType.validate(state);
    } catch (error) {
      return import_utils.Result.err(error);
    }
    return import_utils.Result.ok(new DocumentState(state, lastChangedClock, recordType));
  }
  // eslint-disable-next-line no-restricted-syntax
  get state() {
    return this._atom.get().state;
  }
  // eslint-disable-next-line no-restricted-syntax
  get lastChangedClock() {
    return this._atom.get().lastChangedClock;
  }
  replaceState(state, clock) {
    const diff = (0, import_diff.diffRecord)(this.state, state);
    if (!diff) return import_utils.Result.ok(null);
    try {
      this.recordType.validate(state);
    } catch (error) {
      return import_utils.Result.err(error);
    }
    this._atom.set({ state, lastChangedClock: clock });
    return import_utils.Result.ok(diff);
  }
  mergeDiff(diff, clock) {
    const newState = (0, import_diff.applyObjectDiff)(this.state, diff);
    return this.replaceState(newState, clock);
  }
}
class TLSyncRoom {
  // A table of connected clients
  sessions = /* @__PURE__ */ new Map();
  // eslint-disable-next-line local/prefer-class-methods
  pruneSessions = () => {
    for (const client of this.sessions.values()) {
      switch (client.state) {
        case import_RoomSession.RoomSessionState.Connected: {
          const hasTimedOut = timeSince(client.lastInteractionTime) > import_RoomSession.SESSION_IDLE_TIMEOUT;
          if (hasTimedOut || !client.socket.isOpen) {
            this.cancelSession(client.sessionId);
          }
          break;
        }
        case import_RoomSession.RoomSessionState.AwaitingConnectMessage: {
          const hasTimedOut = timeSince(client.sessionStartTime) > import_RoomSession.SESSION_START_WAIT_TIME;
          if (hasTimedOut || !client.socket.isOpen) {
            this.removeSession(client.sessionId);
          }
          break;
        }
        case import_RoomSession.RoomSessionState.AwaitingRemoval: {
          const hasTimedOut = timeSince(client.cancellationTime) > import_RoomSession.SESSION_REMOVAL_WAIT_TIME;
          if (hasTimedOut) {
            this.removeSession(client.sessionId);
          }
          break;
        }
        default: {
          (0, import_utils.exhaustiveSwitchError)(client);
        }
      }
    }
  };
  disposables = [(0, import_interval.interval)(this.pruneSessions, 2e3)];
  _isClosed = false;
  close() {
    this.disposables.forEach((d) => d());
    this.sessions.forEach((session) => {
      session.socket.close();
    });
    this._isClosed = true;
  }
  isClosed() {
    return this._isClosed;
  }
  events = (0, import_nanoevents.createNanoEvents)();
  // Values associated with each uid (must be serializable).
  /** @internal */
  state = (0, import_state.atom)("room state", {
    documents: {},
    tombstones: {}
  });
  // this clock should start higher than the client, to make sure that clients who sync with their
  // initial lastServerClock value get the full state
  // in this case clients will start with 0, and the server will start with 1
  clock = 1;
  documentClock = 1;
  tombstoneHistoryStartsAtClock = this.clock;
  // map from record id to clock upon deletion
  serializedSchema;
  documentTypes;
  presenceType;
  log;
  schema;
  constructor(opts) {
    this.schema = opts.schema;
    let snapshot = opts.snapshot;
    this.log = opts.log;
    this.onDataChange = opts.onDataChange;
    this.onPresenceChange = opts.onPresenceChange;
    (0, import_utils.assert)(
      import_utils.isNativeStructuredClone,
      "TLSyncRoom is supposed to run either on Cloudflare Workersor on a 18+ version of Node.js, which both support the native structuredClone API"
    );
    this.serializedSchema = JSON.parse(JSON.stringify(this.schema.serialize()));
    this.documentTypes = new Set(
      Object.values(this.schema.types).filter((t) => t.scope === "document").map((t) => t.typeName)
    );
    const presenceTypes = new Set(
      Object.values(this.schema.types).filter((t) => t.scope === "presence")
    );
    if (presenceTypes.size > 1) {
      throw new Error(
        `TLSyncRoom: exactly zero or one presence type is expected, but found ${presenceTypes.size}`
      );
    }
    this.presenceType = presenceTypes.values().next()?.value ?? null;
    if (!snapshot) {
      snapshot = {
        clock: 0,
        documents: [
          {
            state: import_tlschema.DocumentRecordType.create({ id: import_tlschema.TLDOCUMENT_ID }),
            lastChangedClock: 0
          },
          {
            state: import_tlschema.PageRecordType.create({ name: "Page 1", index: "a1" }),
            lastChangedClock: 0
          }
        ]
      };
    }
    this.clock = snapshot.clock;
    let didIncrementClock = false;
    const ensureClockDidIncrement = (_reason) => {
      if (!didIncrementClock) {
        didIncrementClock = true;
        this.clock++;
      }
    };
    const tombstones = { ...snapshot.tombstones };
    const filteredDocuments = [];
    for (const doc of snapshot.documents) {
      if (this.documentTypes.has(doc.state.typeName)) {
        filteredDocuments.push(doc);
      } else {
        ensureClockDidIncrement("doc type was not doc type");
        tombstones[doc.state.id] = this.clock;
      }
    }
    const documents = Object.fromEntries(
      filteredDocuments.map((r) => [
        r.state.id,
        DocumentState.createWithoutValidating(
          r.state,
          r.lastChangedClock,
          (0, import_utils.assertExists)((0, import_utils.getOwnProperty)(this.schema.types, r.state.typeName))
        )
      ])
    );
    const migrationResult = this.schema.migrateStoreSnapshot({
      store: Object.fromEntries(
        (0, import_utils.objectMapEntries)(documents).map(([id, { state }]) => [id, state])
      ),
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      schema: snapshot.schema ?? this.schema.serializeEarliestVersion()
    });
    if (migrationResult.type === "error") {
      throw new Error("Failed to migrate: " + migrationResult.reason);
    }
    for (const [id, r] of (0, import_utils.objectMapEntries)(migrationResult.value)) {
      const existing = documents[id];
      if (!existing) {
        ensureClockDidIncrement("record was added during migration");
        documents[id] = DocumentState.createWithoutValidating(
          r,
          this.clock,
          (0, import_utils.assertExists)((0, import_utils.getOwnProperty)(this.schema.types, r.typeName))
        );
      } else if (!(0, import_lodash.default)(existing.state, r)) {
        ensureClockDidIncrement("record was maybe updated during migration");
        existing.replaceState(r, this.clock);
      }
    }
    for (const id of (0, import_utils.objectMapKeys)(documents)) {
      if (!migrationResult.value[id]) {
        ensureClockDidIncrement("record was removed during migration");
        tombstones[id] = this.clock;
        delete documents[id];
      }
    }
    this.state.set({ documents, tombstones });
    this.pruneTombstones();
    this.documentClock = this.clock;
    if (didIncrementClock) {
      opts.onDataChange?.();
    }
  }
  // eslint-disable-next-line local/prefer-class-methods
  pruneTombstones = () => {
    this.state.update(({ tombstones, documents }) => {
      const entries = Object.entries(this.state.get().tombstones);
      if (entries.length > MAX_TOMBSTONES) {
        entries.sort((a, b) => a[1] - b[1]);
        const excessQuantity = entries.length - MAX_TOMBSTONES;
        tombstones = Object.fromEntries(entries.slice(excessQuantity + TOMBSTONE_PRUNE_BUFFER_SIZE));
      }
      return {
        documents,
        tombstones
      };
    });
  };
  getDocument(id) {
    return this.state.get().documents[id];
  }
  addDocument(id, state, clock) {
    let { documents, tombstones } = this.state.get();
    if ((0, import_utils.hasOwnProperty)(tombstones, id)) {
      tombstones = { ...tombstones };
      delete tombstones[id];
    }
    const createResult = DocumentState.createAndValidate(
      state,
      clock,
      (0, import_utils.assertExists)((0, import_utils.getOwnProperty)(this.schema.types, state.typeName))
    );
    if (!createResult.ok) return createResult;
    documents = { ...documents, [id]: createResult.value };
    this.state.set({ documents, tombstones });
    return import_utils.Result.ok(void 0);
  }
  removeDocument(id, clock) {
    this.state.update(({ documents, tombstones }) => {
      documents = { ...documents };
      delete documents[id];
      tombstones = { ...tombstones, [id]: clock };
      return { documents, tombstones };
    });
  }
  getSnapshot() {
    const { documents, tombstones } = this.state.get();
    return {
      clock: this.clock,
      tombstones,
      schema: this.serializedSchema,
      documents: Object.values(documents).filter((d) => this.documentTypes.has(d.state.typeName)).map((doc) => ({
        state: doc.state,
        lastChangedClock: doc.lastChangedClock
      }))
    };
  }
  /**
   * Send a message to a particular client. Debounces data events
   *
   * @param sessionId - The id of the session to send the message to.
   * @param message - The message to send.
   */
  sendMessage(sessionId, message) {
    const session = this.sessions.get(sessionId);
    if (!session) {
      this.log?.warn?.("Tried to send message to unknown session", message.type);
      return;
    }
    if (session.state !== import_RoomSession.RoomSessionState.Connected) {
      this.log?.warn?.("Tried to send message to disconnected client", message.type);
      return;
    }
    if (session.socket.isOpen) {
      if (message.type !== "patch" && message.type !== "push_result") {
        if (message.type !== "pong") {
          this._flushDataMessages(sessionId);
        }
        session.socket.sendMessage(message);
      } else {
        if (session.debounceTimer === null) {
          session.socket.sendMessage({ type: "data", data: [message] });
          session.debounceTimer = setTimeout(
            () => this._flushDataMessages(sessionId),
            DATA_MESSAGE_DEBOUNCE_INTERVAL
          );
        } else {
          session.outstandingDataMessages.push(message);
        }
      }
    } else {
      this.cancelSession(session.sessionId);
    }
  }
  // needs to accept sessionId and not a session because the session might be dead by the time
  // the timer fires
  _flushDataMessages(sessionId) {
    const session = this.sessions.get(sessionId);
    if (!session || session.state !== import_RoomSession.RoomSessionState.Connected) {
      return;
    }
    session.debounceTimer = null;
    if (session.outstandingDataMessages.length > 0) {
      session.socket.sendMessage({ type: "data", data: session.outstandingDataMessages });
      session.outstandingDataMessages.length = 0;
    }
  }
  /** @internal */
  removeSession(sessionId, fatalReason) {
    const session = this.sessions.get(sessionId);
    if (!session) {
      this.log?.warn?.("Tried to remove unknown session");
      return;
    }
    this.sessions.delete(sessionId);
    const presence = this.getDocument(session.presenceId ?? "");
    try {
      if (fatalReason) {
        session.socket.close(import_TLSyncClient.TLSyncErrorCloseEventCode, fatalReason);
      } else {
        session.socket.close();
      }
    } catch {
    }
    if (presence) {
      this.state.update(({ tombstones, documents }) => {
        documents = { ...documents };
        delete documents[session.presenceId];
        return { documents, tombstones };
      });
      this.broadcastPatch({
        diff: { [session.presenceId]: [import_diff.RecordOpType.Remove] },
        sourceSessionId: sessionId
      });
    }
    this.events.emit("session_removed", { sessionId, meta: session.meta });
    if (this.sessions.size === 0) {
      this.events.emit("room_became_empty");
    }
  }
  cancelSession(sessionId) {
    const session = this.sessions.get(sessionId);
    if (!session) {
      return;
    }
    if (session.state === import_RoomSession.RoomSessionState.AwaitingRemoval) {
      this.log?.warn?.("Tried to cancel session that is already awaiting removal");
      return;
    }
    this.sessions.set(sessionId, {
      state: import_RoomSession.RoomSessionState.AwaitingRemoval,
      sessionId,
      presenceId: session.presenceId,
      socket: session.socket,
      cancellationTime: Date.now(),
      meta: session.meta,
      isReadonly: session.isReadonly,
      requiresLegacyRejection: session.requiresLegacyRejection
    });
    try {
      session.socket.close();
    } catch {
    }
  }
  /**
   * Broadcast a message to all connected clients except the one with the sessionId provided.
   *
   * @param message - The message to broadcast.
   */
  broadcastPatch(message) {
    const { diff, sourceSessionId } = message;
    this.sessions.forEach((session) => {
      if (session.state !== import_RoomSession.RoomSessionState.Connected) return;
      if (sourceSessionId === session.sessionId) return;
      if (!session.socket.isOpen) {
        this.cancelSession(session.sessionId);
        return;
      }
      const res = this.migrateDiffForSession(session.serializedSchema, diff);
      if (!res.ok) {
        this.rejectSession(
          session.sessionId,
          res.error === import_store.MigrationFailureReason.TargetVersionTooNew ? import_TLSyncClient.TLSyncErrorCloseEventReason.SERVER_TOO_OLD : import_TLSyncClient.TLSyncErrorCloseEventReason.CLIENT_TOO_OLD
        );
        return;
      }
      this.sendMessage(session.sessionId, {
        type: "patch",
        diff: res.value,
        serverClock: this.clock
      });
    });
    return this;
  }
  /**
   * When a client connects to the room, add them to the list of clients and then merge the history
   * down into the snapshots.
   *
   * @internal
   */
  handleNewSession(opts) {
    const { sessionId, socket, meta, isReadonly } = opts;
    const existing = this.sessions.get(sessionId);
    this.sessions.set(sessionId, {
      state: import_RoomSession.RoomSessionState.AwaitingConnectMessage,
      sessionId,
      socket,
      presenceId: existing?.presenceId ?? this.presenceType?.createId() ?? null,
      sessionStartTime: Date.now(),
      meta,
      isReadonly: isReadonly ?? false,
      // this gets set later during handleConnectMessage
      requiresLegacyRejection: false
    });
    return this;
  }
  /**
   * When we send a diff to a client, if that client is on a lower version than us, we need to make
   * the diff compatible with their version. At the moment this means migrating each affected record
   * to the client's version and sending the whole record again. We can optimize this later by
   * keeping the previous versions of records around long enough to recalculate these diffs for
   * older client versions.
   */
  migrateDiffForSession(serializedSchema, diff) {
    if (serializedSchema === this.serializedSchema) {
      return import_utils.Result.ok(diff);
    }
    const result = {};
    for (const [id, op] of Object.entries(diff)) {
      if (op[0] === import_diff.RecordOpType.Remove) {
        result[id] = op;
        continue;
      }
      const migrationResult = this.schema.migratePersistedRecord(
        this.getDocument(id).state,
        serializedSchema,
        "down"
      );
      if (migrationResult.type === "error") {
        return import_utils.Result.err(migrationResult.reason);
      }
      result[id] = [import_diff.RecordOpType.Put, migrationResult.value];
    }
    return import_utils.Result.ok(result);
  }
  /**
   * When the server receives a message from the clients Currently, supports connect and patches.
   * Invalid messages types throws an error. Currently, doesn't validate data.
   *
   * @param sessionId - The session that sent the message
   * @param message - The message that was sent
   */
  async handleMessage(sessionId, message) {
    const session = this.sessions.get(sessionId);
    if (!session) {
      this.log?.warn?.("Received message from unknown session");
      return;
    }
    switch (message.type) {
      case "connect": {
        return this.handleConnectRequest(session, message);
      }
      case "push": {
        return this.handlePushRequest(session, message);
      }
      case "ping": {
        if (session.state === import_RoomSession.RoomSessionState.Connected) {
          session.lastInteractionTime = Date.now();
        }
        return this.sendMessage(session.sessionId, { type: "pong" });
      }
      default: {
        (0, import_utils.exhaustiveSwitchError)(message);
      }
    }
  }
  /** If the client is out of date, or we are out of date, we need to let them know */
  rejectSession(sessionId, fatalReason) {
    const session = this.sessions.get(sessionId);
    if (!session) return;
    if (!fatalReason) {
      this.removeSession(sessionId);
      return;
    }
    if (session.requiresLegacyRejection) {
      try {
        if (session.socket.isOpen) {
          let legacyReason;
          switch (fatalReason) {
            case import_TLSyncClient.TLSyncErrorCloseEventReason.CLIENT_TOO_OLD:
              legacyReason = import_protocol.TLIncompatibilityReason.ClientTooOld;
              break;
            case import_TLSyncClient.TLSyncErrorCloseEventReason.SERVER_TOO_OLD:
              legacyReason = import_protocol.TLIncompatibilityReason.ServerTooOld;
              break;
            case import_TLSyncClient.TLSyncErrorCloseEventReason.INVALID_RECORD:
              legacyReason = import_protocol.TLIncompatibilityReason.InvalidRecord;
              break;
            default:
              legacyReason = import_protocol.TLIncompatibilityReason.InvalidOperation;
              break;
          }
          session.socket.sendMessage({
            type: "incompatibility_error",
            reason: legacyReason
          });
        }
      } catch {
      } finally {
        this.removeSession(sessionId);
      }
    } else {
      this.removeSession(sessionId, fatalReason);
    }
  }
  handleConnectRequest(session, message) {
    let theirProtocolVersion = message.protocolVersion;
    if (theirProtocolVersion === 5) {
      theirProtocolVersion = 6;
    }
    session.requiresLegacyRejection = theirProtocolVersion === 6;
    if (theirProtocolVersion === 6) {
      theirProtocolVersion++;
    }
    if (theirProtocolVersion == null || theirProtocolVersion < (0, import_protocol.getTlsyncProtocolVersion)()) {
      this.rejectSession(session.sessionId, import_TLSyncClient.TLSyncErrorCloseEventReason.CLIENT_TOO_OLD);
      return;
    } else if (theirProtocolVersion > (0, import_protocol.getTlsyncProtocolVersion)()) {
      this.rejectSession(session.sessionId, import_TLSyncClient.TLSyncErrorCloseEventReason.SERVER_TOO_OLD);
      return;
    }
    if (message.schema == null) {
      this.rejectSession(session.sessionId, import_TLSyncClient.TLSyncErrorCloseEventReason.CLIENT_TOO_OLD);
      return;
    }
    const migrations = this.schema.getMigrationsSince(message.schema);
    if (!migrations.ok || migrations.value.some((m) => m.scope === "store" || !m.down)) {
      this.rejectSession(session.sessionId, import_TLSyncClient.TLSyncErrorCloseEventReason.CLIENT_TOO_OLD);
      return;
    }
    const sessionSchema = (0, import_lodash.default)(message.schema, this.serializedSchema) ? this.serializedSchema : message.schema;
    const connect = (msg) => {
      this.sessions.set(session.sessionId, {
        state: import_RoomSession.RoomSessionState.Connected,
        sessionId: session.sessionId,
        presenceId: session.presenceId,
        socket: session.socket,
        serializedSchema: sessionSchema,
        lastInteractionTime: Date.now(),
        debounceTimer: null,
        outstandingDataMessages: [],
        meta: session.meta,
        isReadonly: session.isReadonly,
        requiresLegacyRejection: session.requiresLegacyRejection
      });
      this.sendMessage(session.sessionId, msg);
    };
    (0, import_state.transaction)((rollback) => {
      if (
        // if the client requests changes since a time before we have tombstone history, send them the full state
        message.lastServerClock < this.tombstoneHistoryStartsAtClock || // similarly, if they ask for a time we haven't reached yet, send them the full state
        // this will only happen if the DB is reset (or there is no db) and the server restarts
        // or if the server exits/crashes with unpersisted changes
        message.lastServerClock > this.clock
      ) {
        const diff = {};
        for (const [id, doc] of Object.entries(this.state.get().documents)) {
          if (id !== session.presenceId) {
            diff[id] = [import_diff.RecordOpType.Put, doc.state];
          }
        }
        const migrated = this.migrateDiffForSession(sessionSchema, diff);
        if (!migrated.ok) {
          rollback();
          this.rejectSession(
            session.sessionId,
            migrated.error === import_store.MigrationFailureReason.TargetVersionTooNew ? import_TLSyncClient.TLSyncErrorCloseEventReason.SERVER_TOO_OLD : import_TLSyncClient.TLSyncErrorCloseEventReason.CLIENT_TOO_OLD
          );
          return;
        }
        connect({
          type: "connect",
          connectRequestId: message.connectRequestId,
          hydrationType: "wipe_all",
          protocolVersion: (0, import_protocol.getTlsyncProtocolVersion)(),
          schema: this.schema.serialize(),
          serverClock: this.clock,
          diff: migrated.value,
          isReadonly: session.isReadonly
        });
      } else {
        const diff = {};
        const updatedDocs = Object.values(this.state.get().documents).filter(
          (doc) => doc.lastChangedClock > message.lastServerClock
        );
        const presenceDocs = this.presenceType ? Object.values(this.state.get().documents).filter(
          (doc) => this.presenceType.typeName === doc.state.typeName && doc.state.id !== session.presenceId
        ) : [];
        const deletedDocsIds = Object.entries(this.state.get().tombstones).filter(([_id, deletedAtClock]) => deletedAtClock > message.lastServerClock).map(([id]) => id);
        for (const doc of updatedDocs) {
          diff[doc.state.id] = [import_diff.RecordOpType.Put, doc.state];
        }
        for (const doc of presenceDocs) {
          diff[doc.state.id] = [import_diff.RecordOpType.Put, doc.state];
        }
        for (const docId of deletedDocsIds) {
          diff[docId] = [import_diff.RecordOpType.Remove];
        }
        const migrated = this.migrateDiffForSession(sessionSchema, diff);
        if (!migrated.ok) {
          rollback();
          this.rejectSession(
            session.sessionId,
            migrated.error === import_store.MigrationFailureReason.TargetVersionTooNew ? import_TLSyncClient.TLSyncErrorCloseEventReason.SERVER_TOO_OLD : import_TLSyncClient.TLSyncErrorCloseEventReason.CLIENT_TOO_OLD
          );
          return;
        }
        connect({
          type: "connect",
          connectRequestId: message.connectRequestId,
          hydrationType: "wipe_presence",
          schema: this.schema.serialize(),
          protocolVersion: (0, import_protocol.getTlsyncProtocolVersion)(),
          serverClock: this.clock,
          diff: migrated.value,
          isReadonly: session.isReadonly
        });
      }
    });
  }
  handlePushRequest(session, message) {
    if (session && session.state !== import_RoomSession.RoomSessionState.Connected) {
      return;
    }
    if (session) {
      session.lastInteractionTime = Date.now();
    }
    this.clock++;
    const initialDocumentClock = this.documentClock;
    let didPresenceChange = false;
    (0, import_state.transaction)((rollback) => {
      const docChanges = { diff: null };
      const presenceChanges = { diff: null };
      const propagateOp = (changes, id, op) => {
        if (!changes.diff) changes.diff = {};
        changes.diff[id] = op;
      };
      const fail = (reason, underlyingError) => {
        rollback();
        if (session) {
          this.rejectSession(session.sessionId, reason);
        } else {
          throw new Error("failed to apply changes: " + reason, underlyingError);
        }
        if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
          this.log?.error?.("failed to apply push", reason, message, underlyingError);
        }
        return import_utils.Result.err(void 0);
      };
      const addDocument = (changes, id, _state) => {
        const res = session ? this.schema.migratePersistedRecord(_state, session.serializedSchema, "up") : { type: "success", value: _state };
        if (res.type === "error") {
          return fail(
            res.reason === import_store.MigrationFailureReason.TargetVersionTooOld ? import_TLSyncClient.TLSyncErrorCloseEventReason.SERVER_TOO_OLD : import_TLSyncClient.TLSyncErrorCloseEventReason.CLIENT_TOO_OLD
          );
        }
        const { value: state } = res;
        const doc = this.getDocument(id);
        if (doc) {
          const diff = doc.replaceState(state, this.clock);
          if (!diff.ok) {
            return fail(import_TLSyncClient.TLSyncErrorCloseEventReason.INVALID_RECORD);
          }
          if (diff.value) {
            propagateOp(changes, id, [import_diff.RecordOpType.Patch, diff.value]);
          }
        } else {
          const result = this.addDocument(id, state, this.clock);
          if (!result.ok) {
            return fail(import_TLSyncClient.TLSyncErrorCloseEventReason.INVALID_RECORD);
          }
          propagateOp(changes, id, [import_diff.RecordOpType.Put, state]);
        }
        return import_utils.Result.ok(void 0);
      };
      const patchDocument = (changes, id, patch) => {
        const doc = this.getDocument(id);
        if (!doc) return import_utils.Result.ok(void 0);
        const downgraded = session ? this.schema.migratePersistedRecord(doc.state, session.serializedSchema, "down") : { type: "success", value: doc.state };
        if (downgraded.type === "error") {
          return fail(import_TLSyncClient.TLSyncErrorCloseEventReason.CLIENT_TOO_OLD);
        }
        if (downgraded.value === doc.state) {
          const diff = doc.mergeDiff(patch, this.clock);
          if (!diff.ok) {
            return fail(import_TLSyncClient.TLSyncErrorCloseEventReason.INVALID_RECORD);
          }
          if (diff.value) {
            propagateOp(changes, id, [import_diff.RecordOpType.Patch, diff.value]);
          }
        } else {
          const patched = (0, import_diff.applyObjectDiff)(downgraded.value, patch);
          const upgraded = session ? this.schema.migratePersistedRecord(patched, session.serializedSchema, "up") : { type: "success", value: patched };
          if (upgraded.type === "error") {
            return fail(import_TLSyncClient.TLSyncErrorCloseEventReason.CLIENT_TOO_OLD);
          }
          const diff = doc.replaceState(upgraded.value, this.clock);
          if (!diff.ok) {
            return fail(import_TLSyncClient.TLSyncErrorCloseEventReason.INVALID_RECORD);
          }
          if (diff.value) {
            propagateOp(changes, id, [import_diff.RecordOpType.Patch, diff.value]);
          }
        }
        return import_utils.Result.ok(void 0);
      };
      const { clientClock } = message;
      if (this.presenceType && session?.presenceId && "presence" in message && message.presence) {
        if (!session) throw new Error("session is required for presence pushes");
        const id = session.presenceId;
        const [type, val] = message.presence;
        const { typeName } = this.presenceType;
        switch (type) {
          case import_diff.RecordOpType.Put: {
            const res = addDocument(presenceChanges, id, { ...val, id, typeName });
            if (!res.ok) return;
            break;
          }
          case import_diff.RecordOpType.Patch: {
            const res = patchDocument(presenceChanges, id, {
              ...val,
              id: [import_diff.ValueOpType.Put, id],
              typeName: [import_diff.ValueOpType.Put, typeName]
            });
            if (!res.ok) return;
            break;
          }
        }
      }
      if (message.diff && !session?.isReadonly) {
        for (const [id, op] of Object.entries(message.diff)) {
          switch (op[0]) {
            case import_diff.RecordOpType.Put: {
              if (!this.documentTypes.has(op[1].typeName)) {
                return fail(import_TLSyncClient.TLSyncErrorCloseEventReason.INVALID_RECORD);
              }
              const res = addDocument(docChanges, id, op[1]);
              if (!res.ok) return;
              break;
            }
            case import_diff.RecordOpType.Patch: {
              const res = patchDocument(docChanges, id, op[1]);
              if (!res.ok) return;
              break;
            }
            case import_diff.RecordOpType.Remove: {
              const doc = this.getDocument(id);
              if (!doc) {
                continue;
              }
              this.removeDocument(id, this.clock);
              setTimeout(this.pruneTombstones, 0);
              propagateOp(docChanges, id, op);
              break;
            }
          }
        }
      }
      if (
        // if there was only a presence push, the client doesn't need to do anything aside from
        // shift the push request.
        !message.diff || (0, import_lodash.default)(docChanges.diff, message.diff)
      ) {
        if (session) {
          this.sendMessage(session.sessionId, {
            type: "push_result",
            serverClock: this.clock,
            clientClock,
            action: "commit"
          });
        }
      } else if (!docChanges.diff) {
        if (session) {
          this.sendMessage(session.sessionId, {
            type: "push_result",
            serverClock: this.clock,
            clientClock,
            action: "discard"
          });
        }
      } else {
        if (session) {
          const migrateResult = this.migrateDiffForSession(
            session.serializedSchema,
            docChanges.diff
          );
          if (!migrateResult.ok) {
            return fail(
              migrateResult.error === import_store.MigrationFailureReason.TargetVersionTooNew ? import_TLSyncClient.TLSyncErrorCloseEventReason.SERVER_TOO_OLD : import_TLSyncClient.TLSyncErrorCloseEventReason.CLIENT_TOO_OLD
            );
          }
          this.sendMessage(session.sessionId, {
            type: "push_result",
            serverClock: this.clock,
            clientClock,
            action: { rebaseWithDiff: migrateResult.value }
          });
        }
      }
      if (docChanges.diff || presenceChanges.diff) {
        this.broadcastPatch({
          sourceSessionId: session?.sessionId,
          diff: {
            ...docChanges.diff,
            ...presenceChanges.diff
          }
        });
      }
      if (docChanges.diff) {
        this.documentClock = this.clock;
      }
      if (presenceChanges.diff) {
        didPresenceChange = true;
      }
      return;
    });
    if (this.documentClock !== initialDocumentClock) {
      this.onDataChange?.();
    }
    if (didPresenceChange) {
      this.onPresenceChange?.();
    }
  }
  /**
   * Handle the event when a client disconnects.
   *
   * @param sessionId - The session that disconnected.
   */
  handleClose(sessionId) {
    this.cancelSession(sessionId);
  }
  /**
   * Allow applying changes to the store in a transactional way.
   * @param updater - A function that will be called with a store object that can be used to make changes.
   * @returns A promise that resolves when the transaction is complete.
   */
  async updateStore(updater) {
    if (this._isClosed) {
      throw new Error("Cannot update store on a closed room");
    }
    const context = new StoreUpdateContext(
      Object.fromEntries(this.getSnapshot().documents.map((d) => [d.state.id, d.state]))
    );
    try {
      await updater(context);
    } finally {
      context.close();
    }
    const diff = context.toDiff();
    if (Object.keys(diff).length === 0) {
      return;
    }
    this.handlePushRequest(null, { type: "push", diff, clientClock: 0 });
  }
}
class StoreUpdateContext {
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  updates = {
    puts: {},
    deletes: /* @__PURE__ */ new Set()
  };
  put(record) {
    if (this._isClosed) throw new Error("StoreUpdateContext is closed");
    if (record.id in this.snapshot && (0, import_lodash.default)(this.snapshot[record.id], record)) {
      delete this.updates.puts[record.id];
    } else {
      this.updates.puts[record.id] = (0, import_utils.structuredClone)(record);
    }
    this.updates.deletes.delete(record.id);
  }
  delete(recordOrId) {
    if (this._isClosed) throw new Error("StoreUpdateContext is closed");
    const id = typeof recordOrId === "string" ? recordOrId : recordOrId.id;
    delete this.updates.puts[id];
    if (this.snapshot[id]) {
      this.updates.deletes.add(id);
    }
  }
  get(id) {
    if (this._isClosed) throw new Error("StoreUpdateContext is closed");
    if ((0, import_utils.hasOwnProperty)(this.updates.puts, id)) {
      return (0, import_utils.structuredClone)(this.updates.puts[id]);
    }
    if (this.updates.deletes.has(id)) {
      return null;
    }
    return (0, import_utils.structuredClone)(this.snapshot[id] ?? null);
  }
  getAll() {
    if (this._isClosed) throw new Error("StoreUpdateContext is closed");
    const result = Object.values(this.updates.puts);
    for (const [id, record] of Object.entries(this.snapshot)) {
      if (!this.updates.deletes.has(id) && !(0, import_utils.hasOwnProperty)(this.updates.puts, id)) {
        result.push(record);
      }
    }
    return (0, import_utils.structuredClone)(result);
  }
  toDiff() {
    const diff = {};
    for (const [id, record] of Object.entries(this.updates.puts)) {
      diff[id] = [import_diff.RecordOpType.Put, record];
    }
    for (const id of this.updates.deletes) {
      diff[id] = [import_diff.RecordOpType.Remove];
    }
    return diff;
  }
  _isClosed = false;
  close() {
    this._isClosed = true;
  }
}
//# sourceMappingURL=TLSyncRoom.js.map
