"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AtomMap_exports = {};
__export(AtomMap_exports, {
  AtomMap: () => AtomMap
});
module.exports = __toCommonJS(AtomMap_exports);
var import_state = require("@tldraw/state");
var import_utils = require("@tldraw/utils");
var import_ImmutableMap = require("./ImmutableMap");
class AtomMap {
  constructor(name, entries) {
    this.name = name;
    let atoms = (0, import_ImmutableMap.emptyMap)();
    if (entries) {
      atoms = atoms.withMutations((atoms2) => {
        for (const [k, v] of entries) {
          atoms2.set(k, (0, import_state.atom)(`${name}:${String(k)}`, v));
        }
      });
    }
    this.atoms = (0, import_state.atom)(`${name}:atoms`, atoms);
  }
  atoms;
  /** @internal */
  getAtom(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      this.atoms.get();
      return void 0;
    }
    return valueAtom;
  }
  get(key) {
    const value = this.getAtom(key)?.get();
    (0, import_utils.assert)(value !== import_state.UNINITIALIZED);
    return value;
  }
  __unsafe__getWithoutCapture(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) return void 0;
    const value = valueAtom.__unsafe__getWithoutCapture();
    (0, import_utils.assert)(value !== import_state.UNINITIALIZED);
    return value;
  }
  has(key) {
    const valueAtom = this.getAtom(key);
    if (!valueAtom) {
      return false;
    }
    return valueAtom.get() !== import_state.UNINITIALIZED;
  }
  __unsafe__hasWithoutCapture(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) return false;
    (0, import_utils.assert)(valueAtom.__unsafe__getWithoutCapture() !== import_state.UNINITIALIZED);
    return true;
  }
  set(key, value) {
    const existingAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (existingAtom) {
      existingAtom.set(value);
    } else {
      this.atoms.update((atoms) => {
        return atoms.set(key, (0, import_state.atom)(`${this.name}:${String(key)}`, value));
      });
    }
    return this;
  }
  update(key, updater) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      throw new Error(`AtomMap: key ${key} not found`);
    }
    const value = valueAtom.__unsafe__getWithoutCapture();
    (0, import_utils.assert)(value !== import_state.UNINITIALIZED);
    valueAtom.set(updater(value));
  }
  delete(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      return false;
    }
    (0, import_state.transact)(() => {
      valueAtom.set(import_state.UNINITIALIZED);
      this.atoms.update((atoms) => {
        return atoms.delete(key);
      });
    });
    return true;
  }
  deleteMany(keys) {
    return (0, import_state.transact)(() => {
      const deleted = [];
      const newAtoms = this.atoms.get().withMutations((atoms) => {
        for (const key of keys) {
          const valueAtom = atoms.get(key);
          if (!valueAtom) continue;
          const oldValue = valueAtom.get();
          (0, import_utils.assert)(oldValue !== import_state.UNINITIALIZED);
          deleted.push([key, oldValue]);
          atoms.delete(key);
          valueAtom.set(import_state.UNINITIALIZED);
        }
      });
      if (deleted.length) {
        this.atoms.set(newAtoms);
      }
      return deleted;
    });
  }
  clear() {
    return (0, import_state.transact)(() => {
      for (const valueAtom of this.atoms.__unsafe__getWithoutCapture().values()) {
        valueAtom.set(import_state.UNINITIALIZED);
      }
      this.atoms.set((0, import_ImmutableMap.emptyMap)());
    });
  }
  *entries() {
    for (const [key, valueAtom] of this.atoms.get()) {
      const value = valueAtom.get();
      (0, import_utils.assert)(value !== import_state.UNINITIALIZED);
      yield [key, value];
    }
  }
  *keys() {
    for (const key of this.atoms.get().keys()) {
      yield key;
    }
  }
  *values() {
    for (const valueAtom of this.atoms.get().values()) {
      const value = valueAtom.get();
      (0, import_utils.assert)(value !== import_state.UNINITIALIZED);
      yield value;
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.atoms.get().size;
  }
  forEach(callbackfn, thisArg) {
    for (const [key, value] of this.entries()) {
      callbackfn.call(thisArg, value, key, this);
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [Symbol.toStringTag] = "AtomMap";
}
//# sourceMappingURL=AtomMap.js.map
