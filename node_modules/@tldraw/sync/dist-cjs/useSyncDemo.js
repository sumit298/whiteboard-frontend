"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useSyncDemo_exports = {};
__export(useSyncDemo_exports, {
  useSyncDemo: () => useSyncDemo
});
module.exports = __toCommonJS(useSyncDemo_exports);
var import_react = require("react");
var import_tldraw = require("tldraw");
var import_useSync = require("./useSync");
function getEnv(cb) {
  try {
    return cb();
  } catch {
    return void 0;
  }
}
const DEMO_WORKER = getEnv(() => "https://demo.tldraw.xyz") ?? "https://demo.tldraw.xyz";
const IMAGE_WORKER = getEnv(() => process.env.TLDRAW_IMAGE_URL) ?? "https://images.tldraw.xyz";
function useSyncDemo(options) {
  const { roomId, host = DEMO_WORKER, ..._syncOpts } = options;
  const assets = (0, import_react.useMemo)(() => createDemoAssetStore(host), [host]);
  const syncOpts = (0, import_tldraw.useShallowObjectIdentity)(_syncOpts);
  const syncOptsWithDefaults = (0, import_react.useMemo)(() => {
    if ("schema" in syncOpts && syncOpts.schema) return syncOpts;
    return {
      ...syncOpts,
      shapeUtils: "shapeUtils" in syncOpts ? [...import_tldraw.defaultShapeUtils, ...syncOpts.shapeUtils ?? []] : import_tldraw.defaultShapeUtils,
      bindingUtils: "bindingUtils" in syncOpts ? [...import_tldraw.defaultBindingUtils, ...syncOpts.bindingUtils ?? []] : import_tldraw.defaultBindingUtils
    };
  }, [syncOpts]);
  return (0, import_useSync.useSync)({
    uri: `${host}/connect/${encodeURIComponent(roomId)}`,
    roomId,
    assets,
    onMount: (0, import_react.useCallback)(
      (editor) => {
        editor.registerExternalAssetHandler("url", async ({ url }) => {
          return await createAssetFromUrlUsingDemoServer(host, url);
        });
      },
      [host]
    ),
    ...syncOptsWithDefaults
  });
}
function createDemoAssetStore(host) {
  return {
    upload: async (asset, file) => {
      const id = (0, import_tldraw.uniqueId)();
      const objectName = `${id}-${file.name}`.replace(/\W/g, "-");
      const url = `${host}/uploads/${objectName}`;
      await fetch(url, {
        method: "POST",
        body: file
      });
      return { src: url };
    },
    resolve(asset, context) {
      if (!asset.props.src) return null;
      if (asset.type === "video") return asset.props.src;
      if (asset.type !== "image") return null;
      if (!asset.props.src.startsWith("http:") && !asset.props.src.startsWith("https:"))
        return asset.props.src;
      if (context.shouldResolveToOriginal) return asset.props.src;
      if (import_tldraw.MediaHelpers.isAnimatedImageType(asset?.props.mimeType) || asset.props.isAnimated)
        return asset.props.src;
      if (import_tldraw.MediaHelpers.isVectorImageType(asset?.props.mimeType)) return asset.props.src;
      const url = new URL(asset.props.src);
      const isTldrawImage = url.origin === host || /\.tldraw\.(?:com|xyz|dev|workers\.dev)$/.test(url.host);
      if (!isTldrawImage) return asset.props.src;
      const { fileSize = 0 } = asset.props;
      const isWorthResizing = fileSize >= 1024 * 1024 * 1.5;
      if (isWorthResizing) {
        const networkCompensation = !context.networkEffectiveType || context.networkEffectiveType === "4g" ? 1 : 0.5;
        const width = Math.ceil(
          Math.min(
            asset.props.w * (0, import_tldraw.clamp)(context.steppedScreenScale, 1 / 32, 1) * networkCompensation * context.dpr,
            asset.props.w
          )
        );
        url.searchParams.set("w", width.toString());
      }
      const newUrl = `${IMAGE_WORKER}/${url.host}/${url.toString().slice(url.origin.length + 1)}`;
      return newUrl;
    }
  };
}
async function createAssetFromUrlUsingDemoServer(host, url) {
  const urlHash = (0, import_tldraw.getHashForString)(url);
  try {
    const fetchUrl = new URL(`${host}/bookmarks/unfurl`);
    fetchUrl.searchParams.set("url", url);
    const meta = await (await fetch(fetchUrl, { method: "POST" })).json();
    return {
      id: import_tldraw.AssetRecordType.createId(urlHash),
      typeName: "asset",
      type: "bookmark",
      props: {
        src: url,
        description: meta?.description ?? "",
        image: meta?.image ?? "",
        favicon: meta?.favicon ?? "",
        title: meta?.title ?? ""
      },
      meta: {}
    };
  } catch (error) {
    console.error(error);
    return {
      id: import_tldraw.AssetRecordType.createId(urlHash),
      typeName: "asset",
      type: "bookmark",
      props: {
        src: url,
        description: "",
        image: "",
        favicon: "",
        title: ""
      },
      meta: {}
    };
  }
}
//# sourceMappingURL=useSyncDemo.js.map
