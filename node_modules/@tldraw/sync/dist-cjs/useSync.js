"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useSync_exports = {};
__export(useSync_exports, {
  useSync: () => useSync
});
module.exports = __toCommonJS(useSync_exports);
var import_state = require("@tldraw/state");
var import_state_react = require("@tldraw/state-react");
var import_sync_core = require("@tldraw/sync-core");
var import_react = require("react");
var import_tldraw = require("tldraw");
const MULTIPLAYER_EVENT_NAME = "multiplayer.client";
function useSync(opts) {
  const [state, setState] = (0, import_tldraw.useRefState)(null);
  const {
    uri,
    roomId = "default",
    assets,
    onMount,
    trackAnalyticsEvent: track,
    userInfo,
    getUserPresence: _getUserPresence,
    ...schemaOpts
  } = opts;
  const __never__ = 0;
  const schema = (0, import_tldraw.useTLSchemaFromUtils)(schemaOpts);
  const prefs = (0, import_tldraw.useShallowObjectIdentity)(userInfo);
  const getUserPresence = (0, import_tldraw.useReactiveEvent)(_getUserPresence ?? import_tldraw.getDefaultUserPresence);
  const userAtom = (0, import_state_react.useAtom)(
    "userAtom",
    prefs
  );
  (0, import_react.useEffect)(() => {
    userAtom.set(prefs);
  }, [prefs, userAtom]);
  (0, import_react.useEffect)(() => {
    const storeId = (0, import_tldraw.uniqueId)();
    const userPreferences = (0, import_tldraw.computed)(
      "userPreferences",
      () => {
        const userStuff = userAtom.get();
        const user = ((0, import_state.isSignal)(userStuff) ? userStuff.get() : userStuff) ?? (0, import_tldraw.getUserPreferences)();
        return {
          id: user.id,
          color: user.color ?? import_tldraw.defaultUserPreferences.color,
          name: user.name ?? import_tldraw.defaultUserPreferences.name
        };
      }
    );
    const socket = new import_sync_core.ClientWebSocketAdapter(async () => {
      const uriString = typeof uri === "string" ? uri : await uri();
      const withParams = new URL(uriString);
      if (withParams.searchParams.has("sessionId")) {
        throw new Error(
          'useSync. "sessionId" is a reserved query param name. Please use a different name'
        );
      }
      if (withParams.searchParams.has("storeId")) {
        throw new Error(
          'useSync. "storeId" is a reserved query param name. Please use a different name'
        );
      }
      withParams.searchParams.set("sessionId", import_tldraw.TAB_ID);
      withParams.searchParams.set("storeId", storeId);
      return withParams.toString();
    });
    let didCancel = false;
    const collaborationStatusSignal = (0, import_tldraw.computed)(
      "collaboration status",
      () => socket.connectionStatus === "error" ? "offline" : socket.connectionStatus
    );
    const syncMode = (0, import_state.atom)("sync mode", "readwrite");
    const store = (0, import_tldraw.createTLStore)({
      id: storeId,
      schema,
      assets,
      onMount,
      collaboration: {
        status: collaborationStatusSignal,
        mode: syncMode
      }
    });
    const presence = (0, import_tldraw.computed)("instancePresence", () => {
      const presenceState = getUserPresence(store, userPreferences.get());
      if (!presenceState) return null;
      return import_tldraw.InstancePresenceRecordType.create({
        ...presenceState,
        id: import_tldraw.InstancePresenceRecordType.createId(store.id)
      });
    });
    const client = new import_sync_core.TLSyncClient({
      store,
      socket,
      didCancel: () => didCancel,
      onLoad(client2) {
        track?.(MULTIPLAYER_EVENT_NAME, { name: "load", roomId });
        setState({ readyClient: client2 });
      },
      onSyncError(reason) {
        console.error("sync error", reason);
        switch (reason) {
          case import_sync_core.TLSyncErrorCloseEventReason.NOT_FOUND:
            track?.(MULTIPLAYER_EVENT_NAME, { name: "room-not-found", roomId });
            break;
          case import_sync_core.TLSyncErrorCloseEventReason.FORBIDDEN:
            track?.(MULTIPLAYER_EVENT_NAME, { name: "forbidden", roomId });
            break;
          case import_sync_core.TLSyncErrorCloseEventReason.NOT_AUTHENTICATED:
            track?.(MULTIPLAYER_EVENT_NAME, { name: "not-authenticated", roomId });
            break;
          case import_sync_core.TLSyncErrorCloseEventReason.RATE_LIMITED:
            track?.(MULTIPLAYER_EVENT_NAME, { name: "rate-limited", roomId });
            break;
          default:
            track?.(MULTIPLAYER_EVENT_NAME, { name: "sync-error:" + reason, roomId });
            break;
        }
        setState({ error: new import_sync_core.TLRemoteSyncError(reason) });
        socket.close();
      },
      onAfterConnect(_, { isReadonly }) {
        (0, import_state.transact)(() => {
          syncMode.set(isReadonly ? "readonly" : "readwrite");
          store.ensureStoreIsUsable();
        });
      },
      presence
    });
    return () => {
      didCancel = true;
      client.close();
      socket.close();
      setState(null);
    };
  }, [assets, onMount, userAtom, roomId, schema, setState, track, uri, getUserPresence]);
  return (0, import_tldraw.useValue)(
    "remote synced store",
    () => {
      if (!state) return { status: "loading" };
      if (state.error) return { status: "error", error: state.error };
      if (!state.readyClient) return { status: "loading" };
      const connectionStatus = state.readyClient.socket.connectionStatus;
      return {
        status: "synced-remote",
        connectionStatus: connectionStatus === "error" ? "offline" : connectionStatus,
        store: state.readyClient.store
      };
    },
    [state]
  );
}
//# sourceMappingURL=useSync.js.map
