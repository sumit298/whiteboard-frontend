import { atom, isSignal, transact } from "@tldraw/state";
import { useAtom } from "@tldraw/state-react";
import {
  ClientWebSocketAdapter,
  TLRemoteSyncError,
  TLSyncClient,
  TLSyncErrorCloseEventReason
} from "@tldraw/sync-core";
import { useEffect } from "react";
import {
  InstancePresenceRecordType,
  TAB_ID,
  computed,
  createTLStore,
  defaultUserPreferences,
  getDefaultUserPresence,
  getUserPreferences,
  uniqueId,
  useReactiveEvent,
  useRefState,
  useShallowObjectIdentity,
  useTLSchemaFromUtils,
  useValue
} from "tldraw";
const MULTIPLAYER_EVENT_NAME = "multiplayer.client";
function useSync(opts) {
  const [state, setState] = useRefState(null);
  const {
    uri,
    roomId = "default",
    assets,
    onMount,
    trackAnalyticsEvent: track,
    userInfo,
    getUserPresence: _getUserPresence,
    ...schemaOpts
  } = opts;
  const __never__ = 0;
  const schema = useTLSchemaFromUtils(schemaOpts);
  const prefs = useShallowObjectIdentity(userInfo);
  const getUserPresence = useReactiveEvent(_getUserPresence ?? getDefaultUserPresence);
  const userAtom = useAtom(
    "userAtom",
    prefs
  );
  useEffect(() => {
    userAtom.set(prefs);
  }, [prefs, userAtom]);
  useEffect(() => {
    const storeId = uniqueId();
    const userPreferences = computed(
      "userPreferences",
      () => {
        const userStuff = userAtom.get();
        const user = (isSignal(userStuff) ? userStuff.get() : userStuff) ?? getUserPreferences();
        return {
          id: user.id,
          color: user.color ?? defaultUserPreferences.color,
          name: user.name ?? defaultUserPreferences.name
        };
      }
    );
    const socket = new ClientWebSocketAdapter(async () => {
      const uriString = typeof uri === "string" ? uri : await uri();
      const withParams = new URL(uriString);
      if (withParams.searchParams.has("sessionId")) {
        throw new Error(
          'useSync. "sessionId" is a reserved query param name. Please use a different name'
        );
      }
      if (withParams.searchParams.has("storeId")) {
        throw new Error(
          'useSync. "storeId" is a reserved query param name. Please use a different name'
        );
      }
      withParams.searchParams.set("sessionId", TAB_ID);
      withParams.searchParams.set("storeId", storeId);
      return withParams.toString();
    });
    let didCancel = false;
    const collaborationStatusSignal = computed(
      "collaboration status",
      () => socket.connectionStatus === "error" ? "offline" : socket.connectionStatus
    );
    const syncMode = atom("sync mode", "readwrite");
    const store = createTLStore({
      id: storeId,
      schema,
      assets,
      onMount,
      collaboration: {
        status: collaborationStatusSignal,
        mode: syncMode
      }
    });
    const presence = computed("instancePresence", () => {
      const presenceState = getUserPresence(store, userPreferences.get());
      if (!presenceState) return null;
      return InstancePresenceRecordType.create({
        ...presenceState,
        id: InstancePresenceRecordType.createId(store.id)
      });
    });
    const client = new TLSyncClient({
      store,
      socket,
      didCancel: () => didCancel,
      onLoad(client2) {
        track?.(MULTIPLAYER_EVENT_NAME, { name: "load", roomId });
        setState({ readyClient: client2 });
      },
      onSyncError(reason) {
        console.error("sync error", reason);
        switch (reason) {
          case TLSyncErrorCloseEventReason.NOT_FOUND:
            track?.(MULTIPLAYER_EVENT_NAME, { name: "room-not-found", roomId });
            break;
          case TLSyncErrorCloseEventReason.FORBIDDEN:
            track?.(MULTIPLAYER_EVENT_NAME, { name: "forbidden", roomId });
            break;
          case TLSyncErrorCloseEventReason.NOT_AUTHENTICATED:
            track?.(MULTIPLAYER_EVENT_NAME, { name: "not-authenticated", roomId });
            break;
          case TLSyncErrorCloseEventReason.RATE_LIMITED:
            track?.(MULTIPLAYER_EVENT_NAME, { name: "rate-limited", roomId });
            break;
          default:
            track?.(MULTIPLAYER_EVENT_NAME, { name: "sync-error:" + reason, roomId });
            break;
        }
        setState({ error: new TLRemoteSyncError(reason) });
        socket.close();
      },
      onAfterConnect(_, { isReadonly }) {
        transact(() => {
          syncMode.set(isReadonly ? "readonly" : "readwrite");
          store.ensureStoreIsUsable();
        });
      },
      presence
    });
    return () => {
      didCancel = true;
      client.close();
      socket.close();
      setState(null);
    };
  }, [assets, onMount, userAtom, roomId, schema, setState, track, uri, getUserPresence]);
  return useValue(
    "remote synced store",
    () => {
      if (!state) return { status: "loading" };
      if (state.error) return { status: "error", error: state.error };
      if (!state.readyClient) return { status: "loading" };
      const connectionStatus = state.readyClient.socket.connectionStatus;
      return {
        status: "synced-remote",
        connectionStatus: connectionStatus === "error" ? "offline" : connectionStatus,
        store: state.readyClient.store
      };
    },
    [state]
  );
}
export {
  useSync
};
//# sourceMappingURL=useSync.mjs.map
