import { useCallback, useMemo } from "react";
import {
  AssetRecordType,
  MediaHelpers,
  clamp,
  defaultBindingUtils,
  defaultShapeUtils,
  getHashForString,
  uniqueId,
  useShallowObjectIdentity
} from "tldraw";
import { useSync } from "./useSync.mjs";
function getEnv(cb) {
  try {
    return cb();
  } catch {
    return void 0;
  }
}
const DEMO_WORKER = getEnv(() => "https://demo.tldraw.xyz") ?? "https://demo.tldraw.xyz";
const IMAGE_WORKER = getEnv(() => process.env.TLDRAW_IMAGE_URL) ?? "https://images.tldraw.xyz";
function useSyncDemo(options) {
  const { roomId, host = DEMO_WORKER, ..._syncOpts } = options;
  const assets = useMemo(() => createDemoAssetStore(host), [host]);
  const syncOpts = useShallowObjectIdentity(_syncOpts);
  const syncOptsWithDefaults = useMemo(() => {
    if ("schema" in syncOpts && syncOpts.schema) return syncOpts;
    return {
      ...syncOpts,
      shapeUtils: "shapeUtils" in syncOpts ? [...defaultShapeUtils, ...(syncOpts.shapeUtils ?? [])] : defaultShapeUtils,
      bindingUtils: "bindingUtils" in syncOpts ? [...defaultBindingUtils, ...(syncOpts.bindingUtils ?? [])] : defaultBindingUtils
    };
  }, [syncOpts]);
  return useSync({
    uri: `${host}/connect/${encodeURIComponent(roomId)}`,
    roomId,
    assets,
    onMount: useCallback(
      (editor) => {
        editor.registerExternalAssetHandler("url", async ({ url }) => {
          return await createAssetFromUrlUsingDemoServer(host, url);
        });
      },
      [host]
    ),
    ...syncOptsWithDefaults
  });
}
function createDemoAssetStore(host) {
  return {
    upload: async (asset, file) => {
      const id = uniqueId();
      const objectName = `${id}-${file.name}`.replace(/\W/g, "-");
      const url = `${host}/uploads/${objectName}`;
      await fetch(url, {
        method: "POST",
        body: file
      });
      return { src: url };
    },
    resolve(asset, context) {
      if (!asset.props.src) return null;
      if (asset.type === "video") return asset.props.src;
      if (asset.type !== "image") return null;
      if (!asset.props.src.startsWith("http:") && !asset.props.src.startsWith("https:"))
        return asset.props.src;
      if (context.shouldResolveToOriginal) return asset.props.src;
      if (MediaHelpers.isAnimatedImageType(asset?.props.mimeType) || asset.props.isAnimated)
        return asset.props.src;
      if (MediaHelpers.isVectorImageType(asset?.props.mimeType)) return asset.props.src;
      const url = new URL(asset.props.src);
      const isTldrawImage = url.origin === host || /\.tldraw\.(?:com|xyz|dev|workers\.dev)$/.test(url.host);
      if (!isTldrawImage) return asset.props.src;
      const { fileSize = 0 } = asset.props;
      const isWorthResizing = fileSize >= 1024 * 1024 * 1.5;
      if (isWorthResizing) {
        const networkCompensation = !context.networkEffectiveType || context.networkEffectiveType === "4g" ? 1 : 0.5;
        const width = Math.ceil(
          Math.min(
            asset.props.w * clamp(context.steppedScreenScale, 1 / 32, 1) * networkCompensation * context.dpr,
            asset.props.w
          )
        );
        url.searchParams.set("w", width.toString());
      }
      const newUrl = `${IMAGE_WORKER}/${url.host}/${url.toString().slice(url.origin.length + 1)}`;
      return newUrl;
    }
  };
}
async function createAssetFromUrlUsingDemoServer(host, url) {
  const urlHash = getHashForString(url);
  try {
    const fetchUrl = new URL(`${host}/bookmarks/unfurl`);
    fetchUrl.searchParams.set("url", url);
    const meta = await (await fetch(fetchUrl, { method: "POST" })).json();
    return {
      id: AssetRecordType.createId(urlHash),
      typeName: "asset",
      type: "bookmark",
      props: {
        src: url,
        description: meta?.description ?? "",
        image: meta?.image ?? "",
        favicon: meta?.favicon ?? "",
        title: meta?.title ?? ""
      },
      meta: {}
    };
  } catch (error) {
    console.error(error);
    return {
      id: AssetRecordType.createId(urlHash),
      typeName: "asset",
      type: "bookmark",
      props: {
        src: url,
        description: "",
        image: "",
        favicon: "",
        title: ""
      },
      meta: {}
    };
  }
}
export {
  useSyncDemo
};
//# sourceMappingURL=useSyncDemo.mjs.map
